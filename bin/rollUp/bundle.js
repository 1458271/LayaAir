(function () {
     'use strict';

     console.log('--------------------');
     /**
      * 使用全局类的时候，避免引用其他模块
      */
     class ILaya {
         static regClass(c) {
             ILaya.__classMap[c.name] = c;
         }
     }
     ILaya.Laya = null;
     //static classMap:Object=null;
     ILaya.Timer = null;
     ILaya.WorkerLoader = null;
     ILaya.Dragging = null;
     ILaya.GraphicsBounds = null;
     ILaya.Sprite = null;
     ILaya.TextRender = null;
     ILaya.TextAtlas = null;
     ILaya.timer = null;
     ILaya.systemTimer = null;
     ILaya.startTimer = null;
     ILaya.updateTimer = null;
     ILaya.lateTimer = null;
     ILaya.physicsTimer = null;
     ILaya.stage = null;
     ILaya.Loader = null;
     ILaya.loader = null;
     ILaya.TTFLoader = null;
     ILaya.SoundManager = null;
     ILaya.WebAudioSound = null;
     ILaya.AudioSound = null;
     ILaya.ShaderCompile = null;
     ILaya.ClassUtils = null;
     ILaya.SceneUtils = null;
     ILaya.Context = null;
     ILaya.Render = null;
     ILaya.MouseManager = null;
     ILaya.Text = null;
     ILaya.Browser = null;
     ILaya.WebGL = null;
     ILaya.Pool = null;
     ILaya.Utils = null;
     ILaya.Graphics = null;
     ILaya.Submit = null;
     ILaya.Stage = null;
     ILaya.Resource = null;
     ILaya.__classMap = {};

     /**
          * <p> <code>Pool</code> 是对象池类，用于对象的存储、重复使用。</p>
          * <p>合理使用对象池，可以有效减少对象创建的开销，避免频繁的垃圾回收，从而优化游戏流畅度。</p>
          */
     class Pool {
         /**
          * 根据对象类型标识字符，获取对象池。
          * @param sign 对象类型标识字符。
          * @return 对象池。
          */
         static getPoolBySign(sign) {
             return Pool._poolDic[sign] || (Pool._poolDic[sign] = []);
         }
         /**
          * 清除对象池的对象。
          * @param sign 对象类型标识字符。
          */
         static clearBySign(sign) {
             if (Pool._poolDic[sign])
                 Pool._poolDic[sign].length = 0;
         }
         /**
          * 将对象放到对应类型标识的对象池中。
          * @param sign 对象类型标识字符。
          * @param item 对象。
          */
         static recover(sign, item) {
             if (item[Pool.POOLSIGN])
                 return;
             item[Pool.POOLSIGN] = true;
             Pool.getPoolBySign(sign).push(item);
         }
         /**
          * 根据类名进行回收，如果类有类名才进行回收，没有则不回收
          * @param	instance 类的具体实例
          */
         static recoverByClass(instance) {
             if (instance) {
                 var className = instance["__className"] || instance.constructor._$gid;
                 if (className)
                     Pool.recover(className, instance);
             }
         }
         /**
          * 返回类的唯一标识
          */
         static _getClassSign(cla) {
             var className = cla["__className"] || cla["_$gid"];
             if (!className) {
                 cla["_$gid"] = className = Pool._CLSID + "";
                 Pool._CLSID++;
             }
             return className;
         }
         /**
          * 根据类名回收类的实例
          * @param	instance 类的具体实例
          */
         static createByClass(cls) {
             return Pool.getItemByClass(Pool._getClassSign(cls), cls);
         }
         /**
          * <p>根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。</p>
          * <p>当对象池中无此类型标识的对象时，则根据传入的类型，创建一个新的对象返回。</p>
          * @param sign 对象类型标识字符。
          * @param cls 用于创建该类型对象的类。
          * @return 此类型标识的一个对象。
          */
         static getItemByClass(sign, cls) {
             if (!Pool._poolDic[sign])
                 return new cls();
             var pool = Pool.getPoolBySign(sign);
             if (pool.length) {
                 var rst = pool.pop();
                 rst[Pool.POOLSIGN] = false;
             }
             else {
                 rst = new cls();
             }
             return rst;
         }
         /**
          * <p>根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。</p>
          * <p>当对象池中无此类型标识的对象时，则使用传入的创建此类型对象的函数，新建一个对象返回。</p>
          * @param sign 对象类型标识字符。
          * @param createFun 用于创建该类型对象的方法。
          * @param caller this对象
          * @return 此类型标识的一个对象。
          */
         static getItemByCreateFun(sign, createFun, caller = null) {
             var pool = Pool.getPoolBySign(sign);
             var rst = pool.length ? pool.pop() : createFun.call(caller);
             rst[Pool.POOLSIGN] = false;
             return rst;
         }
         /**
          * 根据传入的对象类型标识字符，获取对象池中已存储的此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。
          * @param sign 对象类型标识字符。
          * @return 对象池中此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。
          */
         static getItem(sign) {
             var pool = Pool.getPoolBySign(sign);
             var rst = pool.length ? pool.pop() : null;
             if (rst) {
                 rst[Pool.POOLSIGN] = false;
             }
             return rst;
         }
     }
     /**@private */
     Pool._CLSID = 0;
     /**@private */
     Pool.POOLSIGN = "__InPool";
     /**@private  对象存放池。*/
     Pool._poolDic = {};

     /**
      * 透明命令
      */
     class AlphaCmd {
         /**@private */
         static create(alpha) {
             var cmd = Pool.getItemByClass("AlphaCmd", AlphaCmd);
             cmd.alpha = alpha;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("AlphaCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.alpha(this.alpha);
         }
         /**@private */
         get cmdID() {
             return AlphaCmd.ID;
         }
     }
     AlphaCmd.ID = "Alpha";

     /**
      * 绘制圆形
      */
     class DrawCircleCmd {
         /**@private */
         static create(x, y, radius, fillColor, lineColor, lineWidth, vid) {
             var cmd = Pool.getItemByClass("DrawCircleCmd", DrawCircleCmd);
             cmd.x = x;
             cmd.y = y;
             cmd.radius = radius;
             cmd.fillColor = fillColor;
             cmd.lineColor = lineColor;
             cmd.lineWidth = lineWidth;
             cmd.vid = vid;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.fillColor = null;
             this.lineColor = null;
             Pool.recover("DrawCircleCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context._drawCircle(this.x + gx, this.y + gy, this.radius, this.fillColor, this.lineColor, this.lineWidth, this.vid);
         }
         /**@private */
         get cmdID() {
             return DrawCircleCmd.ID;
         }
     }
     DrawCircleCmd.ID = "DrawCircle";

     /**
      * 绘制曲线
      */
     class DrawCurvesCmd {
         /**@private */
         static create(x, y, points, lineColor, lineWidth) {
             var cmd = Pool.getItemByClass("DrawCurvesCmd", DrawCurvesCmd);
             cmd.x = x;
             cmd.y = y;
             cmd.points = points;
             cmd.lineColor = lineColor;
             cmd.lineWidth = lineWidth;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.points = null;
             this.lineColor = null;
             Pool.recover("DrawCurvesCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.drawCurves(this.x + gx, this.y + gy, this.points, this.lineColor, this.lineWidth);
         }
         /**@private */
         get cmdID() {
             return DrawCurvesCmd.ID;
         }
     }
     DrawCurvesCmd.ID = "DrawCurves";

     /**
      * 绘制图片
      */
     class DrawImageCmd {
         /**@private */
         static create(texture, x, y, width, height) {
             var cmd = Pool.getItemByClass("DrawImageCmd", DrawImageCmd);
             cmd.texture = texture;
             texture._addReference();
             cmd.x = x;
             cmd.y = y;
             cmd.width = width;
             cmd.height = height;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.texture._removeReference();
             this.texture = null;
             Pool.recover("DrawImageCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.drawTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height);
         }
         /**@private */
         get cmdID() {
             return DrawImageCmd.ID;
         }
     }
     DrawImageCmd.ID = "DrawImage";

     /**
      * 绘制单条曲线
      */
     class DrawLineCmd {
         /**@private */
         static create(fromX, fromY, toX, toY, lineColor, lineWidth, vid) {
             var cmd = Pool.getItemByClass("DrawLineCmd", DrawLineCmd);
             cmd.fromX = fromX;
             cmd.fromY = fromY;
             cmd.toX = toX;
             cmd.toY = toY;
             cmd.lineColor = lineColor;
             cmd.lineWidth = lineWidth;
             cmd.vid = vid;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("DrawLineCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context._drawLine(gx, gy, this.fromX, this.fromY, this.toX, this.toY, this.lineColor, this.lineWidth, this.vid);
         }
         /**@private */
         get cmdID() {
             return DrawLineCmd.ID;
         }
     }
     DrawLineCmd.ID = "DrawLine";

     /**
      * 绘制连续曲线
      */
     class DrawLinesCmd {
         /**@private */
         static create(x, y, points, lineColor, lineWidth, vid) {
             var cmd = Pool.getItemByClass("DrawLinesCmd", DrawLinesCmd);
             cmd.x = x;
             cmd.y = y;
             cmd.points = points;
             cmd.lineColor = lineColor;
             cmd.lineWidth = lineWidth;
             cmd.vid = vid;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.points = null;
             this.lineColor = null;
             Pool.recover("DrawLinesCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context._drawLines(this.x + gx, this.y + gy, this.points, this.lineColor, this.lineWidth, this.vid);
         }
         /**@private */
         get cmdID() {
             return DrawLinesCmd.ID;
         }
     }
     DrawLinesCmd.ID = "DrawLines";

     /**
      * 根据路径绘制矢量图形
      */
     class DrawPathCmd {
         /**@private */
         static create(x, y, paths, brush, pen) {
             var cmd = Pool.getItemByClass("DrawPathCmd", DrawPathCmd);
             cmd.x = x;
             cmd.y = y;
             cmd.paths = paths;
             cmd.brush = brush;
             cmd.pen = pen;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.paths = null;
             this.brush = null;
             this.pen = null;
             Pool.recover("DrawPathCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context._drawPath(this.x + gx, this.y + gy, this.paths, this.brush, this.pen);
         }
         /**@private */
         get cmdID() {
             return DrawPathCmd.ID;
         }
     }
     DrawPathCmd.ID = "DrawPath";

     /**
      * 绘制扇形
      */
     class DrawPieCmd {
         /**@private */
         static create(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {
             var cmd = Pool.getItemByClass("DrawPieCmd", DrawPieCmd);
             cmd.x = x;
             cmd.y = y;
             cmd.radius = radius;
             cmd._startAngle = startAngle;
             cmd._endAngle = endAngle;
             cmd.fillColor = fillColor;
             cmd.lineColor = lineColor;
             cmd.lineWidth = lineWidth;
             cmd.vid = vid;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.fillColor = null;
             this.lineColor = null;
             Pool.recover("DrawPieCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context._drawPie(this.x + gx, this.y + gy, this.radius, this._startAngle, this._endAngle, this.fillColor, this.lineColor, this.lineWidth, this.vid);
         }
         /**@private */
         get cmdID() {
             return DrawPieCmd.ID;
         }
         /**
          * 开始角度。
          */
         get startAngle() {
             return this._startAngle * 180 / Math.PI;
         }
         set startAngle(value) {
             this._startAngle = value * Math.PI / 180;
         }
         /**
          * 结束角度。
          */
         get endAngle() {
             return this._endAngle * 180 / Math.PI;
         }
         set endAngle(value) {
             this._endAngle = value * Math.PI / 180;
         }
     }
     DrawPieCmd.ID = "DrawPie";

     /**
      * 绘制多边形
      */
     class DrawPolyCmd {
         /**@private */
         static create(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {
             var cmd = Pool.getItemByClass("DrawPolyCmd", DrawPolyCmd);
             cmd.x = x;
             cmd.y = y;
             cmd.points = points;
             cmd.fillColor = fillColor;
             cmd.lineColor = lineColor;
             cmd.lineWidth = lineWidth;
             cmd.isConvexPolygon = isConvexPolygon;
             cmd.vid = vid;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.points = null;
             this.fillColor = null;
             this.lineColor = null;
             Pool.recover("DrawPolyCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context._drawPoly(this.x + gx, this.y + gy, this.points, this.fillColor, this.lineColor, this.lineWidth, this.isConvexPolygon, this.vid);
         }
         /**@private */
         get cmdID() {
             return DrawPolyCmd.ID;
         }
     }
     DrawPolyCmd.ID = "DrawPoly";

     /**
      * 绘制矩形
      */
     class DrawRectCmd {
         /**@private */
         static create(x, y, width, height, fillColor, lineColor, lineWidth) {
             var cmd = Pool.getItemByClass("DrawRectCmd", DrawRectCmd);
             cmd.x = x;
             cmd.y = y;
             cmd.width = width;
             cmd.height = height;
             cmd.fillColor = fillColor;
             cmd.lineColor = lineColor;
             cmd.lineWidth = lineWidth;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.fillColor = null;
             this.lineColor = null;
             Pool.recover("DrawRectCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.drawRect(this.x + gx, this.y + gy, this.width, this.height, this.fillColor, this.lineColor, this.lineWidth);
         }
         /**@private */
         get cmdID() {
             return DrawRectCmd.ID;
         }
     }
     DrawRectCmd.ID = "DrawRect";

     /**
      * <p> <code>Matrix</code> 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。</p>
      * <p>您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。</p>
      */
     class Matrix {
         /**
          * 使用指定参数创建新的 <code>Matrix</code> 对象。
          * @param a		（可选）缩放或旋转图像时影响像素沿 x 轴定位的值。
          * @param b		（可选）旋转或倾斜图像时影响像素沿 y 轴定位的值。
          * @param c		（可选）旋转或倾斜图像时影响像素沿 x 轴定位的值。
          * @param d		（可选）缩放或旋转图像时影响像素沿 y 轴定位的值。
          * @param tx	（可选）沿 x 轴平移每个点的距离。
          * @param ty	（可选）沿 y 轴平移每个点的距离。
          */
         constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0, nums = 0) {
             /**@private 是否有旋转缩放操作*/
             this._bTransform = false;
             if (Matrix._createFun != null) {
                 return Matrix._createFun(a, b, c, d, tx, ty, nums);
             }
             this.a = a;
             this.b = b;
             this.c = c;
             this.d = d;
             this.tx = tx;
             this.ty = ty;
             this._checkTransform();
         }
         /**
          * 将本矩阵设置为单位矩阵。
          * @return 返回当前矩形。
          */
         identity() {
             this.a = this.d = 1;
             this.b = this.tx = this.ty = this.c = 0;
             this._bTransform = false;
             return this;
         }
         /**@private */
         _checkTransform() {
             return this._bTransform = (this.a !== 1 || this.b !== 0 || this.c !== 0 || this.d !== 1);
         }
         /**
          * 设置沿 x 、y 轴平移每个点的距离。
          * @param	x 沿 x 轴平移每个点的距离。
          * @param	y 沿 y 轴平移每个点的距离。
          * @return	返回对象本身
          */
         setTranslate(x, y) {
             this.tx = x;
             this.ty = y;
             return this;
         }
         /**
          * 沿 x 和 y 轴平移矩阵，平移的变化量由 x 和 y 参数指定。
          * @param	x 沿 x 轴向右移动的量（以像素为单位）。
          * @param	y 沿 y 轴向下移动的量（以像素为单位）。
          * @return 返回此矩形对象。
          */
         translate(x, y) {
             this.tx += x;
             this.ty += y;
             return this;
         }
         /**
          * 对矩阵应用缩放转换。
          * @param	x 用于沿 x 轴缩放对象的乘数。
          * @param	y 用于沿 y 轴缩放对象的乘数。
          * @return	返回矩阵对象本身
          */
         scale(x, y) {
             this.a *= x;
             this.d *= y;
             this.c *= x;
             this.b *= y;
             this.tx *= x;
             this.ty *= y;
             this._bTransform = true;
             return this;
         }
         /**
          * 对 Matrix 对象应用旋转转换。
          * @param	angle 以弧度为单位的旋转角度。
          * @return	返回矩阵对象本身
          */
         rotate(angle) {
             var cos = Math.cos(angle);
             var sin = Math.sin(angle);
             var a1 = this.a;
             var c1 = this.c;
             var tx1 = this.tx;
             this.a = a1 * cos - this.b * sin;
             this.b = a1 * sin + this.b * cos;
             this.c = c1 * cos - this.d * sin;
             this.d = c1 * sin + this.d * cos;
             this.tx = tx1 * cos - this.ty * sin;
             this.ty = tx1 * sin + this.ty * cos;
             this._bTransform = true;
             return this;
         }
         /**
          * 对 Matrix 对象应用倾斜转换。
          * @param	x 沿着 X 轴的 2D 倾斜弧度。
          * @param	y 沿着 Y 轴的 2D 倾斜弧度。
          * @return 当前 Matrix 对象。
          */
         skew(x, y) {
             var tanX = Math.tan(x);
             var tanY = Math.tan(y);
             var a1 = this.a;
             var b1 = this.b;
             this.a += tanY * this.c;
             this.b += tanY * this.d;
             this.c += tanX * a1;
             this.d += tanX * b1;
             return this;
         }
         /**
          * 对指定的点应用当前矩阵的逆转化并返回此点。
          * @param	out 待转化的点 Point 对象。
          * @return	返回out
          */
         invertTransformPoint(out) {
             var a1 = this.a;
             var b1 = this.b;
             var c1 = this.c;
             var d1 = this.d;
             var tx1 = this.tx;
             var n = a1 * d1 - b1 * c1;
             var a2 = d1 / n;
             var b2 = -b1 / n;
             var c2 = -c1 / n;
             var d2 = a1 / n;
             var tx2 = (c1 * this.ty - d1 * tx1) / n;
             var ty2 = -(a1 * this.ty - b1 * tx1) / n;
             return out.setTo(a2 * out.x + c2 * out.y + tx2, b2 * out.x + d2 * out.y + ty2);
         }
         /**
          * 将 Matrix 对象表示的几何转换应用于指定点。
          * @param	out 用来设定输出结果的点。
          * @return	返回out
          */
         transformPoint(out) {
             return out.setTo(this.a * out.x + this.c * out.y + this.tx, this.b * out.x + this.d * out.y + this.ty);
         }
         /**
          * 将 Matrix 对象表示的几何转换应用于指定点，忽略tx、ty。
          * @param	out 用来设定输出结果的点。
          * @return	返回out
          */
         transformPointN(out) {
             return out.setTo(this.a * out.x + this.c * out.y /*+ tx*/, this.b * out.x + this.d * out.y /*+ ty*/);
         }
         /**
          * 获取 X 轴缩放值。
          * @return  X 轴缩放值。
          */
         getScaleX() {
             return this.b === 0 ? this.a : Math.sqrt(this.a * this.a + this.b * this.b);
         }
         /**
          * 获取 Y 轴缩放值。
          * @return Y 轴缩放值。
          */
         getScaleY() {
             return this.c === 0 ? this.d : Math.sqrt(this.c * this.c + this.d * this.d);
         }
         /**
          * 执行原始矩阵的逆转换。
          * @return 当前矩阵对象。
          */
         invert() {
             var a1 = this.a;
             var b1 = this.b;
             var c1 = this.c;
             var d1 = this.d;
             var tx1 = this.tx;
             var n = a1 * d1 - b1 * c1;
             this.a = d1 / n;
             this.b = -b1 / n;
             this.c = -c1 / n;
             this.d = a1 / n;
             this.tx = (c1 * this.ty - d1 * tx1) / n;
             this.ty = -(a1 * this.ty - b1 * tx1) / n;
             return this;
         }
         /**
          *  将 Matrix 的成员设置为指定值。
          * @param	a 缩放或旋转图像时影响像素沿 x 轴定位的值。
          * @param	b 旋转或倾斜图像时影响像素沿 y 轴定位的值。
          * @param	c 旋转或倾斜图像时影响像素沿 x 轴定位的值。
          * @param	d 缩放或旋转图像时影响像素沿 y 轴定位的值。
          * @param	tx 沿 x 轴平移每个点的距离。
          * @param	ty 沿 y 轴平移每个点的距离。
          * @return 当前矩阵对象。
          */
         setTo(a, b, c, d, tx, ty) {
             this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;
             return this;
         }
         /**
          * 将指定矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
          * @param	matrix 要连接到源矩阵的矩阵。
          * @return	当前矩阵。
          */
         concat(matrix) {
             var a = this.a;
             var c = this.c;
             var tx = this.tx;
             this.a = a * matrix.a + this.b * matrix.c;
             this.b = a * matrix.b + this.b * matrix.d;
             this.c = c * matrix.a + this.d * matrix.c;
             this.d = c * matrix.b + this.d * matrix.d;
             this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx;
             this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty;
             return this;
         }
         /**
          * 将指定的两个矩阵相乘后的结果赋值给指定的输出对象。
          * @param	m1 矩阵一。
          * @param	m2 矩阵二。
          * @param	out 输出对象。
          * @return	结果输出对象 out。
          */
         static mul(m1, m2, out) {
             var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
             var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
             if (bb !== 0 || bc !== 0) {
                 out.a = aa * ba + ab * bc;
                 out.b = aa * bb + ab * bd;
                 out.c = ac * ba + ad * bc;
                 out.d = ac * bb + ad * bd;
                 out.tx = ba * atx + bc * aty + btx;
                 out.ty = bb * atx + bd * aty + bty;
             }
             else {
                 out.a = aa * ba;
                 out.b = ab * bd;
                 out.c = ac * ba;
                 out.d = ad * bd;
                 out.tx = ba * atx + btx;
                 out.ty = bd * aty + bty;
             }
             return out;
         }
         /**
          * 将指定的两个矩阵相乘，结果赋值给指定的输出数组，长度为16。
          * @param m1	矩阵一。
          * @param m2	矩阵二。
          * @param out	输出对象Array。
          * @return 结果输出对象 out。
          */
         static mul16(m1, m2, out) {
             var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
             var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
             if (bb !== 0 || bc !== 0) {
                 out[0] = aa * ba + ab * bc;
                 out[1] = aa * bb + ab * bd;
                 out[4] = ac * ba + ad * bc;
                 out[5] = ac * bb + ad * bd;
                 out[12] = ba * atx + bc * aty + btx;
                 out[13] = bb * atx + bd * aty + bty;
             }
             else {
                 out[0] = aa * ba;
                 out[1] = ab * bd;
                 out[4] = ac * ba;
                 out[5] = ad * bd;
                 out[12] = ba * atx + btx;
                 out[13] = bd * aty + bty;
             }
             return out;
         }
         /**
          * @private
          * 对矩阵应用缩放转换。反向相乘
          * @param	x 用于沿 x 轴缩放对象的乘数。
          * @param	y 用于沿 y 轴缩放对象的乘数。
          */
         scaleEx(x, y) {
             var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
             if (bb !== 0 || bc !== 0) {
                 this.a = x * ba;
                 this.b = x * bb;
                 this.c = y * bc;
                 this.d = y * bd;
             }
             else {
                 this.a = x * ba;
                 this.b = 0 * bd;
                 this.c = 0 * ba;
                 this.d = y * bd;
             }
             this._bTransform = true;
         }
         /**
          * @private
          * 对 Matrix 对象应用旋转转换。反向相乘
          * @param	angle 以弧度为单位的旋转角度。
          */
         rotateEx(angle) {
             var cos = Math.cos(angle);
             var sin = Math.sin(angle);
             var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
             if (bb !== 0 || bc !== 0) {
                 this.a = cos * ba + sin * bc;
                 this.b = cos * bb + sin * bd;
                 this.c = -sin * ba + cos * bc;
                 this.d = -sin * bb + cos * bd;
             }
             else {
                 this.a = cos * ba;
                 this.b = sin * bd;
                 this.c = -sin * ba;
                 this.d = cos * bd;
             }
             this._bTransform = true;
         }
         /**
          * 返回此 Matrix 对象的副本。
          * @return 与原始实例具有完全相同的属性的新 Matrix 实例。
          */
         clone() {
             var dec = Matrix.create();
             dec.a = this.a;
             dec.b = this.b;
             dec.c = this.c;
             dec.d = this.d;
             dec.tx = this.tx;
             dec.ty = this.ty;
             dec._bTransform = this._bTransform;
             return dec;
         }
         /**
          * 将当前 Matrix 对象中的所有矩阵数据复制到指定的 Matrix 对象中。
          * @param	dec 要复制当前矩阵数据的 Matrix 对象。
          * @return	已复制当前矩阵数据的 Matrix 对象。
          */
         copyTo(dec) {
             dec.a = this.a;
             dec.b = this.b;
             dec.c = this.c;
             dec.d = this.d;
             dec.tx = this.tx;
             dec.ty = this.ty;
             dec._bTransform = this._bTransform;
             return dec;
         }
         /**
          * 返回列出该 Matrix 对象属性的文本值。
          * @return 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
          */
         toString() {
             return this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.tx + "," + this.ty;
         }
         /**
          * 销毁此对象。
          */
         destroy() {
             this.recover();
         }
         /**
          * 回收到对象池，方便复用
          */
         recover() {
             Pool.recover("Matrix", this.identity());
         }
         /**
          * 从对象池中创建一个 <code>Matrix</code> 对象。
          * @return <code>Matrix</code> 对象。
          */
         static create() {
             return Pool.getItemByClass("Matrix", Matrix);
         }
     }
     /**@private 一个初始化的 <code>Matrix</code> 对象，不允许修改此对象内容。*/
     Matrix.EMPTY = new Matrix();
     /**用于中转使用的 <code>Matrix</code> 对象。*/
     Matrix.TEMP = new Matrix();
     /**@private */
     Matrix._createFun = null;

     /**
      * <code>Point</code> 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
      */
     class Point {
         /**
          * 根据指定坐标，创建一个新的 <code>Point</code> 对象。
          * @param x	（可选）水平坐标。
          * @param y	（可选）垂直坐标。
          */
         constructor(x = 0, y = 0) {
             this.x = x;
             this.y = y;
         }
         /**
          * 从对象池创建
          */
         static create() {
             return Pool.getItemByClass("Point", Point);
         }
         /**
          * 将 <code>Point</code> 的成员设置为指定值。
          * @param	x 水平坐标。
          * @param	y 垂直坐标。
          * @return 当前 Point 对象。
          */
         setTo(x, y) {
             this.x = x;
             this.y = y;
             return this;
         }
         /**
          * 重置
          */
         reset() {
             this.x = this.y = 0;
             return this;
         }
         /**
          * 回收到对象池，方便复用
          */
         recover() {
             Pool.recover("Point", this.reset());
         }
         /**
          * 计算当前点和目标点(x，y)的距离。
          * @param	x 水平坐标。
          * @param	y 垂直坐标。
          * @return	返回当前点和目标点之间的距离。
          */
         distance(x, y) {
             return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
         }
         /**返回包含 x 和 y 坐标的值的字符串。*/
         toString() {
             return this.x + "," + this.y;
         }
         /**
          * 标准化向量。
          */
         normalize() {
             var d = Math.sqrt(this.x * this.x + this.y * this.y);
             if (d > 0) {
                 var id = 1.0 / d;
                 this.x *= id;
                 this.y *= id;
             }
         }
         /**
          * copy point坐标
          * @param	point 需要被copy的point
          */
         copy(point) {
             return this.setTo(point.x, point.y);
         }
     }
     /**临时使用的公用对象。*/
     Point.TEMP = new Point();
     /**@private 全局空的point对象(x=0，y=0)，不允许修改此对象内容*/
     Point.EMPTY = new Point();

     /**
      * <p><code>Rectangle</code> 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。</p>
      * <p>Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。</p>
      */
     class Rectangle {
         /**
          * 创建一个 <code>Rectangle</code> 对象。
          * @param	x 矩形左上角的 X 轴坐标。
          * @param	y 矩形左上角的 Y 轴坐标。
          * @param	width 矩形的宽度。
          * @param	height 矩形的高度。
          */
         constructor(x = 0, y = 0, width = 0, height = 0) {
             this.x = x;
             this.y = y;
             this.width = width;
             this.height = height;
         }
         /** 此矩形右侧的 X 轴坐标。 x 和 width 属性的和。*/
         get right() {
             return this.x + this.width;
         }
         /** 此矩形底端的 Y 轴坐标。y 和 height 属性的和。*/
         get bottom() {
             return this.y + this.height;
         }
         /**
          * 将 Rectangle 的属性设置为指定值。
          * @param	x	x 矩形左上角的 X 轴坐标。
          * @param	y	x 矩形左上角的 Y 轴坐标。
          * @param	width	矩形的宽度。
          * @param	height	矩形的高。
          * @return	返回属性值修改后的矩形对象本身。
          */
         setTo(x, y, width, height) {
             this.x = x;
             this.y = y;
             this.width = width;
             this.height = height;
             return this;
         }
         /**
          * 重置
          */
         reset() {
             this.x = this.y = this.width = this.height = 0;
             return this;
         }
         /**
          * 回收
          */
         recover() {
             if (this == Rectangle.TEMP || this == Rectangle.EMPTY) {
                 console.log("recover Temp or Empty:", this);
                 return;
             }
             Pool.recover("Rectangle", this.reset());
         }
         /**
          * 创建
          */
         static create() {
             return Pool.getItemByClass("Rectangle", Rectangle);
         }
         /**
          * 复制 source 对象的属性值到此矩形对象中。
          * @param	sourceRect	源 Rectangle 对象。
          * @return	返回属性值修改后的矩形对象本身。
          */
         copyFrom(source) {
             this.x = source.x;
             this.y = source.y;
             this.width = source.width;
             this.height = source.height;
             return this;
         }
         /**
          * 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
          * @param x	点的 X 轴坐标值（水平位置）。
          * @param y	点的 Y 轴坐标值（垂直位置）。
          * @return	如果 Rectangle 对象包含指定的点，则值为 true；否则为 false。
          */
         contains(x, y) {
             if (this.width <= 0 || this.height <= 0)
                 return false;
             if (x >= this.x && x < this.right) {
                 if (y >= this.y && y < this.bottom) {
                     return true;
                 }
             }
             return false;
         }
         /**
          * 确定在 rect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
          * @param	rect Rectangle 对象。
          * @return	如果传入的矩形对象与此对象相交，则返回 true 值，否则返回 false。
          */
         intersects(rect) {
             return !(rect.x > (this.x + this.width) || (rect.x + rect.width) < this.x || rect.y > (this.y + this.height) || (rect.y + rect.height) < this.y);
         }
         /**
          * 如果在 rect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。如果矩形不相交，则此方法返回null。
          * @param rect	待比较的矩形区域。
          * @param out	（可选）待输出的矩形区域。如果为空则创建一个新的。建议：尽量复用对象，减少对象创建消耗。
          * @return	返回相交的矩形区域对象。
          */
         intersection(rect, out = null) {
             if (!this.intersects(rect))
                 return null;
             out || (out = new Rectangle());
             out.x = Math.max(this.x, rect.x);
             out.y = Math.max(this.y, rect.y);
             out.width = Math.min(this.right, rect.right) - out.x;
             out.height = Math.min(this.bottom, rect.bottom) - out.y;
             return out;
         }
         /**
          * <p>矩形联合，通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。</p>
          * <p>注意：union() 方法忽略高度或宽度值为 0 的矩形，如：var rect2:Rectangle = new Rectangle(300,300,50,0);</p>
          * @param	要添加到此 Rectangle 对象的 Rectangle 对象。
          * @param	out	用于存储输出结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。Rectangle.TEMP对象用于对象复用。
          * @return	充当两个矩形的联合的新 Rectangle 对象。
          */
         union(source, out = null) {
             out || (out = new Rectangle());
             this.clone(out);
             if (source.width <= 0 || source.height <= 0)
                 return out;
             out.addPoint(source.x, source.y);
             out.addPoint(source.right, source.bottom);
             return this;
         }
         /**
          * 返回一个 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
          * @param out	（可选）用于存储结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。。Rectangle.TEMP对象用于对象复用。
          * @return Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
          */
         clone(out = null) {
             out || (out = new Rectangle());
             out.x = this.x;
             out.y = this.y;
             out.width = this.width;
             out.height = this.height;
             return out;
         }
         /**
          * 当前 Rectangle 对象的水平位置 x 和垂直位置 y 以及高度 width 和宽度 height 以逗号连接成的字符串。
          */
         toString() {
             return this.x + "," + this.y + "," + this.width + "," + this.height;
         }
         /**
          * 检测传入的 Rectangle 对象的属性是否与当前 Rectangle 对象的属性 x、y、width、height 属性值都相等。
          * @param	rect 待比较的 Rectangle 对象。
          * @return	如果判断的属性都相等，则返回 true ,否则返回 false。
          */
         equals(rect) {
             if (!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height)
                 return false;
             return true;
         }
         /**
          * <p>为当前矩形对象加一个点，以使当前矩形扩展为包含当前矩形和此点的最小矩形。</p>
          * <p>此方法会修改本对象。</p>
          * @param x	点的 X 坐标。
          * @param y	点的 Y 坐标。
          * @return 返回此 Rectangle 对象。
          */
         addPoint(x, y) {
             this.x > x && (this.width += this.x - x, this.x = x); //左边界比较
             this.y > y && (this.height += this.y - y, this.y = y); //上边界比较
             if (this.width < x - this.x)
                 this.width = x - this.x; //右边界比较
             if (this.height < y - this.y)
                 this.height = y - this.y; //下边界比较
             return this;
         }
         /**
          * @private
          * 返回代表当前矩形的顶点数据。
          * @return 顶点数据。
          */
         _getBoundPoints() {
             var rst = Rectangle._temB;
             rst.length = 0;
             if (this.width == 0 || this.height == 0)
                 return rst;
             rst.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height);
             return rst;
         }
         /**
          * @private
          * 返回矩形的顶点数据。
          */
         static _getBoundPointS(x, y, width, height) {
             var rst = Rectangle._temA;
             rst.length = 0;
             if (width == 0 || height == 0)
                 return rst;
             rst.push(x, y, x + width, y, x, y + height, x + width, y + height);
             return rst;
         }
         /**
          * @private
          * 返回包含所有点的最小矩形。
          * @param pointList 点列表。
          * @return 包含所有点的最小矩形矩形对象。
          */
         static _getWrapRec(pointList, rst = null) {
             if (!pointList || pointList.length < 1)
                 return rst ? rst.setTo(0, 0, 0, 0) : Rectangle.TEMP.setTo(0, 0, 0, 0);
             rst = rst ? rst : Rectangle.create();
             var i, len = pointList.length, minX, maxX, minY, maxY, tPoint = Point.TEMP;
             minX = minY = 99999;
             maxX = maxY = -minX;
             for (i = 0; i < len; i += 2) {
                 tPoint.x = pointList[i];
                 tPoint.y = pointList[i + 1];
                 minX = minX < tPoint.x ? minX : tPoint.x;
                 minY = minY < tPoint.y ? minY : tPoint.y;
                 maxX = maxX > tPoint.x ? maxX : tPoint.x;
                 maxY = maxY > tPoint.y ? maxY : tPoint.y;
             }
             return rst.setTo(minX, minY, maxX - minX, maxY - minY);
         }
         /**
          * 确定此 Rectangle 对象是否为空。
          * @return 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false。
          */
         isEmpty() {
             if (this.width <= 0 || this.height <= 0)
                 return true;
             return false;
         }
     }
     /**@private 全局空的矩形区域x=0,y=0,width=0,height=0，不允许修改此对象内容*/
     Rectangle.EMPTY = new Rectangle();
     /**全局临时的矩形区域，此对象用于全局复用，以减少对象创建*/
     Rectangle.TEMP = new Rectangle();
     /** @private */
     Rectangle._temB = [];
     /** @private */
     Rectangle._temA = [];

     /**
      * @private
      * CommandEncoder
      */
     class CommandEncoder {
         //TODO:coverage
         constructor(layagl, reserveSize, adjustSize, isSyncToRenderThread) {
             this._idata = [];
         }
         //TODO:coverage
         getArrayData() {
             return this._idata;
         }
         //TODO:coverage
         getPtrID() {
             return 0;
         }
         beginEncoding() {
         }
         endEncoding() {
         }
         //TODO:coverage
         clearEncoding() {
             this._idata.length = 0;
         }
         //TODO:coverage
         getCount() {
             return this._idata.length;
         }
         //TODO:coverage
         add_ShaderValue(o) {
             this._idata.push(o);
         }
         //TODO:coverage
         addShaderUniform(one) {
             this.add_ShaderValue(one);
         }
     }

     /**
      * @private
      * 封装GL命令
      */
     class LayaGL {
         //TODO:coverage
         createCommandEncoder(reserveSize = 128, adjustSize = 64, isSyncToRenderThread = false) {
             return new CommandEncoder(this, reserveSize, adjustSize, isSyncToRenderThread);
         }
         beginCommandEncoding(commandEncoder) {
         }
         endCommandEncoding() {
         }
         //TODO:coverage
         static getFrameCount() {
             return 0;
         }
         static syncBufferToRenderThread(value, index = 0) {
         }
         static createArrayBufferRef(arrayBuffer, type, syncRender) {
         }
         static createArrayBufferRefs(arrayBuffer, type, syncRender, refType) {
         }
         matrix4x4Multiply(m1, m2, out) {
         }
         evaluateClipDatasRealTime(nodes, playCurTime, realTimeCurrentFrameIndexs, addtive) {
         }
     }
     //-------------------------------------------------------------------------------------
     LayaGL.EXECUTE_JS_THREAD_BUFFER = 0; //直接执行JS线程中的buffer
     LayaGL.EXECUTE_RENDER_THREAD_BUFFER = 1; //直接执行渲染线程的buffer
     LayaGL.EXECUTE_COPY_TO_RENDER = 2; //拷贝buffer到渲染线程
     LayaGL.EXECUTE_COPY_TO_RENDER3D = 3; //拷贝3Dbuffer到渲染线程
     //-------------------------------------------------------------------------------------
     LayaGL.ARRAY_BUFFER_TYPE_DATA = 0; //创建ArrayBuffer时的类型为Data
     LayaGL.ARRAY_BUFFER_TYPE_CMD = 1; //创建ArrayBuffer时的类型为Command
     LayaGL.ARRAY_BUFFER_REF_REFERENCE = 0; //创建ArrayBuffer时的类型为引用
     LayaGL.ARRAY_BUFFER_REF_COPY = 1; //创建ArrayBuffer时的类型为拷贝
     LayaGL.UPLOAD_SHADER_UNIFORM_TYPE_ID = 0; //data按照ID传入
     LayaGL.UPLOAD_SHADER_UNIFORM_TYPE_DATA = 1; //data按照数据传入

     /**
          * <p><code>Handler</code> 是事件处理器类。</p>
          * <p>推荐使用 Handler.create() 方法从对象池创建，减少对象创建消耗。创建的 Handler 对象不再使用后，可以使用 Handler.recover() 将其回收到对象池，回收后不要再使用此对象，否则会导致不可预料的错误。</p>
          * <p><b>注意：</b>由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。</p>
          */
     class Handler {
         /**
          * 根据指定的属性值，创建一个 <code>Handler</code> 类的实例。
          * @param	caller 执行域。
          * @param	method 处理函数。
          * @param	args 函数参数。
          * @param	once 是否只执行一次。
          */
         constructor(caller = null, method = null, args = null, once = false) {
             /** 表示是否只执行一次。如果为true，回调后执行recover()进行回收，回收后会被再利用，默认为false 。*/
             this.once = false;
             /**@private */
             this._id = 0;
             this.setTo(caller, method, args, once);
         }
         /**
          * 设置此对象的指定属性值。
          * @param	caller 执行域(this)。
          * @param	method 回调方法。
          * @param	args 携带的参数。
          * @param	once 是否只执行一次，如果为true，执行后执行recover()进行回收。
          * @return  返回 handler 本身。
          */
         setTo(caller, method, args, once) {
             this._id = Handler._gid++;
             this.caller = caller;
             this.method = method;
             this.args = args;
             this.once = once;
             return this;
         }
         /**
          * 执行处理器。
          */
         run() {
             if (this.method == null)
                 return null;
             var id = this._id;
             var result = this.method.apply(this.caller, this.args);
             this._id === id && this.once && this.recover();
             return result;
         }
         /**
          * 执行处理器，并携带额外数据。
          * @param	data 附加的回调数据，可以是单数据或者Array(作为多参)。
          */
         runWith(data) {
             if (this.method == null)
                 return null;
             var id = this._id;
             if (data == null)
                 var result = this.method.apply(this.caller, this.args);
             else if (!this.args && !data.unshift)
                 result = this.method.call(this.caller, data);
             else if (this.args)
                 result = this.method.apply(this.caller, this.args.concat(data));
             else
                 result = this.method.apply(this.caller, data);
             this._id === id && this.once && this.recover();
             return result;
         }
         /**
          * 清理对象引用。
          */
         clear() {
             this.caller = null;
             this.method = null;
             this.args = null;
             return this;
         }
         /**
          * 清理并回收到 Handler 对象池内。
          */
         recover() {
             if (this._id > 0) {
                 this._id = 0;
                 Handler._pool.push(this.clear());
             }
         }
         /**
          * 从对象池内创建一个Handler，默认会执行一次并立即回收，如果不需要自动回收，设置once参数为false。
          * @param	caller 执行域(this)。
          * @param	method 回调方法。
          * @param	args 携带的参数。
          * @param	once 是否只执行一次，如果为true，回调后执行recover()进行回收，默认为true。
          * @return  返回创建的handler实例。
          */
         static create(caller, method, args = null, once = true) {
             if (Handler._pool.length)
                 return Handler._pool.pop().setTo(caller, method, args, once);
             return new Handler(caller, method, args, once);
         }
     }
     /**@private handler对象池*/
     Handler._pool = [];
     /**@private */
     Handler._gid = 1;

     /**
      * <code>EventDispatcher</code> 类是可调度事件的所有类的基类。
      */
     class EventDispatcher {
         //[IF-JS]Object.defineProperty(EventDispatcher.prototype, "_events", {enumerable: false,writable:true});
         /**
          * 检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。
          * @param	type 事件的类型。
          * @return 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
          */
         hasListener(type) {
             var listener = this._events && this._events[type];
             return !!listener;
         }
         /**
          * 派发事件。
          * @param type	事件类型。
          * @param data	（可选）回调数据。<b>注意：</b>如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p ，且 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。
          * @return 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。
          */
         event(type, data = null) {
             if (!this._events || !this._events[type])
                 return false;
             var listeners = this._events[type];
             if (listeners.run) {
                 if (listeners.once)
                     delete this._events[type];
                 data != null ? listeners.runWith(data) : listeners.run();
             }
             else {
                 for (var i = 0, n = listeners.length; i < n; i++) {
                     var listener = listeners[i];
                     if (listener) {
                         (data != null) ? listener.runWith(data) : listener.run();
                     }
                     if (!listener || listener.once) {
                         listeners.splice(i, 1);
                         i--;
                         n--;
                     }
                 }
                 if (listeners.length === 0 && this._events)
                     delete this._events[type];
             }
             return true;
         }
         /**
          * 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
          * @param type		事件的类型。
          * @param caller	事件侦听函数的执行域。
          * @param listener	事件侦听函数。
          * @param args		（可选）事件侦听函数的回调参数。
          * @return 此 EventDispatcher 对象。
          */
         on(type, caller, listener, args = null) {
             return this._createListener(type, caller, listener, args, false);
         }
         /**
          * 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
          * @param type		事件的类型。
          * @param caller	事件侦听函数的执行域。
          * @param listener	事件侦听函数。
          * @param args		（可选）事件侦听函数的回调参数。
          * @return 此 EventDispatcher 对象。
          */
         once(type, caller, listener, args = null) {
             return this._createListener(type, caller, listener, args, true);
         }
         /**@private */
         _createListener(type, caller, listener, args, once, offBefore = true) {
             //移除之前相同的监听
             offBefore && this.off(type, caller, listener, once);
             //使用对象池进行创建回收
             var handler = EventHandler.create(caller || this, listener, args, once);
             this._events || (this._events = {});
             var events = this._events;
             //默认单个，每个对象只有多个监听才用数组，节省一个数组的消耗
             if (!events[type])
                 events[type] = handler;
             else {
                 if (!events[type].run)
                     events[type].push(handler);
                 else
                     events[type] = [events[type], handler];
             }
             return this;
         }
         /**
          * 从 EventDispatcher 对象中删除侦听器。
          * @param type		事件的类型。
          * @param caller	事件侦听函数的执行域。
          * @param listener	事件侦听函数。
          * @param onceOnly	（可选）如果值为 true ,则只移除通过 once 方法添加的侦听器。
          * @return 此 EventDispatcher 对象。
          */
         off(type, caller, listener, onceOnly = false) {
             if (!this._events || !this._events[type])
                 return this;
             var listeners = this._events[type];
             if (listeners != null) {
                 if (listeners.run) {
                     if ((!caller || listeners.caller === caller) && (listener == null || listeners.method === listener) && (!onceOnly || listeners.once)) {
                         delete this._events[type];
                         listeners.recover();
                     }
                 }
                 else {
                     var count = 0;
                     for (var i = 0, n = listeners.length; i < n; i++) {
                         var item = listeners[i];
                         if (!item) {
                             count++;
                             continue;
                         }
                         if (item && (!caller || item.caller === caller) && (listener == null || item.method === listener) && (!onceOnly || item.once)) {
                             count++;
                             listeners[i] = null;
                             item.recover();
                         }
                     }
                     //如果全部移除，则删除索引
                     if (count === n)
                         delete this._events[type];
                 }
             }
             return this;
         }
         /**
          * 从 EventDispatcher 对象中删除指定事件类型的所有侦听器。
          * @param type	（可选）事件类型，如果值为 null，则移除本对象所有类型的侦听器。
          * @return 此 EventDispatcher 对象。
          */
         offAll(type = null) {
             var events = this._events;
             if (!events)
                 return this;
             if (type) {
                 this._recoverHandlers(events[type]);
                 delete events[type];
             }
             else {
                 for (var name in events) {
                     this._recoverHandlers(events[name]);
                 }
                 this._events = null;
             }
             return this;
         }
         /**
          * 移除caller为target的所有事件监听
          * @param	caller caller对象
          */
         offAllCaller(caller) {
             if (caller && this._events) {
                 for (var name in this._events) {
                     this.off(name, caller, null);
                 }
             }
             return this;
         }
         _recoverHandlers(arr) {
             if (!arr)
                 return;
             if (arr.run) {
                 arr.recover();
             }
             else {
                 for (var i = arr.length - 1; i > -1; i--) {
                     if (arr[i]) {
                         arr[i].recover();
                         arr[i] = null;
                     }
                 }
             }
         }
         /**
          * 检测指定事件类型是否是鼠标事件。
          * @param	type 事件的类型。
          * @return	如果是鼠标事件，则值为 true;否则，值为 false。
          */
         isMouseEvent(type) {
             return EventDispatcher.MOUSE_EVENTS[type] || false;
         }
     }
     /**@private */
     EventDispatcher.MOUSE_EVENTS = { "rightmousedown": true, "rightmouseup": true, "rightclick": true, "mousedown": true, "mouseup": true, "mousemove": true, "mouseover": true, "mouseout": true, "click": true, "doubleclick": true };
     /**@private */
     class EventHandler extends Handler {
         constructor(caller, method, args, once) {
             super(caller, method, args, once);
         }
         /*override*/ recover() {
             if (this._id > 0) {
                 this._id = 0;
                 EventHandler._pool.push(this.clear());
             }
         }
         /**
          * 从对象池内创建一个Handler，默认会执行一次回收，如果不需要自动回收，设置once参数为false。
          * @param caller	执行域(this)。
          * @param method	回调方法。
          * @param args		（可选）携带的参数。
          * @param once		（可选）是否只执行一次，如果为true，回调后执行recover()进行回收，默认为true。
          * @return 返回创建的handler实例。
          */
         static create(caller, method, args = null, once = true) {
             if (EventHandler._pool.length)
                 return EventHandler._pool.pop().setTo(caller, method, args, once);
             return new EventHandler(caller, method, args, once);
         }
     }
     /**@private handler对象池*/
     EventHandler._pool = [];

     /**
          * <p><code>URL</code> 提供URL格式化，URL版本管理的类。</p>
          * <p>引擎加载资源的时候，会自动调用formatURL函数格式化URL路径</p>
          * <p>通过basePath属性可以设置网络基础路径</p>
          * <p>通过设置customFormat函数，可以自定义URL格式化的方式</p>
          * <p>除了默认的通过增加后缀的格式化外，通过VersionManager类，可以开启IDE提供的，基于目录的管理方式来替代 "?v=" 的管理方式</p>
          * @see laya.net.VersionManager
          */
     class URL {
         /**创建一个新的 <code>URL</code> 实例。*/
         constructor(url) {
             this._url = URL.formatURL(url);
             this._path = URL.getPath(url);
         }
         /**格式化后的地址。*/
         get url() {
             return this._url;
         }
         /**地址的文件夹路径（不包括文件名）。*/
         get path() {
             return this._path;
         }
         static set basePath(value) {
             URL._basePath = ILaya.Laya._getUrlPath(); //还原BaseURL为Index目录
             URL._basePath = URL.formatURL(value);
         }
         /**基础路径。如果不设置，默认为当前网页的路径。最终地址将被格式化为 basePath+相对URL地址，*/
         static get basePath() {
             return URL._basePath;
         }
         /**
          * 格式化指定的地址并返回。
          * @param	url 地址。
          * @param	base 基础路径，如果没有，则使用basePath。
          * @return	格式化处理后的地址。
          */
         static formatURL(url) {
             if (!url)
                 return "null path";
             //如果是全路径，直接返回，提高性能
             if (url.indexOf(":") > 0)
                 return url;
             //自定义路径格式化
             if (URL.customFormat != null)
                 url = URL.customFormat(url);
             //如果是全路径，直接返回，提高性能
             if (url.indexOf(":") > 0)
                 return url;
             var char1 = url.charAt(0);
             if (char1 === ".") {
                 return URL._formatRelativePath(URL._basePath + url);
             }
             else if (char1 === '~') {
                 return URL.rootPath + url.substring(1);
             }
             else if (char1 === "d") {
                 if (url.indexOf("data:image") === 0)
                     return url;
             }
             else if (char1 === "/") {
                 return url;
             }
             return URL._basePath + url;
         }
         /**
          * @private
          * 格式化相对路径。
          */
         static _formatRelativePath(value) {
             var parts = value.split("/");
             for (var i = 0, len = parts.length; i < len; i++) {
                 if (parts[i] == '..') {
                     parts.splice(i - 1, 2);
                     i -= 2;
                 }
             }
             return parts.join('/');
         }
         /**
          * 获取指定 URL 的文件夹路径（不包括文件名）。
          * <p><b>注意：</b>末尾有斜杠（/）。</p>
          * @param	url url地址。
          * @return  返回文件夹路径。
          */
         static getPath(url) {
             var ofs = url.lastIndexOf('/');
             return ofs > 0 ? url.substr(0, ofs + 1) : "";
         }
         /**
          * 获取指定 URL 的文件名。
          * @param	url 地址。
          * @return 	返回文件名。
          */
         static getFileName(url) {
             var ofs = url.lastIndexOf('/');
             return ofs > 0 ? url.substr(ofs + 1) : url;
         }
         /**
          * @private 兼容微信
          */
         static getAdptedFilePath(url) {
             if (!URL.exportSceneToJson || !url)
                 return url;
             var i, len;
             len = URL._adpteTypeList.length;
             var tArr;
             for (i = 0; i < len; i++) {
                 tArr = URL._adpteTypeList[i];
                 url = url.replace(tArr[0], tArr[1]);
             }
             return url;
         }
     }
     /**URL地址版本映射表，比如{"aaa/bb.png":99,"aaa/bb.png":12}，默认情况下，通过formatURL格式化后，会自动生成为"aaa/bb.png?v=99"的一个地址*/
     URL.version = {};
     /**兼容微信不支持加载scene后缀场景，设置为true，则会把scene加载替换为json*/
     URL.exportSceneToJson = false;
     /**基础路径。如果不设置，默认为当前网页的路径。最终地址将被格式化为 basePath+相对URL地址，*/
     URL._basePath = "";
     /**root路径。只针对'~'类型的url路径有效*/
     URL.rootPath = "";
     /** 自定义URL格式化的方式。例如： customFormat = function(url:String):String{} */
     URL.customFormat = function (url) {
         var newUrl = URL.version[url];
         if (!window.conch && newUrl)
             url += "?v=" + newUrl;
         return url;
     };
     /**
      * @private
      */
     URL._adpteTypeList = [[".scene3d", ".json"], [".scene", ".json"], [".taa", ".json"], [".prefab", ".json"]];

     /**
      * <code>Resource</code> 资源存取类。
      */
     class Resource extends EventDispatcher {
         /**
          * 创建一个 <code>Resource</code> 实例。
          */
         constructor() {
             super();
             /**@private */
             this._id = 0;
             /**@private */
             this._url = null;
             /**@private */
             this._cpuMemory = 0;
             /**@private */
             this._gpuMemory = 0;
             /**@private */
             this._destroyed = false;
             /**@private */
             this._referenceCount = 0;
             /**是否加锁，如果true为不能使用自动释放机制。*/
             this.lock = false;
             /**名称。 */
             this.name = null;
             this._id = ++Resource._uniqueIDCounter;
             this._destroyed = false;
             this._referenceCount = 0;
             Resource._idResourcesMap[this.id] = this;
             this.lock = false;
         }
         /**
          * 当前内存，以字节为单位。
          */
         static get cpuMemory() {
             return Resource._cpuMemory;
         }
         /**
          * 当前显存，以字节为单位。
          */
         static get gpuMemory() {
             return Resource._gpuMemory;
         }
         /**
          * @private
          */
         static _addCPUMemory(size) {
             Resource._cpuMemory += size;
         }
         /**
          * @private
          */
         static _addGPUMemory(size) {
             Resource._gpuMemory += size;
         }
         /**
          * @private
          */
         static _addMemory(cpuSize, gpuSize) {
             Resource._cpuMemory += cpuSize;
             Resource._gpuMemory += gpuSize;
         }
         /**
          * 通过资源ID返回已载入资源。
          * @param id 资源ID
          * @return 资源 <code>Resource</code> 对象。
          */
         static getResourceByID(id) {
             return Resource._idResourcesMap[id];
         }
         /**
          * 通过url返回已载入资源。
          * @param url 资源URL
          * @param index 索引
          * @return 资源 <code>Resource</code> 对象。
          */
         static getResourceByURL(url, index = 0) {
             return Resource._urlResourcesMap[url][index];
         }
         /**
          * 销毁当前没有被使用的资源,该函数会忽略lock=true的资源。
          * @param group 指定分组。
          */
         static destroyUnusedResources() {
             for (var k in Resource._idResourcesMap) {
                 var res = Resource._idResourcesMap[k];
                 if (!res.lock && res._referenceCount === 0)
                     res.destroy();
             }
         }
         /**
          * 获取唯一标识ID,通常用于识别。
          */
         get id() {
             return this._id;
         }
         /**
          * 获取资源的URL地址。
          * @return URL地址。
          */
         get url() {
             return this._url;
         }
         /**
          * 内存大小。
          */
         get cpuMemory() {
             return this._cpuMemory;
         }
         /**
          * 显存大小。
          */
         get gpuMemory() {
             return this._gpuMemory;
         }
         /**
          * 是否已处理。
          */
         get destroyed() {
             return this._destroyed;
         }
         /**
          * 获取资源的引用计数。
          */
         get referenceCount() {
             return this._referenceCount;
         }
         /**
          * @private
          */
         _setCPUMemory(value) {
             var offsetValue = value - this._cpuMemory;
             this._cpuMemory = value;
             Resource._addCPUMemory(offsetValue);
         }
         /**
          * @private
          */
         _setGPUMemory(value) {
             var offsetValue = value - this._gpuMemory;
             this._gpuMemory = value;
             Resource._addGPUMemory(offsetValue);
         }
         /**
          * @private
          */
         _setCreateURL(url) {
             url = URL.formatURL(url); //需要序列化为绝对路径
             if (this._url !== url) {
                 var resList;
                 if (this._url) {
                     resList = Resource._urlResourcesMap[this._url];
                     resList.splice(resList.indexOf(this), 1);
                     (resList.length === 0) && (delete Resource._urlResourcesMap[this._url]);
                 }
                 if (url) {
                     resList = Resource._urlResourcesMap[url];
                     (resList) || (Resource._urlResourcesMap[url] = resList = []);
                     resList.push(this);
                 }
                 this._url = url;
             }
         }
         /**
          * @private
          */
         _addReference(count = 1) {
             this._referenceCount += count;
         }
         /**
          * @private
          */
         _removeReference(count = 1) {
             this._referenceCount -= count;
         }
         /**
          * @private
          */
         _clearReference() {
             this._referenceCount = 0;
         }
         /**
          * @private
          */
         _recoverResource() {
         }
         /**
          * @private
          */
         _disposeResource() {
         }
         /**
          * @private
          */
         _activeResource() {
         }
         /**
          * 销毁资源,销毁后资源不能恢复。
          */
         destroy() {
             if (this._destroyed)
                 return;
             this._destroyed = true;
             this.lock = false; //解锁资源，强制清理
             this._disposeResource();
             delete Resource._idResourcesMap[this.id];
             var resList;
             if (this._url) {
                 resList = Resource._urlResourcesMap[this._url];
                 if (resList) {
                     resList.splice(resList.indexOf(this), 1);
                     (resList.length === 0) && (delete Resource._urlResourcesMap[this._url]);
                 }
                 var resou = ILaya.Loader.getRes(this._url);
                 (resou == this) && (delete ILaya.Loader.loadedMap[this._url]);
             }
         }
     }
     /** @private */
     Resource._uniqueIDCounter = 0;
     /** @private */
     Resource._idResourcesMap = {};
     /** @private */
     Resource._urlResourcesMap = {};
     /** @private 以字节为单位。*/
     Resource._cpuMemory = 0;
     /** @private 以字节为单位。*/
     Resource._gpuMemory = 0;

     /**
          * @private
          * <code>Bitmap</code> 图片资源类。
          */
     class Bitmap extends Resource {
         /**
          * 获取宽度。
          */
         get width() {
             return this._width;
         }
         /***
          * 获取高度。
          */
         get height() {
             return this._height;
         }
         /**
          * 创建一个 <code>Bitmap</code> 实例。
          */
         constructor() {
             super();
             this._width = -1;
             this._height = -1;
         }
         /**
          * @private
          * 获取纹理资源。
          */
         //TODO:coverage
         _getSource() {
             throw "Bitmap: must override it.";
         }
     }

     class WebGLContext {
         /**
          * @private
          */
         static useProgram(gl, program) {
             if (WebGLContext._useProgram === program)
                 return false;
             gl.useProgram(program);
             WebGLContext._useProgram = program;
             return true;
         }
         /**
          * @private
          */
         //TODO:coverage
         static setDepthTest(gl, value) {
             value !== WebGLContext._depthTest && (WebGLContext._depthTest = value, value ? gl.enable(WebGLContext.DEPTH_TEST) : gl.disable(WebGLContext.DEPTH_TEST));
         }
         /**
          * @private
          */
         //TODO:coverage
         static setDepthMask(gl, value) {
             value !== WebGLContext._depthMask && (WebGLContext._depthMask = value, gl.depthMask(value));
         }
         /**
          * @private
          */
         //TODO:coverage
         static setDepthFunc(gl, value) {
             value !== WebGLContext._depthFunc && (WebGLContext._depthFunc = value, gl.depthFunc(value));
         }
         /**
          * @private
          */
         static setBlend(gl, value) {
             value !== WebGLContext._blend && (WebGLContext._blend = value, value ? gl.enable(WebGLContext.BLEND) : gl.disable(WebGLContext.BLEND));
         }
         /**
          * @private
          */
         static setBlendFunc(gl, sFactor, dFactor) {
             (sFactor !== WebGLContext._sFactor || dFactor !== WebGLContext._dFactor) && (WebGLContext._sFactor = WebGLContext._srcAlpha = sFactor, WebGLContext._dFactor = WebGLContext._dstAlpha = dFactor, gl.blendFunc(sFactor, dFactor));
         }
         /**
          * @private
          */
         static setBlendFuncSeperate(gl, srcRGB, dstRGB, srcAlpha, dstAlpha) {
             if (srcRGB !== WebGLContext._sFactor || dstRGB !== WebGLContext._dFactor || srcAlpha !== WebGLContext._srcAlpha || dstAlpha !== WebGLContext._dstAlpha) {
                 WebGLContext._sFactor = srcRGB;
                 WebGLContext._dFactor = dstRGB;
                 WebGLContext._srcAlpha = srcAlpha;
                 WebGLContext._dstAlpha = dstAlpha;
                 gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
             }
         }
         /**
          * @private
          */
         //TODO:coverage
         static setCullFace(gl, value) {
             value !== WebGLContext._cullFace && (WebGLContext._cullFace = value, value ? gl.enable(WebGLContext.CULL_FACE) : gl.disable(WebGLContext.CULL_FACE));
         }
         /**
          * @private
          */
         //TODO:coverage
         static setFrontFace(gl, value) {
             value !== WebGLContext._frontFace && (WebGLContext._frontFace = value, gl.frontFace(value));
         }
         /**
          * @private
          */
         static activeTexture(gl, textureID) {
             if (WebGLContext._activedTextureID !== textureID) {
                 gl.activeTexture(textureID);
                 WebGLContext._activedTextureID = textureID;
             }
         }
         /**
          * @private
          */
         static bindTexture(gl, target, texture) {
             if (WebGLContext._activeTextures[WebGLContext._activedTextureID - WebGLContext.TEXTURE0] !== texture) {
                 gl.bindTexture(target, texture);
                 WebGLContext._activeTextures[WebGLContext._activedTextureID - WebGLContext.TEXTURE0] = texture;
             }
         }
         getContextAttributes() { return null; }
         isContextLost() { }
         getSupportedExtensions() { return null; }
         getExtension(name) { return null; }
         activeTexture(texture) { }
         attachShader(program, shader) { }
         bindAttribLocation(program, index, name) { }
         bindBuffer(target, buffer) { }
         bindFramebuffer(target, framebuffer) { }
         bindRenderbuffer(target, renderbuffer) { }
         bindTexture(target, texture) { }
         useTexture(value) { }
         blendColor(red, green, blue, alpha) { }
         blendEquation(mode) { }
         blendEquationSeparate(modeRGB, modeAlpha) { }
         blendFunc(sfactor, dfactor) { }
         blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) { }
         bufferData(target, size, usage) { }
         bufferSubData(target, offset, data) { }
         checkFramebufferStatus(target) { return null; }
         clear(mask) { }
         clearColor(red, green, blue, alpha) { }
         clearDepth(depth) { }
         clearStencil(s) { }
         colorMask(red, green, blue, alpha) { }
         compileShader(shader) { }
         copyTexImage2D(target, level, internalformat, x, y, width, height, border) { }
         copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height) { }
         createBuffer() { }
         createFramebuffer() { }
         createProgram() { }
         createRenderbuffer() { }
         createShader(type) { }
         createTexture() { return null; }
         cullFace(mode) { }
         deleteBuffer(buffer) { }
         deleteFramebuffer(framebuffer) { }
         deleteProgram(program) { }
         deleteRenderbuffer(renderbuffer) { }
         deleteShader(shader) { }
         deleteTexture(texture) { }
         depthFunc(func) { }
         depthMask(flag) { }
         depthRange(zNear, zFar) { }
         detachShader(program, shader) { }
         disable(cap) { }
         disableVertexAttribArray(index) { }
         drawArrays(mode, first, count) { }
         drawElements(mode, count, type, offset) { }
         enable(cap) { }
         enableVertexAttribArray(index) { }
         finish() { }
         flush() { }
         framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) { }
         framebufferTexture2D(target, attachment, textarget, texture, level) { }
         frontFace(mode) { return null; }
         generateMipmap(target) { return null; }
         getActiveAttrib(program, index) { return null; }
         getActiveUniform(program, index) { return null; }
         getAttribLocation(program, name) { return 0; }
         getParameter(pname) { return null; }
         getBufferParameter(target, pname) { return null; }
         getError() { return null; }
         getFramebufferAttachmentParameter(target, attachment, pname) { }
         getProgramParameter(program, pname) { return 0; }
         getProgramInfoLog(program) { return null; }
         getRenderbufferParameter(target, pname) { return null; }
         getShaderPrecisionFormat(...arg) { return null; }
         getShaderParameter(shader, pname) { }
         getShaderInfoLog(shader) { return null; }
         getShaderSource(shader) { return null; }
         getTexParameter(target, pname) { }
         getUniform(program, location) { }
         getUniformLocation(program, name) { return null; }
         getVertexAttrib(index, pname) { return null; }
         getVertexAttribOffset(index, pname) { return null; }
         hint(target, mode) { }
         isBuffer(buffer) { }
         isEnabled(cap) { }
         isFramebuffer(framebuffer) { }
         isProgram(program) { }
         isRenderbuffer(renderbuffer) { }
         isShader(shader) { }
         isTexture(texture) { }
         lineWidth(width) { }
         linkProgram(program) { }
         pixelStorei(pname, param) { }
         polygonOffset(factor, units) { }
         readPixels(x, y, width, height, format, type, pixels) { }
         renderbufferStorage(target, internalformat, width, height) { }
         sampleCoverage(value, invert) { }
         scissor(x, y, width, height) { }
         shaderSource(shader, source) { }
         stencilFunc(func, ref, mask) { }
         stencilFuncSeparate(face, func, ref, mask) { }
         stencilMask(mask) { }
         stencilMaskSeparate(face, mask) { }
         stencilOp(fail, zfail, zpass) { }
         stencilOpSeparate(face, fail, zfail, zpass) { }
         texImage2D(...args) { }
         texParameterf(target, pname, param) { }
         texParameteri(target, pname, param) { }
         texSubImage2D(...args) { }
         uniform1f(location, x) { }
         uniform1fv(location, v) { }
         uniform1i(location, x) { }
         uniform1iv(location, v) { }
         uniform2f(location, x, y) { }
         uniform2fv(location, v) { }
         uniform2i(location, x, y) { }
         uniform2iv(location, v) { }
         uniform3f(location, x, y, z) { }
         uniform3fv(location, v) { }
         uniform3i(location, x, y, z) { }
         uniform3iv(location, v) { }
         uniform4f(location, x, y, z, w) { }
         uniform4fv(location, v) { }
         uniform4i(location, x, y, z, w) { }
         uniform4iv(location, v) { }
         uniformMatrix2fv(location, transpose, value) { }
         uniformMatrix3fv(location, transpose, value) { }
         uniformMatrix4fv(location, transpose, value) { }
         useProgram(program) { }
         validateProgram(program) { }
         vertexAttrib1f(indx, x) { }
         vertexAttrib1fv(indx, values) { }
         vertexAttrib2f(indx, x, y) { }
         vertexAttrib2fv(indx, values) { }
         vertexAttrib3f(indx, x, y, z) { }
         vertexAttrib3fv(indx, values) { }
         vertexAttrib4f(indx, x, y, z, w) { }
         vertexAttrib4fv(indx, values) { }
         vertexAttribPointer(indx, size, type, normalized, stride, offset) { }
         viewport(x, y, width, height) { }
         configureBackBuffer(width, height, antiAlias, enableDepthAndStencil = true, wantsBestResolution = false) { } /*;*/
         compressedTexImage2D(...args) { }
         //--------------------------------------------------------------------------------------------------------------------------------------------------------------------
         /**
          * @private
          */
         static __init_native() {
             if (!ILaya.Render.supportWebGLPlusRendering)
                 return;
             var webGLContext = WebGLContext;
             webGLContext.activeTexture = webGLContext.activeTextureForNative;
             webGLContext.bindTexture = webGLContext.bindTextureForNative;
             /*webGLContext.useProgram = webGLContext.useProgramForNative;
             webGLContext.bindVertexArray = webGLContext.bindVertexArrayForNative;
             webGLContext.setDepthTest = webGLContext.setDepthTestForNative;
             webGLContext.setDepthMask = webGLContext.setDepthMaskForNative;
             webGLContext.setDepthFunc = webGLContext.setDepthFuncForNative;
             webGLContext.setBlend = webGLContext.setBlendForNative;
             webGLContext.setBlendFunc = webGLContext.setBlendFuncForNative;
             webGLContext.setCullFace = webGLContext.setCullFaceForNative;
             webGLContext.setFrontFace = webGLContext.setFrontFaceForNative;*/
         }
         /**
          * @private
          */
         //TODO:coverage
         static useProgramForNative(gl, program) {
             gl.useProgram(program);
             return true;
         }
         /**
          * @private
          */
         //TODO:coverage
         static setDepthTestForNative(gl, value) {
             if (value)
                 gl.enable(WebGLContext.DEPTH_TEST);
             else
                 gl.disable(WebGLContext.DEPTH_TEST);
         }
         /**
          * @private
          */
         //TODO:coverage
         static setDepthMaskForNative(gl, value) {
             gl.depthMask(value);
         }
         /**
          * @private
          */
         //TODO:coverage
         static setDepthFuncForNative(gl, value) {
             gl.depthFunc(value);
         }
         /**
          * @private
          */
         //TODO:coverage
         static setBlendForNative(gl, value) {
             if (value)
                 gl.enable(WebGLContext.BLEND);
             else
                 gl.disable(WebGLContext.BLEND);
         }
         /**
          * @private
          */
         //TODO:coverage
         static setBlendFuncForNative(gl, sFactor, dFactor) {
             gl.blendFunc(sFactor, dFactor);
         }
         /**
          * @private
          */
         //TODO:coverage
         static setCullFaceForNative(gl, value) {
             if (value)
                 gl.enable(WebGLContext.CULL_FACE);
             else
                 gl.disable(WebGLContext.CULL_FACE);
         }
         /**
          * @private
          */
         //TODO:coverage
         static setFrontFaceForNative(gl, value) {
             gl.frontFace(value);
         }
         /**
          * @private
          */
         //TODO:coverage
         static activeTextureForNative(gl, textureID) {
             gl.activeTexture(textureID);
         }
         /**
          * @private
          */
         //TODO:coverage
         static bindTextureForNative(gl, target, texture) {
             gl.bindTexture(target, texture);
         }
         /**
          * @private
          */
         //TODO:coverage
         static bindVertexArrayForNative(gl, vertexArray) {
             gl.bindVertexArray(vertexArray);
         }
     }
     WebGLContext.DEPTH_BUFFER_BIT = 0x00000100;
     WebGLContext.STENCIL_BUFFER_BIT = 0x00000400;
     WebGLContext.COLOR_BUFFER_BIT = 0x00004000;
     WebGLContext.POINTS = 0x0000;
     WebGLContext.LINES = 0x0001;
     WebGLContext.LINE_LOOP = 0x0002;
     WebGLContext.LINE_STRIP = 0x0003;
     WebGLContext.TRIANGLES = 0x0004;
     WebGLContext.TRIANGLE_STRIP = 0x0005;
     WebGLContext.TRIANGLE_FAN = 0x0006;
     WebGLContext.ZERO = 0;
     WebGLContext.ONE = 1;
     WebGLContext.SRC_COLOR = 0x0300;
     WebGLContext.ONE_MINUS_SRC_COLOR = 0x0301;
     WebGLContext.SRC_ALPHA = 0x0302;
     WebGLContext.ONE_MINUS_SRC_ALPHA = 0x0303;
     WebGLContext.DST_ALPHA = 0x0304;
     WebGLContext.ONE_MINUS_DST_ALPHA = 0x0305;
     WebGLContext.DST_COLOR = 0x0306;
     WebGLContext.ONE_MINUS_DST_COLOR = 0x0307;
     WebGLContext.SRC_ALPHA_SATURATE = 0x0308;
     WebGLContext.FUNC_ADD = 0x8006;
     WebGLContext.BLEND_EQUATION = 0x8009;
     WebGLContext.BLEND_EQUATION_RGB = 0x8009;
     WebGLContext.BLEND_EQUATION_ALPHA = 0x883D;
     WebGLContext.FUNC_SUBTRACT = 0x800A;
     WebGLContext.FUNC_REVERSE_SUBTRACT = 0x800B;
     WebGLContext.BLEND_DST_RGB = 0x80C8;
     WebGLContext.BLEND_SRC_RGB = 0x80C9;
     WebGLContext.BLEND_DST_ALPHA = 0x80CA;
     WebGLContext.BLEND_SRC_ALPHA = 0x80CB;
     WebGLContext.CONSTANT_COLOR = 0x8001;
     WebGLContext.ONE_MINUS_CONSTANT_COLOR = 0x8002;
     WebGLContext.CONSTANT_ALPHA = 0x8003;
     WebGLContext.ONE_MINUS_CONSTANT_ALPHA = 0x8004;
     WebGLContext.BLEND_COLOR = 0x8005;
     WebGLContext.ARRAY_BUFFER = 0x8892;
     WebGLContext.ELEMENT_ARRAY_BUFFER = 0x8893;
     WebGLContext.ARRAY_BUFFER_BINDING = 0x8894;
     WebGLContext.ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
     WebGLContext.STREAM_DRAW = 0x88E0;
     WebGLContext.STATIC_DRAW = 0x88E4;
     WebGLContext.DYNAMIC_DRAW = 0x88E8;
     WebGLContext.BUFFER_SIZE = 0x8764;
     WebGLContext.BUFFER_USAGE = 0x8765;
     WebGLContext.CURRENT_VERTEX_ATTRIB = 0x8626;
     WebGLContext.FRONT = 0x0404;
     WebGLContext.BACK = 0x0405;
     WebGLContext.CULL_FACE = 0x0B44;
     WebGLContext.FRONT_AND_BACK = 0x0408;
     WebGLContext.BLEND = 0x0BE2;
     WebGLContext.DITHER = 0x0BD0;
     WebGLContext.STENCIL_TEST = 0x0B90;
     WebGLContext.DEPTH_TEST = 0x0B71;
     WebGLContext.SCISSOR_TEST = 0x0C11;
     WebGLContext.POLYGON_OFFSET_FILL = 0x8037;
     WebGLContext.SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
     WebGLContext.SAMPLE_COVERAGE = 0x80A0;
     WebGLContext.NO_ERROR = 0;
     WebGLContext.INVALID_ENUM = 0x0500;
     WebGLContext.INVALID_VALUE = 0x0501;
     WebGLContext.INVALID_OPERATION = 0x0502;
     WebGLContext.OUT_OF_MEMORY = 0x0505;
     WebGLContext.CW = 0x0900;
     WebGLContext.CCW = 0x0901;
     WebGLContext.LINE_WIDTH = 0x0B21;
     WebGLContext.ALIASED_POINT_SIZE_RANGE = 0x846D;
     WebGLContext.ALIASED_LINE_WIDTH_RANGE = 0x846E;
     WebGLContext.CULL_FACE_MODE = 0x0B45;
     WebGLContext.FRONT_FACE = 0x0B46;
     WebGLContext.DEPTH_RANGE = 0x0B70;
     WebGLContext.DEPTH_WRITEMASK = 0x0B72;
     WebGLContext.DEPTH_CLEAR_VALUE = 0x0B73;
     WebGLContext.DEPTH_FUNC = 0x0B74;
     WebGLContext.STENCIL_CLEAR_VALUE = 0x0B91;
     WebGLContext.STENCIL_FUNC = 0x0B92;
     WebGLContext.STENCIL_FAIL = 0x0B94;
     WebGLContext.STENCIL_PASS_DEPTH_FAIL = 0x0B95;
     WebGLContext.STENCIL_PASS_DEPTH_PASS = 0x0B96;
     WebGLContext.STENCIL_REF = 0x0B97;
     WebGLContext.STENCIL_VALUE_MASK = 0x0B93;
     WebGLContext.STENCIL_WRITEMASK = 0x0B98;
     WebGLContext.STENCIL_BACK_FUNC = 0x8800;
     WebGLContext.STENCIL_BACK_FAIL = 0x8801;
     WebGLContext.STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
     WebGLContext.STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
     WebGLContext.STENCIL_BACK_REF = 0x8CA3;
     WebGLContext.STENCIL_BACK_VALUE_MASK = 0x8CA4;
     WebGLContext.STENCIL_BACK_WRITEMASK = 0x8CA5;
     WebGLContext.VIEWPORT = 0x0BA2;
     WebGLContext.SCISSOR_BOX = 0x0C10;
     WebGLContext.COLOR_CLEAR_VALUE = 0x0C22;
     WebGLContext.COLOR_WRITEMASK = 0x0C23;
     WebGLContext.UNPACK_ALIGNMENT = 0x0CF5;
     WebGLContext.PACK_ALIGNMENT = 0x0D05;
     WebGLContext.MAX_TEXTURE_SIZE = 0x0D33;
     WebGLContext.MAX_VIEWPORT_DIMS = 0x0D3A;
     WebGLContext.SUBPIXEL_BITS = 0x0D50;
     WebGLContext.RED_BITS = 0x0D52;
     WebGLContext.GREEN_BITS = 0x0D53;
     WebGLContext.BLUE_BITS = 0x0D54;
     WebGLContext.ALPHA_BITS = 0x0D55;
     WebGLContext.DEPTH_BITS = 0x0D56;
     WebGLContext.STENCIL_BITS = 0x0D57;
     WebGLContext.POLYGON_OFFSET_UNITS = 0x2A00;
     WebGLContext.POLYGON_OFFSET_FACTOR = 0x8038;
     WebGLContext.TEXTURE_BINDING_2D = 0x8069;
     WebGLContext.SAMPLE_BUFFERS = 0x80A8;
     WebGLContext.SAMPLES = 0x80A9;
     WebGLContext.SAMPLE_COVERAGE_VALUE = 0x80AA;
     WebGLContext.SAMPLE_COVERAGE_INVERT = 0x80AB;
     WebGLContext.NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
     WebGLContext.COMPRESSED_TEXTURE_FORMATS = 0x86A3;
     WebGLContext.DONT_CARE = 0x1100;
     WebGLContext.FASTEST = 0x1101;
     WebGLContext.NICEST = 0x1102;
     WebGLContext.GENERATE_MIPMAP_HINT = 0x8192;
     WebGLContext.BYTE = 0x1400;
     WebGLContext.UNSIGNED_BYTE = 0x1401;
     WebGLContext.SHORT = 0x1402;
     WebGLContext.UNSIGNED_SHORT = 0x1403;
     WebGLContext.INT = 0x1404;
     WebGLContext.UNSIGNED_INT = 0x1405;
     WebGLContext.FLOAT = 0x1406;
     WebGLContext.DEPTH_COMPONENT = 0x1902;
     WebGLContext.ALPHA = 0x1906;
     WebGLContext.RGB = 0x1907;
     WebGLContext.RGBA = 0x1908;
     WebGLContext.LUMINANCE = 0x1909;
     WebGLContext.LUMINANCE_ALPHA = 0x190A;
     WebGLContext.UNSIGNED_SHORT_4_4_4_4 = 0x8033;
     WebGLContext.UNSIGNED_SHORT_5_5_5_1 = 0x8034;
     WebGLContext.UNSIGNED_SHORT_5_6_5 = 0x8363;
     WebGLContext.FRAGMENT_SHADER = 0x8B30;
     WebGLContext.VERTEX_SHADER = 0x8B31;
     WebGLContext.MAX_VERTEX_ATTRIBS = 0x8869;
     WebGLContext.MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
     WebGLContext.MAX_VARYING_VECTORS = 0x8DFC;
     WebGLContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
     WebGLContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
     WebGLContext.MAX_TEXTURE_IMAGE_UNITS = 0x8872;
     WebGLContext.MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
     WebGLContext.SHADER_TYPE = 0x8B4F;
     WebGLContext.DELETE_STATUS = 0x8B80;
     WebGLContext.LINK_STATUS = 0x8B82;
     WebGLContext.VALIDATE_STATUS = 0x8B83;
     WebGLContext.ATTACHED_SHADERS = 0x8B85;
     WebGLContext.ACTIVE_UNIFORMS = 0x8B86;
     WebGLContext.ACTIVE_ATTRIBUTES = 0x8B89;
     WebGLContext.SHADING_LANGUAGE_VERSION = 0x8B8C;
     WebGLContext.CURRENT_PROGRAM = 0x8B8D;
     WebGLContext.NEVER = 0x0200;
     WebGLContext.LESS = 0x0201;
     WebGLContext.EQUAL = 0x0202;
     WebGLContext.LEQUAL = 0x0203;
     WebGLContext.GREATER = 0x0204;
     WebGLContext.NOTEQUAL = 0x0205;
     WebGLContext.GEQUAL = 0x0206;
     WebGLContext.ALWAYS = 0x0207;
     WebGLContext.KEEP = 0x1E00;
     WebGLContext.REPLACE = 0x1E01;
     WebGLContext.INCR = 0x1E02;
     WebGLContext.DECR = 0x1E03;
     WebGLContext.INVERT = 0x150A;
     WebGLContext.INCR_WRAP = 0x8507;
     WebGLContext.DECR_WRAP = 0x8508;
     WebGLContext.VENDOR = 0x1F00;
     WebGLContext.RENDERER = 0x1F01;
     WebGLContext.VERSION = 0x1F02;
     WebGLContext.NEAREST = 0x2600;
     WebGLContext.LINEAR = 0x2601;
     WebGLContext.NEAREST_MIPMAP_NEAREST = 0x2700;
     WebGLContext.LINEAR_MIPMAP_NEAREST = 0x2701;
     WebGLContext.NEAREST_MIPMAP_LINEAR = 0x2702;
     WebGLContext.LINEAR_MIPMAP_LINEAR = 0x2703;
     WebGLContext.TEXTURE_MAG_FILTER = 0x2800;
     WebGLContext.TEXTURE_MIN_FILTER = 0x2801;
     WebGLContext.TEXTURE_WRAP_S = 0x2802;
     WebGLContext.TEXTURE_WRAP_T = 0x2803;
     WebGLContext.TEXTURE_2D = 0x0DE1;
     WebGLContext.TEXTURE_3D = 0x806f;
     WebGLContext.TEXTURE = 0x1702;
     WebGLContext.TEXTURE_CUBE_MAP = 0x8513;
     WebGLContext.TEXTURE_BINDING_CUBE_MAP = 0x8514;
     WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
     WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
     WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
     WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
     WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
     WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
     WebGLContext.MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
     WebGLContext.TEXTURE0 = 0x84C0;
     WebGLContext.TEXTURE1 = 0x84C1;
     WebGLContext.TEXTURE2 = 0x84C2;
     WebGLContext.TEXTURE3 = 0x84C3;
     WebGLContext.TEXTURE4 = 0x84C4;
     WebGLContext.TEXTURE5 = 0x84C5;
     WebGLContext.TEXTURE6 = 0x84C6;
     WebGLContext.TEXTURE7 = 0x84C7;
     WebGLContext.TEXTURE8 = 0x84C8;
     WebGLContext.TEXTURE9 = 0x84C9;
     WebGLContext.TEXTURE10 = 0x84CA;
     WebGLContext.TEXTURE11 = 0x84CB;
     WebGLContext.TEXTURE12 = 0x84CC;
     WebGLContext.TEXTURE13 = 0x84CD;
     WebGLContext.TEXTURE14 = 0x84CE;
     WebGLContext.TEXTURE15 = 0x84CF;
     WebGLContext.TEXTURE16 = 0x84D0;
     WebGLContext.TEXTURE17 = 0x84D1;
     WebGLContext.TEXTURE18 = 0x84D2;
     WebGLContext.TEXTURE19 = 0x84D3;
     WebGLContext.TEXTURE20 = 0x84D4;
     WebGLContext.TEXTURE21 = 0x84D5;
     WebGLContext.TEXTURE22 = 0x84D6;
     WebGLContext.TEXTURE23 = 0x84D7;
     WebGLContext.TEXTURE24 = 0x84D8;
     WebGLContext.TEXTURE25 = 0x84D9;
     WebGLContext.TEXTURE26 = 0x84DA;
     WebGLContext.TEXTURE27 = 0x84DB;
     WebGLContext.TEXTURE28 = 0x84DC;
     WebGLContext.TEXTURE29 = 0x84DD;
     WebGLContext.TEXTURE30 = 0x84DE;
     WebGLContext.TEXTURE31 = 0x84DF;
     WebGLContext.ACTIVE_TEXTURE = 0x84E0;
     WebGLContext.REPEAT = 0x2901;
     WebGLContext.CLAMP_TO_EDGE = 0x812F;
     WebGLContext.MIRRORED_REPEAT = 0x8370;
     WebGLContext.FLOAT_VEC2 = 0x8B50;
     WebGLContext.FLOAT_VEC3 = 0x8B51;
     WebGLContext.FLOAT_VEC4 = 0x8B52;
     WebGLContext.INT_VEC2 = 0x8B53;
     WebGLContext.INT_VEC3 = 0x8B54;
     WebGLContext.INT_VEC4 = 0x8B55;
     WebGLContext.BOOL = 0x8B56;
     WebGLContext.BOOL_VEC2 = 0x8B57;
     WebGLContext.BOOL_VEC3 = 0x8B58;
     WebGLContext.BOOL_VEC4 = 0x8B59;
     WebGLContext.FLOAT_MAT2 = 0x8B5A;
     WebGLContext.FLOAT_MAT3 = 0x8B5B;
     WebGLContext.FLOAT_MAT4 = 0x8B5C;
     WebGLContext.SAMPLER_2D = 0x8B5E;
     WebGLContext.SAMPLER_CUBE = 0x8B60;
     WebGLContext.VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
     WebGLContext.VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
     WebGLContext.VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
     WebGLContext.VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
     WebGLContext.VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
     WebGLContext.VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
     WebGLContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
     WebGLContext.COMPILE_STATUS = 0x8B81;
     WebGLContext.LOW_FLOAT = 0x8DF0;
     WebGLContext.MEDIUM_FLOAT = 0x8DF1;
     WebGLContext.HIGH_FLOAT = 0x8DF2;
     WebGLContext.LOW_INT = 0x8DF3;
     WebGLContext.MEDIUM_INT = 0x8DF4;
     WebGLContext.HIGH_INT = 0x8DF5;
     WebGLContext.FRAMEBUFFER = 0x8D40;
     WebGLContext.RENDERBUFFER = 0x8D41;
     WebGLContext.RGBA4 = 0x8056;
     WebGLContext.RGB5_A1 = 0x8057;
     WebGLContext.RGB565 = 0x8D62;
     WebGLContext.DEPTH_COMPONENT16 = 0x81A5;
     WebGLContext.STENCIL_INDEX = 0x1901;
     WebGLContext.STENCIL_INDEX8 = 0x8D48;
     WebGLContext.DEPTH_STENCIL = 0x84F9;
     WebGLContext.RENDERBUFFER_WIDTH = 0x8D42;
     WebGLContext.RENDERBUFFER_HEIGHT = 0x8D43;
     WebGLContext.RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
     WebGLContext.RENDERBUFFER_RED_SIZE = 0x8D50;
     WebGLContext.RENDERBUFFER_GREEN_SIZE = 0x8D51;
     WebGLContext.RENDERBUFFER_BLUE_SIZE = 0x8D52;
     WebGLContext.RENDERBUFFER_ALPHA_SIZE = 0x8D53;
     WebGLContext.RENDERBUFFER_DEPTH_SIZE = 0x8D54;
     WebGLContext.RENDERBUFFER_STENCIL_SIZE = 0x8D55;
     WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
     WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
     WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
     WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
     WebGLContext.COLOR_ATTACHMENT0 = 0x8CE0;
     WebGLContext.DEPTH_ATTACHMENT = 0x8D00;
     WebGLContext.STENCIL_ATTACHMENT = 0x8D20;
     WebGLContext.DEPTH_STENCIL_ATTACHMENT = 0x821A;
     WebGLContext.NONE = 0;
     WebGLContext.FRAMEBUFFER_COMPLETE = 0x8CD5;
     WebGLContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
     WebGLContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
     WebGLContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
     WebGLContext.FRAMEBUFFER_UNSUPPORTED = 0x8CDD;
     WebGLContext.FRAMEBUFFER_BINDING = 0x8CA6;
     WebGLContext.RENDERBUFFER_BINDING = 0x8CA7;
     WebGLContext.MAX_RENDERBUFFER_SIZE = 0x84E8;
     WebGLContext.INVALID_FRAMEBUFFER_OPERATION = 0x0506;
     WebGLContext.UNPACK_FLIP_Y_WEBGL = 0x9240;
     WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
     WebGLContext.CONTEXT_LOST_WEBGL = 0x9242;
     WebGLContext.UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
     WebGLContext.BROWSER_DEFAULT_WEBGL = 0x9244;
     //WebGL2.0
     WebGLContext.HALF_FLOAT = 0x140B;
     WebGLContext.RGB16F = 0x881A;
     WebGLContext.RGBA16F = 0x881A;
     /**@private */
     WebGLContext.mainContext = null;
     /**@private */
     WebGLContext._activeTextures = new Array(8);
     /**@private */
     WebGLContext._glTextureIDs = [WebGLContext.TEXTURE0, WebGLContext.TEXTURE1, WebGLContext.TEXTURE2, WebGLContext.TEXTURE3, WebGLContext.TEXTURE4, WebGLContext.TEXTURE5, WebGLContext.TEXTURE6, WebGLContext.TEXTURE7];
     /**@private */
     WebGLContext._useProgram = null;
     /**@private */
     WebGLContext._depthTest = true;
     /**@private */
     WebGLContext._depthMask = true;
     /**@private */
     WebGLContext._depthFunc = WebGLContext.LESS;
     /**@private */
     WebGLContext._blend = false;
     /**@private */
     WebGLContext._sFactor = WebGLContext.ONE; //待确认
     /**@private */
     WebGLContext._dFactor = WebGLContext.ZERO; //待确认
     /**@private */
     WebGLContext._srcAlpha = WebGLContext.ONE; //待确认
     /**@private */
     WebGLContext._dstAlpha = WebGLContext.ZERO; //待确认
     /**@private */
     WebGLContext._cullFace = false;
     /**@private */
     WebGLContext._frontFace = WebGLContext.CCW;
     /**@private */
     WebGLContext._activedTextureID = WebGLContext.TEXTURE0; //默认激活纹理区为0

     /**
      * <code>BaseTexture</code> 纹理的父类，抽象类，不允许实例。
      */
     class BaseTexture extends Bitmap {
         /**
          * 创建一个 <code>BaseTexture</code> 实例。
          */
         constructor(format, mipMap) {
             super();
             this._wrapModeU = BaseTexture.WARPMODE_REPEAT;
             this._wrapModeV = BaseTexture.WARPMODE_REPEAT;
             this._filterMode = BaseTexture.FILTERMODE_BILINEAR;
             this._readyed = false;
             this._width = -1;
             this._height = -1;
             this._format = format;
             this._mipmap = mipMap;
             this._anisoLevel = 1;
             this._glTexture = LayaGL.instance.createTexture();
         }
         /**
          * 是否使用mipLevel
          */
         get mipmap() {
             return this._mipmap;
         }
         /**
          * 纹理格式
          */
         get format() {
             return this._format;
         }
         /**
          * 获取纹理横向循环模式。
          */
         get wrapModeU() {
             return this._wrapModeU;
         }
         /**
          * 设置纹理横向循环模式。
          */
         set wrapModeU(value) {
             if (this._wrapModeU !== value) {
                 this._wrapModeU = value;
                 (this._width !== -1) && (this._setWarpMode(WebGLContext.TEXTURE_WRAP_S, value));
             }
         }
         /**
          * 获取纹理纵向循环模式。
          */
         get wrapModeV() {
             return this._wrapModeV;
         }
         /**
          * 设置纹理纵向循环模式。
          */
         set wrapModeV(value) {
             if (this._wrapModeV !== value) {
                 this._wrapModeV = value;
                 (this._height !== -1) && (this._setWarpMode(WebGLContext.TEXTURE_WRAP_T, value));
             }
         }
         /**
          * 缩小过滤器
          */
         get filterMode() {
             return this._filterMode;
         }
         /**
          * 缩小过滤器
          */
         set filterMode(value) {
             if (value !== this._filterMode) {
                 this._filterMode = value;
                 ((this._width !== -1) && (this._height !== -1)) && (this._setFilterMode(value));
             }
         }
         /**
          * 各向异性等级
          */
         get anisoLevel() {
             return this._anisoLevel;
         }
         /**
          * 各向异性等级
          */
         set anisoLevel(value) {
             if (value !== this._anisoLevel) {
                 this._anisoLevel = Math.max(1, Math.min(16, value));
                 ((this._width !== -1) && (this._height !== -1)) && (this._setAnisotropy(value));
             }
         }
         /**
          * 获取默认纹理资源。
          */
         get defaulteTexture() {
             throw "BaseTexture:must override it.";
         }
         /**
          * @private
          */
         _isPot(size) {
             return (size & (size - 1)) === 0;
         }
         /**
          * @private
          */
         _getGLFormat() {
             var glFormat;
             let gpu = LayaGL.layaGPUInstance;
             switch (this._format) {
                 case BaseTexture.FORMAT_R8G8B8:
                     glFormat = WebGLContext.RGB;
                     break;
                 case BaseTexture.FORMAT_R8G8B8A8:
                     glFormat = WebGLContext.RGBA;
                     break;
                 case BaseTexture.FORMAT_ALPHA8:
                     glFormat = WebGLContext.ALPHA;
                     break;
                 case BaseTexture.FORMAT_DXT1:
                     if (gpu._compressedTextureS3tc)
                         glFormat = gpu._compressedTextureS3tc.COMPRESSED_RGB_S3TC_DXT1_EXT;
                     else
                         throw "BaseTexture: not support DXT1 format.";
                     break;
                 case BaseTexture.FORMAT_DXT5:
                     if (gpu._compressedTextureS3tc)
                         glFormat = gpu._compressedTextureS3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                     else
                         throw "BaseTexture: not support DXT5 format.";
                     break;
                 case BaseTexture.FORMAT_ETC1RGB:
                     if (gpu._compressedTextureEtc1)
                         glFormat = gpu._compressedTextureEtc1.COMPRESSED_RGB_ETC1_WEBGL;
                     else
                         throw "BaseTexture: not support ETC1RGB format.";
                     break;
                 case BaseTexture.FORMAT_PVRTCRGB_2BPPV:
                     if (gpu._compressedTexturePvrtc)
                         glFormat = gpu._compressedTexturePvrtc.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                     else
                         throw "BaseTexture: not support PVRTCRGB_2BPPV format.";
                     break;
                 case BaseTexture.FORMAT_PVRTCRGBA_2BPPV:
                     if (gpu._compressedTexturePvrtc)
                         glFormat = gpu._compressedTexturePvrtc.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                     else
                         throw "BaseTexture: not support PVRTCRGBA_2BPPV format.";
                     break;
                 case BaseTexture.FORMAT_PVRTCRGB_4BPPV:
                     if (gpu._compressedTexturePvrtc)
                         glFormat = gpu._compressedTexturePvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                     else
                         throw "BaseTexture: not support PVRTCRGB_4BPPV format.";
                     break;
                 case BaseTexture.FORMAT_PVRTCRGBA_4BPPV:
                     if (gpu._compressedTexturePvrtc)
                         glFormat = gpu._compressedTexturePvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                     else
                         throw "BaseTexture: not support PVRTCRGBA_4BPPV format.";
                     break;
                 default:
                     throw "BaseTexture: unknown texture format.";
             }
             return glFormat;
         }
         /**
          * @private
          */
         _setFilterMode(value) {
             var gl = LayaGL.instance;
             WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
             switch (value) {
                 case BaseTexture.FILTERMODE_POINT:
                     if (this._mipmap)
                         gl.texParameteri(this._glTextureType, WebGLContext.TEXTURE_MIN_FILTER, WebGLContext.NEAREST_MIPMAP_NEAREST);
                     else
                         gl.texParameteri(this._glTextureType, WebGLContext.TEXTURE_MIN_FILTER, WebGLContext.NEAREST);
                     gl.texParameteri(this._glTextureType, WebGLContext.TEXTURE_MAG_FILTER, WebGLContext.NEAREST);
                     break;
                 case BaseTexture.FILTERMODE_BILINEAR:
                     if (this._mipmap)
                         gl.texParameteri(this._glTextureType, WebGLContext.TEXTURE_MIN_FILTER, WebGLContext.LINEAR_MIPMAP_NEAREST);
                     else
                         gl.texParameteri(this._glTextureType, WebGLContext.TEXTURE_MIN_FILTER, WebGLContext.LINEAR);
                     gl.texParameteri(this._glTextureType, WebGLContext.TEXTURE_MAG_FILTER, WebGLContext.LINEAR);
                     break;
                 case BaseTexture.FILTERMODE_TRILINEAR:
                     if (this._mipmap)
                         gl.texParameteri(this._glTextureType, WebGLContext.TEXTURE_MIN_FILTER, WebGLContext.LINEAR_MIPMAP_LINEAR);
                     else
                         gl.texParameteri(this._glTextureType, WebGLContext.TEXTURE_MIN_FILTER, WebGLContext.LINEAR);
                     gl.texParameteri(this._glTextureType, WebGLContext.TEXTURE_MAG_FILTER, WebGLContext.LINEAR);
                     break;
                 default:
                     throw new Error("BaseTexture:unknown filterMode value.");
             }
         }
         /**
          * @private
          */
         _setWarpMode(orientation, mode) {
             var gl = LayaGL.instance;
             WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
             if (this._isPot(this._width) && this._isPot(this._height)) {
                 switch (mode) {
                     case BaseTexture.WARPMODE_REPEAT:
                         gl.texParameteri(this._glTextureType, orientation, WebGLContext.REPEAT);
                         break;
                     case BaseTexture.WARPMODE_CLAMP:
                         gl.texParameteri(this._glTextureType, orientation, WebGLContext.CLAMP_TO_EDGE);
                         break;
                 }
             }
             else {
                 gl.texParameteri(this._glTextureType, orientation, WebGLContext.CLAMP_TO_EDGE);
             }
         }
         /**
          * @private
          */
         _setAnisotropy(value) {
             var anisotropic = LayaGL.layaGPUInstance._extTextureFilterAnisotropic;
             if (anisotropic && !ILaya.Browser.onLimixiu) {
                 value = Math.max(value, 1);
                 var gl = LayaGL.instance;
                 WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
                 value = Math.min(gl.getParameter(anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), value);
                 gl.texParameterf(this._glTextureType, anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, value);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _disposeResource() {
             if (this._glTexture) {
                 LayaGL.instance.deleteTexture(this._glTexture);
                 this._glTexture = null;
                 this._setGPUMemory(0);
             }
         }
         /**
          * 获取纹理资源。
          */
         /*override*/ _getSource() {
             if (this._readyed)
                 return this._glTexture;
             else
                 return null;
         }
         /**
          * 通过基础数据生成mipMap。
          */
         generateMipmap() {
             if (this._isPot(this.width) && this._isPot(this.height))
                 LayaGL.instance.generateMipmap(this._glTextureType);
         }
     }
     /** @private */
     BaseTexture.WARPMODE_REPEAT = 0;
     /** @private */
     BaseTexture.WARPMODE_CLAMP = 1;
     /**寻址模式_重复。*/
     BaseTexture.FILTERMODE_POINT = 0;
     /**寻址模式_不循环。*/
     BaseTexture.FILTERMODE_BILINEAR = 1;
     /**寻址模式_不循环。*/
     BaseTexture.FILTERMODE_TRILINEAR = 2;
     /**纹理格式_R8G8B8。*/
     BaseTexture.FORMAT_R8G8B8 = 0;
     /**纹理格式_R8G8B8A8。*/
     BaseTexture.FORMAT_R8G8B8A8 = 1;
     /**纹理格式_ALPHA8。*/
     BaseTexture.FORMAT_ALPHA8 = 2;
     /**纹理格式_DXT1。*/
     BaseTexture.FORMAT_DXT1 = 3;
     /**纹理格式_DXT5。*/
     BaseTexture.FORMAT_DXT5 = 4;
     /**纹理格式_ETC2RGB。*/
     BaseTexture.FORMAT_ETC1RGB = 5;
     ///**纹理格式_ETC2RGB。*/
     //public static const FORMAT_ETC2RGB:int = 6;
     ///**纹理格式_ETC2RGBA。*/
     //public static const FORMAT_ETC2RGBA:int = 7;
     /**纹理格式_ETC2RGB_PUNCHTHROUGHALPHA。*/
     //public static const FORMAT_ETC2RGB_PUNCHTHROUGHALPHA:int = 8;
     /**纹理格式_PVRTCRGB_2BPPV。*/
     BaseTexture.FORMAT_PVRTCRGB_2BPPV = 9;
     /**纹理格式_PVRTCRGBA_2BPPV。*/
     BaseTexture.FORMAT_PVRTCRGBA_2BPPV = 10;
     /**纹理格式_PVRTCRGB_4BPPV。*/
     BaseTexture.FORMAT_PVRTCRGB_4BPPV = 11;
     /**纹理格式_PVRTCRGBA_4BPPV。*/
     BaseTexture.FORMAT_PVRTCRGBA_4BPPV = 12;
     /**渲染纹理格式_16位半精度RGBA浮点格式。*/
     BaseTexture.RENDERTEXTURE_FORMAT_RGBA_HALF_FLOAT = 14;
     /**深度格式_DEPTH_16。*/
     BaseTexture.FORMAT_DEPTH_16 = 0;
     /**深度格式_STENCIL_8。*/
     BaseTexture.FORMAT_STENCIL_8 = 1;
     /**深度格式_DEPTHSTENCIL_16_8。*/
     BaseTexture.FORMAT_DEPTHSTENCIL_16_8 = 2;
     /**深度格式_DEPTHSTENCIL_NONE。*/
     BaseTexture.FORMAT_DEPTHSTENCIL_NONE = 3;

     /**
      * <code>Texture2D</code> 类用于生成2D纹理。
      */
     class Texture2D extends BaseTexture {
         /**
          * 创建一个 <code>Texture2D</code> 实例。
          * @param	width 宽。
          * @param	height 高。
          * @param	format 贴图格式。
          * @param	mipmap 是否生成mipmap。
          * @param	canRead 是否可读像素,如果为true,会在内存保留像素数据。
          */
         constructor(width = 0, height = 0, format = BaseTexture.FORMAT_R8G8B8A8, mipmap = true, canRead = false) {
             super(format, mipmap);
             this._glTextureType = WebGLContext.TEXTURE_2D;
             this._width = width;
             this._height = height;
             this._canRead = canRead;
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_S, this._wrapModeU); //TODO:重置宽高需要调整
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_T, this._wrapModeV); //TODO:重置宽高需要调整
             this._setFilterMode(this._filterMode); //TODO:重置宽高需要调整
             this._setAnisotropy(this._anisoLevel);
             if (this._mipmap) {
                 this._mipmapCount = Math.max(Math.ceil(Math.log2(width)) + 1, Math.ceil(Math.log2(2)) + 1);
                 for (var i = 0; i < this._mipmapCount; i++)
                     this._setPixels(null, i, Math.max(width >> i, 1), Math.max(height >> i, 1)); //初始化各级mipmap
                 this._setGPUMemory(width * height * 4 * (1 + 1 / 3));
             }
             else {
                 this._mipmapCount = 1;
                 this._setGPUMemory(width * height * 4);
             }
         }
         /**
          * @private
          */
         static __init__() {
             var pixels = new Uint8Array(3);
             pixels[0] = 128;
             pixels[1] = 128;
             pixels[2] = 128;
             Texture2D.grayTexture = new Texture2D(1, 1, BaseTexture.FORMAT_R8G8B8, false, false);
             Texture2D.grayTexture.setPixels(pixels);
             Texture2D.grayTexture.lock = true; //锁住资源防止被资源管理释放
             pixels[0] = 255;
             pixels[1] = 255;
             pixels[2] = 255;
             Texture2D.whiteTexture = new Texture2D(1, 1, BaseTexture.FORMAT_R8G8B8, false, false);
             Texture2D.whiteTexture.setPixels(pixels);
             Texture2D.whiteTexture.lock = true; //锁住资源防止被资源管理释放
             pixels[0] = 0;
             pixels[1] = 0;
             pixels[2] = 0;
             Texture2D.blackTexture = new Texture2D(1, 1, BaseTexture.FORMAT_R8G8B8, false, false);
             Texture2D.blackTexture.setPixels(pixels);
             Texture2D.blackTexture.lock = true; //锁住资源防止被资源管理释放
         }
         /**
          * @inheritDoc
          */
         static _parse(data, propertyParams = null, constructParams = null) {
             var texture = constructParams ? new Texture2D(constructParams[0], constructParams[1], constructParams[2], constructParams[3], constructParams[4]) : new Texture2D(0, 0);
             if (propertyParams) {
                 texture.wrapModeU = propertyParams.wrapModeU;
                 texture.wrapModeV = propertyParams.wrapModeV;
                 texture.filterMode = propertyParams.filterMode;
                 texture.anisoLevel = propertyParams.anisoLevel;
             }
             switch (texture._format) {
                 case BaseTexture.FORMAT_R8G8B8:
                 case BaseTexture.FORMAT_R8G8B8A8:
                     texture.loadImageSource(data);
                     break;
                 case BaseTexture.FORMAT_DXT1:
                 case BaseTexture.FORMAT_DXT5:
                 case BaseTexture.FORMAT_ETC1RGB:
                 case BaseTexture.FORMAT_PVRTCRGB_2BPPV:
                 case BaseTexture.FORMAT_PVRTCRGBA_2BPPV:
                 case BaseTexture.FORMAT_PVRTCRGB_4BPPV:
                 case BaseTexture.FORMAT_PVRTCRGBA_4BPPV:
                     texture.setCompressData(data);
                     break;
                 default:
                     throw "Texture2D:unkonwn format.";
             }
             return texture;
         }
         /**
          * 加载Texture2D。
          * @param url Texture2D地址。
          * @param complete 完成回掉。
          */
         static load(url, complete) {
             ILaya.loader.create(url, complete, null, ILaya.Loader.TEXTURE2D);
         }
         /**
          * 获取mipmap数量。
          */
         get mipmapCount() {
             return this._mipmapCount;
         }
         /**
          * @inheritDoc
          */
         /*override*/ get defaulteTexture() {
             return Texture2D.grayTexture;
         }
         /**
          * @private
          */
         _getFormatByteCount() {
             switch (this._format) {
                 case BaseTexture.FORMAT_R8G8B8:
                     return 3;
                 case BaseTexture.FORMAT_R8G8B8A8:
                     return 4;
                 case BaseTexture.FORMAT_ALPHA8:
                     return 1;
                 default:
                     throw "Texture2D: unknown format.";
             }
         }
         /**
          * @private
          */
         _setPixels(pixels, miplevel, width, height) {
             var gl = LayaGL.instance;
             var textureType = this._glTextureType;
             var glFormat = this._getGLFormat();
             WebGLContext.bindTexture(gl, textureType, this._glTexture);
             if (this.format === BaseTexture.FORMAT_R8G8B8) {
                 gl.pixelStorei(WebGLContext.UNPACK_ALIGNMENT, 1); //字节对齐
                 gl.texImage2D(textureType, miplevel, glFormat, width, height, 0, glFormat, WebGLContext.UNSIGNED_BYTE, pixels);
                 gl.pixelStorei(WebGLContext.UNPACK_ALIGNMENT, 4);
             }
             else {
                 gl.texImage2D(textureType, miplevel, glFormat, width, height, 0, glFormat, WebGLContext.UNSIGNED_BYTE, pixels);
             }
         }
         /**
          * @private
          */
         _calcualatesCompressedDataSize(format, width, height) {
             switch (format) {
                 case BaseTexture.FORMAT_DXT1:
                 case BaseTexture.FORMAT_ETC1RGB:
                     return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;
                 case BaseTexture.FORMAT_DXT5:
                     return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;
                 case BaseTexture.FORMAT_PVRTCRGB_4BPPV:
                 case BaseTexture.FORMAT_PVRTCRGBA_4BPPV:
                     return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);
                 case BaseTexture.FORMAT_PVRTCRGB_2BPPV:
                 case BaseTexture.FORMAT_PVRTCRGBA_2BPPV:
                     return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);
                 default:
                     return 0;
             }
         }
         /**
          * @private
          */
         _pharseDDS(arrayBuffer) {
             const FOURCC_DXT1 = 827611204;
             const FOURCC_DXT5 = 894720068;
             const DDPF_FOURCC = 0x4;
             const DDSD_MIPMAPCOUNT = 0x20000;
             const DDS_MAGIC = 0x20534444;
             const DDS_HEADER_LENGTH = 31;
             const DDS_HEADER_MAGIC = 0;
             const DDS_HEADER_SIZE = 1;
             const DDS_HEADER_FLAGS = 2;
             const DDS_HEADER_HEIGHT = 3;
             const DDS_HEADER_WIDTH = 4;
             const DDS_HEADER_MIPMAPCOUNT = 7;
             const DDS_HEADER_PF_FLAGS = 20;
             const DDS_HEADER_PF_FOURCC = 21;
             var header = new Int32Array(arrayBuffer, 0, DDS_HEADER_LENGTH);
             if (header[DDS_HEADER_MAGIC] != DDS_MAGIC)
                 throw "Invalid magic number in DDS header";
             if (!(header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC))
                 throw "Unsupported format, must contain a FourCC code";
             var compressedFormat = header[DDS_HEADER_PF_FOURCC];
             switch (this._format) {
                 case BaseTexture.FORMAT_DXT1:
                     if (compressedFormat !== FOURCC_DXT1)
                         throw "the FourCC code is not same with texture format.";
                     break;
                 case BaseTexture.FORMAT_DXT5:
                     if (compressedFormat !== FOURCC_DXT5)
                         throw "the FourCC code is not same with texture format.";
                     break;
                 default:
                     throw "unknown texture format.";
             }
             var mipLevels = 1;
             if (header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {
                 mipLevels = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);
                 if (!this._mipmap)
                     throw "the mipmap is not same with Texture2D.";
             }
             else {
                 if (this._mipmap)
                     throw "the mipmap is not same with Texture2D.";
             }
             var width = header[DDS_HEADER_WIDTH];
             var height = header[DDS_HEADER_HEIGHT];
             this._width = width;
             this._height = height;
             var dataOffset = header[DDS_HEADER_SIZE] + 4;
             this._upLoadCompressedTexImage2D(arrayBuffer, width, height, mipLevels, dataOffset, 0);
         }
         /**
          * @private
          */
         _pharseKTX(arrayBuffer) {
             const ETC_HEADER_LENGTH = 13;
             const ETC_HEADER_FORMAT = 4;
             const ETC_HEADER_HEIGHT = 7;
             const ETC_HEADER_WIDTH = 6;
             const ETC_HEADER_MIPMAPCOUNT = 11;
             const ETC_HEADER_METADATA = 12;
             var id = new Uint8Array(arrayBuffer, 0, 12);
             if (id[0] != 0xAB || id[1] != 0x4B || id[2] != 0x54 || id[3] != 0x58 || id[4] != 0x20 || id[5] != 0x31 || id[6] != 0x31 || id[7] != 0xBB || id[8] != 0x0D || id[9] != 0x0A || id[10] != 0x1A || id[11] != 0x0A)
                 throw ("Invalid fileIdentifier in KTX header");
             var header = new Int32Array(id.buffer, id.length, ETC_HEADER_LENGTH);
             var compressedFormat = header[ETC_HEADER_FORMAT];
             switch (compressedFormat) {
                 case LayaGL.layaGPUInstance._compressedTextureEtc1.COMPRESSED_RGB_ETC1_WEBGL:
                     this._format = BaseTexture.FORMAT_ETC1RGB;
                     break;
                 default:
                     throw "unknown texture format.";
             }
             var mipLevels = header[ETC_HEADER_MIPMAPCOUNT];
             var width = header[ETC_HEADER_WIDTH];
             var height = header[ETC_HEADER_HEIGHT];
             this._width = width;
             this._height = height;
             var dataOffset = 64 + header[ETC_HEADER_METADATA];
             this._upLoadCompressedTexImage2D(arrayBuffer, width, height, mipLevels, dataOffset, 4);
         }
         /**
          * @private
          */
         _pharsePVR(arrayBuffer) {
             const PVR_FORMAT_2BPP_RGB = 0;
             const PVR_FORMAT_2BPP_RGBA = 1;
             const PVR_FORMAT_4BPP_RGB = 2;
             const PVR_FORMAT_4BPP_RGBA = 3;
             const PVR_MAGIC = 0x03525650;
             const PVR_HEADER_LENGTH = 13;
             const PVR_HEADER_MAGIC = 0;
             const PVR_HEADER_FORMAT = 2;
             const PVR_HEADER_HEIGHT = 6;
             const PVR_HEADER_WIDTH = 7;
             const PVR_HEADER_MIPMAPCOUNT = 11;
             const PVR_HEADER_METADATA = 12;
             var header = new Int32Array(arrayBuffer, 0, PVR_HEADER_LENGTH);
             if (header[PVR_HEADER_MAGIC] != PVR_MAGIC)
                 throw ("Invalid magic number in PVR header");
             var compressedFormat = header[PVR_HEADER_FORMAT];
             switch (compressedFormat) {
                 case PVR_FORMAT_2BPP_RGB:
                     this._format = BaseTexture.FORMAT_PVRTCRGB_2BPPV;
                     break;
                 case PVR_FORMAT_4BPP_RGB:
                     this._format = BaseTexture.FORMAT_PVRTCRGB_4BPPV;
                     break;
                 case PVR_FORMAT_2BPP_RGBA:
                     this._format = BaseTexture.FORMAT_PVRTCRGBA_2BPPV;
                     break;
                 case PVR_FORMAT_4BPP_RGBA:
                     this._format = BaseTexture.FORMAT_PVRTCRGBA_4BPPV;
                     break;
                 default:
                     throw "Texture2D:unknown PVR format.";
             }
             var mipLevels = header[PVR_HEADER_MIPMAPCOUNT];
             var width = header[PVR_HEADER_WIDTH];
             var height = header[PVR_HEADER_HEIGHT];
             this._width = width;
             this._height = height;
             var dataOffset = header[PVR_HEADER_METADATA] + 52;
             this._upLoadCompressedTexImage2D(arrayBuffer, width, height, mipLevels, dataOffset, 0);
         }
         /**
          * @private
          */
         _upLoadCompressedTexImage2D(data, width, height, miplevelCount, dataOffset, imageSizeOffset) {
             var gl = LayaGL.instance;
             var textureType = this._glTextureType;
             WebGLContext.bindTexture(gl, textureType, this._glTexture);
             var glFormat = this._getGLFormat();
             var offset = dataOffset;
             for (var i = 0; i < miplevelCount; i++) {
                 offset += imageSizeOffset;
                 var mipDataSize = this._calcualatesCompressedDataSize(this._format, width, height);
                 var mipData = new Uint8Array(data, offset, mipDataSize);
                 gl.compressedTexImage2D(textureType, i, glFormat, width, height, 0, mipData);
                 width = Math.max(width >> 1, 1.0);
                 height = Math.max(height >> 1, 1.0);
                 offset += mipDataSize;
             }
             var memory = offset;
             this._setGPUMemory(memory);
             //if (_canRead)
             //_pixels = pixels;
             this._readyed = true;
             this._activeResource();
         }
         /**
          * 通过图片源填充纹理,可为HTMLImageElement、HTMLCanvasElement、HTMLVideoElement、ImageBitmap、ImageData,
          * 设置之后纹理宽高可能会发生变化。
          */
         loadImageSource(source, premultiplyAlpha = false) {
             var width = source.width;
             var height = source.height;
             this._width = width;
             this._height = height;
             if (!(this._isPot(width) && this._isPot(height)))
                 this._mipmap = false;
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_S, this._wrapModeU); //宽高变化后需要重新设置
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_T, this._wrapModeV); //宽高变化后需要重新设置
             this._setFilterMode(this._filterMode); //宽高变化后需要重新设置
             var gl = LayaGL.instance;
             WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
             var glFormat = this._getGLFormat();
             if (ILaya.Render.isConchApp) { //[NATIVE]临时
                 if (source.setPremultiplyAlpha) {
                     source.setPremultiplyAlpha(premultiplyAlpha);
                 }
                 gl.texImage2D(this._glTextureType, 0, WebGLContext.RGBA, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, source);
             }
             else {
                 (premultiplyAlpha) && (gl.pixelStorei(WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true));
                 gl.texImage2D(this._glTextureType, 0, glFormat, glFormat, WebGLContext.UNSIGNED_BYTE, source);
                 (premultiplyAlpha) && (gl.pixelStorei(WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false));
             }
             if (this._mipmap) {
                 gl.generateMipmap(this._glTextureType);
                 this._setGPUMemory(width * height * 4 * (1 + 1 / 3));
             }
             else {
                 this._setGPUMemory(width * height * 4);
             }
             if (this._canRead) { //TODO:是否所有图源都可以
                 if (ILaya.Render.isConchApp) {
                     this._pixels = new Uint8Array(source._nativeObj.getImageData(0, 0, width, height)); //TODO:如果为RGB,会错误
                 }
                 else {
                     ILaya.Browser.canvas.size(width, height);
                     ILaya.Browser.canvas.clear();
                     ILaya.Browser.context.drawImage(source, 0, 0, width, height);
                     this._pixels = new Uint8Array(ILaya.Browser.context.getImageData(0, 0, width, height).data.buffer); //TODO:如果为RGB,会错误
                 }
             }
             this._readyed = true;
             this._activeResource();
         }
         /**
          * 通过像素填充纹理。
          * @param	pixels 像素。
          * @param   miplevel 层级。
          */
         setPixels(pixels, miplevel = 0) {
             if (!pixels)
                 throw "Texture2D:pixels can't be null.";
             var width = Math.max(this._width >> miplevel, 1);
             var height = Math.max(this._height >> miplevel, 1);
             var pixelsCount = width * height * this._getFormatByteCount();
             if (pixels.length < pixelsCount)
                 throw "Texture2D:pixels length should at least " + pixelsCount + ".";
             this._setPixels(pixels, miplevel, width, height);
             if (this._canRead)
                 this._pixels = pixels;
             this._readyed = true;
             this._activeResource();
         }
         /**
          * 通过像素填充部分纹理。
          * @param  x X轴像素起点。
          * @param  y Y轴像素起点。
          * @param  width 像素宽度。
          * @param  height 像素高度。
          * @param  pixels 像素数组。
          * @param  miplevel 层级。
          */
         setSubPixels(x, y, width, height, pixels, miplevel = 0) {
             if (!pixels)
                 throw "Texture2D:pixels can't be null.";
             var gl = LayaGL.instance;
             var textureType = this._glTextureType;
             WebGLContext.bindTexture(gl, textureType, this._glTexture);
             var glFormat = this._getGLFormat();
             if (this._format === BaseTexture.FORMAT_R8G8B8) {
                 gl.pixelStorei(WebGLContext.UNPACK_ALIGNMENT, 1); //字节对齐
                 gl.texSubImage2D(textureType, miplevel, x, y, width, height, glFormat, WebGLContext.UNSIGNED_BYTE, pixels);
                 gl.pixelStorei(WebGLContext.UNPACK_ALIGNMENT, 4);
             }
             else {
                 gl.texSubImage2D(textureType, miplevel, x, y, width, height, glFormat, WebGLContext.UNSIGNED_BYTE, pixels);
             }
             //if (_canRead)
             //_pixels = pixels;//TODO:
             this._readyed = true;
             this._activeResource();
         }
         /**
          * 通过压缩数据填充纹理。
          * @param	data 压缩数据。
          * @param   miplevel 层级。
          */
         setCompressData(data) {
             switch (this._format) {
                 case BaseTexture.FORMAT_DXT1:
                 case BaseTexture.FORMAT_DXT5:
                     this._pharseDDS(data);
                     break;
                 case BaseTexture.FORMAT_ETC1RGB:
                     this._pharseKTX(data);
                     break;
                 case BaseTexture.FORMAT_PVRTCRGB_2BPPV:
                 case BaseTexture.FORMAT_PVRTCRGBA_2BPPV:
                 case BaseTexture.FORMAT_PVRTCRGB_4BPPV:
                 case BaseTexture.FORMAT_PVRTCRGBA_4BPPV:
                     this._pharsePVR(data);
                     break;
                 default:
                     throw "Texture2D:unkonwn format.";
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _recoverResource() {
             //TODO:补充
         }
         /**
          * 返回图片像素。
          * @return 图片像素。
          */
         getPixels() {
             if (this._canRead)
                 return this._pixels;
             else
                 throw new Error("Texture2D: must set texture canRead is true.");
         }
     }
     /**Texture2D资源。*/
     Texture2D.TEXTURE2D = "TEXTURE2D";
     /**纯灰色纹理。*/
     Texture2D.grayTexture = null;
     /**纯白色纹理。*/
     Texture2D.whiteTexture = null;
     /**纯黑色纹理。*/
     Texture2D.blackTexture = null;

     /**
      * ...
      * @author ...
      */
     class BaseShader extends Resource {
         constructor() {
             super();
         }
     }

     class RenderState2D {
         /* 不知道 有什么用，删掉先
         public static function getMatrArray():Array {
             return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
         }
         */
         //TODO:coverage
         static mat2MatArray(mat, matArray) {
             var m = mat;
             var m4 = matArray;
             m4[0] = m.a;
             m4[1] = m.b;
             m4[2] = RenderState2D.EMPTYMAT4_ARRAY[2];
             m4[3] = RenderState2D.EMPTYMAT4_ARRAY[3];
             m4[4] = m.c;
             m4[5] = m.d;
             m4[6] = RenderState2D.EMPTYMAT4_ARRAY[6];
             m4[7] = RenderState2D.EMPTYMAT4_ARRAY[7];
             m4[8] = RenderState2D.EMPTYMAT4_ARRAY[8];
             m4[9] = RenderState2D.EMPTYMAT4_ARRAY[9];
             m4[10] = RenderState2D.EMPTYMAT4_ARRAY[10];
             m4[11] = RenderState2D.EMPTYMAT4_ARRAY[11];
             m4[12] = m.tx;
             m4[13] = m.ty;
             m4[14] = RenderState2D.EMPTYMAT4_ARRAY[14];
             m4[15] = RenderState2D.EMPTYMAT4_ARRAY[15];
             return matArray;
         }
         static restoreTempArray() {
             RenderState2D.TEMPMAT4_ARRAY[0] = 1;
             RenderState2D.TEMPMAT4_ARRAY[1] = 0;
             RenderState2D.TEMPMAT4_ARRAY[4] = 0;
             RenderState2D.TEMPMAT4_ARRAY[5] = 1;
             RenderState2D.TEMPMAT4_ARRAY[12] = 0;
             RenderState2D.TEMPMAT4_ARRAY[13] = 0;
         }
         static clear() {
             RenderState2D.worldScissorTest = false;
             //worldFilters = null;
             RenderState2D.worldAlpha = 1;
             //worldClipRect.x = worldClipRect.y = 0;
             //worldClipRect.width = width;
             //worldClipRect.height = height;
         }
     }
     RenderState2D._MAXSIZE = 99999999;
     /**@private 一个初始化的 <code>Matrix</code> 对象，不允许修改此对象内容。*/
     RenderState2D.EMPTYMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
     RenderState2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
     RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
     RenderState2D.worldMatrix = new Matrix();
     RenderState2D.matWVP = null; // :Matrix4x4 = Matrix4x4.DEFAULT;		// 3d矩阵
     RenderState2D.worldAlpha = 1.0;
     RenderState2D.worldScissorTest = false;
     RenderState2D.width = 0;
     RenderState2D.height = 0;

     /**
      * <code>RenderTexture</code> 类用于创建渲染目标。
      */
     class RenderTexture2D extends BaseTexture {
         /**
          * @param width  宽度。
          * @param height 高度。
          * @param format 纹理格式。
          * @param depthStencilFormat 深度格式。
          * 创建一个 <code>RenderTexture</code> 实例。
          */
         constructor(width, height, format = BaseTexture.FORMAT_R8G8B8, depthStencilFormat = BaseTexture.FORMAT_DEPTH_16) {
             super(format, false);
             this._mgrKey = 0; //给WebGLRTMgr用的
             this._glTextureType = WebGLContext.TEXTURE_2D;
             this._width = width;
             this._height = height;
             this._depthStencilFormat = depthStencilFormat;
             this._create(width, height);
             this.lock = true;
         }
         /**
          * 获取当前激活的Rendertexture
          */
         static get currentActive() {
             return RenderTexture2D._currentActive;
         }
         /**
          * 获取深度格式。
          *@return 深度格式。
          */
         get depthStencilFormat() {
             return this._depthStencilFormat;
         }
         /**
          * @inheritDoc
          */
         /*override*/ get defaulteTexture() {
             return Texture2D.grayTexture;
         }
         getIsReady() {
             return true;
         }
         /**
          * 获取宽度。
          */
         get sourceWidth() {
             return this._width;
         }
         /***
          * 获取高度。
          */
         get sourceHeight() {
             return this._height;
         }
         /**
          * 获取offsetX。
          */
         get offsetX() {
             return 0;
         }
         /***
          * 获取offsetY
          */
         get offsetY() {
             return 0;
         }
         /**
          * @private
          */
         _create(width, height) {
             var gl = LayaGL.instance;
             this._frameBuffer = gl.createFramebuffer();
             WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
             var glFormat = this._getGLFormat();
             gl.texImage2D(this._glTextureType, 0, glFormat, width, height, 0, glFormat, WebGLContext.UNSIGNED_BYTE, null);
             this._setGPUMemory(width * height * 4);
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, this._frameBuffer);
             gl.framebufferTexture2D(WebGLContext.FRAMEBUFFER, WebGLContext.COLOR_ATTACHMENT0, WebGLContext.TEXTURE_2D, this._glTexture, 0);
             if (this._depthStencilFormat !== BaseTexture.FORMAT_DEPTHSTENCIL_NONE) {
                 this._depthStencilBuffer = gl.createRenderbuffer();
                 gl.bindRenderbuffer(WebGLContext.RENDERBUFFER, this._depthStencilBuffer);
                 switch (this._depthStencilFormat) {
                     case BaseTexture.FORMAT_DEPTH_16:
                         gl.renderbufferStorage(WebGLContext.RENDERBUFFER, WebGLContext.DEPTH_COMPONENT16, width, height);
                         gl.framebufferRenderbuffer(WebGLContext.FRAMEBUFFER, WebGLContext.DEPTH_ATTACHMENT, WebGLContext.RENDERBUFFER, this._depthStencilBuffer);
                         break;
                     case BaseTexture.FORMAT_STENCIL_8:
                         gl.renderbufferStorage(WebGLContext.RENDERBUFFER, WebGLContext.STENCIL_INDEX8, width, height);
                         gl.framebufferRenderbuffer(WebGLContext.FRAMEBUFFER, WebGLContext.STENCIL_ATTACHMENT, WebGLContext.RENDERBUFFER, this._depthStencilBuffer);
                         break;
                     case BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                         gl.renderbufferStorage(WebGLContext.RENDERBUFFER, WebGLContext.DEPTH_STENCIL, width, height);
                         gl.framebufferRenderbuffer(WebGLContext.FRAMEBUFFER, WebGLContext.DEPTH_STENCIL_ATTACHMENT, WebGLContext.RENDERBUFFER, this._depthStencilBuffer);
                         break;
                     default:
                     //console.log("RenderTexture: unkonw depth format.");//2d并不需要depthbuffer
                 }
             }
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
             gl.bindRenderbuffer(WebGLContext.RENDERBUFFER, null);
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_S, this._wrapModeU);
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_T, this._wrapModeV);
             this._setFilterMode(this._filterMode);
             this._setAnisotropy(this._anisoLevel);
             this._readyed = true;
             this._activeResource();
         }
         /**
          * 生成mipMap。
          */
         /*override*/ generateMipmap() {
             if (this._isPot(this.width) && this._isPot(this.height)) {
                 this._mipmap = true;
                 LayaGL.instance.generateMipmap(this._glTextureType);
                 this._setFilterMode(this._filterMode);
                 this._setGPUMemory(this.width * this.height * 4 * (1 + 1 / 3));
             }
             else {
                 this._mipmap = false;
                 this._setGPUMemory(this.width * this.height * 4);
             }
         }
         /**
          * 保存当前的RT信息。
          */
         static pushRT() {
             RenderTexture2D.rtStack.push({ rt: RenderTexture2D._currentActive, w: RenderState2D.width, h: RenderState2D.height });
         }
         /**
          * 恢复上次保存的RT信息
          */
         static popRT() {
             var gl = LayaGL.instance;
             var top = RenderTexture2D.rtStack.pop();
             if (top) {
                 if (RenderTexture2D._currentActive != top.rt) {
                     LayaGL.instance.bindFramebuffer(WebGLContext.FRAMEBUFFER, top.rt ? top.rt._frameBuffer : null);
                     RenderTexture2D._currentActive = top.rt;
                 }
                 gl.viewport(0, 0, top.w, top.h);
                 RenderState2D.width = top.w;
                 RenderState2D.height = top.h;
             }
         }
         /**
          * 开始绑定。
          */
         start() {
             var gl = LayaGL.instance;
             //(memorySize == 0) && recreateResource();
             LayaGL.instance.bindFramebuffer(WebGLContext.FRAMEBUFFER, this._frameBuffer);
             this._lastRT = RenderTexture2D._currentActive;
             RenderTexture2D._currentActive = this;
             this._readyed = true;
             //var gl:LayaGL = LayaGL.instance;//TODO:这段代码影响2D、3D混合
             ////(memorySize == 0) && recreateResource();
             //LayaGL.instance.bindFramebuffer(WebGLContext.FRAMEBUFFER, _frameBuffer);
             //_lastRT = _currentActive;
             //_currentActive = this;
             ////_readyed = false;  
             //_readyed = true;	//这个没什么用。还会影响流程，比如我有时候并不调用end。所以直接改成true
             //
             ////if (_type == TYPE2D) {
             gl.viewport(0, 0, this._width, this._height); //外部设置
             this._lastWidth = RenderState2D.width;
             this._lastHeight = RenderState2D.height;
             RenderState2D.width = this._width;
             RenderState2D.height = this._height;
             BaseShader.activeShader = null;
             ////}
         }
         /**
          * 结束绑定。
          */
         end() {
             LayaGL.instance.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
             RenderTexture2D._currentActive = null;
             this._readyed = true;
         }
         /**
          * 恢复上一次的RenderTarge.由于使用自己保存的，所以如果被外面打断了的话，会出错。
          */
         restore() {
             var gl = LayaGL.instance;
             if (this._lastRT != RenderTexture2D._currentActive) {
                 LayaGL.instance.bindFramebuffer(WebGLContext.FRAMEBUFFER, this._lastRT ? this._lastRT._frameBuffer : null);
                 RenderTexture2D._currentActive = this._lastRT;
             }
             this._readyed = true;
             //if (_type == TYPE2D)//待调整
             //{
             gl.viewport(0, 0, this._lastWidth, this._lastHeight);
             RenderState2D.width = this._lastWidth;
             RenderState2D.height = this._lastHeight;
             BaseShader.activeShader = null;
             //} else 
             //	gl.viewport(0, 0, Laya.stage.width, Laya.stage.height);
         }
         clear(r = 0.0, g = 0.0, b = 0.0, a = 1.0) {
             var gl = LayaGL.instance;
             gl.clearColor(r, g, b, a);
             var clearFlag = WebGLContext.COLOR_BUFFER_BIT;
             switch (this._depthStencilFormat) {
                 //case WebGLContext.DEPTH_COMPONENT: 
                 case WebGLContext.DEPTH_COMPONENT16:
                     clearFlag |= WebGLContext.DEPTH_BUFFER_BIT;
                     break;
                 //case WebGLContext.STENCIL_INDEX:
                 case WebGLContext.STENCIL_INDEX8:
                     clearFlag |= WebGLContext.STENCIL_BUFFER_BIT;
                     break;
                 case WebGLContext.DEPTH_STENCIL:
                     clearFlag |= WebGLContext.DEPTH_BUFFER_BIT;
                     clearFlag |= WebGLContext.STENCIL_BUFFER_BIT;
                     break;
             }
             gl.clear(clearFlag);
         }
         /**
          * 获得像素数据。
          * @param x X像素坐标。
          * @param y Y像素坐标。
          * @param width 宽度。
          * @param height 高度。
          * @return 像素数据。
          */
         getData(x, y, width, height) {
             if (ILaya.Render.isConchApp && window.conchConfig.threadMode == 2) {
                 throw "native 2 thread mode use getDataAsync";
             }
             var gl = LayaGL.instance;
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, this._frameBuffer);
             var canRead = (gl.checkFramebufferStatus(WebGLContext.FRAMEBUFFER) === WebGLContext.FRAMEBUFFER_COMPLETE);
             if (!canRead) {
                 gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
                 return null;
             }
             var pixels = new Uint8Array(this._width * this._height * 4);
             var glFormat = this._getGLFormat();
             gl.readPixels(x, y, width, height, glFormat, WebGLContext.UNSIGNED_BYTE, pixels);
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
             return pixels;
         }
         /**
          * native多线程
          */
         getDataAsync(x, y, width, height, callBack) {
             var gl = LayaGL.instance;
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, this._frameBuffer);
             gl.readPixelsAsync(x, y, width, height, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, function (data) {
                 callBack(new Uint8Array(data));
             });
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
         }
         recycle() {
         }
         /**
          * @inheritDoc
          */
         /*override*/ _disposeResource() {
             if (this._frameBuffer) {
                 var gl = LayaGL.instance;
                 gl.deleteTexture(this._glTexture);
                 gl.deleteFramebuffer(this._frameBuffer);
                 gl.deleteRenderbuffer(this._depthStencilBuffer);
                 this._glTexture = null;
                 this._frameBuffer = null;
                 this._depthStencilBuffer = null;
                 this._setGPUMemory(0);
             }
         }
     }
     //为push,pop 用的。以后和上面只保留一份。
     //由于可能递归，所以不能简单的用save，restore
     RenderTexture2D.rtStack = []; //rt:RenderTexture，w:int，h:int
     RenderTexture2D.defuv = [0, 0, 1, 0, 1, 1, 0, 1];
     RenderTexture2D.flipyuv = [0, 1, 1, 1, 1, 0, 0, 0];

     /**
      * WebGLRTMgr 管理WebGLRenderTarget的创建和回收
      */
     class WebGLRTMgr {
         /**
          * 获得一个renderTarget
          * 暂时先按照严格大小判断。
          *
          * @param	w
          * @param	h
          * @return
          */
         static getRT(w, h) {
             w = w | 0;
             h = h | 0;
             if (w >= 10000) {
                 console.error('getRT error! w too big');
             }
             var key = h * 10000 + w;
             var sw = WebGLRTMgr.dict[key];
             var ret;
             if (sw) {
                 if (sw.length > 0) {
                     ret = sw.pop();
                     ret._mgrKey = key; //只有不再mgr中的才有key
                     return ret;
                 }
             }
             ret = new RenderTexture2D(w, h, BaseTexture.FORMAT_R8G8B8A8, -1);
             ret._mgrKey = key;
             return ret;
         }
         /**
          * 回收一个renderTarget
          * @param	rt
          */
         static releaseRT(rt) {
             //如果_mgrKey<=0表示已经加进来了。
             if (rt._mgrKey <= 0)
                 return;
             var sw = WebGLRTMgr.dict[rt._mgrKey];
             !sw && (sw = [], WebGLRTMgr.dict[rt._mgrKey] = sw);
             rt._mgrKey = 0;
             sw.push(rt);
         }
     }
     WebGLRTMgr.dict = {}; //key=h*10000+w

     class BlendMode {
         static _init_(gl) {
             BlendMode.fns = [BlendMode.BlendNormal, BlendMode.BlendAdd, BlendMode.BlendMultiply, BlendMode.BlendScreen, BlendMode.BlendOverlay, BlendMode.BlendLight, BlendMode.BlendMask, BlendMode.BlendDestinationOut];
             BlendMode.targetFns = [BlendMode.BlendNormalTarget, BlendMode.BlendAddTarget, BlendMode.BlendMultiplyTarget, BlendMode.BlendScreenTarget, BlendMode.BlendOverlayTarget, BlendMode.BlendLightTarget, BlendMode.BlendMask, BlendMode.BlendDestinationOut];
         }
         static BlendNormal(gl) {
             //为了避免黑边，和canvas作为贴图的黑边
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.ONE_MINUS_SRC_ALPHA);
         }
         static BlendAdd(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.DST_ALPHA);
         }
         //TODO:coverage
         static BlendMultiply(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.DST_COLOR, WebGLContext.ONE_MINUS_SRC_ALPHA);
         }
         //TODO:coverage
         static BlendScreen(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.ONE);
         }
         //TODO:coverage
         static BlendOverlay(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.ONE_MINUS_SRC_COLOR);
         }
         //TODO:coverage
         static BlendLight(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.ONE);
         }
         static BlendNormalTarget(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.ONE_MINUS_SRC_ALPHA);
         }
         //TODO:coverage
         static BlendAddTarget(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.DST_ALPHA);
         }
         //TODO:coverage
         static BlendMultiplyTarget(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.DST_COLOR, WebGLContext.ONE_MINUS_SRC_ALPHA);
         }
         //TODO:coverage
         static BlendScreenTarget(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.ONE);
         }
         //TODO:coverage
         static BlendOverlayTarget(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.ONE_MINUS_SRC_COLOR);
         }
         //TODO:coverage
         static BlendLightTarget(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.ONE);
         }
         static BlendMask(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ZERO, WebGLContext.SRC_ALPHA);
         }
         //TODO:coverage
         static BlendDestinationOut(gl) {
             WebGLContext.setBlendFunc(gl, WebGLContext.ZERO, WebGLContext.ZERO);
         }
     }
     BlendMode.activeBlendFunction = null;
     BlendMode.NAMES = ["normal", "add", "multiply", "screen", "overlay", "light", "mask", "destination-out"];
     BlendMode.TOINT = { "normal": 0, "add": 1, "multiply": 2, "screen": 3, "overlay": 4, "light": 5, "mask": 6, "destination-out": 7, "lighter": 1 };
     BlendMode.NORMAL = "normal"; //0
     BlendMode.ADD = "add"; //1
     BlendMode.MULTIPLY = "multiply"; //2
     BlendMode.SCREEN = "screen"; //3
     BlendMode.OVERLAY = "overlay"; //4
     BlendMode.LIGHT = "light"; //5
     BlendMode.MASK = "mask"; //6
     BlendMode.DESTINATIONOUT = "destination-out"; //7
     BlendMode.LIGHTER = "lighter"; //1  等同于加色法
     BlendMode.fns = [];
     BlendMode.targetFns = [];

     class ShaderDefinesBase {
         constructor(name2int, int2name, int2nameMap) {
             this._value = 0;
             this._name2int = name2int;
             this._int2name = int2name;
             this._int2nameMap = int2nameMap;
         }
         //TODO:coverage
         add(value) {
             if (typeof (value) == 'string') {
                 this._value |= this._name2int[value];
             }
             else {
                 this._value |= value;
             }
             return this._value;
         }
         addInt(value) {
             this._value |= value;
             return this._value;
         }
         //TODO:coverage
         remove(value) {
             if (typeof (value) == 'string') {
                 this._value &= ~(this._name2int[value]);
             }
             else {
                 this._value &= (~value);
             }
             return this._value;
         }
         //TODO:coverage
         isDefine(def) {
             return (this._value & def) === def;
         }
         //TODO:coverage
         getValue() {
             return this._value;
         }
         setValue(value) {
             this._value = value;
         }
         toNameDic() {
             var r = this._int2nameMap[this._value];
             return r ? r : ShaderDefinesBase._toText(this._value, this._int2name, this._int2nameMap);
         }
         static _reg(name, value, _name2int, _int2name) {
             _name2int[name] = value;
             _int2name[value] = name;
         }
         static _toText(value, _int2name, _int2nameMap) {
             var r = _int2nameMap[value];
             if (r)
                 return r;
             var o = {};
             var d = 1;
             for (var i = 0; i < 32; i++) {
                 d = 1 << i;
                 if (d > value)
                     break;
                 if (value & d) {
                     var name = _int2name[d];
                     name && (o[name] = "");
                 }
             }
             _int2nameMap[value] = o;
             return o;
         }
         //TODO:coverage
         static _toInt(names, _name2int) {
             var words = names.split('.');
             var num = 0;
             for (var i = 0, n = words.length; i < n; i++) {
                 var value = _name2int[words[i]];
                 if (!value)
                     throw new Error("Defines to int err:" + names + "/" + words[i]);
                 num |= value;
             }
             return num;
         }
     }

     class ShaderDefines2D extends ShaderDefinesBase {
         constructor() {
             super(ShaderDefines2D.__name2int, ShaderDefines2D.__int2name, ShaderDefines2D.__int2nameMap);
         }
         static __init__() {
             ShaderDefines2D.reg("TEXTURE2D", ShaderDefines2D.TEXTURE2D);
             ShaderDefines2D.reg("PRIMITIVE", ShaderDefines2D.PRIMITIVE);
             ShaderDefines2D.reg("GLOW_FILTER", ShaderDefines2D.FILTERGLOW);
             ShaderDefines2D.reg("BLUR_FILTER", ShaderDefines2D.FILTERBLUR);
             ShaderDefines2D.reg("COLOR_FILTER", ShaderDefines2D.FILTERCOLOR);
             ShaderDefines2D.reg("COLOR_ADD", ShaderDefines2D.COLORADD);
             ShaderDefines2D.reg("WORLDMAT", ShaderDefines2D.WORLDMAT);
             ShaderDefines2D.reg("FILLTEXTURE", ShaderDefines2D.FILLTEXTURE);
             ShaderDefines2D.reg("FSHIGHPRECISION", ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION);
             ShaderDefines2D.reg('MVP3D', ShaderDefines2D.MVP3D);
         }
         static reg(name, value) {
             this._reg(name, value, ShaderDefines2D.__name2int, ShaderDefines2D.__int2name);
         }
         //TODO:coverage
         static toText(value, int2name, int2nameMap) {
             return this._toText(value, int2name, int2nameMap);
         }
         //TODO:coverage
         static toInt(names) {
             return this._toInt(names, ShaderDefines2D.__name2int);
         }
     }
     ShaderDefines2D.TEXTURE2D = 0x01;
     ShaderDefines2D.PRIMITIVE = 0x04;
     ShaderDefines2D.FILTERGLOW = 0x08;
     ShaderDefines2D.FILTERBLUR = 0x10;
     ShaderDefines2D.FILTERCOLOR = 0x20;
     ShaderDefines2D.COLORADD = 0x40;
     ShaderDefines2D.WORLDMAT = 0x80;
     ShaderDefines2D.FILLTEXTURE = 0x100;
     ShaderDefines2D.SKINMESH = 0x200;
     ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION = 0x400;
     ShaderDefines2D.MVP3D = 0x800;
     ShaderDefines2D.NOOPTMASK = ShaderDefines2D.FILTERGLOW | ShaderDefines2D.FILTERBLUR | ShaderDefines2D.FILTERCOLOR | ShaderDefines2D.FILLTEXTURE; //有这些定义的不要优化。见submittexture
     ShaderDefines2D.__name2int = {};
     ShaderDefines2D.__int2name = [];
     ShaderDefines2D.__int2nameMap = [];

     /**
          * <p> <code>Stat</code> 是一个性能统计面板，可以实时更新相关的性能参数。</p>
          * <p>参与统计的性能参数如下（所有参数都是每大约1秒进行更新）：<br/>
          * FPS(Canvas)/FPS(WebGL)：Canvas 模式或者 WebGL 模式下的帧频，也就是每秒显示的帧数，值越高、越稳定，感觉越流畅；<br/>
          * Sprite：统计所有渲染节点（包括容器）数量，它的大小会影响引擎进行节点遍历、数据组织和渲染的效率。其值越小，游戏运行效率越高；<br/>
          * DrawCall：此值是决定性能的重要指标，其值越小，游戏运行效率越高。Canvas模式下表示每大约1秒的图像绘制次数；WebGL模式下表示每大约1秒的渲染提交批次，每次准备数据并通知GPU渲染绘制的过程称为1次DrawCall，在每次DrawCall中除了在通知GPU的渲染上比较耗时之外，切换材质与shader也是非常耗时的操作；<br/>
          * CurMem：Canvas模式下，表示内存占用大小，值越小越好，过高会导致游戏闪退；WebGL模式下，表示内存与显存的占用，值越小越好；<br/>
          * Shader：是 WebGL 模式独有的性能指标，表示每大约1秒 Shader 提交次数，值越小越好；<br/>
          * Canvas：由三个数值组成，只有设置 CacheAs 后才会有值，默认为0/0/0。从左到右数值的意义分别为：每帧重绘的画布数量 / 缓存类型为"normal"类型的画布数量 / 缓存类型为"bitmap"类型的画布数量。</p>
          */
     class Stat {
         /**
          * 显示性能统计信息。
          * @param	x X轴显示位置。
          * @param	y Y轴显示位置。
          */
         static show(x = 0, y = 0) {
             Stat._StatRender.show(x, y);
         }
         /**激活性能统计*/
         static enable() {
             Stat._StatRender.enable();
         }
         /**
          * 隐藏性能统计信息。
          */
         static hide() {
             Stat._StatRender.hide();
         }
         /**
          * @private
          * 清零性能统计计算相关的数据。
          */
         static clear() {
             Stat.trianglesFaces = Stat.renderBatches = Stat.savedRenderBatches = Stat.shaderCall = Stat.spriteRenderUseCacheCount = Stat.frustumCulling = Stat.octreeNodeCulling = Stat.canvasNormal = Stat.canvasBitmap = Stat.canvasReCache = 0;
         }
         /**
          * 点击性能统计显示区域的处理函数。
          */
         static set onclick(fn) {
             Stat._StatRender.set_onclick(fn);
         }
     }
     /** 每秒帧数。*/
     Stat.FPS = 0;
     /**主舞台 <code>Stage</code> 渲染次数计数。 */
     Stat.loopCount = 0;
     /** 着色器请求次数。*/
     Stat.shaderCall = 0;
     /** 渲染批次。*/
     Stat.renderBatches = 0;
     /** 节省的渲染批次。*/
     Stat.savedRenderBatches = 0;
     /** 三角形面数。*/
     Stat.trianglesFaces = 0;
     /** 精灵<code>Sprite</code> 的数量。*/
     Stat.spriteCount = 0;
     /** 精灵渲染使用缓存<code>Sprite</code> 的数量。*/
     Stat.spriteRenderUseCacheCount = 0;
     /** 视锥剔除次数。*/
     Stat.frustumCulling = 0;
     /**	八叉树节点剔除次数。*/
     Stat.octreeNodeCulling = 0;
     /** 画布 canvas 使用标准渲染的次数。*/
     Stat.canvasNormal = 0;
     /** 画布 canvas 使用位图渲染的次数。*/
     Stat.canvasBitmap = 0;
     /** 画布 canvas 缓冲区重绘次数。*/
     Stat.canvasReCache = 0;
     /** 表示当前使用的是否为慢渲染模式。*/
     Stat.renderSlow = false;
     Stat._fpsData = [];
     Stat._timer = 0;
     Stat._count = 0;
     /**@private*/
     Stat._StatRender = null;

     /**
          * @private
          * <code>StringKey</code> 类用于存取字符串对应的数字。
          */
     class StringKey {
         constructor() {
             this._strsToID = {};
             this._idToStrs = [];
             this._length = 0;
         }
         //TODO:
         /**
          * 添加一个字符。
          * @param	str 字符，将作为key 存储相应生成的数字。
          * @return 此字符对应的数字。
          */
         //TODO:coverage
         add(str) {
             var index = this._strsToID[str];
             if (index != null)
                 return index;
             this._idToStrs[this._length] = str;
             return this._strsToID[str] = this._length++;
         }
         /**
          * 获取指定字符对应的ID。
          * @param	str 字符。
          * @return 此字符对应的ID。
          */
         //TODO:coverage
         getID(str) {
             var index = this._strsToID[str];
             return index == null ? -1 : index;
         }
         /**
          * 根据指定ID获取对应字符。
          * @param  id ID。
          * @return 此id对应的字符。
          */
         //TODO:coverage
         getName(id) {
             var str = this._idToStrs[id];
             return str == null ? undefined : str;
         }
     }

     class Shader extends BaseShader {
         /**
          * 根据vs和ps信息生成shader对象
          * 把自己存储在 sharders 数组中
          * @param	vs
          * @param	ps
          * @param	name:
          * @param	nameMap 帮助里要详细解释为什么需要nameMap
          */
         constructor(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
             super();
             this._attribInfo = null;
             this.customCompile = false;
             this._curActTexIndex = 0;
             //存储一些私有变量
             this.tag = {};
             this._program = null;
             this._params = null;
             this._paramsMap = {};
             if ((!vs) || (!ps))
                 throw "Shader Error";
             this._attribInfo = bindAttrib;
             this._id = ++Shader._count;
             this._vs = vs;
             this._ps = ps;
             this._nameMap = nameMap ? nameMap : {};
             saveName != null && (Shader.sharders[saveName] = this);
             this.recreateResource();
             this.lock = true;
         }
         //TODO:coverage
         static getShader(name) {
             return Shader.sharders[name];
         }
         //TODO:coverage
         static create(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
             return new Shader(vs, ps, saveName, nameMap, bindAttrib);
         }
         /**
          * 根据宏动态生成shader文件，支持#include?COLOR_FILTER "parts/ColorFilter_ps_logic.glsl";条件嵌入文件
          * @param	name
          * @param	vs
          * @param	ps
          * @param	define 宏定义，格式:{name:value...}
          * @return
          */
         //TODO:coverage
         static withCompile(nameID, define, shaderName, createShader) {
             if (shaderName && Shader.sharders[shaderName])
                 return Shader.sharders[shaderName];
             var pre = Shader._preCompileShader[Shader.SHADERNAME2ID * nameID];
             if (!pre)
                 throw new Error("withCompile shader err!" + nameID);
             return pre.createShader(define, shaderName, createShader, null);
         }
         /**
          * 根据宏动态生成shader文件，支持#include?COLOR_FILTER "parts/ColorFilter_ps_logic.glsl";条件嵌入文件
          * @param	name
          * @param	vs
          * @param	ps
          * @param	define 宏定义，格式:{name:value...}
          * @return
          */
         static withCompile2D(nameID, mainID, define, shaderName, createShader, bindAttrib = null) {
             if (shaderName && Shader.sharders[shaderName])
                 return Shader.sharders[shaderName];
             var pre = Shader._preCompileShader[Shader.SHADERNAME2ID * nameID + mainID];
             if (!pre)
                 throw new Error("withCompile shader err!" + nameID + " " + mainID);
             return pre.createShader(define, shaderName, createShader, bindAttrib);
         }
         static addInclude(fileName, txt) {
             ILaya.ShaderCompile.addInclude(fileName, txt);
         }
         /**
          * 预编译shader文件，主要是处理宏定义
          * @param	nameID,一般是特殊宏+shaderNameID*0.0002组成的一个浮点数当做唯一标识
          * @param	vs
          * @param	ps
          */
         //TODO:coverage
         static preCompile(nameID, vs, ps, nameMap) {
             var id = Shader.SHADERNAME2ID * nameID;
             Shader._preCompileShader[id] = new ILaya.ShaderCompile(vs, ps, nameMap);
         }
         /**
          * 预编译shader文件，主要是处理宏定义
          * @param	nameID,一般是特殊宏+shaderNameID*0.0002组成的一个浮点数当做唯一标识
          * @param	vs
          * @param	ps
          */
         static preCompile2D(nameID, mainID, vs, ps, nameMap) {
             var id = Shader.SHADERNAME2ID * nameID + mainID;
             Shader._preCompileShader[id] = new ILaya.ShaderCompile(vs, ps, nameMap);
         }
         recreateResource() {
             this._compile();
             this._setGPUMemory(0); //忽略尺寸尺寸
         }
         //TODO:coverage
         /*override*/ _disposeResource() {
             WebGLContext.mainContext.deleteShader(this._vshader);
             WebGLContext.mainContext.deleteShader(this._pshader);
             WebGLContext.mainContext.deleteProgram(this._program);
             this._vshader = this._pshader = this._program = null;
             this._params = null;
             this._paramsMap = {};
             this._setGPUMemory(0);
             this._curActTexIndex = 0;
         }
         _compile() {
             if (!this._vs || !this._ps || this._params)
                 return;
             /*
             trace("================================");
             trace(_vs);
             trace(_ps);
             trace("\n");
             */
             this._reCompile = true;
             this._params = [];
             var result;
             if (this.customCompile)
                 result = ILaya.ShaderCompile.preGetParams(this._vs, this._ps);
             var gl = WebGLContext.mainContext;
             this._program = gl.createProgram();
             this._vshader = Shader._createShader(gl, this._vs, WebGLContext.VERTEX_SHADER);
             this._pshader = Shader._createShader(gl, this._ps, WebGLContext.FRAGMENT_SHADER);
             gl.attachShader(this._program, this._vshader);
             gl.attachShader(this._program, this._pshader);
             var one, i, n, location;
             //属性用指定location的方法，这样更灵活，更方便与vao结合。
             //注意注意注意 这个必须放到link前面
             var attribDescNum = this._attribInfo ? this._attribInfo.length : 0;
             for (i = 0; i < attribDescNum; i += 2) {
                 gl.bindAttribLocation(this._program, this._attribInfo[i + 1], this._attribInfo[i]);
             }
             gl.linkProgram(this._program);
             if (!this.customCompile && !gl.getProgramParameter(this._program, WebGLContext.LINK_STATUS)) {
                 throw gl.getProgramInfoLog(this._program);
             }
             //trace(_vs);
             //trace(_ps);
             /*
             var attribNum:int = customCompile ? result.attributes.length : gl.getProgramParameter(_program, WebGLContext.ACTIVE_ATTRIBUTES); //得到attribute的个数
             
             for (i = 0; i < attribNum; i++) {
                 var attrib:* = customCompile ? result.attributes[i] : gl.getActiveAttrib(_program, i); //attrib对象，{name,size,type}
                 location = gl.getAttribLocation(_program, attrib.name); //用名字来得到location
                 one = {vartype: "attribute", glfun:null, ivartype: 0, attrib: attrib, location: location, name: attrib.name, type: attrib.type, isArray: false, isSame: false, preValue: null, indexOfParams: 0};
                 _params.push(one);
             }
             */
             var nUniformNum = this.customCompile ? result.uniforms.length : gl.getProgramParameter(this._program, WebGLContext.ACTIVE_UNIFORMS); //个数
             for (i = 0; i < nUniformNum; i++) {
                 var uniform = this.customCompile ? result.uniforms[i] : gl.getActiveUniform(this._program, i); //得到uniform对象，包括名字等信息 {name,type,size}
                 location = gl.getUniformLocation(this._program, uniform.name); //用名字来得到location
                 one = { vartype: "uniform", glfun: null, ivartype: 1, location: location, name: uniform.name, type: uniform.type, isArray: false, isSame: false, preValue: null, indexOfParams: 0 };
                 if (one.name.indexOf('[0]') > 0) {
                     one.name = one.name.substr(0, one.name.length - 3);
                     one.isArray = true;
                     one.location = gl.getUniformLocation(this._program, one.name);
                 }
                 this._params.push(one);
             }
             for (i = 0, n = this._params.length; i < n; i++) {
                 one = this._params[i];
                 one.indexOfParams = i;
                 one.index = 1;
                 one.value = [one.location, null];
                 one.codename = one.name;
                 one.name = this._nameMap[one.codename] ? this._nameMap[one.codename] : one.codename;
                 this._paramsMap[one.name] = one;
                 one._this = this;
                 one.uploadedValue = [];
                 switch (one.type) {
                     case WebGLContext.INT:
                         one.fun = one.isArray ? this._uniform1iv : this._uniform1i;
                         break;
                     case WebGLContext.FLOAT:
                         one.fun = one.isArray ? this._uniform1fv : this._uniform1f;
                         break;
                     case WebGLContext.FLOAT_VEC2:
                         one.fun = one.isArray ? this._uniform_vec2v : this._uniform_vec2;
                         break;
                     case WebGLContext.FLOAT_VEC3:
                         one.fun = one.isArray ? this._uniform_vec3v : this._uniform_vec3;
                         break;
                     case WebGLContext.FLOAT_VEC4:
                         one.fun = one.isArray ? this._uniform_vec4v : this._uniform_vec4;
                         break;
                     case WebGLContext.SAMPLER_2D:
                         one.fun = this._uniform_sampler2D;
                         break;
                     case WebGLContext.SAMPLER_CUBE:
                         one.fun = this._uniform_samplerCube;
                         break;
                     case WebGLContext.FLOAT_MAT4:
                         one.glfun = gl.uniformMatrix4fv;
                         one.fun = this._uniformMatrix4fv;
                         break;
                     case WebGLContext.BOOL:
                         one.fun = this._uniform1i;
                         break;
                     case WebGLContext.FLOAT_MAT2:
                     case WebGLContext.FLOAT_MAT3:
                         //TODO 这个有人会用的。
                         throw new Error("compile shader err!");
                     default:
                         throw new Error("compile shader err!");
                 }
             }
         }
         static _createShader(gl, str, type) {
             var shader = gl.createShader(type);
             gl.shaderSource(shader, str);
             gl.compileShader(shader);
             if (gl.getShaderParameter(shader, WebGLContext.COMPILE_STATUS)) {
                 return shader;
             }
             else {
                 console.log(gl.getShaderInfoLog(shader));
                 return null;
             }
         }
         /**
          * 根据变量名字获得
          * @param	name
          * @return
          */
         //TODO:coverage
         getUniform(name) {
             return this._paramsMap[name];
         }
         //TODO:coverage
         _uniform1f(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value) {
                 WebGLContext.mainContext.uniform1f(one.location, uploadedValue[0] = value);
                 return 1;
             }
             return 0;
         }
         //TODO:coverage
         _uniform1fv(one, value) {
             if (value.length < 4) {
                 var uploadedValue = one.uploadedValue;
                 if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                     WebGLContext.mainContext.uniform1fv(one.location, value);
                     uploadedValue[0] = value[0];
                     uploadedValue[1] = value[1];
                     uploadedValue[2] = value[2];
                     uploadedValue[3] = value[3];
                     return 1;
                 }
                 return 0;
             }
             else {
                 WebGLContext.mainContext.uniform1fv(one.location, value);
                 return 1;
             }
         }
         _uniform_vec2(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1]) {
                 WebGLContext.mainContext.uniform2f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
                 return 1;
             }
             return 0;
         }
         //TODO:coverage
         _uniform_vec2v(one, value) {
             if (value.length < 2) {
                 var uploadedValue = one.uploadedValue;
                 if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                     WebGLContext.mainContext.uniform2fv(one.location, value);
                     uploadedValue[0] = value[0];
                     uploadedValue[1] = value[1];
                     uploadedValue[2] = value[2];
                     uploadedValue[3] = value[3];
                     return 1;
                 }
                 return 0;
             }
             else {
                 WebGLContext.mainContext.uniform2fv(one.location, value);
                 return 1;
             }
         }
         //TODO:coverage
         _uniform_vec3(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
                 WebGLContext.mainContext.uniform3f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
                 return 1;
             }
             return 0;
         }
         //TODO:coverage
         _uniform_vec3v(one, value) {
             WebGLContext.mainContext.uniform3fv(one.location, value);
             return 1;
         }
         _uniform_vec4(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                 WebGLContext.mainContext.uniform4f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
                 return 1;
             }
             return 0;
         }
         //TODO:coverage
         _uniform_vec4v(one, value) {
             WebGLContext.mainContext.uniform4fv(one.location, value);
             return 1;
         }
         //TODO:coverage
         _uniformMatrix2fv(one, value) {
             WebGLContext.mainContext.uniformMatrix2fv(one.location, false, value);
             return 1;
         }
         //TODO:coverage
         _uniformMatrix3fv(one, value) {
             WebGLContext.mainContext.uniformMatrix3fv(one.location, false, value);
             return 1;
         }
         _uniformMatrix4fv(one, value) {
             WebGLContext.mainContext.uniformMatrix4fv(one.location, false, value);
             return 1;
         }
         //TODO:coverage
         _uniform1i(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value) {
                 WebGLContext.mainContext.uniform1i(one.location, uploadedValue[0] = value);
                 return 1;
             }
             return 0;
         }
         //TODO:coverage
         _uniform1iv(one, value) {
             WebGLContext.mainContext.uniform1iv(one.location, value);
             return 1;
         }
         //TODO:coverage
         _uniform_ivec2(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1]) {
                 WebGLContext.mainContext.uniform2i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
                 return 1;
             }
             return 0;
         }
         //TODO:coverage
         _uniform_ivec2v(one, value) {
             WebGLContext.mainContext.uniform2iv(one.location, value);
             return 1;
         }
         //TODO:coverage
         _uniform_vec3i(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
                 WebGLContext.mainContext.uniform3i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
                 return 1;
             }
             return 0;
         }
         _uniform_vec3vi(one, value) {
             WebGLContext.mainContext.uniform3iv(one.location, value);
             return 1;
         }
         //TODO:coverage
         _uniform_vec4i(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                 WebGLContext.mainContext.uniform4i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
                 return 1;
             }
             return 0;
         }
         //TODO:coverage
         _uniform_vec4vi(one, value) {
             WebGLContext.mainContext.uniform4iv(one.location, value);
             return 1;
         }
         _uniform_sampler2D(one, value) {
             var gl = WebGLContext.mainContext;
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] == null) {
                 uploadedValue[0] = this._curActTexIndex;
                 gl.uniform1i(one.location, this._curActTexIndex);
                 WebGLContext.activeTexture(gl, WebGLContext.TEXTURE0 + this._curActTexIndex);
                 WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_2D, value);
                 this._curActTexIndex++;
                 return 1;
             }
             else {
                 WebGLContext.activeTexture(gl, WebGLContext.TEXTURE0 + uploadedValue[0]);
                 WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_2D, value);
                 return 0;
             }
         }
         //TODO:coverage
         _uniform_samplerCube(one, value) {
             var gl = WebGLContext.mainContext;
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] == null) {
                 uploadedValue[0] = this._curActTexIndex;
                 gl.uniform1i(one.location, this._curActTexIndex);
                 WebGLContext.activeTexture(gl, WebGLContext.TEXTURE0 + this._curActTexIndex);
                 WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_CUBE_MAP, value);
                 this._curActTexIndex++;
                 return 1;
             }
             else {
                 WebGLContext.activeTexture(gl, WebGLContext.TEXTURE0 + uploadedValue[0]);
                 WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_CUBE_MAP, value);
                 return 0;
             }
         }
         //TODO:coverage
         _noSetValue(one) {
             console.log("no....:" + one.name);
             //throw new Error("upload shader err,must set value:"+one.name);
         }
         //TODO:coverage
         uploadOne(name, value) {
             //activeResource();
             WebGLContext.useProgram(WebGLContext.mainContext, this._program);
             var one = this._paramsMap[name];
             one.fun.call(this, one, value);
         }
         uploadTexture2D(value) {
             //这个可能执行频率非常高，所以这里能省就省点
             //Stat.shaderCall++;
             //var gl:WebGLContext = WebGLContext.mainContext;
             //WebGLContext.activeTexture(gl,WebGLContext.TEXTURE0);	2d必须是active0
             var CTX = WebGLContext;
             if (CTX._activeTextures[0] !== value) {
                 CTX.bindTexture(WebGLContext.mainContext, CTX.TEXTURE_2D, value);
                 CTX._activeTextures[0] = value;
             }
         }
         /**
          * 提交shader到GPU
          * @param	shaderValue
          */
         upload(shaderValue, params = null) {
             BaseShader.activeShader = BaseShader.bindShader = this;
             //recreateResource();
             var gl = WebGLContext.mainContext;
             WebGLContext.useProgram(gl, this._program);
             if (this._reCompile) {
                 params = this._params;
                 this._reCompile = false;
             }
             else {
                 params = params || this._params;
             }
             var one, value, n = params.length, shaderCall = 0;
             for (var i = 0; i < n; i++) {
                 one = params[i];
                 if ((value = shaderValue[one.name]) !== null)
                     shaderCall += one.fun.call(this, one, value);
                 /*
                 one.glfun?
                     one.glfun.call(gl, one.location, false, value):
                     one.fun.call(this, one, value);*/
             }
             Stat.shaderCall += shaderCall;
         }
         /**
          * 按数组的定义提交
          * @param	shaderValue 数组格式[name,value,...]
          */
         //TODO:coverage
         uploadArray(shaderValue, length, _bufferUsage) {
             BaseShader.activeShader = this;
             BaseShader.bindShader = this;
             //activeResource();
             WebGLContext.useProgram(WebGLContext.mainContext, this._program);
             var params = this._params, value;
             var one, shaderCall = 0;
             for (var i = length - 2; i >= 0; i -= 2) {
                 one = this._paramsMap[shaderValue[i]];
                 if (!one)
                     continue;
                 value = shaderValue[i + 1];
                 if (value != null) {
                     _bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind();
                     shaderCall += one.fun.call(this, one, value);
                 }
             }
             Stat.shaderCall += shaderCall;
         }
         /**
          * 得到编译后的变量及相关预定义
          * @return
          */
         //TODO:coverage
         getParams() {
             return this._params;
         }
         /**
          * 设置shader里面的attribute绑定到哪个location，必须与mesh2d的对应起来，
          * 这个必须在编译之前设置。
          * @param attribDesc 属性描述，格式是 [attributeName, location, attributeName, location ... ]
          */
         //TODO:coverage
         setAttributesLocation(attribDesc) {
             this._attribInfo = attribDesc;
         }
     }
     //private static var _TEXTURES:Array =  [WebGLContext.TEXTURE0, WebGLContext.TEXTURE1, WebGLContext.TEXTURE2, WebGLContext.TEXTURE3, WebGLContext.TEXTURE4, WebGLContext.TEXTURE5, WebGLContext.TEXTURE6,, WebGLContext.TEXTURE7, WebGLContext.TEXTURE8];
     Shader._count = 0;
     Shader._preCompileShader = {}; //存储预编译结果，可以通过名字获得内容,目前不支持#ifdef嵌套和条件
     Shader.SHADERNAME2ID = 0.0002;
     Shader.nameKey = new StringKey();
     Shader.sharders = new Array(0x20); // (sharders = [], sharders.length = 0x20, sharders);

     class Shader2X extends Shader {
         constructor(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
             super(vs, ps, saveName, nameMap, bindAttrib);
             this._params2dQuick2 = null;
             this._shaderValueWidth = 0;
             this._shaderValueHeight = 0;
         }
         //TODO:coverage
         /*override*/ _disposeResource() {
             super._disposeResource();
             this._params2dQuick2 = null;
         }
         //TODO:coverage
         upload2dQuick2(shaderValue) {
             this.upload(shaderValue, this._params2dQuick2 || this._make2dQuick2());
         }
         //去掉size的所有的uniform
         _make2dQuick2() {
             if (!this._params2dQuick2) {
                 this._params2dQuick2 = [];
                 var params = this._params, one;
                 for (var i = 0, n = params.length; i < n; i++) {
                     one = params[i];
                     if (one.name !== "size")
                         this._params2dQuick2.push(one);
                 }
             }
             return this._params2dQuick2;
         }
         static create(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
             return new Shader2X(vs, ps, saveName, nameMap, bindAttrib);
         }
     }

     class Value2D {
         //public var clipDir:Array = [Context._MAXSIZE, 0, 0, Context._MAXSIZE];		//裁剪信息
         //public var clipRect:Array = [0, 0];						//裁剪位置
         constructor(mainID, subID) {
             this.defines = new ShaderDefines2D();
             this.size = [0, 0];
             this.alpha = 1.0; //这个目前只给setIBVB用。其他的都放到attribute的color中了
             this.ALPHA = 1.0; //这个？
             this.subID = 0;
             this.ref = 1;
             this._cacheID = 0;
             this.clipMatDir = [ILaya.Context._MAXSIZE, 0, 0, ILaya.Context._MAXSIZE];
             this.clipMatPos = [0, 0];
             this.clipOff = [0, 0]; // 裁剪是否需要加上偏移，cacheas normal用
             this.mainID = mainID;
             this.subID = subID;
             this.textureHost = null;
             this.texture = null;
             //this.fillStyle = null;
             this.color = null;
             //this.strokeStyle = null;
             this.colorAdd = null;
             this.u_mmat2 = null;
             this._cacheID = mainID | subID;
             this._inClassCache = Value2D._cache[this._cacheID];
             if (mainID > 0 && !this._inClassCache) {
                 this._inClassCache = Value2D._cache[this._cacheID] = [];
                 this._inClassCache._length = 0;
             }
             this.clear();
         }
         static _initone(type, classT) {
             Value2D._typeClass[type] = classT;
             Value2D._cache[type] = [];
             Value2D._cache[type]._length = 0;
         }
         static __init__() {
         }
         setValue(value) { }
         //throw new Error("todo in subclass");
         //不知道什么意思，这个名字太难懂，反正只有submitIBVB中用到。直接把代码拷贝到哪里
         //public function refresh():ShaderValue
         _ShaderWithCompile() {
             var ret = Shader.withCompile2D(0, this.mainID, this.defines.toNameDic(), this.mainID | this.defines._value, Shader2X.create, this._attribLocation);
             //ret.setAttributesLocation(_attribLocation); 由于上面函数的流程的修改，导致这里已经晚了
             return ret;
         }
         upload() {
             var renderstate2d = RenderState2D;
             // 如果有矩阵的话，就设置 WORLDMAT 宏
             RenderState2D.worldMatrix4 === RenderState2D.TEMPMAT4_ARRAY || this.defines.addInt(ShaderDefines2D.WORLDMAT);
             this.mmat = renderstate2d.worldMatrix4;
             if (RenderState2D.matWVP) {
                 this.defines.addInt(ShaderDefines2D.MVP3D);
                 this.u_MvpMatrix = RenderState2D.matWVP.elements;
             }
             var sd = Shader.sharders[this.mainID | this.defines._value] || this._ShaderWithCompile();
             if (sd._shaderValueWidth !== renderstate2d.width || sd._shaderValueHeight !== renderstate2d.height) {
                 this.size[0] = renderstate2d.width;
                 this.size[1] = renderstate2d.height;
                 sd._shaderValueWidth = renderstate2d.width;
                 sd._shaderValueHeight = renderstate2d.height;
                 sd.upload(this, null);
             }
             else {
                 sd.upload(this, sd._params2dQuick2 || sd._make2dQuick2());
             }
         }
         //TODO:coverage
         setFilters(value) {
             this.filters = value;
             if (!value)
                 return;
             var n = value.length, f;
             for (var i = 0; i < n; i++) {
                 f = value[i];
                 if (f) {
                     this.defines.add(f.type); //搬到setValue中
                     f.action.setValue(this);
                 }
             }
         }
         clear() {
             this.defines._value = this.subID + (ILaya.WebGL.shaderHighPrecision ? ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION : 0);
             this.clipOff[0] = 0;
         }
         release() {
             if ((--this.ref) < 1) {
                 this._inClassCache && (this._inClassCache[this._inClassCache._length++] = this);
                 //this.fillStyle = null;
                 //this.strokeStyle = null;
                 this.clear();
                 this.filters = null;
                 this.ref = 1;
                 this.clipOff[0] = 0;
             }
         }
         static create(mainType, subType) {
             var types = Value2D._cache[mainType | subType];
             if (types._length)
                 return types[--types._length];
             else
                 return new Value2D._typeClass[mainType | subType](subType);
         }
     }
     Value2D._cache = [];
     Value2D._typeClass = [];
     Value2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

     /**
          * ...
          * @author xie
          */
     class SubmitKey {
         constructor() {
             this.clear();
         }
         clear() {
             this.submitType = -1;
             this.blendShader = this.other = 0;
             //alpha = 1;
         }
         //TODO:coverage
         copyFrom(src) {
             this.other = src.other;
             this.blendShader = src.blendShader;
             this.submitType = src.submitType;
             //alpha = src.alpha;
         }
         copyFrom2(src, submitType, other) {
             //this.blendShader = src.blendShader;
             //this.alpha = src.alpha;			
             this.other = other;
             this.submitType = submitType;
         }
         //�Ƚ�3�����ⲿ�ṩ2��
         //TODO:coverage
         equal3_2(next, submitType, other) {
             return this.submitType === submitType && this.other === other && this.blendShader === next.blendShader; // && this.alpha === alpha;
         }
         //ȫ�Ƚϡ��ⲿ�ṩ2��
         //TODO:coverage
         equal4_2(next, submitType, other) {
             return this.submitType === submitType && this.other === other && this.blendShader === next.blendShader; // && alpha === next.alpha;
         }
         //�Ƚ�3��
         //TODO:coverage
         equal_3(next) {
             return this.submitType === next.submitType && this.blendShader === next.blendShader; // && alpha === next.alpha;
         }
         //ȫ�Ƚϡ�4��
         //TODO:coverage
         equal(next) {
             return this.other === next.other && this.submitType === next.submitType && this.blendShader === next.blendShader; // && alpha === next.alpha;
         }
     }

     class SubmitCMD {
         constructor() {
             this._ref = 1;
             this._key = new SubmitKey();
         }
         renderSubmit() {
             this.fun.apply(this._this, this.args);
             return 1;
         }
         getRenderType() {
             return 0;
         }
         releaseRender() {
             if ((--this._ref) < 1) {
                 var pool = SubmitCMD.POOL;
                 pool[pool._length++] = this;
             }
         }
         static create(args, fun, thisobj) {
             var o = SubmitCMD.POOL._length ? SubmitCMD.POOL[--SubmitCMD.POOL._length] : new SubmitCMD();
             o.fun = fun;
             o.args = args;
             o._this = thisobj;
             o._ref = 1;
             o._key.clear();
             return o;
         }
     }
     SubmitCMD.POOL = [];
     {
         SubmitCMD.POOL._length = 0;
     }

     /**
      * <code>Filter</code> 是滤镜基类。
      */
     class Filter {
         /**
          * 创建一个 <code>Filter</code> 实例。
          * */
         constructor() { }
         /**@private 滤镜类型。*/
         get type() { return -1; }
     }
     /**@private 模糊滤镜。*/
     Filter.BLUR = 0x10;
     /**@private 颜色滤镜。*/
     Filter.COLOR = 0x20;
     /**@private 发光滤镜。*/
     Filter.GLOW = 0x08;
     Filter._filter = function (sprite, context, x, y) {
         var webglctx = context;
         var next = this._next;
         if (next) {
             var filters = sprite.filters, len = filters.length;
             //如果只有一个滤镜，那么还用原来的方式
             if (len == 1 && (filters[0].type == Filter.COLOR)) {
                 context.save();
                 context.setColorFilter(filters[0]);
                 next._fun.call(next, sprite, context, x, y);
                 context.restore();
                 return;
             }
             //思路：依次遍历滤镜，每次滤镜都画到out的RenderTarget上，然后把out画取src的RenderTarget做原图，去叠加新的滤镜
             var svCP = Value2D.create(ShaderDefines2D.TEXTURE2D, 0); //拷贝用shaderValue
             var b;
             var p = Point.TEMP;
             var tMatrix = webglctx._curMat;
             var mat = Matrix.create();
             tMatrix.copyTo(mat);
             var tPadding = 0; //给glow用
             var tHalfPadding = 0;
             var tIsHaveGlowFilter = false;
             //这里判断是否存储了out，如果存储了直接用;
             var source = null;
             var out = sprite._cacheStyle.filterCache || null;
             if (!out || sprite.getRepaint() != 0) {
                 tIsHaveGlowFilter = sprite._isHaveGlowFilter();
                 //glow需要扩展边缘
                 if (tIsHaveGlowFilter) {
                     tPadding = 50;
                     tHalfPadding = 25;
                 }
                 b = new Rectangle();
                 b.copyFrom(sprite.getSelfBounds());
                 b.x += sprite.x;
                 b.y += sprite.y;
                 b.x -= sprite.pivotX + 4; //blur 
                 b.y -= sprite.pivotY + 4; //blur
                 var tSX = b.x;
                 var tSY = b.y;
                 //重新计算宽和高
                 b.width += (tPadding + 8); //增加宽度 blur  由于blur系数为9
                 b.height += (tPadding + 8); //增加高度 blur
                 p.x = b.x * mat.a + b.y * mat.c;
                 p.y = b.y * mat.d + b.x * mat.b;
                 b.x = p.x;
                 b.y = p.y;
                 p.x = b.width * mat.a + b.height * mat.c;
                 p.y = b.height * mat.d + b.width * mat.b;
                 b.width = p.x;
                 b.height = p.y;
                 if (b.width <= 0 || b.height <= 0) {
                     return;
                 }
                 out && WebGLRTMgr.releaseRT(out); // out.recycle();
                 source = WebGLRTMgr.getRT(b.width, b.height);
                 var outRT = out = WebGLRTMgr.getRT(b.width, b.height);
                 sprite._getCacheStyle().filterCache = out;
                 //使用RT
                 webglctx.pushRT();
                 webglctx.useRT(source);
                 var tX = sprite.x - tSX + tHalfPadding;
                 var tY = sprite.y - tSY + tHalfPadding;
                 //执行节点的渲染
                 next._fun.call(next, sprite, context, tX, tY);
                 webglctx.useRT(outRT);
                 for (var i = 0; i < len; i++) {
                     if (i != 0) {
                         //把out往src上画。这只是一个拷贝的过程，下面draw(src) to outRT 才是真正的应用filter
                         //由于是延迟执行，不能直接在这里swap。 TODO 改成延迟swap
                         webglctx.useRT(source);
                         webglctx.drawTarget(outRT, 0, 0, b.width, b.height, Matrix.TEMP.identity(), svCP, null, BlendMode.TOINT.overlay);
                         webglctx.useRT(outRT);
                     }
                     var fil = filters[i];
                     //把src往out上画
                     switch (fil.type) {
                         case Filter.BLUR:
                             fil._glRender && fil._glRender.render(source, context, b.width, b.height, fil);
                             //BlurFilterGLRender.render(source, context, b.width, b.height, fil as BlurFilter);
                             break;
                         case Filter.GLOW:
                             //GlowFilterGLRender.render(source, context, b.width, b.height, fil as GlowFilter);
                             fil._glRender && fil._glRender.render(source, context, b.width, b.height, fil);
                             break;
                         case Filter.COLOR:
                             webglctx.setColorFilter(fil);
                             webglctx.drawTarget(source, 0, 0, b.width, b.height, Matrix.EMPTY.identity(), Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                             webglctx.setColorFilter(null);
                             break;
                     }
                 }
                 webglctx.popRT();
             }
             else {
                 tIsHaveGlowFilter = sprite._cacheStyle.hasGlowFilter || false;
                 if (tIsHaveGlowFilter) {
                     tPadding = 50;
                     tHalfPadding = 25;
                 }
                 b = sprite.getBounds();
                 if (b.width <= 0 || b.height <= 0) {
                     return;
                 }
                 b.width += tPadding;
                 b.height += tPadding;
                 p.x = b.x * mat.a + b.y * mat.c;
                 p.y = b.y * mat.d + b.x * mat.b;
                 b.x = p.x;
                 b.y = p.y;
                 p.x = b.width * mat.a + b.height * mat.c;
                 p.y = b.height * mat.d + b.width * mat.b;
                 b.width = p.x;
                 b.height = p.y;
                 //scope.addValue("out", out);
             }
             x = x - tHalfPadding - sprite.x;
             y = y - tHalfPadding - sprite.y;
             p.setTo(x, y);
             mat.transformPoint(p);
             x = p.x + b.x;
             y = p.y + b.y;
             //把最后的out纹理画出来
             webglctx._drawRenderTexture(out, x, y, b.width, b.height, Matrix.TEMP.identity(), 1.0, RenderTexture2D.defuv);
             //把对象放回池子中
             //var submit:SubmitCMD = SubmitCMD.create([scope], Filter._recycleScope, this);
             if (source) {
                 var submit = SubmitCMD.create([source], function (s) {
                     s.destroy();
                 }, this);
                 source = null;
                 context.addRenderObject(submit);
             }
             mat.destroy();
         }
     };

     /**
      * <code>Utils</code> 是工具类。
      */
     class Utils {
         /**
          * 角度转弧度。
          * @param	angle 角度值。
          * @return	返回弧度值。
          */
         static toRadian(angle) {
             return angle * Utils._pi2;
         }
         /**
          * 弧度转换为角度。
          * @param	radian 弧度值。
          * @return	返回角度值。
          */
         static toAngle(radian) {
             return radian * Utils._pi;
         }
         /**
          * 将传入的 uint 类型颜色值转换为字符串型颜色值。
          * @param color 颜色值。
          * @return 字符串型颜色值。
          */
         static toHexColor(color) {
             if (color < 0 || isNaN(color))
                 return null;
             var str = color.toString(16);
             while (str.length < 6)
                 str = "0" + str;
             return "#" + str;
         }
         /**获取一个全局唯一ID。*/
         static getGID() {
             return Utils._gid++;
         }
         /**
          * @private
          * <p>连接数组。和array的concat相比，此方法不创建新对象</p>
          * <b>注意：</b>若 参数 a 不为空，则会改变参数 source 的值为连接后的数组。
          * @param	source 待连接的数组目标对象。
          * @param	array 待连接的数组对象。
          * @return 连接后的数组。
          */
         static concatArray(source, array) {
             if (!array)
                 return source;
             if (!source)
                 return array;
             var i, len = array.length;
             for (i = 0; i < len; i++) {
                 source.push(array[i]);
             }
             return source;
         }
         /**
          * @private
          * 清空数组对象。
          * @param	array 数组。
          * @return	清空后的 array 对象。
          */
         static clearArray(array) {
             if (!array)
                 return array;
             array.length = 0;
             return array;
         }
         /**
          * @private
          * 清空source数组，复制array数组的值。
          * @param	source 需要赋值的数组。
          * @param	array 新的数组值。
          * @return 	复制后的数据 source 。
          */
         static copyArray(source, array) {
             source || (source = []);
             if (!array)
                 return source;
             source.length = array.length;
             var i, len = array.length;
             for (i = 0; i < len; i++) {
                 source[i] = array[i];
             }
             return source;
         }
         /**
          * @private
          * 根据传入的显示对象 <code>Sprite</code> 和此显示对象上的 两个点，返回此对象上的两个点在舞台坐标系上组成的最小的矩形区域对象。
          * @param	sprite 显示对象 <code>Sprite</code>。
          * @param	x0	点一的 X 轴坐标点。
          * @param	y0	点一的 Y 轴坐标点。
          * @param	x1	点二的 X 轴坐标点。
          * @param	y1	点二的 Y 轴坐标点。
          * @return 两个点在舞台坐标系组成的矩形对象 <code>Rectangle</code>。
          */
         static getGlobalRecByPoints(sprite, x0, y0, x1, y1) {
             var newLTPoint;
             newLTPoint = Point.create().setTo(x0, y0);
             newLTPoint = sprite.localToGlobal(newLTPoint);
             var newRBPoint;
             newRBPoint = Point.create().setTo(x1, y1);
             newRBPoint = sprite.localToGlobal(newRBPoint);
             var rst = Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y]);
             newLTPoint.recover();
             newRBPoint.recover();
             return rst;
         }
         /**
          * 计算传入的显示对象 <code>Sprite</code> 的全局坐标系的坐标和缩放值，返回 <code>Rectangle</code> 对象存放计算出的坐标X值、Y值、ScaleX值、ScaleY值。
          * @param	sprite <code>Sprite</code> 对象。
          * @return  矩形对象 <code>Rectangle</code>
          */
         static getGlobalPosAndScale(sprite) {
             return Utils.getGlobalRecByPoints(sprite, 0, 0, 1, 1);
         }
         /**
          * 给传入的函数绑定作用域，返回绑定后的函数。
          * @param	fun 函数对象。
          * @param	scope 函数作用域。
          * @return 绑定后的函数。
          */
         static bind(fun, scope) {
             var rst = fun;
             rst = fun.bind(scope);
             return rst;
         }
         /**
          * @private
          * 对传入的数组列表，根据子项的属性 Z 值进行重新排序。返回是否已重新排序的 Boolean 值。
          * @param	array 子对象数组。
          * @return	Boolean 值，表示是否已重新排序。
          */
         static updateOrder(array) {
             if (!array || array.length < 2)
                 return false;
             var i = 1, j, len = array.length, key, c;
             while (i < len) {
                 j = i;
                 c = array[j];
                 key = array[j]._zOrder;
                 while (--j > -1) {
                     if (array[j]._zOrder > key)
                         array[j + 1] = array[j];
                     else
                         break;
                 }
                 array[j + 1] = c;
                 i++;
             }
             return true;
         }
         /**
          * @private
          * 批量移动点坐标。
          * @param points 坐标列表。
          * @param x x轴偏移量。
          * @param y y轴偏移量。
          */
         static transPointList(points, x, y) {
             var i, len = points.length;
             for (i = 0; i < len; i += 2) {
                 points[i] += x;
                 points[i + 1] += y;
             }
         }
         /**
          * 解析一个字符串，并返回一个整数。和JS原生的parseInt不同：如果str为空或者非数字，原生返回NaN，这里返回0。
          * @param	str		要被解析的字符串。
          * @param	radix	表示要解析的数字的基数。默认值为0，表示10进制，其他值介于 2 ~ 36 之间。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数不在上述范围内，则此方法返回 0。
          * @return	返回解析后的数字。
          */
         static parseInt(str, radix = 0) {
             var result = parseInt(str, radix);
             if (isNaN(result))
                 return 0;
             return result;
         }
         /**@private */
         static getFileExtension(path) {
             Utils._extReg.lastIndex = path.lastIndexOf(".");
             var result = Utils._extReg.exec(path);
             if (result && result.length > 1) {
                 return result[1].toLowerCase();
             }
             return null;
         }
         /**
          * 获取指定区域内相对于窗口左上角的transform。
          * @param	coordinateSpace	坐标空间，不能是Stage引用
          * @param	x				相对于coordinateSpace的x坐标
          * @param	y				相对于coordinateSpace的y坐标
          * @return
          */
         static getTransformRelativeToWindow(coordinateSpace, x, y) {
             var stage = Utils.gStage;
             // coordinateSpace的全局缩放、坐标
             var globalTransform = Utils.getGlobalPosAndScale(coordinateSpace);
             // canvas的transform矩阵
             var canvasMatrix = stage._canvasTransform.clone();
             // 在矩阵变化前前记录的canvas的坐标
             var canvasLeft = canvasMatrix.tx;
             var canvasTop = canvasMatrix.ty;
             // 把矩阵转回0度，得到正确的画布缩放比
             canvasMatrix.rotate(-Math.PI / 180 * stage.canvasDegree);
             // 组合画布缩放和舞台适配缩放
             canvasMatrix.scale(stage.clientScaleX, stage.clientScaleY);
             // 画布是否处于正常角度的垂直角度，-90或90度
             var perpendicular = (stage.canvasDegree % 180 != 0);
             var tx, ty;
             if (perpendicular) {
                 // 在舞台上的坐标
                 tx = y + globalTransform.y;
                 ty = x + globalTransform.x;
                 // 在画布上的坐标
                 tx *= canvasMatrix.d;
                 ty *= canvasMatrix.a;
                 // 设置了screenMode = horizontal
                 if (stage.canvasDegree == 90) {
                     // 在浏览器窗口上的坐标
                     // 此时画布的left是视觉上的right，画布的left是视觉上的top
                     tx = canvasLeft - tx;
                     ty += canvasTop;
                 }
                 // screenMode = vertical并且设备在横屏状态，画布旋转-90度
                 else {
                     // 在浏览器窗口上的坐标
                     // 此时画布的left是视觉上的left，画布的top是视觉上的bottom
                     tx += canvasLeft;
                     ty = canvasTop - ty;
                 }
             }
             // 没有canvas旋转
             else {
                 // 在舞台上的坐标
                 tx = x + globalTransform.x;
                 ty = y + globalTransform.y;
                 // 在画布上的坐标
                 tx *= canvasMatrix.a;
                 ty *= canvasMatrix.d;
                 // 在浏览器窗口上的坐标
                 tx += canvasLeft;
                 ty += canvasTop;
             }
             // Safari兼容
             ty += stage['_safariOffsetY'];
             // 组合画布缩放和舞台适配缩放以及显示对象缩放，得到DOM原因的缩放因子
             var domScaleX, domScaleY;
             if (perpendicular) {
                 domScaleX = canvasMatrix.d * globalTransform.height;
                 domScaleY = canvasMatrix.a * globalTransform.width;
             }
             else {
                 domScaleX = canvasMatrix.a * globalTransform.width;
                 domScaleY = canvasMatrix.d * globalTransform.height;
             }
             return { x: tx, y: ty, scaleX: domScaleX, scaleY: domScaleY };
         }
         /**
          * 使DOM元素使用舞台内的某块区域内。
          * @param	dom				DOM元素引用
          * @param	coordinateSpace	坐标空间，不能是Stage引用
          * @param	x				相对于coordinateSpace的x坐标
          * @param	y				相对于coordinateSpace的y坐标
          * @param	width			宽度
          * @param	height			高度
          */
         static fitDOMElementInArea(dom, coordinateSpace, x, y, width, height) {
             if (!dom._fitLayaAirInitialized) {
                 dom._fitLayaAirInitialized = true;
                 dom.style.transformOrigin = dom.style.webKittransformOrigin = "left top";
                 dom.style.position = "absolute";
             }
             var transform = Utils.getTransformRelativeToWindow(coordinateSpace, x, y);
             // 设置dom样式
             dom.style.transform = dom.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (Utils.gStage.canvasDegree) + "deg)";
             dom.style.width = width + 'px';
             dom.style.height = height + 'px';
             dom.style.left = transform.x + 'px';
             dom.style.top = transform.y + 'px';
         }
         /**
          * @private
          * 是否是可用的Texture数组
          * @param	textureList
          * @return
          */
         static isOkTextureList(textureList) {
             if (!textureList)
                 return false;
             var i, len = textureList.length;
             var tTexture;
             for (i = 0; i < len; i++) {
                 tTexture = textureList[i];
                 if (!tTexture || !tTexture._getSource())
                     return false;
             }
             return true;
         }
         /**
          * @private
          * 是否是可用的绘图指令数组
          * @param	cmds
          * @return
          */
         static isOKCmdList(cmds) {
             //todo 改成适应新版cmd版本
             if (!cmds)
                 return false;
             var i, len = cmds.length;
             //var context:RenderContext = Render._context;
             var cmd;
             for (i = 0; i < len; i++) {
                 cmd = cmds[i];
                 //switch(cmd.callee)
                 //{
                 //case context._drawTexture: 
                 //case context._fillTexture: 
                 //case context._drawTextureWithTransform: 
                 //tex = cmd[0];
                 //if (!tex || !tex.source) return false;
                 //
                 //}
             }
             return true;
         }
         /**
          * 获得URL参数值
          * @param	name 参数名称
          * @return	参数值
          */
         static getQueryString(name) {
             if (ILaya.Browser.onMiniGame)
                 return null;
             if (!window.location || !window.location.search)
                 return null;
             var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
             var r = window.location.search.substr(1).match(reg);
             if (r != null)
                 return unescape(r[2]);
             return null;
         }
     }
     /**@private */
     Utils.gStage = null;
     /**@private */
     Utils._gid = 1;
     /**@private */
     Utils._pi = 180 / Math.PI;
     /**@private */
     Utils._pi2 = Math.PI / 180;
     /**@private */
     Utils._extReg = /\.(\w+)\??/g;
     /**
      * 将字符串解析成 XML 对象。
      * @param value 需要解析的字符串。
      * @return js原生的XML对象。
      */
     Utils.parseXMLFromString = function (value) {
         var rst;
         value = value.replace(/>\s+</g, '><');
         rst = (new DOMParser()).parseFromString(value, 'text/xml');
         if (rst.firstChild.textContent.indexOf("This page contains the following errors") > -1) {
             throw new Error(rst.firstChild.firstChild.textContent);
         }
         return rst;
     };

     /**
      * @private
      * <code>ColorUtils</code> 是一个颜色值处理类。
      */
     class ColorUtils {
         /**
          * 根据指定的属性值，创建一个 <code>Color</code> 类的实例。
          * @param	value 颜色值，可以是字符串："#ff0000"或者16进制颜色 0xff0000。
          */
         constructor(value) {
             /**rgba 取值范围0-1*/
             //TODO:delete？
             this.arrColor = [];
             if (value == null) {
                 this.strColor = "#00000000";
                 this.numColor = 0;
                 this.arrColor = [0, 0, 0, 0];
                 return;
             }
             var i, len;
             var color;
             if (typeof (value) == 'string') {
                 if (value.indexOf("rgba(") >= 0 || value.indexOf("rgb(") >= 0) {
                     var tStr = value;
                     var beginI, endI;
                     beginI = tStr.indexOf("(");
                     endI = tStr.indexOf(")");
                     tStr = tStr.substring(beginI + 1, endI);
                     this.arrColor = tStr.split(",");
                     len = this.arrColor.length;
                     for (i = 0; i < len; i++) {
                         this.arrColor[i] = parseFloat(this.arrColor[i]);
                         if (i < 3) {
                             this.arrColor[i] = Math.round(this.arrColor[i]);
                         }
                     }
                     if (this.arrColor.length == 4) {
                         color = ((this.arrColor[0] * 256 + this.arrColor[1]) * 256 + this.arrColor[2]) * 256 + Math.round(this.arrColor[3] * 255);
                     }
                     else {
                         color = ((this.arrColor[0] * 256 + this.arrColor[1]) * 256 + this.arrColor[2]);
                     }
                     this.strColor = value;
                 }
                 else {
                     this.strColor = value;
                     value.charAt(0) === '#' && (value = value.substr(1));
                     len = value.length;
                     if (len === 3 || len === 4) {
                         var temp = "";
                         for (i = 0; i < len; i++) {
                             temp += (value[i] + value[i]);
                         }
                         value = temp;
                     }
                     color = parseInt(value, 16);
                 }
             }
             else {
                 color = value;
                 this.strColor = Utils.toHexColor(color);
             }
             if (this.strColor.indexOf("rgba") >= 0 || this.strColor.length === 9) {
                 //color:0xrrggbbaa numColor此时为负数
                 this.arrColor = [((0xFF000000 & color) >>> 24) / 255, ((0xFF0000 & color) >> 16) / 255, ((0xFF00 & color) >> 8) / 255, (0xFF & color) / 255];
                 this.numColor = (0xff000000 & color) >>> 24 | (color & 0xff0000) >> 8 | (color & 0x00ff00) << 8 | ((color & 0xff) << 24); //to 0xffbbggrr
             }
             else {
                 this.arrColor = [((0xFF0000 & color) >> 16) / 255, ((0xFF00 & color) >> 8) / 255, (0xFF & color) / 255, 1];
                 this.numColor = 0xff000000 | (color & 0xff0000) >> 16 | (color & 0x00ff00) | (color & 0xff) << 16; //to 0xffbbggrr
             }
             this.arrColor.__id = ++ColorUtils._COLODID;
         }
         /**@private */
         static _initDefault() {
             ColorUtils._DEFAULT = {};
             for (var i in ColorUtils._COLOR_MAP)
                 ColorUtils._SAVE[i] = ColorUtils._DEFAULT[i] = new ColorUtils(ColorUtils._COLOR_MAP[i]);
             return ColorUtils._DEFAULT;
         }
         /**@private 缓存太大，则清理缓存*/
         static _initSaveMap() {
             ColorUtils._SAVE_SIZE = 0;
             ColorUtils._SAVE = {};
             for (var i in ColorUtils._DEFAULT)
                 ColorUtils._SAVE[i] = ColorUtils._DEFAULT[i];
         }
         /**
          * 根据指定的属性值，创建并返回一个 <code>Color</code> 类的实例。
          * @param	value 颜色值，可以是字符串："#ff0000"或者16进制颜色 0xff0000。
          * @return 一个 <code>Color</code> 类的实例。
          */
         static create(value) {
             var key = value + "";
             var color = ColorUtils._SAVE[key];
             if (color != null)
                 return color;
             if (ColorUtils._SAVE_SIZE < 1000)
                 ColorUtils._initSaveMap();
             return ColorUtils._SAVE[key] = new ColorUtils(value);
         }
     }
     /*[FILEINDEX:10000]*/
     /**@private */
     ColorUtils._SAVE = {};
     /**@private */
     ColorUtils._SAVE_SIZE = 0;
     /**@private */
     ColorUtils._COLOR_MAP = { "purple": "#800080", "orange": "#ffa500", "white": '#FFFFFF', "red": '#FF0000', "green": '#00FF00', "blue": '#0000FF', "black": '#000000', "yellow": '#FFFF00', 'gray': '#808080' };
     /**@private */
     ColorUtils._DEFAULT = ColorUtils._initDefault();
     /**@private */
     ColorUtils._COLODID = 1;

     /**
      * <p><code>ColorFilter</code> 是颜色滤镜。使用 ColorFilter 类可以将 4 x 5 矩阵转换应用于输入图像上的每个像素的 RGBA 颜色和 Alpha 值，以生成具有一组新的 RGBA 颜色和 Alpha 值的结果。该类允许饱和度更改、色相旋转、亮度转 Alpha 以及各种其他效果。您可以将滤镜应用于任何显示对象（即，从 Sprite 类继承的对象）。</p>
      * <p>注意：对于 RGBA 值，最高有效字节代表红色通道值，其后的有效字节分别代表绿色、蓝色和 Alpha 通道值。</p>
      */
     class ColorFilter extends Filter {
         /**
          * 创建一个 <code>ColorFilter</code> 实例。
          * @param mat	（可选）由 20 个项目（排列成 4 x 5 矩阵）组成的数组，用于颜色转换。
          */
         constructor(mat = null) {
             super();
             if (!mat)
                 mat = this._copyMatrix(ColorFilter.IDENTITY_MATRIX);
             this._mat = new Float32Array(16);
             this._alpha = new Float32Array(4);
             this.setByMatrix(mat);
         }
         /**
          * 设置为灰色滤镜
          */
         gray() {
             return this.setByMatrix(ColorFilter.GRAY_MATRIX);
         }
         /**
          * 设置为变色滤镜
          * @param red 红色增量,范围:0~255
          * @param green 绿色增量,范围:0~255
          * @param blue 蓝色增量,范围:0~255
          * @param alpha alpha,范围:0~1
          */
         color(red = 0, green = 0, blue = 0, alpha = 1) {
             return this.setByMatrix([1, 0, 0, 0, red, 0, 1, 0, 0, green, 0, 0, 1, 0, blue, 0, 0, 0, 1, alpha]);
         }
         /**
          * 设置滤镜色
          * @param	color 颜色值
          */
         setColor(color) {
             var arr = ColorUtils.create(color).arrColor;
             var mt = [0, 0, 0, 0, 256 * arr[0], 0, 0, 0, 0, 256 * arr[1], 0, 0, 0, 0, 256 * arr[2], 0, 0, 0, 1, 0];
             return this.setByMatrix(mt);
         }
         /**
          * 设置矩阵数据
          * @param matrix 由 20 个项目（排列成 4 x 5 矩阵）组成的数组
          * @return this
          */
         setByMatrix(matrix) {
             if (this._matrix != matrix)
                 this._copyMatrix(matrix);
             var j = 0;
             var z = 0;
             for (var i = 0; i < 20; i++) {
                 if (i % 5 != 4) {
                     this._mat[j++] = matrix[i];
                 }
                 else {
                     this._alpha[z++] = matrix[i];
                 }
             }
             return this;
         }
         /**@private */
         /*override*/ get type() {
             return Filter.COLOR;
         }
         /**
          * 调整颜色，包括亮度，对比度，饱和度和色调
          * @param brightness 亮度,范围:-100~100
          * @param contrast 对比度,范围:-100~100
          * @param saturation 饱和度,范围:-100~100
          * @param hue 色调,范围:-180~180
          * @return this
          */
         adjustColor(brightness, contrast, saturation, hue) {
             this.adjustHue(hue);
             this.adjustContrast(contrast);
             this.adjustBrightness(brightness);
             this.adjustSaturation(saturation);
             return this;
         }
         /**
          * 调整亮度
          * @param brightness 亮度,范围:-100~100
          * @return this
          */
         adjustBrightness(brightness) {
             brightness = this._clampValue(brightness, 100);
             if (brightness == 0 || isNaN(brightness))
                 return this;
             return this._multiplyMatrix([1, 0, 0, 0, brightness, 0, 1, 0, 0, brightness, 0, 0, 1, 0, brightness, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
         }
         /**
          * 调整对比度
          * @param contrast 对比度,范围:-100~100
          * @return this
          */
         adjustContrast(contrast) {
             contrast = this._clampValue(contrast, 100);
             if (contrast == 0 || isNaN(contrast))
                 return this;
             var x;
             if (contrast < 0) {
                 x = 127 + contrast / 100 * 127;
             }
             else {
                 x = contrast % 1;
                 if (x == 0) {
                     x = ColorFilter.DELTA_INDEX[contrast];
                 }
                 else {
                     x = ColorFilter.DELTA_INDEX[(contrast << 0)] * (1 - x) + ColorFilter.DELTA_INDEX[(contrast << 0) + 1] * x;
                 }
                 x = x * 127 + 127;
             }
             var x1 = x / 127;
             var x2 = (127 - x) * 0.5;
             return this._multiplyMatrix([x1, 0, 0, 0, x2, 0, x1, 0, 0, x2, 0, 0, x1, 0, x2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
         }
         /**
          * 调整饱和度
          * @param saturation 饱和度,范围:-100~100
          * @return this
          */
         adjustSaturation(saturation) {
             saturation = this._clampValue(saturation, 100);
             if (saturation == 0 || isNaN(saturation))
                 return this;
             var x = 1 + ((saturation > 0) ? 3 * saturation / 100 : saturation / 100);
             var dx = 1 - x;
             var r = 0.3086 * dx;
             var g = 0.6094 * dx;
             var b = 0.0820 * dx;
             return this._multiplyMatrix([r + x, g, b, 0, 0, r, g + x, b, 0, 0, r, g, b + x, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
         }
         /**
          * 调整色调
          * @param hue 色调,范围:-180~180
          * @return this
          */
         adjustHue(hue) {
             hue = this._clampValue(hue, 180) / 180 * Math.PI;
             if (hue == 0 || isNaN(hue))
                 return this;
             var cos = Math.cos(hue);
             var sin = Math.sin(hue);
             var r = 0.213;
             var g = 0.715;
             var b = 0.072;
             return this._multiplyMatrix([r + cos * (1 - r) + sin * (-r), g + cos * (-g) + sin * (-g), b + cos * (-b) + sin * (1 - b), 0, 0, r + cos * (-r) + sin * (0.143), g + cos * (1 - g) + sin * (0.140), b + cos * (-b) + sin * (-0.283), 0, 0, r + cos * (-r) + sin * (-(1 - r)), g + cos * (-g) + sin * (g), b + cos * (1 - b) + sin * (b), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
         }
         /**
          * 重置成单位矩阵，去除滤镜效果
          */
         reset() {
             return this.setByMatrix(this._copyMatrix(ColorFilter.IDENTITY_MATRIX));
         }
         /**
          * 矩阵乘法
          * @param matrix
          * @return this
          */
         _multiplyMatrix(matrix) {
             var col = [];
             this._matrix = this._fixMatrix(this._matrix);
             for (var i = 0; i < 5; i++) {
                 for (var j = 0; j < 5; j++) {
                     col[j] = this._matrix[j + i * 5];
                 }
                 for (j = 0; j < 5; j++) {
                     var val = 0;
                     for (var k = 0; k < 5; k++) {
                         val += matrix[j + k * 5] * col[k];
                     }
                     this._matrix[j + i * 5] = val;
                 }
             }
             return this.setByMatrix(this._matrix);
         }
         /**
          * 规范值的范围
          * @param val 当前值
          * @param limit 值的范围-limit~limit
          */
         _clampValue(val, limit) {
             return Math.min(limit, Math.max(-limit, val));
         }
         /**
          * 规范矩阵,将矩阵调整到正确的大小
          * @param matrix 需要调整的矩阵
          */
         _fixMatrix(matrix = null) {
             if (matrix == null)
                 return ColorFilter.IDENTITY_MATRIX;
             if (matrix.length < ColorFilter.LENGTH)
                 matrix = matrix.slice(0, matrix.length).concat(ColorFilter.IDENTITY_MATRIX.slice(matrix.length, ColorFilter.LENGTH));
             else if (matrix.length > ColorFilter.LENGTH)
                 matrix = matrix.slice(0, ColorFilter.LENGTH);
             return matrix;
         }
         /**
          * 复制矩阵
          */
         _copyMatrix(matrix) {
             var len = ColorFilter.LENGTH;
             if (!this._matrix)
                 this._matrix = [];
             for (var i = 0; i < len; i++) {
                 this._matrix[i] = matrix[i];
             }
             return this._matrix;
         }
     }
     /**对比度列表*/
     ColorFilter.DELTA_INDEX = [0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.11, 0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24, 0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 0.5, 0.53, 0.56, 0.59, 0.62, 0.65, 0.68, 0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98, 1.0, 1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54, 1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0, 2.12, 2.25, 2.37, 2.50, 2.62, 2.75, 2.87, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0, 4.3, 4.7, 4.9, 5.0, 5.5, 6.0, 6.5, 6.8, 7.0, 7.3, 7.5, 7.8, 8.0, 8.4, 8.7, 9.0, 9.4, 9.6, 9.8, 10.0];
     /**灰色矩阵*/
     ColorFilter.GRAY_MATRIX = [0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0, 0, 0, 1, 0];
     /**单位矩阵,表示什么效果都没有*/
     ColorFilter.IDENTITY_MATRIX = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
     /**标准矩阵长度*/
     ColorFilter.LENGTH = 25;

     /**
      * 绘制单个贴图
      */
     class DrawTextureCmd {
         constructor() {
             this.colorFlt = null;
         }
         /**@private */
         static create(texture, x, y, width, height, matrix, alpha, color, blendMode) {
             var cmd = Pool.getItemByClass("DrawTextureCmd", DrawTextureCmd);
             cmd.texture = texture;
             texture._addReference();
             cmd.x = x;
             cmd.y = y;
             cmd.width = width;
             cmd.height = height;
             cmd.matrix = matrix;
             cmd.alpha = alpha;
             cmd.color = color;
             cmd.blendMode = blendMode;
             if (color) {
                 cmd.colorFlt = new ColorFilter();
                 cmd.colorFlt.setColor(color);
             }
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.texture._removeReference();
             this.texture = null;
             this.matrix = null;
             Pool.recover("DrawTextureCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.drawTextureWithTransform(this.texture, this.x, this.y, this.width, this.height, this.matrix, gx, gy, this.alpha, this.blendMode, this.colorFlt);
         }
         /**@private */
         get cmdID() {
             return DrawTextureCmd.ID;
         }
     }
     DrawTextureCmd.ID = "DrawTexture";

     /**
      * 填充贴图
      */
     class FillTextureCmd {
         /**@private */
         static create(texture, x, y, width, height, type, offset, other) {
             var cmd = Pool.getItemByClass("FillTextureCmd", FillTextureCmd);
             cmd.texture = texture;
             cmd.x = x;
             cmd.y = y;
             cmd.width = width;
             cmd.height = height;
             cmd.type = type;
             cmd.offset = offset;
             cmd.other = other;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.texture = null;
             this.offset = null;
             this.other = null;
             Pool.recover("FillTextureCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.fillTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height, this.type, this.offset, this.other);
         }
         /**@private */
         get cmdID() {
             return FillTextureCmd.ID;
         }
     }
     FillTextureCmd.ID = "FillTexture";

     /**
      * 恢复命令，和save配套使用
      */
     class RestoreCmd {
         /**@private */
         static create() {
             var cmd = Pool.getItemByClass("RestoreCmd", RestoreCmd);
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("RestoreCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.restore();
         }
         /**@private */
         get cmdID() {
             return RestoreCmd.ID;
         }
     }
     RestoreCmd.ID = "Restore";

     /**
      * 旋转命令
      */
     class RotateCmd {
         /**@private */
         static create(angle, pivotX, pivotY) {
             var cmd = Pool.getItemByClass("RotateCmd", RotateCmd);
             cmd.angle = angle;
             cmd.pivotX = pivotX;
             cmd.pivotY = pivotY;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("RotateCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context._rotate(this.angle, this.pivotX + gx, this.pivotY + gy);
         }
         /**@private */
         get cmdID() {
             return RotateCmd.ID;
         }
     }
     RotateCmd.ID = "Rotate";

     /**
      * 缩放命令
      */
     class ScaleCmd {
         /**@private */
         static create(scaleX, scaleY, pivotX, pivotY) {
             var cmd = Pool.getItemByClass("ScaleCmd", ScaleCmd);
             cmd.scaleX = scaleX;
             cmd.scaleY = scaleY;
             cmd.pivotX = pivotX;
             cmd.pivotY = pivotY;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("ScaleCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context._scale(this.scaleX, this.scaleY, this.pivotX + gx, this.pivotY + gy);
         }
         /**@private */
         get cmdID() {
             return ScaleCmd.ID;
         }
     }
     ScaleCmd.ID = "Scale";

     /**
      * 矩阵命令
      */
     class TransformCmd {
         /**@private */
         static create(matrix, pivotX, pivotY) {
             var cmd = Pool.getItemByClass("TransformCmd", TransformCmd);
             cmd.matrix = matrix;
             cmd.pivotX = pivotX;
             cmd.pivotY = pivotY;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.matrix = null;
             Pool.recover("TransformCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context._transform(this.matrix, this.pivotX + gx, this.pivotY + gy);
         }
         /**@private */
         get cmdID() {
             return TransformCmd.ID;
         }
     }
     TransformCmd.ID = "Transform";

     /**
      * 位移命令
      */
     class TranslateCmd {
         /**@private */
         static create(tx, ty) {
             var cmd = Pool.getItemByClass("TranslateCmd", TranslateCmd);
             cmd.tx = tx;
             cmd.ty = ty;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("TranslateCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.translate(this.tx, this.ty);
         }
         /**@private */
         get cmdID() {
             return TranslateCmd.ID;
         }
     }
     TranslateCmd.ID = "Translate";

     /**
          * @private
          * 计算贝塞尔曲线的工具类。
          */
     class Bezier {
         constructor() {
             /** @private */
             this._controlPoints = [new Point(), new Point(), new Point()];
             /** @private */
             this._calFun = this.getPoint2;
         }
         /** @private */
         _switchPoint(x, y) {
             var tPoint = this._controlPoints.shift();
             tPoint.setTo(x, y);
             this._controlPoints.push(tPoint);
         }
         /**
          * 计算二次贝塞尔点。
          */
         getPoint2(t, rst) {
             //二次贝塞尔曲线公式
             var p1 = this._controlPoints[0];
             var p2 = this._controlPoints[1];
             var p3 = this._controlPoints[2];
             var lineX = Math.pow((1 - t), 2) * p1.x + 2 * t * (1 - t) * p2.x + Math.pow(t, 2) * p3.x;
             var lineY = Math.pow((1 - t), 2) * p1.y + 2 * t * (1 - t) * p2.y + Math.pow(t, 2) * p3.y;
             rst.push(lineX, lineY);
         }
         /**
          * 计算三次贝塞尔点
          */
         getPoint3(t, rst) {
             //三次贝塞尔曲线公式
             var p1 = this._controlPoints[0];
             var p2 = this._controlPoints[1];
             var p3 = this._controlPoints[2];
             var p4 = this._controlPoints[3];
             var lineX = Math.pow((1 - t), 3) * p1.x + 3 * p2.x * t * (1 - t) * (1 - t) + 3 * p3.x * t * t * (1 - t) + p4.x * Math.pow(t, 3);
             var lineY = Math.pow((1 - t), 3) * p1.y + 3 * p2.y * t * (1 - t) * (1 - t) + 3 * p3.y * t * t * (1 - t) + p4.y * Math.pow(t, 3);
             rst.push(lineX, lineY);
         }
         /**
          * 计算贝塞尔点序列
          */
         insertPoints(count, rst) {
             var i;
             count = count > 0 ? count : 5;
             var dLen;
             dLen = 1 / count;
             for (i = 0; i <= 1; i += dLen) {
                 this._calFun(i, rst);
             }
         }
         /**
          * 获取贝塞尔曲线上的点。
          * @param pList 控制点[x0,y0,x1,y1...]
          * @param inSertCount 每次曲线的插值数量
          */
         getBezierPoints(pList, inSertCount = 5, count = 2) {
             var i, len;
             len = pList.length;
             if (len < (count + 1) * 2)
                 return [];
             var rst = [];
             switch (count) {
                 case 2:
                     this._calFun = this.getPoint2;
                     break;
                 case 3:
                     this._calFun = this.getPoint3;
                     break;
                 default:
                     return [];
             }
             while (this._controlPoints.length <= count) {
                 this._controlPoints.push(Point.create());
             }
             for (i = 0; i < count * 2; i += 2) {
                 this._switchPoint(pList[i], pList[i + 1]);
             }
             for (i = count * 2; i < len; i += 2) {
                 this._switchPoint(pList[i], pList[i + 1]);
                 if ((i / 2) % count == 0)
                     this.insertPoints(inSertCount, rst);
             }
             return rst;
         }
     }
     /**
      * 工具类单例
      */
     Bezier.I = new Bezier();

     /**
      * @private
      * 凸包算法。
      */
     class GrahamScan {
         static multiply(p1, p2, p0) {
             return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
         }
         /**
          * 计算两个点的距离。
          * @param	p1
          * @param	p2
          * @return
          */
         static dis(p1, p2) {
             return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
         }
         static _getPoints(count, tempUse = false, rst = null) {
             if (!GrahamScan._mPointList)
                 GrahamScan._mPointList = [];
             while (GrahamScan._mPointList.length < count)
                 GrahamScan._mPointList.push(new Point());
             if (!rst)
                 rst = [];
             rst.length = 0;
             if (tempUse) {
                 //				rst=_mPointList.slice(0,count);
                 GrahamScan.getFrom(rst, GrahamScan._mPointList, count);
             }
             else {
                 //				rst=_mPointList.splice(0,count);
                 GrahamScan.getFromR(rst, GrahamScan._mPointList, count);
             }
             return rst;
         }
         /**
          * 将数组 src 从索引0位置 依次取 cout 个项添加至 tst 数组的尾部。
          * @param	rst 原始数组，用于添加新的子元素。
          * @param	src 用于取子元素的数组。
          * @param	count 需要取得子元素个数。
          * @return 添加完子元素的 rst 对象。
          */
         static getFrom(rst, src, count) {
             var i;
             for (i = 0; i < count; i++) {
                 rst.push(src[i]);
             }
             return rst;
         }
         /**
          * 将数组 src 从末尾索引位置往头部索引位置方向 依次取 cout 个项添加至 tst 数组的尾部。
          * @param	rst 原始数组，用于添加新的子元素。
          * @param	src 用于取子元素的数组。
          * @param	count 需要取得子元素个数。
          * @return 添加完子元素的 rst 对象。
          */
         static getFromR(rst, src, count) {
             var i;
             for (i = 0; i < count; i++) {
                 rst.push(src.pop());
             }
             return rst;
         }
         /**
          *  [x,y...]列表 转 Point列表
          * @param pList Point列表
          * @return [x,y...]列表
          */
         static pListToPointList(pList, tempUse = false) {
             var i, len = pList.length / 2, rst = GrahamScan._getPoints(len, tempUse, GrahamScan._tempPointList);
             for (i = 0; i < len; i++) {
                 rst[i].setTo(pList[i + i], pList[i + i + 1]);
             }
             return rst;
         }
         /**
          * Point列表转[x,y...]列表
          * @param pointList Point列表
          * @return [x,y...]列表
          */
         static pointListToPlist(pointList) {
             var i, len = pointList.length, rst = GrahamScan._temPList, tPoint;
             rst.length = 0;
             for (i = 0; i < len; i++) {
                 tPoint = pointList[i];
                 rst.push(tPoint.x, tPoint.y);
             }
             return rst;
         }
         /**
          *  寻找包括所有点的最小多边形顶点集合
          * @param pList 形如[x0,y0,x1,y1...]的点列表
          * @return  最小多边形顶点集合
          */
         static scanPList(pList) {
             return Utils.copyArray(pList, GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList, true))));
         }
         /**
          * 寻找包括所有点的最小多边形顶点集合
          * @param PointSet Point列表
          * @return 最小多边形顶点集合
          */
         static scan(PointSet) {
             var i, j, k = 0, tmp, n = PointSet.length, ch;
             var _tmpDic = {};
             var key;
             ch = GrahamScan._temArr;
             ch.length = 0;
             n = PointSet.length;
             for (i = n - 1; i >= 0; i--) {
                 tmp = PointSet[i];
                 key = tmp.x + "_" + tmp.y;
                 if (!(key in _tmpDic)) {
                     _tmpDic[key] = true;
                     ch.push(tmp);
                 }
             }
             n = ch.length;
             Utils.copyArray(PointSet, ch);
             //			PointSet=ch;
             //			n=PointSet.length;
             //找到最下且偏左的那个点  
             for (i = 1; i < n; i++)
                 if ((PointSet[i].y < PointSet[k].y) || ((PointSet[i].y == PointSet[k].y) && (PointSet[i].x < PointSet[k].x)))
                     k = i;
             //将这个点指定为PointSet[0]  
             tmp = PointSet[0];
             PointSet[0] = PointSet[k];
             PointSet[k] = tmp;
             //按极角从小到大,距离偏短进行排序  
             for (i = 1; i < n - 1; i++) {
                 k = i;
                 for (j = i + 1; j < n; j++)
                     if ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) > 0) || ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) == 0) && (GrahamScan.dis(PointSet[0], PointSet[j]) < GrahamScan.dis(PointSet[0], PointSet[k]))))
                         k = j; //k保存极角最小的那个点,或者相同距离原点最近  
                 tmp = PointSet[i];
                 PointSet[i] = PointSet[k];
                 PointSet[k] = tmp;
             }
             //第三个点先入栈  
             ch = GrahamScan._temArr;
             ch.length = 0;
             //trace("scan:",PointSet[0],PointSet[1],PointSet[2]);
             if (PointSet.length < 3) {
                 return Utils.copyArray(ch, PointSet);
             }
             ch.push(PointSet[0], PointSet[1], PointSet[2]);
             //ch=[PointSet[0],PointSet[1],PointSet[2]];
             //判断与其余所有点的关系  
             for (i = 3; i < n; i++) {
                 //不满足向左转的关系,栈顶元素出栈  
                 while (ch.length >= 2 && GrahamScan.multiply(PointSet[i], ch[ch.length - 1], ch[ch.length - 2]) >= 0)
                     ch.pop();
                 //当前点与栈内所有点满足向左关系,因此入栈.  
                 PointSet[i] && ch.push(PointSet[i]);
             }
             return ch;
         }
     }
     GrahamScan._tempPointList = [];
     GrahamScan._temPList = [];
     GrahamScan._temArr = [];

     /**
          *  Config 用于配置一些全局参数。如需更改，请在初始化引擎之前设置。
          */
     class Config {
     }
     /**
      * 动画 Animation 的默认播放时间间隔，单位为毫秒。
      */
     Config.animationInterval = 50;
     /**
      * 设置是否抗锯齿，只对2D(WebGL)、3D有效。
      */
     Config.isAntialias = false;
     /**
      * 设置画布是否透明，只对2D(WebGL)、3D有效。
      */
     Config.isAlpha = false;
     /**
      * 设置画布是否预乘，只对2D(WebGL)、3D有效。
      */
     Config.premultipliedAlpha = true;
     /**
      * 设置画布的是否开启模板缓冲，只对2D(WebGL)、3D有效。
      */
     Config.isStencil = true;
     /**
      * 是否强制WebGL同步刷新。
      */
     Config.preserveDrawingBuffer = false;
     /**
      * 当使用webGL渲染2d的时候，每次创建vb是否直接分配足够64k个顶点的缓存。这样可以提高效率。
      */
     Config.webGL2D_MeshAllocMaxMem = true;
     /**
      * 是否强制使用像素采样。适用于像素风格游戏
      */
     Config.is2DPixelArtGame = false;
     /**
      * 是否使用webgl2
      */
     Config.useWebGL2 = true;
     Config.useRetinalCanvas = false;

     class DrawStyle {
         constructor(value) {
             this.setValue(value);
         }
         static create(value) {
             if (value) {
                 var color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
                 return color._drawStyle || (color._drawStyle = new DrawStyle(value));
             }
             return DrawStyle.DEFAULT;
         }
         setValue(value) {
             if (value) {
                 this._color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
             }
             else
                 this._color = ColorUtils.create("#000000");
         }
         reset() {
             this._color = ColorUtils.create("#000000");
         }
         toInt() {
             return this._color.numColor;
         }
         equal(value) {
             if (typeof (value) == 'string')
                 return this._color.strColor === value;
             if (value instanceof ColorUtils)
                 return this._color.numColor === value.numColor;
             return false;
         }
         toColorStr() {
             return this._color.strColor;
         }
     }
     DrawStyle.DEFAULT = new DrawStyle("#000000");

     class Path {
         constructor() {
             //public var _rect:Rectangle;
             this._lastOriX = 0; //moveto等的原始位置。没有经过内部矩阵变换的
             this._lastOriY = 0;
             this.paths = []; //所有的路径。{@type renderPath[] }
             this._curPath = null;
         }
         beginPath(convex) {
             this.paths.length = 1;
             this._curPath = this.paths[0] = new renderPath();
             this._curPath.convex = convex;
             //_curPath.path = [];
         }
         closePath() {
             this._curPath.loop = true;
         }
         newPath() {
             this._curPath = new renderPath();
             this.paths.push(this._curPath);
         }
         addPoint(pointX, pointY) {
             //tempArray.push(pointX, pointY);
             this._curPath.path.push(pointX, pointY);
         }
         //直接添加一个完整的path
         push(points, convex) {
             if (!this._curPath) {
                 this._curPath = new renderPath();
                 this.paths.push(this._curPath);
             }
             else if (this._curPath.path.length > 0) {
                 this._curPath = new renderPath();
                 this.paths.push(this._curPath);
             }
             var rp = this._curPath;
             rp.path = points.slice(); //TODO 这个可能多次slice了
             rp.convex = convex;
         }
         reset() {
             this.paths.length = 0; //TODO 复用
         }
     }
     class renderPath {
         constructor() {
             this.path = []; //[x,y,x,y,....]的数组
             this.loop = false;
             this.convex = false;
         }
     }

     class SubmitBase {
         constructor(renderType = SubmitBase.TYPE_2D) {
             this.clipInfoID = -1; //用来比较clipinfo
             this._mesh = null; //代替 _vb,_ib
             this._blendFn = null;
             this._id = 0;
             this._renderType = 0;
             this._parent = null;
             //渲染key，通过key判断是否是同一个
             this._key = new SubmitKey();
             // 从VB中什么地方开始画，画到哪
             this._startIdx = 0; //indexbuffer 的偏移，单位是byte
             this._numEle = 0;
             this._ref = 1; // 其实已经没有用了
             this.shaderValue = null;
             this._renderType = renderType;
             this._id = ++SubmitBase.ID;
         }
         static __init__() {
             var s = SubmitBase.RENDERBASE = new SubmitBase(-1);
             s.shaderValue = new Value2D(0, 0);
             s.shaderValue.ALPHA = 1;
             s._ref = 0xFFFFFFFF;
         }
         getID() {
             return this._id;
         }
         getRenderType() {
             return this._renderType;
         }
         toString() {
             return "ibindex:" + this._startIdx + " num:" + this._numEle + " key=" + this._key;
         }
         renderSubmit() { return 1; }
         releaseRender() { }
     }
     SubmitBase.TYPE_2D = 10000;
     SubmitBase.TYPE_CANVAS = 10003;
     SubmitBase.TYPE_CMDSETRT = 10004;
     SubmitBase.TYPE_CUSTOM = 10005;
     SubmitBase.TYPE_BLURRT = 10006;
     SubmitBase.TYPE_CMDDESTORYPRERT = 10007;
     SubmitBase.TYPE_DISABLESTENCIL = 10008;
     SubmitBase.TYPE_OTHERIBVB = 10009;
     SubmitBase.TYPE_PRIMITIVE = 10010;
     SubmitBase.TYPE_RT = 10011;
     SubmitBase.TYPE_BLUR_RT = 10012;
     SubmitBase.TYPE_TARGET = 10013;
     SubmitBase.TYPE_CHANGE_VALUE = 10014;
     SubmitBase.TYPE_SHAPE = 10015;
     SubmitBase.TYPE_TEXTURE = 10016;
     SubmitBase.TYPE_FILLTEXTURE = 10017;
     SubmitBase.KEY_ONCE = -1;
     SubmitBase.KEY_FILLRECT = 1;
     SubmitBase.KEY_DRAWTEXTURE = 2;
     SubmitBase.KEY_VG = 3;
     SubmitBase.KEY_TRIANGLES = 4;
     SubmitBase.ID = 1;
     SubmitBase.preRender = null; //上一个submit，主要用来比较key,以减少uniform的重复提交。

     class SaveBase {
         constructor() {
         }
         static _createArray() {
             var value = [];
             value._length = 0;
             return value;
         }
         static _init() {
             var namemap = SaveBase._namemap = {};
             namemap[SaveBase.TYPE_ALPHA] = "ALPHA";
             namemap[SaveBase.TYPE_FILESTYLE] = "fillStyle";
             namemap[SaveBase.TYPE_FONT] = "font";
             namemap[SaveBase.TYPE_LINEWIDTH] = "lineWidth";
             namemap[SaveBase.TYPE_STROKESTYLE] = "strokeStyle";
             namemap[SaveBase.TYPE_ENABLEMERGE] = "_mergeID";
             namemap[SaveBase.TYPE_MARK] = namemap[SaveBase.TYPE_TRANSFORM] = namemap[SaveBase.TYPE_TRANSLATE] = [];
             namemap[SaveBase.TYPE_TEXTBASELINE] = "textBaseline";
             namemap[SaveBase.TYPE_TEXTALIGN] = "textAlign";
             namemap[SaveBase.TYPE_GLOBALCOMPOSITEOPERATION] = "_nBlendType";
             namemap[SaveBase.TYPE_SHADER] = "shader";
             namemap[SaveBase.TYPE_FILTERS] = "filters";
             namemap[SaveBase.TYPE_COLORFILTER] = '_colorFiler';
             return namemap;
         }
         isSaveMark() { return false; }
         restore(context) {
             this._dataObj[this._valueName] = this._value;
             SaveBase.POOL[SaveBase.POOL._length++] = this;
             this._newSubmit && (context._curSubmit = SubmitBase.RENDERBASE);
         }
         static save(context, type, dataObj, newSubmit) {
             if ((context._saveMark._saveuse & type) !== type) {
                 context._saveMark._saveuse |= type;
                 var cache = SaveBase.POOL;
                 var o = cache._length > 0 ? cache[--cache._length] : (new SaveBase());
                 o._value = dataObj[o._valueName = SaveBase._namemap[type]];
                 o._dataObj = dataObj;
                 o._newSubmit = newSubmit;
                 var _save = context._save;
                 _save[_save._length++] = o;
             }
         }
     }
     /*[FILEINDEX:1]*/
     /*[DISBALEOUTCONST-BEGIN]*/
     SaveBase.TYPE_ALPHA = 0x1;
     SaveBase.TYPE_FILESTYLE = 0x2;
     SaveBase.TYPE_FONT = 0x8;
     SaveBase.TYPE_LINEWIDTH = 0x100;
     SaveBase.TYPE_STROKESTYLE = 0x200;
     SaveBase.TYPE_MARK = 0x400;
     SaveBase.TYPE_TRANSFORM = 0x800;
     SaveBase.TYPE_TRANSLATE = 0x1000;
     SaveBase.TYPE_ENABLEMERGE = 0x2000;
     SaveBase.TYPE_TEXTBASELINE = 0x4000;
     SaveBase.TYPE_TEXTALIGN = 0x8000;
     SaveBase.TYPE_GLOBALCOMPOSITEOPERATION = 0x10000;
     SaveBase.TYPE_CLIPRECT = 0x20000;
     SaveBase.TYPE_CLIPRECT_STENCIL = 0x40000;
     SaveBase.TYPE_IBVB = 0x80000;
     SaveBase.TYPE_SHADER = 0x100000;
     SaveBase.TYPE_FILTERS = 0x200000;
     SaveBase.TYPE_FILTERS_TYPE = 0x400000;
     SaveBase.TYPE_COLORFILTER = 0x800000;
     /*[DISBALEOUTCONST-END]*/
     SaveBase.POOL = SaveBase._createArray();
     SaveBase._namemap = SaveBase._init();

     class SaveClipRect {
         constructor() {
             //public var _clipSaveRect:Rectangle;
             //private var _transedClipInfo:Array = new Array(6);
             this._globalClipMatrix = new Matrix();
             this._clipInfoID = -1;
             this._clipRect = new Rectangle();
             this.incache = false;
         }
         isSaveMark() { return false; }
         restore(context) {
             /*
             context._transedClipInfo[0] = _transedClipInfo[0];
             context._transedClipInfo[1] = _transedClipInfo[1];
             context._transedClipInfo[2] = _transedClipInfo[2];
             context._transedClipInfo[3] = _transedClipInfo[3];
             context._transedClipInfo[4] = _transedClipInfo[4];
             context._transedClipInfo[5] = _transedClipInfo[5];
             */
             this._globalClipMatrix.copyTo(context._globalClipMatrix);
             this._clipRect.clone(context._clipRect);
             context._clipInfoID = this._clipInfoID;
             //context._clipTransed = false;	//ֱ�����¼���
             SaveClipRect.POOL[SaveClipRect.POOL._length++] = this;
             context._clipInCache = this.incache;
             /*
             context._clipRect = _clipSaveRect;
             context._curSubmit = context._submits[context._submits._length++] = SubmitBase.RENDERBASE;
             context._submitKey.submitType=-1;
             */
         }
         static save(context) {
             if ((context._saveMark._saveuse & SaveBase.TYPE_CLIPRECT) == SaveBase.TYPE_CLIPRECT)
                 return;
             context._saveMark._saveuse |= SaveBase.TYPE_CLIPRECT;
             var cache = SaveClipRect.POOL;
             var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRect());
             //o._clipSaveRect = context._clipRect;
             //context._clipRect = o._clipRect.copyFrom(context._clipRect);
             //o._submitScissor = submitScissor;
             context._globalClipMatrix.copyTo(o._globalClipMatrix);
             /*
             o._transedClipInfo[0] = context._transedClipInfo[0];
             o._transedClipInfo[1] = context._transedClipInfo[1];
             o._transedClipInfo[2] = context._transedClipInfo[2];
             o._transedClipInfo[3] = context._transedClipInfo[3];
             o._transedClipInfo[4] = context._transedClipInfo[4];
             o._transedClipInfo[5] = context._transedClipInfo[5];
             */
             context._clipRect.clone(o._clipRect);
             o._clipInfoID = context._clipInfoID;
             o.incache = context._clipInCache;
             var _save = context._save;
             _save[_save._length++] = o;
         }
     }
     SaveClipRect.POOL = SaveBase._createArray();

     class SaveMark {
         constructor() {
             this._saveuse = 0;
         }
         isSaveMark() {
             return true;
         }
         restore(context) {
             context._saveMark = this._preSaveMark;
             SaveMark.POOL[SaveMark.POOL._length++] = this;
         }
         static Create(context) {
             var no = SaveMark.POOL;
             var o = no._length > 0 ? no[--no._length] : (new SaveMark());
             o._saveuse = 0;
             o._preSaveMark = context._saveMark;
             context._saveMark = o;
             return o;
         }
     }
     SaveMark.POOL = SaveBase._createArray();

     class SaveTransform {
         constructor() {
             this._matrix = new Matrix();
         }
         isSaveMark() { return false; }
         restore(context) {
             context._curMat = this._savematrix;
             SaveTransform.POOL[SaveTransform.POOL._length++] = this;
         }
         static save(context) {
             var _saveMark = context._saveMark;
             if ((_saveMark._saveuse & SaveBase.TYPE_TRANSFORM) === SaveBase.TYPE_TRANSFORM)
                 return;
             _saveMark._saveuse |= SaveBase.TYPE_TRANSFORM;
             var no = SaveTransform.POOL;
             var o = no._length > 0 ? no[--no._length] : (new SaveTransform());
             o._savematrix = context._curMat;
             context._curMat = context._curMat.copyTo(o._matrix);
             var _save = context._save;
             _save[_save._length++] = o;
         }
     }
     SaveTransform.POOL = SaveBase._createArray();

     class SaveTranslate {
         constructor() {
             this._mat = new Matrix();
         }
         isSaveMark() { return false; }
         restore(context) {
             this._mat.copyTo(context._curMat);
             SaveTranslate.POOL[SaveTranslate.POOL._length++] = this;
         }
         static save(context) {
             var no = SaveTranslate.POOL;
             var o = no._length > 0 ? no[--no._length] : (new SaveTranslate());
             context._curMat.copyTo(o._mat);
             var _save = context._save;
             _save[_save._length++] = o;
         }
     }
     SaveTranslate.POOL = SaveBase._createArray();

     /**
          *
          * @author laya
          */
     class RenderInfo {
     }
     RenderInfo.loopStTm = 0; // 当前帧的开始时间
     RenderInfo.loopCount = 0; //

     class Buffer {
         constructor() {
             this._byteLength = 0;
             this._glBuffer = LayaGL.instance.createBuffer();
         }
         get bufferUsage() {
             return this._bufferUsage;
         }
         /**
          * @private
          * 绕过全局状态判断,例如VAO局部状态设置
          */
         _bindForVAO() {
         }
         /**
          * @private
          */
         //TODO:coverage
         bind() {
             return false;
         }
         /**
          * @private
          */
         destroy() {
             if (this._glBuffer) {
                 LayaGL.instance.deleteBuffer(this._glBuffer);
                 this._glBuffer = null;
             }
         }
     }

     class Buffer2D extends Buffer {
         constructor() {
             super();
             this._maxsize = 0;
             this._upload = true;
             this._uploadSize = 0;
             this._bufferSize = 0;
             this._u8Array = null; //反正常常要拷贝老的数据，所以保留这个可以提高效率
         }
         static __int__(gl) {
         }
         get bufferLength() {
             return this._buffer.byteLength;
         }
         set byteLength(value) {
             this.setByteLength(value);
         }
         setByteLength(value) {
             if (this._byteLength !== value) {
                 value <= this._bufferSize || (this._resizeBuffer(value * 2 + 256, true));
                 this._byteLength = value;
             }
         }
         /**
          * 在当前的基础上需要多大空间，单位是byte
          * @param	sz
          * @return  增加大小之前的写位置。单位是byte
          */
         needSize(sz) {
             var old = this._byteLength;
             if (sz) {
                 var needsz = this._byteLength + sz;
                 needsz <= this._bufferSize || (this._resizeBuffer(needsz << 1, true));
                 this._byteLength = needsz;
             }
             return old;
         }
         _bufferData() {
             this._maxsize = Math.max(this._maxsize, this._byteLength);
             if (RenderInfo.loopCount % 30 == 0) { //每30帧缩小一下buffer	。TODO 这个有问题。不知道_maxsize和_byteLength是怎么维护的，这里会导致重新分配64字节
                 if (this._buffer.byteLength > (this._maxsize + 64)) {
                     //_setGPUMemory(_buffer.byteLength);
                     this._buffer = this._buffer.slice(0, this._maxsize + 64);
                     this._bufferSize = this._buffer.byteLength;
                     this._checkArrayUse();
                 }
                 this._maxsize = this._byteLength;
             }
             if (this._uploadSize < this._buffer.byteLength) {
                 this._uploadSize = this._buffer.byteLength;
                 LayaGL.instance.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);
                 //_setGPUMemory(_uploadSize);
             }
             LayaGL.instance.bufferSubData(this._bufferType, 0, new Uint8Array(this._buffer, 0, this._byteLength));
         }
         //TODO:coverage
         _bufferSubData(offset = 0, dataStart = 0, dataLength = 0) {
             this._maxsize = Math.max(this._maxsize, this._byteLength);
             if (RenderInfo.loopCount % 30 == 0) {
                 if (this._buffer.byteLength > (this._maxsize + 64)) {
                     //_setGPUMemory(_buffer.byteLength);
                     this._buffer = this._buffer.slice(0, this._maxsize + 64);
                     this._bufferSize = this._buffer.byteLength;
                     this._checkArrayUse();
                 }
                 this._maxsize = this._byteLength;
             }
             if (this._uploadSize < this._buffer.byteLength) {
                 this._uploadSize = this._buffer.byteLength;
                 LayaGL.instance.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);
                 //_setGPUMemory(_uploadSize);
             }
             if (dataStart || dataLength) {
                 var subBuffer = this._buffer.slice(dataStart, dataLength);
                 LayaGL.instance.bufferSubData(this._bufferType, offset, subBuffer);
             }
             else {
                 LayaGL.instance.bufferSubData(this._bufferType, offset, this._buffer);
             }
         }
         /**
          * buffer重新分配了，继承类根据需要做相应的处理。
          */
         _checkArrayUse() {
         }
         /**
          * 给vao使用的 _bind_upload函数。不要与已经绑定的判断是否相同
          * @return
          */
         _bind_uploadForVAO() {
             if (!this._upload)
                 return false;
             this._upload = false;
             this._bindForVAO();
             this._bufferData();
             return true;
         }
         _bind_upload() {
             if (!this._upload)
                 return false;
             this._upload = false;
             this.bind();
             this._bufferData();
             return true;
         }
         //TODO:coverage
         _bind_subUpload(offset = 0, dataStart = 0, dataLength = 0) {
             if (!this._upload)
                 return false;
             this._upload = false;
             this.bind();
             this._bufferSubData(offset, dataStart, dataLength);
             return true;
         }
         /**
          * 重新分配buffer大小，如果nsz比原来的小则什么都不做。
          * @param	nsz		buffer大小，单位是byte。
          * @param	copy	是否拷贝原来的buffer的数据。
          * @return
          */
         _resizeBuffer(nsz, copy) {
             var buff = this._buffer;
             if (nsz <= buff.byteLength)
                 return this;
             var u8buf = this._u8Array;
             //_setGPUMemory(nsz);
             if (copy && buff && buff.byteLength > 0) {
                 var newbuffer = new ArrayBuffer(nsz);
                 var oldU8Arr = (u8buf && u8buf.buffer == buff) ? u8buf : new Uint8Array(buff);
                 u8buf = this._u8Array = new Uint8Array(newbuffer);
                 u8buf.set(oldU8Arr, 0);
                 buff = this._buffer = newbuffer;
             }
             else {
                 buff = this._buffer = new ArrayBuffer(nsz);
                 this._u8Array = null;
             }
             this._checkArrayUse();
             this._upload = true;
             this._bufferSize = buff.byteLength;
             return this;
         }
         append(data) {
             this._upload = true;
             var byteLen, n;
             byteLen = data.byteLength;
             if (data instanceof Uint8Array) {
                 this._resizeBuffer(this._byteLength + byteLen, true);
                 n = new Uint8Array(this._buffer, this._byteLength);
             }
             else if (data instanceof Uint16Array) {
                 this._resizeBuffer(this._byteLength + byteLen, true);
                 n = new Uint16Array(this._buffer, this._byteLength);
             }
             else if (data instanceof Float32Array) {
                 this._resizeBuffer(this._byteLength + byteLen, true);
                 n = new Float32Array(this._buffer, this._byteLength);
             }
             n.set(data, 0);
             this._byteLength += byteLen;
             this._checkArrayUse();
         }
         /**
          * 附加Uint16Array的数据。数据长度是len。byte的话要*2
          * @param	data
          * @param	len
          */
         appendU16Array(data, len) {
             this._resizeBuffer(this._byteLength + len * 2, true);
             //(new Uint16Array(_buffer, _byteLength, len)).set(data.slice(0, len));
             //下面这种写法比上面的快多了
             var u = new Uint16Array(this._buffer, this._byteLength, len); //TODO 怎么能不用new
             if (len == 6) {
                 u[0] = data[0];
                 u[1] = data[1];
                 u[2] = data[2];
                 u[3] = data[3];
                 u[4] = data[4];
                 u[5] = data[5];
             }
             else if (len >= 100) {
                 u.set(new Uint16Array(data.buffer, 0, len));
             }
             else {
                 for (var i = 0; i < len; i++) {
                     u[i] = data[i];
                 }
             }
             this._byteLength += len * 2;
             this._checkArrayUse();
         }
         //TODO:coverage
         appendEx(data, type) {
             this._upload = true;
             var byteLen, n;
             byteLen = data.byteLength;
             this._resizeBuffer(this._byteLength + byteLen, true);
             n = new type(this._buffer, this._byteLength);
             n.set(data, 0);
             this._byteLength += byteLen;
             this._checkArrayUse();
         }
         //TODO:coverage
         appendEx2(data, type, dataLen, perDataLen = 1) {
             this._upload = true;
             var byteLen, n;
             byteLen = dataLen * perDataLen;
             this._resizeBuffer(this._byteLength + byteLen, true);
             n = new type(this._buffer, this._byteLength);
             var i;
             for (i = 0; i < dataLen; i++) {
                 n[i] = data[i];
             }
             this._byteLength += byteLen;
             this._checkArrayUse();
         }
         //TODO:coverage
         getBuffer() {
             return this._buffer;
         }
         setNeedUpload() {
             this._upload = true;
         }
         //TODO:coverage
         getNeedUpload() {
             return this._upload;
         }
         //TODO:coverage
         upload() {
             var scuess = this._bind_upload();
             LayaGL.instance.bindBuffer(this._bufferType, null);
             if (this._bufferType == WebGLContext.ARRAY_BUFFER)
                 Buffer._bindedVertexBuffer = null;
             if (this._bufferType == WebGLContext.ELEMENT_ARRAY_BUFFER)
                 Buffer._bindedIndexBuffer = null;
             BaseShader.activeShader = null;
             return scuess;
         }
         //TODO:coverage
         subUpload(offset = 0, dataStart = 0, dataLength = 0) {
             var scuess = this._bind_subUpload();
             LayaGL.instance.bindBuffer(this._bufferType, null);
             if (this._bufferType == WebGLContext.ARRAY_BUFFER)
                 Buffer._bindedVertexBuffer = null;
             if (this._bufferType == WebGLContext.ELEMENT_ARRAY_BUFFER)
                 Buffer._bindedIndexBuffer = null;
             BaseShader.activeShader = null;
             return scuess;
         }
         _disposeResource() {
             this._upload = true;
             this._uploadSize = 0;
         }
         /**
          * 清理数据。保留ArrayBuffer
          */
         clear() {
             this._byteLength = 0;
             this._upload = true;
         }
     }
     Buffer2D.FLOAT32 = 4;
     Buffer2D.SHORT = 2;

     class VertexBuffer2D extends Buffer2D {
         constructor(vertexStride, bufferUsage) {
             super();
             this._vertexStride = vertexStride;
             this._bufferUsage = bufferUsage;
             this._bufferType = WebGLContext.ARRAY_BUFFER;
             this._buffer = new ArrayBuffer(8);
             this._floatArray32 = new Float32Array(this._buffer);
             this._uint32Array = new Uint32Array(this._buffer);
         }
         get vertexStride() {
             return this._vertexStride;
         }
         getFloat32Array() {
             return this._floatArray32;
         }
         /**
          * 在当前位置插入float数组。
          * @param	data
          * @param	pos
          */
         appendArray(data) {
             var oldoff = this._byteLength >> 2;
             this.setByteLength(this._byteLength + data.length * 4);
             var vbdata = this.getFloat32Array();
             vbdata.set(data, oldoff);
             this._upload = true;
         }
         /*override*/ _checkArrayUse() {
             this._floatArray32 && (this._floatArray32 = new Float32Array(this._buffer));
             this._uint32Array && (this._uint32Array = new Uint32Array(this._buffer));
         }
         //只删除buffer，不disableVertexAttribArray
         deleteBuffer() {
             super._disposeResource();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _bindForVAO() {
             LayaGL.instance.bindBuffer(WebGLContext.ARRAY_BUFFER, this._glBuffer);
         }
         /**
          * @inheritDoc
          */
         /*override*/ bind() {
             if (Buffer._bindedVertexBuffer !== this._glBuffer) {
                 LayaGL.instance.bindBuffer(WebGLContext.ARRAY_BUFFER, this._glBuffer);
                 Buffer._bindedVertexBuffer = this._glBuffer;
                 return true;
             }
             return false;
         }
         /*override*/ destroy() {
             super.destroy();
             this._byteLength = 0;
             this._upload = true;
             this._buffer = null;
             this._floatArray32 = null;
         }
     }
     VertexBuffer2D.create = function (vertexStride, bufferUsage = 0x88e8 /* WebGLContext.DYNAMIC_DRAW*/) {
         return new VertexBuffer2D(vertexStride, bufferUsage);
     };

     class IndexBuffer2D extends Buffer2D {
         constructor(bufferUsage = 0x88e4 /* WebGLContext.STATIC_DRAW*/) {
             super();
             this._bufferUsage = bufferUsage;
             this._bufferType = WebGLContext.ELEMENT_ARRAY_BUFFER;
             this._buffer = new ArrayBuffer(8);
         }
         /*override*/ _checkArrayUse() {
             this._uint16Array && (this._uint16Array = new Uint16Array(this._buffer));
         }
         getUint16Array() {
             return this._uint16Array || (this._uint16Array = new Uint16Array(this._buffer));
         }
         /**
          * @inheritDoc
          */
         /*override*/ _bindForVAO() {
             LayaGL.instance.bindBuffer(WebGLContext.ELEMENT_ARRAY_BUFFER, this._glBuffer);
         }
         /**
          * @inheritDoc
          */
         /*override*/ bind() {
             if (Buffer._bindedIndexBuffer !== this._glBuffer) {
                 LayaGL.instance.bindBuffer(WebGLContext.ELEMENT_ARRAY_BUFFER, this._glBuffer);
                 Buffer._bindedIndexBuffer = this._glBuffer;
                 return true;
             }
             return false;
         }
         destory() {
             this._uint16Array = null;
             this._buffer = null;
         }
         disposeResource() {
             this._disposeResource();
         }
     }
     IndexBuffer2D.create = function (bufferUsage = 0x88e4 /* WebGLContext.STATIC_DRAW*/) {
         return new IndexBuffer2D(bufferUsage);
     };

     /**
      * ...
      * @author ...
      */
     class BufferStateBase {
         constructor() {
             this._nativeVertexArrayObject = LayaGL.layaGPUInstance.createVertexArray();
         }
         /**
          * @private
          */
         bind() {
             if (BufferStateBase._curBindedBufferState !== this) {
                 LayaGL.layaGPUInstance.bindVertexArray(this._nativeVertexArrayObject);
                 BufferStateBase._curBindedBufferState = this;
             }
         }
         /**
          * @private
          */
         unBind() {
             if (BufferStateBase._curBindedBufferState === this) {
                 LayaGL.layaGPUInstance.bindVertexArray(null);
                 BufferStateBase._curBindedBufferState = null;
             }
             else {
                 throw "BufferState: must call bind() function first.";
             }
         }
         /**
          * @private
          */
         destroy() {
             LayaGL.layaGPUInstance.deleteVertexArray(this._nativeVertexArrayObject);
         }
         /**
          * @private
          */
         bindForNative() {
             LayaGL.instance.bindVertexArray(this._nativeVertexArrayObject);
             BufferStateBase._curBindedBufferState = this;
         }
         /**
          * @private
          */
         unBindForNative() {
             LayaGL.instance.bindVertexArray(null);
             BufferStateBase._curBindedBufferState = null;
         }
     }

     /**
          * ...
          * @author ...
          */
     class BufferState2D extends BufferStateBase {
         constructor() {
             super();
         }
     }

     /**
      * Mesh2d只是保存数据。描述attribute用的。本身不具有渲染功能。
      */
     class Mesh2D {
         /**
          *
          * @param	stride
          * @param	vballoc  vb预分配的大小。主要是用来提高效率。防止不断的resizebfufer
          * @param	iballoc
          */
         constructor(stride, vballoc, iballoc) {
             this._stride = 0; //顶点结构大小。每个mesh的顶点结构是固定的。
             this.vertNum = 0; //当前的顶点的个数
             this.indexNum = 0; //实际index 个数。例如一个三角形是3个。由于ib本身可能超过实际使用的数量，所以需要一个indexNum
             this._applied = false; //是否已经设置给webgl了
             this._quadNum = 0;
             //public static var meshlist:Array = [];	//活着的mesh对象列表。
             this.canReuse = false; //用完以后，是删除还是回收。
             this._stride = stride;
             this._vb = new VertexBuffer2D(stride, WebGLContext.DYNAMIC_DRAW);
             if (vballoc) {
                 this._vb._resizeBuffer(vballoc, false);
             }
             else {
                 Config.webGL2D_MeshAllocMaxMem && this._vb._resizeBuffer(64 * 1024 * stride, false);
             }
             this._ib = new IndexBuffer2D();
             if (iballoc) {
                 this._ib._resizeBuffer(iballoc, false);
             }
             //meshlist.push(this);
         }
         /**
          * 重新创建一个mesh。复用这个对象的vertex结构，ib对象和attribinfo对象
          */
         //TODO:coverage
         cloneWithNewVB() {
             var mesh = new Mesh2D(this._stride, 0, 0);
             mesh._ib = this._ib;
             mesh._quadNum = this._quadNum;
             mesh._attribInfo = this._attribInfo;
             return mesh;
         }
         /**
          * 创建一个mesh，使用当前对象的vertex结构。vb和ib自己提供。
          * @return
          */
         //TODO:coverage
         cloneWithNewVBIB() {
             var mesh = new Mesh2D(this._stride, 0, 0);
             mesh._attribInfo = this._attribInfo;
             return mesh;
         }
         /**
          * 获得一个可以写的vb对象
          */
         //TODO:coverage
         getVBW() {
             this._vb.setNeedUpload();
             return this._vb;
         }
         /**
          * 获得一个只读vb
          */
         //TODO:coverage
         getVBR() {
             return this._vb;
         }
         //TODO:coverage
         getIBR() {
             return this._ib;
         }
         /**
          * 获得一个可写的ib
          */
         //TODO:coverage
         getIBW() {
             this._ib.setNeedUpload();
             return this._ib;
         }
         /**
          * 直接创建一个固定的ib。按照固定四边形的索引。
          * @param	var QuadNum
          */
         createQuadIB(QuadNum) {
             this._quadNum = QuadNum;
             this._ib._resizeBuffer(QuadNum * 6 * 2, false); //short类型
             this._ib.byteLength = this._ib.bufferLength; //这个我也不知道是什么意思
             var bd = this._ib.getUint16Array();
             var idx = 0;
             var curvert = 0;
             for (var i = 0; i < QuadNum; i++) {
                 bd[idx++] = curvert;
                 bd[idx++] = curvert + 2;
                 bd[idx++] = curvert + 1;
                 bd[idx++] = curvert;
                 bd[idx++] = curvert + 3;
                 bd[idx++] = curvert + 2;
                 curvert += 4;
             }
             this._ib.setNeedUpload();
         }
         /**
          * 设置mesh的属性。每3个一组，对应的location分别是0,1,2...
          * 含义是：type,size,offset
          * 不允许多流。因此stride是固定的，offset只是在一个vertex之内。
          * @param	attribs
          */
         setAttributes(attribs) {
             this._attribInfo = attribs;
             if (this._attribInfo.length % 3 != 0) {
                 throw 'Mesh2D setAttributes error!';
             }
         }
         /**
          * 初始化VAO的配置，只需要执行一次。以后使用的时候直接bind就行
          * @param	gl
          */
         configVAO(gl) {
             if (this._applied)
                 return;
             this._applied = true;
             if (!this._vao) {
                 //_vao = __JS__('gl.createVertexArray();');
                 this._vao = new BufferState2D();
                 //_vao.dbgid = _gvaoid++;
             }
             this._vao.bind();
             //gl.bindVertexArray(_vao);
             this._vb._bindForVAO();
             //_vb._bind(); 这个有相同优化，不适用于vao
             this._ib.setNeedUpload(); //vao的话，必须要绑定ib。即使是共享的别人的。
             this._ib._bind_uploadForVAO();
             //gl.bindBuffer(WebGLContext.ARRAY_BUFFER,_vb);
             //gl.bindBuffer(WebGLContext.ELEMENT_ARRAY_BUFFER, _ib);
             var attribNum = this._attribInfo.length / 3;
             var idx = 0;
             for (var i = 0; i < attribNum; i++) {
                 var _size = this._attribInfo[idx + 1];
                 var _type = this._attribInfo[idx];
                 var _off = this._attribInfo[idx + 2];
                 gl.enableVertexAttribArray(i);
                 gl.vertexAttribPointer(i, _size, _type, false, this._stride, _off); //注意 normalize都设置为false了，想必没人要用这个功能把。
                 idx += 3;
             }
             this._vao.unBind();
             //gl.bindVertexArray(null);
         }
         /**
          * 应用这个mesh
          * @param	gl
          */
         useMesh(gl) {
             //要先bind，在bufferData
             this._applied || this.configVAO(gl);
             //var attribNum:int = _attribInfo.length / 3;
             //var bindedAttributeBuffer:Array = Buffer._bindedAtributeBuffer;
             //for ( var i:int = 0; i < attribNum; i++) 
             //(bindedAttributeBuffer[i]) || (gl.enableVertexAttribArray(i), bindedAttributeBuffer[i] = _vb);
             //WebGLContext.bindVertexArray(gl, null);
             //gl.disableVertexAttribArray(0);
             this._vao.bind();
             //gl.bindVertexArray(_vao);
             this._vb.bind(); //vao必须要再bind vb,否则下面的操作可能是在操作其他的mesh
             this._ib._bind_upload() || this._ib.bind();
             this._vb._bind_upload() || this._vb.bind();
         }
         //TODO:coverage
         getEleNum() {
             return this._ib.getBuffer().byteLength / 2;
         }
         /**
          * 子类实现。用来把自己放到对应的回收池中，以便复用。
          */
         releaseMesh() { }
         /**
          * 释放资源。
          */
         destroy() {
         }
         /**
          * 清理vb数据
          */
         clearVB() {
             this._vb.clear();
         }
     }
     Mesh2D._gvaoid = 0;

     /**
      * drawImage，fillRect等会用到的简单的mesh。每次添加必然是一个四边形。
      */
     class MeshQuadTexture extends Mesh2D {
         //private static var _num;
         constructor() {
             super(MeshQuadTexture.const_stride, 4, 4); //x,y,u,v,rgba
             this.canReuse = true;
             this.setAttributes(MeshQuadTexture._fixattriInfo);
             if (!MeshQuadTexture._fixib) {
                 this.createQuadIB(MeshQuadTexture._maxIB); //每个quad 4个顶点。正好达到64k的索引。
                 MeshQuadTexture._fixib = this._ib;
             }
             else {
                 this._ib = MeshQuadTexture._fixib;
                 this._quadNum = MeshQuadTexture._maxIB;
             }
         }
         /**
          *
          */
         static getAMesh(mainctx) {
             //console.log('getmesh');
             var ret = null;
             if (MeshQuadTexture._POOL.length) {
                 ret = MeshQuadTexture._POOL.pop();
             }
             else
                 ret = new MeshQuadTexture();
             // 先分配64k顶点的空间，这样可以避免浪费内存，否则后面增加内存的时候是成倍增加的，当快超过64k的时候，直接变成了128k
             mainctx && ret._vb._resizeBuffer(64 * 1024 * MeshQuadTexture.const_stride, false);
             return ret;
         }
         /**
          * 把本对象放到回收池中，以便getMesh能用。
          */
         /*override*/ releaseMesh() {
             this._vb.setByteLength(0);
             this.vertNum = 0;
             this.indexNum = 0;
             //_applied = false;
             MeshQuadTexture._POOL.push(this);
         }
         /*override*/ destroy() {
             //_ib.destroy(); ib是公用的。
             this._vb.destroy();
             this._vb.deleteBuffer();
         }
         /**
          *
          * @param	pos
          * @param	uv
          * @param	color
          * @param	clip   ox,oy,xx,xy,yx,yy
          * @param 	useTex 是否使用贴图。false的话是给fillRect用的
          */
         addQuad(pos, uv, color, useTex) {
             var vb = this._vb;
             var vpos = (vb._byteLength >> 2); //float数组的下标
             //x,y,u,v,rgba
             vb.setByteLength((vpos + MeshQuadTexture.const_stride) << 2); //是一个四边形的大小，也是这里填充的大小
             var vbdata = vb._floatArray32 || vb.getFloat32Array();
             var vbu32Arr = vb._uint32Array;
             var cpos = vpos;
             var useTexVal = useTex ? 0xff : 0;
             vbdata[cpos++] = pos[0];
             vbdata[cpos++] = pos[1];
             vbdata[cpos++] = uv[0];
             vbdata[cpos++] = uv[1];
             vbu32Arr[cpos++] = color;
             vbu32Arr[cpos++] = useTexVal;
             vbdata[cpos++] = pos[2];
             vbdata[cpos++] = pos[3];
             vbdata[cpos++] = uv[2];
             vbdata[cpos++] = uv[3];
             vbu32Arr[cpos++] = color;
             vbu32Arr[cpos++] = useTexVal;
             vbdata[cpos++] = pos[4];
             vbdata[cpos++] = pos[5];
             vbdata[cpos++] = uv[4];
             vbdata[cpos++] = uv[5];
             vbu32Arr[cpos++] = color;
             vbu32Arr[cpos++] = useTexVal;
             vbdata[cpos++] = pos[6];
             vbdata[cpos++] = pos[7];
             vbdata[cpos++] = uv[6];
             vbdata[cpos++] = uv[7];
             vbu32Arr[cpos++] = color;
             vbu32Arr[cpos++] = useTexVal;
             vb._upload = true;
         }
     }
     MeshQuadTexture.const_stride = 24; // 48;  24是不带clip的
     MeshQuadTexture._maxIB = 16 * 1024;
     MeshQuadTexture._fixattriInfo = [WebGLContext.FLOAT, 4, 0,
         WebGLContext.UNSIGNED_BYTE, 4, 16,
         WebGLContext.UNSIGNED_BYTE, 4, 20];
     MeshQuadTexture._POOL = [];

     /**
      * 与MeshQuadTexture基本相同。不过index不是固定的
      */
     class MeshTexture extends Mesh2D {
         constructor() {
             super(MeshTexture.const_stride, 4, 4); //x,y,u,v,rgba
             this.canReuse = true;
             this.setAttributes(MeshTexture._fixattriInfo);
         }
         /**
          *
          */
         static getAMesh(mainctx) {
             //console.log('getmesh');
             var ret;
             if (MeshTexture._POOL.length) {
                 ret = MeshTexture._POOL.pop();
             }
             else
                 ret = new MeshTexture();
             mainctx && ret._vb._resizeBuffer(64 * 1024 * MeshTexture.const_stride, false);
             return ret;
         }
         addData(vertices, uvs, idx, matrix, rgba) {
             //vb
             var vb = this._vb;
             var ib = this._ib;
             var vertsz = vertices.length >> 1;
             var startpos = vb.needSize(vertsz * MeshTexture.const_stride); //vb的起点。			
             var f32pos = startpos >> 2;
             var vbdata = vb._floatArray32 || vb.getFloat32Array();
             var vbu32Arr = vb._uint32Array;
             var ci = 0;
             var m00 = matrix.a;
             var m01 = matrix.b;
             var m10 = matrix.c;
             var m11 = matrix.d;
             var tx = matrix.tx;
             var ty = matrix.ty;
             var i = 0;
             //var clipinfo:Array = ctx.getTransedClipInfo();
             for (i = 0; i < vertsz; i++) {
                 var x = vertices[ci], y = vertices[ci + 1];
                 vbdata[f32pos] = x * m00 + y * m10 + tx;
                 vbdata[f32pos + 1] = x * m01 + y * m11 + ty;
                 vbdata[f32pos + 2] = uvs[ci];
                 vbdata[f32pos + 3] = uvs[ci + 1];
                 vbu32Arr[f32pos + 4] = rgba;
                 vbu32Arr[f32pos + 5] = 0xff;
                 f32pos += 6;
                 //裁剪信息。
                 //vbdata[f32pos++] = clipinfo[2] ; vbdata[f32pos++] = clipinfo[3]; vbdata[f32pos++] = clipinfo[4]; vbdata[f32pos++] = clipinfo[5];//cliprect的方向
                 //vbdata[f32pos++] = clipinfo[0]; vbdata[f32pos++] = clipinfo[1];	//cliprect的位置
                 ci += 2;
             }
             vb.setNeedUpload();
             var vertN = this.vertNum;
             var sz = idx.length;
             var stib = ib.needSize(idx.byteLength);
             var cidx = ib.getUint16Array();
             //var cidx:Uint16Array = new Uint16Array(__JS__('ib._buffer'), stib);
             var stibid = stib >> 1; // indexbuffer的起始位置
             if (vertN > 0) {
                 var end = stibid + sz;
                 var si = 0;
                 for (i = stibid; i < end; i++, si++) {
                     cidx[i] = idx[si] + vertN;
                 }
             }
             else {
                 cidx.set(idx, stibid);
             }
             ib.setNeedUpload();
             this.vertNum += vertsz;
             this.indexNum += idx.length;
         }
         /**
          * 把本对象放到回收池中，以便getMesh能用。
          */
         /*override*/ releaseMesh() {
             this._vb.setByteLength(0);
             this._ib.setByteLength(0);
             this.vertNum = 0;
             this.indexNum = 0;
             //_applied = false;
             MeshTexture._POOL.push(this);
         }
         /*override*/ destroy() {
             this._ib.destroy();
             this._vb.destroy();
             this._ib.disposeResource();
             this._vb.deleteBuffer();
         }
     }
     MeshTexture.const_stride = 24;
     MeshTexture._fixattriInfo = [WebGLContext.FLOAT, 4, 0,
         WebGLContext.UNSIGNED_BYTE, 4, 16,
         WebGLContext.UNSIGNED_BYTE, 4, 20];
     MeshTexture._POOL = [];

     /**
      * 用来画矢量的mesh。顶点格式固定为 x,y,rgba
      */
     class MeshVG extends Mesh2D {
         constructor() {
             super(MeshVG.const_stride, 4, 4); //x,y,rgba
             this.canReuse = true;
             this.setAttributes(MeshVG._fixattriInfo);
         }
         static getAMesh(mainctx) {
             //console.log('getmeshvg');
             var ret;
             if (MeshVG._POOL.length) {
                 ret = MeshVG._POOL.pop();
             }
             else
                 ret = new MeshVG();
             mainctx && ret._vb._resizeBuffer(64 * 1024 * MeshVG.const_stride, false);
             return ret;
         }
         /**
          * 往矢量mesh中添加顶点和index。会把rgba和points在mesh中合并。
          * @param	points	顶点数组，只包含x,y。[x,y,x,y...]
          * @param	rgba	rgba颜色
          * @param	ib		index数组。
          */
         addVertAndIBToMesh(ctx, points, rgba, ib) {
             var startpos = this._vb.needSize(points.length / 2 * MeshVG.const_stride); //vb的起点。
             var f32pos = startpos >> 2;
             var vbdata = this._vb._floatArray32 || this._vb.getFloat32Array();
             var vbu32Arr = this._vb._uint32Array;
             var ci = 0;
             //vb
             //var clipinfo:Array = ctx.getTransedClipInfo();
             var sz = points.length / 2;
             for (var i = 0; i < sz; i++) {
                 vbdata[f32pos++] = points[ci];
                 vbdata[f32pos++] = points[ci + 1];
                 ci += 2;
                 vbu32Arr[f32pos++] = rgba;
                 /*
                 //裁剪信息。
                 vbdata[f32pos++] = clipinfo[2] ; vbdata[f32pos++] = clipinfo[3]; vbdata[f32pos++] = clipinfo[4]; vbdata[f32pos++] = clipinfo[5];//cliprect的方向
                 vbdata[f32pos++] = clipinfo[0]; vbdata[f32pos++] = clipinfo[1]; //cliprect的位置
                 */
             }
             this._vb.setNeedUpload();
             //ib
             //TODO 现在这种添加数据的方法效率非常低。而且会引起大量的gc
             this._ib.append(new Uint16Array(ib));
             this._ib.setNeedUpload();
             this.vertNum += sz;
             this.indexNum += ib.length;
         }
         /**
          * 把本对象放到回收池中，以便getMesh能用。
          */
         /*override*/ releaseMesh() {
             this._vb.setByteLength(0);
             this._ib.setByteLength(0);
             this.vertNum = 0;
             this.indexNum = 0;
             //_applied = false;
             MeshVG._POOL.push(this);
         }
         /*override*/ destroy() {
             this._ib.destroy();
             this._vb.destroy();
             this._ib.disposeResource();
             this._vb.deleteBuffer();
         }
     }
     MeshVG.const_stride = 12; // 36;
     MeshVG._fixattriInfo = [WebGLContext.FLOAT, 2, 0,
         WebGLContext.UNSIGNED_BYTE, 4, 8];
     MeshVG._POOL = [];

     /**
      * 对象 cacheas normal的时候，本质上只是想把submit缓存起来，以后直接执行
      * 为了避免各种各样的麻烦，这里采用复制相应部分的submit的方法。执行环境还是在原来的context中
      * 否则包括clip等都非常难以处理
      */
     class WebGLCacheAsNormalCanvas {
         constructor(ctx, sp) {
             this.submitStartPos = 0; // 对应的context的submit的开始的地方
             this.submitEndPos = 0;
             this.context = null;
             this.touches = []; //记录的文字信息。cacheas normal的话，文字要能正确touch
             this.submits = []; // 从context中剪切的submit
             this.sprite = null; // 对应的sprite对象
             this.meshlist = []; //本context用到的mesh
             // cache的时候对应的clip
             this.cachedClipInfo = new Matrix(); // 用来判断是否需要把cache无效
             //private var oldMatrix:Matrix = null;				//本地画的时候完全不应用矩阵，所以需要先保存老的，以便恢复		这样会丢失缩放信息，导致文字模糊，所以不用这种方式了
             this.oldTx = 0;
             this.oldTy = 0;
             // 创建这个canvas的时候对应的矩阵的逆矩阵。因为要保留矩阵的缩放信息。所以采用逆矩阵的方法。
             this.invMat = new Matrix();
             this.context = ctx;
             this.sprite = sp;
             ctx._globalClipMatrix.copyTo(this.cachedClipInfo);
         }
         startRec() {
             // 如果有文字优化，这里要先提交一下
             if (this.context._charSubmitCache._enbale) {
                 this.context._charSubmitCache.enable(false, this.context);
                 this.context._charSubmitCache.enable(true, this.context);
             }
             this.context._incache = true;
             this.touches.length = 0;
             //记录需要touch的文字资源
             this.context.touches = this.touches;
             this.context._globalClipMatrix.copyTo(this.cachedClipInfo);
             this.submits.length = 0;
             this.submitStartPos = this.context._submits._length;
             // 先把之前的释放掉
             for (var i = 0, sz = this.meshlist.length; i < sz; i++) {
                 var curm = this.meshlist[i];
                 curm.canReuse ? (curm.releaseMesh()) : (curm.destroy());
             }
             this.meshlist.length = 0;
             this._mesh = MeshQuadTexture.getAMesh(false);
             this._pathMesh = MeshVG.getAMesh(false);
             this._triangleMesh = MeshTexture.getAMesh(false);
             this.meshlist.push(this._mesh);
             this.meshlist.push(this._pathMesh);
             this.meshlist.push(this._triangleMesh);
             // 打断合并
             this.context._curSubmit = SubmitBase.RENDERBASE;
             // 接管context中的一些值
             this._oldMesh = this.context._mesh;
             this._oldPathMesh = this.context._pathMesh;
             this._oldTriMesh = this.context._triangleMesh;
             this._oldMeshList = this.context.meshlist;
             this.context._mesh = this._mesh;
             this.context._pathMesh = this._pathMesh;
             this.context._triangleMesh = this._triangleMesh;
             this.context.meshlist = this.meshlist;
             // 要取消位置，因为以后会再传入位置。这里好乱
             this.oldTx = this.context._curMat.tx;
             this.oldTy = this.context._curMat.ty;
             this.context._curMat.tx = 0;
             this.context._curMat.ty = 0;
             // 取消缩放等
             this.context._curMat.copyTo(this.invMat);
             this.invMat.invert();
             //oldMatrix = context._curMat;
             //context._curMat = matI;
         }
         endRec() {
             // 如果有文字优化，这里要先提交一下
             if (this.context._charSubmitCache._enbale) {
                 this.context._charSubmitCache.enable(false, this.context);
                 this.context._charSubmitCache.enable(true, this.context);
             }
             // copy submit
             var parsubmits = this.context._submits;
             this.submitEndPos = parsubmits._length;
             var num = this.submitEndPos - this.submitStartPos;
             for (var i = 0; i < num; i++) {
                 this.submits.push(parsubmits[this.submitStartPos + i]);
             }
             parsubmits._length -= num;
             // 恢复原始context的值
             this.context._mesh = this._oldMesh;
             this.context._pathMesh = this._oldPathMesh;
             this.context._triangleMesh = this._oldTriMesh;
             this.context.meshlist = this._oldMeshList;
             // 打断合并
             this.context._curSubmit = SubmitBase.RENDERBASE;
             // 恢复matrix
             //context._curMat = oldMatrix;
             this.context._curMat.tx = this.oldTx;
             this.context._curMat.ty = this.oldTy;
             this.context.touches = null;
             this.context._incache = false;
         }
         /**
          * 当前缓存是否还有效。例如clip变了就失效了，因为clip太难自动处理
          * @return
          */
         isCacheValid() {
             var curclip = this.context._globalClipMatrix;
             if (curclip.a != this.cachedClipInfo.a || curclip.b != this.cachedClipInfo.b || curclip.c != this.cachedClipInfo.c
                 || curclip.d != this.cachedClipInfo.d || curclip.tx != this.cachedClipInfo.tx || curclip.ty != this.cachedClipInfo.ty)
                 return false;
             return true;
         }
         flushsubmit() {
             var curSubmit = SubmitBase.RENDERBASE;
             this.submits.forEach(function (subm) {
                 if (subm == SubmitBase.RENDERBASE)
                     return;
                 SubmitBase.preRender = curSubmit;
                 curSubmit = subm;
                 subm.renderSubmit();
             });
         }
         releaseMem() {
         }
     }
     WebGLCacheAsNormalCanvas.matI = new Matrix();

     var texture_vs = "/*\r\n\ttexture和fillrect使用的。\r\n*/\r\nattribute vec4 posuv;\r\nattribute vec4 attribColor;\r\nattribute vec4 attribFlags;\r\n//attribute vec4 clipDir;\r\n//attribute vec2 clipRect;\r\nuniform vec4 clipMatDir;\r\nuniform vec2 clipMatPos;\t\t// 这个是全局的，不用再应用矩阵了。\r\nvarying vec2 cliped;\r\nuniform vec2 size;\r\nuniform vec2 clipOff;\t\t\t// 使用要把clip偏移。cacheas normal用. 只用了[0]\r\n#ifdef WORLDMAT\r\n\tuniform mat4 mmat;\r\n#endif\r\n#ifdef MVP3D\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\nvarying vec4 v_texcoordAlpha;\r\nvarying vec4 v_color;\r\nvarying float v_useTex;\r\n\r\nvoid main() {\r\n\r\n\tvec4 pos = vec4(posuv.xy,0.,1.);\r\n#ifdef WORLDMAT\r\n\tpos=mmat*pos;\r\n#endif\r\n\tvec4 pos1  =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,0.,1.0);\r\n#ifdef MVP3D\r\n\tgl_Position=u_MvpMatrix*pos1;\r\n#else\r\n\tgl_Position=pos1;\r\n#endif\r\n\tv_texcoordAlpha.xy = posuv.zw;\r\n\t//v_texcoordAlpha.z = attribColor.a/255.0;\r\n\tv_color = attribColor/255.0;\r\n\tv_color.xyz*=v_color.w;//反正后面也要预乘\r\n\t\r\n\tv_useTex = attribFlags.r/255.0;\r\n\tfloat clipw = length(clipMatDir.xy);\r\n\tfloat cliph = length(clipMatDir.zw);\r\n\t\r\n\tvec2 clpos = clipMatPos.xy;\r\n\t#ifdef WORLDMAT\r\n\t\t// 如果有mmat，需要修改clipMatPos,因为 这是cacheas normal （如果不是就错了）， clipMatPos被去掉了偏移\r\n\t\tif(clipOff[0]>0.0){\r\n\t\t\tclpos.x+=mmat[3].x;\t//tx\t最简单处理\r\n\t\t\tclpos.y+=mmat[3].y;\t//ty\r\n\t\t}\r\n\t#endif\r\n\tvec2 clippos = pos.xy - clpos;\t//pos已经应用矩阵了，为了减的有意义，clip的位置也要缩放\r\n\tif(clipw>20000. && cliph>20000.)\r\n\t\tcliped = vec2(0.5,0.5);\r\n\telse {\r\n\t\t//转成0到1之间。/clipw/clipw 表示clippos与normalize之后的clip朝向点积之后，再除以clipw\r\n\t\tcliped=vec2( dot(clippos,clipMatDir.xy)/clipw/clipw, dot(clippos,clipMatDir.zw)/cliph/cliph);\r\n\t}\r\n\r\n}";

     var texture_ps = "/*\r\n\ttexture和fillrect使用的。\r\n*/\r\n#ifdef FSHIGHPRECISION\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_texcoordAlpha;\r\nvarying vec4 v_color;\r\nvarying float v_useTex;\r\nuniform sampler2D texture;\r\nvarying vec2 cliped;\r\n\r\n#ifdef BLUR_FILTER\r\nuniform vec4 strength_sig2_2sig2_gauss1;\r\nuniform vec2 blurInfo;\r\n\r\n#define PI 3.141593\r\n\r\nfloat getGaussian(float x, float y){\r\n    return strength_sig2_2sig2_gauss1.w*exp(-(x*x+y*y)/strength_sig2_2sig2_gauss1.z);\r\n}\r\n\r\nvec4 blur(){\r\n    const float blurw = 9.0;\r\n    vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\r\n    vec2 halfsz=vec2(blurw,blurw)/2.0/blurInfo;    \r\n    vec2 startpos=v_texcoordAlpha.xy-halfsz;\r\n    vec2 ctexcoord = startpos;\r\n    vec2 step = 1.0/blurInfo;  //每个像素      \r\n    \r\n    for(float y = 0.0;y<=blurw; ++y){\r\n        ctexcoord.x=startpos.x;\r\n        for(float x = 0.0;x<=blurw; ++x){\r\n            //TODO 纹理坐标的固定偏移应该在vs中处理\r\n            vec4Color += texture2D(texture, ctexcoord)*getGaussian(x-blurw/2.0,y-blurw/2.0);\r\n            ctexcoord.x+=step.x;\r\n        }\r\n        ctexcoord.y+=step.y;\r\n    }\r\n    return vec4Color;\r\n}\r\n#endif\r\n\r\n#ifdef COLOR_FILTER\r\nuniform vec4 colorAlpha;\r\nuniform mat4 colorMat;\r\n#endif\r\n\r\n#ifdef GLOW_FILTER\r\nuniform vec4 u_color;\r\nuniform vec4 u_blurInfo1;\r\nuniform vec4 u_blurInfo2;\r\n#endif\r\n\r\n#ifdef COLOR_ADD\r\nuniform vec4 colorAdd;\r\n#endif\r\n\r\n#ifdef FILLTEXTURE\t\r\nuniform vec4 u_TexRange;//startu,startv,urange, vrange\r\n#endif\r\nvoid main() {\r\n\tif(cliped.x<0.) discard;\r\n\tif(cliped.x>1.) discard;\r\n\tif(cliped.y<0.) discard;\r\n\tif(cliped.y>1.) discard;\r\n\t\r\n#ifdef FILLTEXTURE\t\r\n   vec4 color= texture2D(texture, fract(v_texcoordAlpha.xy)*u_TexRange.zw + u_TexRange.xy);\r\n#else\r\n   vec4 color= texture2D(texture, v_texcoordAlpha.xy);\r\n#endif\r\n\r\n   if(v_useTex<=0.)color = vec4(1.,1.,1.,1.);\r\n   color.a*=v_color.w;\r\n   //color.rgb*=v_color.w;\r\n   color.rgb*=v_color.rgb;\r\n   gl_FragColor=color;\r\n   \r\n   #ifdef COLOR_ADD\r\n\tgl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\r\n\tgl_FragColor.xyz *= colorAdd.a;\r\n   #endif\r\n   \r\n   #ifdef BLUR_FILTER\r\n\tgl_FragColor =   blur();\r\n\tgl_FragColor.w*=v_color.w;   \r\n   #endif\r\n   \r\n   #ifdef COLOR_FILTER\r\n\tmat4 alphaMat =colorMat;\r\n\r\n\talphaMat[0][3] *= gl_FragColor.a;\r\n\talphaMat[1][3] *= gl_FragColor.a;\r\n\talphaMat[2][3] *= gl_FragColor.a;\r\n\r\n\tgl_FragColor = gl_FragColor * alphaMat;\r\n\tgl_FragColor += colorAlpha/255.0*gl_FragColor.a;\r\n   #endif\r\n   \r\n   #ifdef GLOW_FILTER\r\n\tconst float c_IterationTime = 10.0;\r\n\tfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\r\n\tvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\r\n\tvec2 vec2FilterDir = vec2(-(u_blurInfo1.z)/u_blurInfo2.x,-(u_blurInfo1.w)/u_blurInfo2.y);\r\n\tvec2 vec2FilterOff = vec2(u_blurInfo1.x/u_blurInfo2.x/c_IterationTime * 2.0,u_blurInfo1.y/u_blurInfo2.y/c_IterationTime * 2.0);\r\n\tfloat maxNum = u_blurInfo1.x * u_blurInfo1.y;\r\n\tvec2 vec2Off = vec2(0.0,0.0);\r\n\tfloat floatOff = c_IterationTime/2.0;\r\n\tfor(float i = 0.0;i<=c_IterationTime; ++i){\r\n\t\tfor(float j = 0.0;j<=c_IterationTime; ++j){\r\n\t\t\tvec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\r\n\t\t\tvec4Color += texture2D(texture, v_texcoordAlpha.xy + vec2FilterDir + vec2Off)/floatIterationTotalTime;\r\n\t\t}\r\n\t}\r\n\tgl_FragColor = vec4(u_color.rgb,vec4Color.a * u_blurInfo2.z);\r\n\tgl_FragColor.rgb *= gl_FragColor.a;   \r\n   #endif\r\n   \r\n}";

     var prime_vs = "attribute vec4 position;\r\nattribute vec4 attribColor;\r\n//attribute vec4 clipDir;\r\n//attribute vec2 clipRect;\r\nuniform vec4 clipMatDir;\r\nuniform vec2 clipMatPos;\r\n#ifdef WORLDMAT\r\n\tuniform mat4 mmat;\r\n#endif\r\nuniform mat4 u_mmat2;\r\n//uniform vec2 u_pos;\r\nuniform vec2 size;\r\nvarying vec4 color;\r\n//vec4 dirxy=vec4(0.9,0.1, -0.1,0.9);\r\n//vec4 clip=vec4(100.,30.,300.,600.);\r\nvarying vec2 cliped;\r\nvoid main(){\r\n\t\r\n#ifdef WORLDMAT\r\n\tvec4 pos=mmat*vec4(position.xy,0.,1.);\r\n\tgl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\r\n#else\r\n\tgl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\r\n#endif\t\r\n\tfloat clipw = length(clipMatDir.xy);\r\n\tfloat cliph = length(clipMatDir.zw);\r\n\tvec2 clippos = position.xy - clipMatPos.xy;\t//pos已经应用矩阵了，为了减的有意义，clip的位置也要缩放\r\n\tif(clipw>20000. && cliph>20000.)\r\n\t\tcliped = vec2(0.5,0.5);\r\n\telse {\r\n\t\t//clipdir是带缩放的方向，由于上面clippos是在缩放后的空间计算的，所以需要把方向先normalize一下\r\n\t\tcliped=vec2( dot(clippos,clipMatDir.xy)/clipw/clipw, dot(clippos,clipMatDir.zw)/cliph/cliph);\r\n\t}\r\n  //pos2d.x = dot(clippos,dirx);\r\n  color=attribColor/255.;\r\n}";

     var prime_ps = "precision mediump float;\r\n//precision mediump float;\r\nvarying vec4 color;\r\n//uniform float alpha;\r\nvarying vec2 cliped;\r\nvoid main(){\r\n\t//vec4 a=vec4(color.r, color.g, color.b, 1);\r\n\t//a.a*=alpha;\r\n    gl_FragColor= color;// vec4(color.r, color.g, color.b, alpha);\r\n\tgl_FragColor.rgb*=color.a;\r\n\tif(cliped.x<0.) discard;\r\n\tif(cliped.x>1.) discard;\r\n\tif(cliped.y<0.) discard;\r\n\tif(cliped.y>1.) discard;\r\n}";

     var skin_vs = "attribute vec2 position;\r\nattribute vec2 texcoord;\r\nattribute vec4 color;\r\nuniform vec2 size;\r\nuniform float offsetX;\r\nuniform float offsetY;\r\nuniform mat4 mmat;\r\nuniform mat4 u_mmat2;\r\nvarying vec2 v_texcoord;\r\nvarying vec4 v_color;\r\nvoid main() {\r\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\r\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\r\n  v_color = color;\r\n  v_color.rgb *= v_color.a;\r\n  v_texcoord = texcoord;  \r\n}";

     var skin_ps = "precision mediump float;\r\nvarying vec2 v_texcoord;\r\nvarying vec4 v_color;\r\nuniform sampler2D texture;\r\nuniform float alpha;\r\nvoid main() {\r\n\tvec4 t_color = texture2D(texture, v_texcoord);\r\n\tgl_FragColor = t_color.rgba * v_color;\r\n\tgl_FragColor *= alpha;\r\n}";

     class Shader2D {
         constructor() {
             this.ALPHA = 1;
             this.defines = new ShaderDefines2D();
             this.shaderType = 0;
             this.fillStyle = DrawStyle.DEFAULT;
             this.strokeStyle = DrawStyle.DEFAULT;
         }
         destroy() {
             this.defines = null;
             this.filters = null;
         }
         static __init__() {
             Shader.preCompile2D(0, ShaderDefines2D.TEXTURE2D, texture_vs, texture_ps, null);
             Shader.preCompile2D(0, ShaderDefines2D.PRIMITIVE, prime_vs, prime_ps, null);
             Shader.preCompile2D(0, ShaderDefines2D.SKINMESH, skin_vs, skin_ps, null);
         }
     }

     class SkinMeshBuffer {
         //TODO:coverage
         constructor() {
             this.ib = IndexBuffer2D.create(WebGLContext.DYNAMIC_DRAW);
             this.vb = VertexBuffer2D.create(8);
         }
         //TODO:coverage
         static getInstance() {
             return SkinMeshBuffer.instance = SkinMeshBuffer.instance || new SkinMeshBuffer();
         }
         //TODO:coverage
         addSkinMesh(skinMesh) {
             //skinMesh.getData(vb, ib, vb.byteLength / 32);
             skinMesh.getData2(this.vb, this.ib, this.vb._byteLength / 32);
         }
         reset() {
             this.vb.clear();
             this.ib.clear();
         }
     }

     class BasePoly {
         /**
          * 构造线的三角形数据。根据一个位置数组生成vb和ib
          * @param	p
          * @param	indices
          * @param	lineWidth
          * @param	indexBase				顶点开始的值，ib中的索引会加上这个
          * @param	outVertex
          * @return
          */
         static createLine2(p, indices, lineWidth, indexBase, outVertex, loop) {
             if (p.length < 4)
                 return null;
             var points = BasePoly.tempData.length > (p.length + 2) ? BasePoly.tempData : new Array(p.length + 2); //可能有loop，所以+2
             points[0] = p[0];
             points[1] = p[1];
             /*
             var points:Array = p.concat();
             if (loop) {
                 points.push(points[0], points[1]);
             }
             */
             var newlen = 2; //points的下标，也是points的实际长度
             var i = 0;
             var length = p.length;
             //先过滤一下太相近的点
             for (i = 2; i < length; i += 2) {
                 if (Math.abs(p[i] - p[i - 2]) + Math.abs(p[i + 1] - p[i - 1]) > 0.01) { //只是判断是否重合，所以不用sqrt
                     points[newlen++] = p[i];
                     points[newlen++] = p[i + 1];
                 }
             }
             //如果终点和起点没有重合，且要求loop的情况的处理
             if (loop && Math.abs(p[0] - points[newlen - 2]) + Math.abs(p[1] - points[newlen - 1]) > 0.01) {
                 points[newlen++] = p[0];
                 points[newlen++] = p[1];
             }
             var result = outVertex;
             length = newlen / 2; //points可能有多余的点，所以要用inew来表示
             var w = lineWidth / 2;
             var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
             var perpx, perpy, perp2x, perp2y;
             var a1, b1, c1, a2, b2, c2;
             var denom, dist;
             p1x = points[0];
             p1y = points[1];
             p2x = points[2];
             p2y = points[3];
             perpx = -(p1y - p2y);
             perpy = p1x - p2x;
             dist = Math.sqrt(perpx * perpx + perpy * perpy);
             perpx = perpx / dist * w;
             perpy = perpy / dist * w;
             result.push(p1x - perpx, p1y - perpy, p1x + perpx, p1y + perpy);
             for (i = 1; i < length - 1; i++) {
                 p1x = points[(i - 1) * 2];
                 p1y = points[(i - 1) * 2 + 1];
                 p2x = points[(i) * 2];
                 p2y = points[(i) * 2 + 1];
                 p3x = points[(i + 1) * 2];
                 p3y = points[(i + 1) * 2 + 1];
                 perpx = -(p1y - p2y);
                 perpy = p1x - p2x;
                 dist = Math.sqrt(perpx * perpx + perpy * perpy);
                 perpx = perpx / dist * w;
                 perpy = perpy / dist * w;
                 perp2x = -(p2y - p3y);
                 perp2y = p2x - p3x;
                 dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                 perp2x = perp2x / dist * w;
                 perp2y = perp2y / dist * w;
                 a1 = (-perpy + p1y) - (-perpy + p2y);
                 b1 = (-perpx + p2x) - (-perpx + p1x);
                 c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                 a2 = (-perp2y + p3y) - (-perp2y + p2y);
                 b2 = (-perp2x + p2x) - (-perp2x + p3x);
                 c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                 denom = a1 * b2 - a2 * b1;
                 if (Math.abs(denom) < 0.1) {
                     denom += 10.1;
                     result.push(p2x - perpx, p2y - perpy, p2x + perpx, p2y + perpy);
                     continue;
                 }
                 px = (b1 * c2 - b2 * c1) / denom;
                 py = (a2 * c1 - a1 * c2) / denom;
                 result.push(px, py, p2x - (px - p2x), p2y - (py - p2y));
             }
             p1x = points[newlen - 4];
             p1y = points[newlen - 3];
             p2x = points[newlen - 2];
             p2y = points[newlen - 1];
             perpx = -(p1y - p2y);
             perpy = p1x - p2x;
             dist = Math.sqrt(perpx * perpx + perpy * perpy);
             perpx = perpx / dist * w;
             perpy = perpy / dist * w;
             result.push(p2x - perpx, p2y - perpy, p2x + perpx, p2y + perpy);
             for (i = 1; i < length; i++) {
                 indices.push(indexBase + (i - 1) * 2, indexBase + (i - 1) * 2 + 1, indexBase + i * 2 + 1, indexBase + i * 2 + 1, indexBase + i * 2, indexBase + (i - 1) * 2);
             }
             return result;
         }
         /**
          * 相邻的两段线，边界会相交，这些交点可以作为三角形的顶点。有两种可选，一种是采用左左,右右交点，一种是采用 左右，左右交点。当两段线夹角很小的时候，如果采用
          * 左左，右右会产生很长很长的交点，这时候就要采用左右左右交点，相当于把尖角截断。
          * 当采用左左右右交点的时候，直接用切线的垂线。采用左右左右的时候，用切线
          * 切线直接采用两个方向的平均值。不能用3-1的方式，那样垂线和下一段可能都在同一方向（例如都在右方）
          * 注意把重合的点去掉
          * @param	path
          * @param	color
          * @param	width
          * @param	loop
          * @param	outvb
          * @param	vbstride  顶点占用几个float,(bytelength/4)
          * @param	outib
          * test:
          * 横线
          * [100,100, 400,100]
          * 竖线
          * [100,100, 100,400]
          * 直角
          * [100,100, 400,100, 400,400]
          * 重合点
          * [100,100,100,100,400,100]
          * 同一直线上的点
          * [100,100,100,200,100,3000]
          * 像老式电视的左边不封闭的图形
          * [98,176,  163,178, 95,66, 175,177, 198,178, 252,56, 209,178,  248,175,  248,266,  209,266, 227,277, 203,280, 188,271,  150,271, 140,283, 122,283, 131,268, 99,268]
          *
          */
         //TODO:coverage
         static createLineTriangle(path, color, width, loop, outvb, vbstride, outib) {
             var points = path.slice();
             var ptlen = points.length;
             var p1x = points[0], p1y = points[1];
             var p2x = points[2], p2y = points[2];
             var len = 0;
             var rp = 0;
             var dx = 0, dy = 0;
             //计算每一段的长度，取出有效数据。保存:长度，方向，拐角，切线
             //x,y,len,dx,dy,tx,ty,dot
             //数组中每个都表示当前点开始的长度，方向
             //x,y,dx,dy
             var pointnum = ptlen / 2;
             if (pointnum <= 1)
                 return;
             if (pointnum == 2) {
                 //TODO
                 return;
             }
             var tmpData = new Array(pointnum * 4); //TODO 做到外面
             var realPtNum = 0; //去掉重复点后的实际点个数。同一直线上的点不做优化
             //var segNum:int = pointnum + (loop?1:0);
             var ci = 0;
             for (var i = 0; i < pointnum - 1; i++) {
                 p1x = points[ci++], p1y = points[ci++];
                 p2x = points[ci++], p2y = points[ci++];
                 dx = p2x - p1x, dy = p2y - p1y;
                 if (dx != 0 && dy != 0) {
                     len = Math.sqrt(dx * dx + dy * dy);
                     if (len > 1e-3) {
                         rp = realPtNum * 4;
                         tmpData[rp] = p1x;
                         tmpData[rp + 1] = p1y;
                         tmpData[rp + 2] = dx / len;
                         tmpData[rp + 3] = dy / len;
                         realPtNum++;
                     }
                 }
             }
             if (loop) { //loop的话，需要取第一个点来算
                 p1x = points[ptlen - 2], p1y = points[ptlen - 1];
                 p2x = points[0], p2y = points[1];
                 dx = p2x - p1x, dy = p2y - p1y;
                 if (dx != 0 && dy != 0) { //如果长度为零的话，最后这个点就不用加了，上一个点就是指向了第一个点。
                     len = Math.sqrt(dx * dx + dy * dy);
                     if (len > 1e-3) {
                         rp = realPtNum * 4;
                         tmpData[rp] = p1x;
                         tmpData[rp + 1] = p1y;
                         tmpData[rp + 2] = dx / len;
                         tmpData[rp + 3] = dy / len;
                         realPtNum++;
                     }
                 }
             }
             else { //不是loop的话，直接取当前段的朝向，记录在上一个点上
                 rp = realPtNum * 4;
                 tmpData[rp] = p1x;
                 tmpData[rp + 1] = p1y;
                 tmpData[rp + 2] = dx / len;
                 tmpData[rp + 3] = dy / len;
                 realPtNum++;
             }
             ci = 0;
             /**
              * 根据前后两段的方向，计算垂线的方向，根据这个方向和任意一边的dxdy的垂线的点积为w/2可以得到长度。就可以得到增加的点
              */
             //如果相邻两段朝向的dot值接近-1，则表示反向了，需要改成切
             for (i = 0; i < pointnum; i++) {
                 p1x = points[ci], p1y = points[ci + 1];
                 p2x = points[ci + 2], p2y = points[ci + 3];
                 var p3x = points[ci + 4], p3y = points[ci + 5];
             }
         }
     }
     BasePoly.tempData = new Array(256);

     class EarcutNode {
         constructor(i, x, y) {
             // vertice index in coordinates array
             this.i = i;
             // vertex coordinates
             this.x = x;
             this.y = y;
             // previous and next vertice nodes in a polygon ring
             this.prev = null;
             this.next = null;
             // z-order curve value
             this.z = null;
             // previous and next nodes in z-order
             this.prevZ = null;
             this.nextZ = null;
             // indicates whether this is a steiner point
             this.steiner = false;
         }
     }

     class Earcut {
         static earcut(data, holeIndices, dim) {
             dim = dim || 2;
             var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = Earcut.linkedList(data, 0, outerLen, dim, true), triangles = [];
             if (!outerNode)
                 return triangles;
             var minX, minY, maxX, maxY, x, y, invSize;
             if (hasHoles)
                 outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim);
             // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
             if (data.length > 80 * dim) {
                 minX = maxX = data[0];
                 minY = maxY = data[1];
                 for (var i = dim; i < outerLen; i += dim) {
                     x = data[i];
                     y = data[i + 1];
                     if (x < minX)
                         minX = x;
                     if (y < minY)
                         minY = y;
                     if (x > maxX)
                         maxX = x;
                     if (y > maxY)
                         maxY = y;
                 }
                 // minX, minY and invSize are later used to transform coords into integers for z-order calculation
                 invSize = Math.max(maxX - minX, maxY - minY);
                 invSize = invSize !== 0 ? 1 / invSize : 0;
             }
             Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
             return triangles;
         }
         // create a circular doubly linked list from polygon points in the specified winding order
         static linkedList(data, start, end, dim, clockwise) {
             var i, last;
             if (clockwise === (Earcut.signedArea(data, start, end, dim) > 0)) {
                 for (i = start; i < end; i += dim)
                     last = Earcut.insertNode(i, data[i], data[i + 1], last);
             }
             else {
                 for (i = end - dim; i >= start; i -= dim)
                     last = Earcut.insertNode(i, data[i], data[i + 1], last);
             }
             if (last && Earcut.equals(last, last.next)) {
                 Earcut.removeNode(last);
                 last = last.next;
             }
             return last;
         }
         // eliminate colinear or duplicate points
         static filterPoints(start, end) {
             if (!start)
                 return start;
             if (!end)
                 end = start;
             var p = start, again;
             do {
                 again = false;
                 if (!p.steiner && (Earcut.equals(p, p.next) || Earcut.area(p.prev, p, p.next) === 0)) {
                     Earcut.removeNode(p);
                     p = end = p.prev;
                     if (p === p.next)
                         break;
                     again = true;
                 }
                 else {
                     p = p.next;
                 }
             } while (again || p !== end);
             return end;
         }
         // main ear slicing loop which triangulates a polygon (given as a linked list)
         static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
             if (!ear)
                 return;
             // interlink polygon nodes in z-order
             if (!pass && invSize)
                 Earcut.indexCurve(ear, minX, minY, invSize);
             var stop = ear, prev, next;
             // iterate through ears, slicing them one by one
             while (ear.prev !== ear.next) {
                 prev = ear.prev;
                 next = ear.next;
                 if (invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) {
                     // cut off the triangle
                     triangles.push(prev.i / dim);
                     triangles.push(ear.i / dim);
                     triangles.push(next.i / dim);
                     Earcut.removeNode(ear);
                     // skipping the next vertice leads to less sliver triangles
                     ear = next.next;
                     stop = next.next;
                     continue;
                 }
                 ear = next;
                 // if we looped through the whole remaining polygon and can't find any more ears
                 if (ear === stop) {
                     // try filtering points and slicing again
                     if (!pass) {
                         Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
                         // if this didn't work, try curing all small self-intersections locally
                     }
                     else if (pass === 1) {
                         ear = Earcut.cureLocalIntersections(ear, triangles, dim);
                         Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                         // as a last resort, try splitting the remaining polygon into two
                     }
                     else if (pass === 2) {
                         Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                     }
                     break;
                 }
             }
         }
         // check whether a polygon node forms a valid ear with adjacent nodes
         static isEar(ear) {
             var a = ear.prev, b = ear, c = ear.next;
             if (Earcut.area(a, b, c) >= 0)
                 return false; // reflex, can't be an ear
             // now make sure we don't have other points inside the potential ear
             var p = ear.next.next;
             while (p !== ear.prev) {
                 if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                     Earcut.area(p.prev, p, p.next) >= 0)
                     return false;
                 p = p.next;
             }
             return true;
         }
         //TODO:coverage
         static isEarHashed(ear, minX, minY, invSize) {
             var a = ear.prev, b = ear, c = ear.next;
             if (Earcut.area(a, b, c) >= 0)
                 return false; // reflex, can't be an ear
             // triangle bbox; min & max are calculated like this for speed
             var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
             // z-order range for the current triangle bbox;
             var minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize), maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize);
             // first look for points inside the triangle in increasing z-order
             var p = ear.nextZ;
             while (p && p.z <= maxZ) {
                 if (p !== ear.prev && p !== ear.next &&
                     Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                     Earcut.area(p.prev, p, p.next) >= 0)
                     return false;
                 p = p.nextZ;
             }
             // then look for points in decreasing z-order
             p = ear.prevZ;
             while (p && p.z >= minZ) {
                 if (p !== ear.prev && p !== ear.next &&
                     Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                     Earcut.area(p.prev, p, p.next) >= 0)
                     return false;
                 p = p.prevZ;
             }
             return true;
         }
         // go through all polygon nodes and cure small local self-intersections
         //TODO:coverage
         static cureLocalIntersections(start, triangles, dim) {
             var p = start;
             do {
                 var a = p.prev, b = p.next.next;
                 if (!Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a)) {
                     triangles.push(a.i / dim);
                     triangles.push(p.i / dim);
                     triangles.push(b.i / dim);
                     // remove two nodes involved
                     Earcut.removeNode(p);
                     Earcut.removeNode(p.next);
                     p = start = b;
                 }
                 p = p.next;
             } while (p !== start);
             return p;
         }
         // try splitting polygon into two and triangulate them independently
         //TODO:coverage
         static splitEarcut(start, triangles, dim, minX, minY, invSize) {
             // look for a valid diagonal that divides the polygon into two
             var a = start;
             do {
                 var b = a.next.next;
                 while (b !== a.prev) {
                     if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {
                         // split the polygon in two by the diagonal
                         var c = Earcut.splitPolygon(a, b);
                         // filter colinear points around the cuts
                         a = Earcut.filterPoints(a, a.next);
                         c = Earcut.filterPoints(c, c.next);
                         // run earcut on each half
                         Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize);
                         Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize);
                         return;
                     }
                     b = b.next;
                 }
                 a = a.next;
             } while (a !== start);
         }
         // link every hole into the outer loop, producing a single-ring polygon without holes
         //TODO:coverage
         static eliminateHoles(data, holeIndices, outerNode, dim) {
             var queue = [], i, len, start, end, list;
             for (i = 0, len = holeIndices.length; i < len; i++) {
                 start = holeIndices[i] * dim;
                 end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                 list = Earcut.linkedList(data, start, end, dim, false);
                 if (list === list.next)
                     list.steiner = true;
                 queue.push(Earcut.getLeftmost(list));
             }
             queue.sort(Earcut.compareX);
             // process holes from left to right
             for (i = 0; i < queue.length; i++) {
                 Earcut.eliminateHole(queue[i], outerNode);
                 outerNode = Earcut.filterPoints(outerNode, outerNode.next);
             }
             return outerNode;
         }
         //TODO:coverage
         static compareX(a, b) {
             return a.x - b.x;
         }
         // find a bridge between vertices that connects hole with an outer ring and and link it
         //TODO:coverage
         static eliminateHole(hole, outerNode) {
             outerNode = Earcut.findHoleBridge(hole, outerNode);
             if (outerNode) {
                 var b = Earcut.splitPolygon(outerNode, hole);
                 Earcut.filterPoints(b, b.next);
             }
         }
         // David Eberly's algorithm for finding a bridge between hole and outer polygon
         //TODO:coverage
         static findHoleBridge(hole, outerNode) {
             var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
             // find a segment intersected by a ray from the hole's leftmost point to the left;
             // segment's endpoint with lesser x will be potential connection point
             do {
                 if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                     var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                     if (x <= hx && x > qx) {
                         qx = x;
                         if (x === hx) {
                             if (hy === p.y)
                                 return p;
                             if (hy === p.next.y)
                                 return p.next;
                         }
                         m = p.x < p.next.x ? p : p.next;
                     }
                 }
                 p = p.next;
             } while (p !== outerNode);
             if (!m)
                 return null;
             if (hx === qx)
                 return m.prev; // hole touches outer segment; pick lower endpoint
             // look for points inside the triangle of hole point, segment intersection and endpoint;
             // if there are no points found, we have a valid connection;
             // otherwise choose the point of the minimum angle with the ray as connection point
             var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
             p = m.next;
             while (p !== stop) {
                 if (hx >= p.x && p.x >= mx && hx !== p.x &&
                     Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                     tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                     if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Earcut.locallyInside(p, hole)) {
                         m = p;
                         tanMin = tan;
                     }
                 }
                 p = p.next;
             }
             return m;
         }
         // interlink polygon nodes in z-order
         //TODO:coverage
         static indexCurve(start, minX, minY, invSize) {
             var p = start;
             do {
                 if (p.z === null)
                     p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize);
                 p.prevZ = p.prev;
                 p.nextZ = p.next;
                 p = p.next;
             } while (p !== start);
             p.prevZ.nextZ = null;
             p.prevZ = null;
             Earcut.sortLinked(p);
         }
         // Simon Tatham's linked list merge sort algorithm
         // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
         //TODO:coverage
         static sortLinked(list) {
             var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
             do {
                 p = list;
                 list = null;
                 tail = null;
                 numMerges = 0;
                 while (p) {
                     numMerges++;
                     q = p;
                     pSize = 0;
                     for (i = 0; i < inSize; i++) {
                         pSize++;
                         q = q.nextZ;
                         if (!q)
                             break;
                     }
                     qSize = inSize;
                     while (pSize > 0 || (qSize > 0 && q)) {
                         if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                             e = p;
                             p = p.nextZ;
                             pSize--;
                         }
                         else {
                             e = q;
                             q = q.nextZ;
                             qSize--;
                         }
                         if (tail)
                             tail.nextZ = e;
                         else
                             list = e;
                         e.prevZ = tail;
                         tail = e;
                     }
                     p = q;
                 }
                 tail.nextZ = null;
                 inSize *= 2;
             } while (numMerges > 1);
             return list;
         }
         // z-order of a point given coords and inverse of the longer side of data bbox
         //TODO:coverage
         static zOrder(x, y, minX, minY, invSize) {
             // coords are transformed into non-negative 15-bit integer range
             x = 32767 * (x - minX) * invSize;
             y = 32767 * (y - minY) * invSize;
             x = (x | (x << 8)) & 0x00FF00FF;
             x = (x | (x << 4)) & 0x0F0F0F0F;
             x = (x | (x << 2)) & 0x33333333;
             x = (x | (x << 1)) & 0x55555555;
             y = (y | (y << 8)) & 0x00FF00FF;
             y = (y | (y << 4)) & 0x0F0F0F0F;
             y = (y | (y << 2)) & 0x33333333;
             y = (y | (y << 1)) & 0x55555555;
             return x | (y << 1);
         }
         // find the leftmost node of a polygon ring
         //TODO:coverage
         static getLeftmost(start) {
             var p = start, leftmost = start;
             do {
                 if (p.x < leftmost.x)
                     leftmost = p;
                 p = p.next;
             } while (p !== start);
             return leftmost;
         }
         // check if a point lies within a convex triangle
         static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
             return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                 (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                 (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
         }
         // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
         //TODO:coverage
         static isValidDiagonal(a, b) {
             return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) &&
                 Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b);
         }
         // signed area of a triangle
         static area(p, q, r) {
             return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
         }
         // check if two points are equal
         static equals(p1, p2) {
             return p1.x === p2.x && p1.y === p2.y;
         }
         // check if two segments intersect
         //TODO:coverage
         static intersects(p1, q1, p2, q2) {
             if ((Earcut.equals(p1, q1) && Earcut.equals(p2, q2)) ||
                 (Earcut.equals(p1, q2) && Earcut.equals(p2, q1)))
                 return true;
             return Earcut.area(p1, q1, p2) > 0 !== Earcut.area(p1, q1, q2) > 0 &&
                 Earcut.area(p2, q2, p1) > 0 !== Earcut.area(p2, q2, q1) > 0;
         }
         // check if a polygon diagonal intersects any polygon segments
         //TODO:coverage
         static intersectsPolygon(a, b) {
             var p = a;
             do {
                 if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                     Earcut.intersects(p, p.next, a, b))
                     return true;
                 p = p.next;
             } while (p !== a);
             return false;
         }
         // check if a polygon diagonal is locally inside the polygon
         //TODO:coverage
         static locallyInside(a, b) {
             return Earcut.area(a.prev, a, a.next) < 0 ?
                 Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 :
                 Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0;
         }
         // check if the middle point of a polygon diagonal is inside the polygon
         //TODO:coverage
         static middleInside(a, b) {
             var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
             do {
                 if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                     (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                     inside = !inside;
                 p = p.next;
             } while (p !== a);
             return inside;
         }
         // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
         // if one belongs to the outer ring and another to a hole, it merges it into a single ring
         //TODO:coverage
         static splitPolygon(a, b) {
             var a2 = new EarcutNode(a.i, a.x, a.y), b2 = new EarcutNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
             a.next = b;
             b.prev = a;
             a2.next = an;
             an.prev = a2;
             b2.next = a2;
             a2.prev = b2;
             bp.next = b2;
             b2.prev = bp;
             return b2;
         }
         // create a node and optionally link it with previous one (in a circular doubly linked list)
         static insertNode(i, x, y, last) {
             var p = new EarcutNode(i, x, y);
             if (!last) {
                 p.prev = p;
                 p.next = p;
             }
             else {
                 p.next = last.next;
                 p.prev = last;
                 last.next.prev = p;
                 last.next = p;
             }
             return p;
         }
         static removeNode(p) {
             p.next.prev = p.prev;
             p.prev.next = p.next;
             if (p.prevZ)
                 p.prevZ.nextZ = p.nextZ;
             if (p.nextZ)
                 p.nextZ.prevZ = p.prevZ;
         }
         // return a percentage difference between the polygon area and its triangulation area;
         // used to verify correctness of triangulation
         /*earcut.deviation = function (data, holeIndices, dim, triangles) {
             var hasHoles = holeIndices && holeIndices.length;
             var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
         
             var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
             if (hasHoles) {
                 for (var i = 0, len = holeIndices.length; i < len; i++) {
                     var start = holeIndices[i] * dim;
                     var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                     polygonArea -= Math.abs(signedArea(data, start, end, dim));
                 }
             }
         
             var trianglesArea = 0;
             for (i = 0; i < triangles.length; i += 3) {
                 var a = triangles[i] * dim;
                 var b = triangles[i + 1] * dim;
                 var c = triangles[i + 2] * dim;
                 trianglesArea += Math.abs(
                     (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                     (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
             }
         
             return polygonArea === 0 && trianglesArea === 0 ? 0 :
                 Math.abs((trianglesArea - polygonArea) / polygonArea);
         };*/
         static signedArea(data, start, end, dim) {
             var sum = 0;
             for (var i = start, j = end - dim; i < end; i += dim) {
                 sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                 j = i;
             }
             return sum;
         }
     }

     class CONST3D2D {
     }
     CONST3D2D.BYTES_PE = 4;
     CONST3D2D.BYTES_PIDX = 2;
     CONST3D2D.defaultMatrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
     CONST3D2D.defaultMinusYMatrix4 = [1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
     CONST3D2D.uniformMatrix3 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0];
     CONST3D2D._TMPARRAY = [];
     CONST3D2D._OFFSETX = 0;
     CONST3D2D._OFFSETY = 0;

     class Submit extends SubmitBase {
         constructor(renderType = SubmitBase.TYPE_2D) {
             super(renderType);
         }
         /*override*/ renderSubmit() {
             if (this._numEle === 0 || !this._mesh || this._numEle == 0)
                 return 1; //怎么会有_numEle是0的情况?
             var _tex = this.shaderValue.textureHost;
             if (_tex) {
                 var source = _tex._getSource();
                 if (!source)
                     return 1;
                 this.shaderValue.texture = source;
             }
             var gl = WebGLContext.mainContext;
             this._mesh.useMesh(gl);
             //_ib._bind_upload() || _ib._bind();
             //_vb._bind_upload() || _vb._bind();
             this.shaderValue.upload();
             if (BlendMode.activeBlendFunction !== this._blendFn) {
                 WebGLContext.setBlend(gl, true);
                 this._blendFn(gl);
                 BlendMode.activeBlendFunction = this._blendFn;
             }
             gl.drawElements(WebGLContext.TRIANGLES, this._numEle, WebGLContext.UNSIGNED_SHORT, this._startIdx);
             Stat.renderBatches++;
             Stat.trianglesFaces += this._numEle / 3;
             return 1;
         }
         /*override*/ releaseRender() {
             if (SubmitBase.RENDERBASE == this)
                 return;
             if ((--this._ref) < 1) {
                 Submit.POOL[Submit._poolSize++] = this;
                 this.shaderValue.release();
                 this.shaderValue = null;
                 //_vb = null;
                 //_mesh.destroy();
                 this._mesh = null;
                 this._parent && (this._parent.releaseRender(), this._parent = null);
             }
         }
         /*
            create方法只传对submit设置的值
          */
         static create(context, mesh, sv) {
             var o = Submit._poolSize ? Submit.POOL[--Submit._poolSize] : new Submit();
             o._ref = 1;
             o._mesh = mesh;
             o._key.clear();
             o._startIdx = mesh.indexNum * CONST3D2D.BYTES_PIDX;
             o._numEle = 0;
             var blendType = context._nBlendType;
             o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
             o.shaderValue = sv;
             o.shaderValue.setValue(context._shader2D);
             var filters = context._shader2D.filters;
             filters && o.shaderValue.setFilters(filters);
             return o;
         }
         /**
          * 创建一个矢量submit
          * @param	ctx
          * @param	mesh
          * @param	numEle		对应drawElement的第二个参数:count
          * @param	offset		drawElement的时候的ib的偏移。
          * @param	sv			Value2D
          * @return
          */
         static createShape(ctx, mesh, numEle, sv) {
             var o = Submit._poolSize ? Submit.POOL[--Submit._poolSize] : (new Submit());
             o._mesh = mesh;
             o._numEle = numEle;
             o._startIdx = mesh.indexNum * 2;
             o._ref = 1;
             o.shaderValue = sv;
             o.shaderValue.setValue(ctx._shader2D);
             var blendType = ctx._nBlendType;
             o._key.blendShader = blendType;
             o._blendFn = ctx._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
             return o;
         }
     }
     Submit._poolSize = 0;
     Submit.POOL = [];

     /**
      * cache as normal 模式下的生成的canvas的渲染。
      */
     class SubmitCanvas extends SubmitBase {
         constructor() {
             super(SubmitBase.TYPE_2D);
             this._matrix = new Matrix(); // 用来计算当前的世界矩阵
             this._matrix4 = CONST3D2D.defaultMatrix4.concat();
             this.shaderValue = new Value2D(0, 0);
         }
         static create(canvas, alpha, filters) {
             var o = (!SubmitCanvas.POOL._length) ? (new SubmitCanvas()) : SubmitCanvas.POOL[--SubmitCanvas.POOL._length];
             o.canv = canvas;
             o._ref = 1;
             o._numEle = 0;
             var v = o.shaderValue;
             v.alpha = alpha;
             v.defines.setValue(0);
             filters && filters.length && v.setFilters(filters);
             return o;
         }
         /*override*/ renderSubmit() {
             // 下面主要是为了给canvas设置矩阵。因为canvas保存的是没有偏移的。
             var preAlpha = RenderState2D.worldAlpha;
             var preMatrix4 = RenderState2D.worldMatrix4;
             var preMatrix = RenderState2D.worldMatrix;
             var preFilters = RenderState2D.worldFilters;
             var preWorldShaderDefines = RenderState2D.worldShaderDefines;
             var v = this.shaderValue;
             var m = this._matrix;
             var m4 = this._matrix4;
             var mout = Matrix.TEMP;
             Matrix.mul(m, preMatrix, mout);
             m4[0] = mout.a;
             m4[1] = mout.b;
             m4[4] = mout.c;
             m4[5] = mout.d;
             m4[12] = mout.tx;
             m4[13] = mout.ty;
             RenderState2D.worldMatrix = mout.clone();
             RenderState2D.worldMatrix4 = m4;
             RenderState2D.worldAlpha = RenderState2D.worldAlpha * v.alpha;
             if (v.filters && v.filters.length) {
                 RenderState2D.worldFilters = v.filters;
                 RenderState2D.worldShaderDefines = v.defines;
             }
             this.canv['flushsubmit']();
             RenderState2D.worldAlpha = preAlpha;
             RenderState2D.worldMatrix4 = preMatrix4;
             RenderState2D.worldMatrix.destroy();
             RenderState2D.worldMatrix = preMatrix;
             RenderState2D.worldFilters = preFilters;
             RenderState2D.worldShaderDefines = preWorldShaderDefines;
             return 1;
         }
         /*override*/ releaseRender() {
             if ((--this._ref) < 1) {
                 var cache = SubmitCanvas.POOL;
                 //_vb = null;
                 this._mesh = null;
                 cache[cache._length++] = this;
             }
         }
         /*override*/ getRenderType() {
             return SubmitBase.TYPE_CANVAS;
         }
         ;
     }
     SubmitCanvas.POOL = [];
     {
         SubmitCanvas.POOL._length = 0;
     }

     class SubmitTarget {
         constructor() {
             this.blendType = 0;
             this._ref = 1;
             this._key = new SubmitKey();
         }
         renderSubmit() {
             var gl = WebGLContext.mainContext;
             this._mesh.useMesh(gl);
             var target = this.srcRT;
             if (target) { //??为什么会出现为空的情况
                 this.shaderValue.texture = target._getSource();
                 this.shaderValue.upload();
                 this.blend();
                 Stat.renderBatches++;
                 Stat.trianglesFaces += this._numEle / 3;
                 WebGLContext.mainContext.drawElements(WebGLContext.TRIANGLES, this._numEle, WebGLContext.UNSIGNED_SHORT, this._startIdx);
             }
             return 1;
         }
         blend() {
             if (BlendMode.activeBlendFunction !== BlendMode.fns[this.blendType]) {
                 var gl = WebGLContext.mainContext;
                 gl.enable(WebGLContext.BLEND);
                 BlendMode.fns[this.blendType](gl);
                 BlendMode.activeBlendFunction = BlendMode.fns[this.blendType];
             }
         }
         getRenderType() {
             return 0;
         }
         releaseRender() {
             if ((--this._ref) < 1) {
                 var pool = SubmitTarget.POOL;
                 pool[pool._length++] = this;
             }
         }
         static create(context, mesh, sv, rt) {
             var o = SubmitTarget.POOL._length ? SubmitTarget.POOL[--SubmitTarget.POOL._length] : new SubmitTarget();
             o._mesh = mesh;
             o.srcRT = rt;
             o._startIdx = mesh.indexNum * CONST3D2D.BYTES_PIDX;
             o._ref = 1;
             o._key.clear();
             o._numEle = 0;
             o.blendType = context._nBlendType;
             o._key.blendShader = o.blendType;
             o.shaderValue = sv;
             o.shaderValue.setValue(context._shader2D);
             if (context._colorFiler) {
                 var ft = context._colorFiler;
                 sv.defines.add(ft.type);
                 sv.colorMat = ft._mat;
                 sv.colorAlpha = ft._alpha;
             }
             return o;
         }
     }
     SubmitTarget.POOL = [];
     {
         SubmitTarget.POOL._length = 0;
     }

     class SubmitTexture extends SubmitBase {
         constructor(renderType = SubmitBase.TYPE_2D) {
             super(renderType);
         }
         /*override*/ releaseRender() {
             if ((--this._ref) < 1) {
                 SubmitTexture.POOL[SubmitTexture._poolSize++] = this;
                 this.shaderValue.release();
                 //_vb = null;
                 this._mesh = null; //下次create会重新赋值。既然会重新赋值，那还设置干嘛
                 this._parent && (this._parent.releaseRender(), this._parent = null);
             }
         }
         /*override*/ renderSubmit() {
             if (this._numEle === 0)
                 return 1;
             var tex = this.shaderValue.textureHost;
             if (tex) { //现在fillrect也用的这个submit，所以不必要求有texture
                 var source = tex ? tex._getSource() : null;
                 if (!source)
                     return 1;
             }
             var gl = WebGLContext.mainContext;
             this._mesh.useMesh(gl);
             //如果shader参数都相同，只要提交texture就行了
             var lastSubmit = SubmitBase.preRender;
             var prekey = SubmitBase.preRender._key;
             if (this._key.blendShader === 0 && (this._key.submitType === prekey.submitType && this._key.blendShader === prekey.blendShader) && BaseShader.activeShader &&
                 SubmitBase.preRender.clipInfoID == this.clipInfoID &&
                 lastSubmit.shaderValue.defines._value === this.shaderValue.defines._value && //shader define要相同. 
                 (this.shaderValue.defines._value & ShaderDefines2D.NOOPTMASK) == 0 //只有基本类型的shader走这个，像blur，glow，filltexture等都不要这样优化
             ) {
                 BaseShader.activeShader.uploadTexture2D(source);
             }
             else {
                 if (BlendMode.activeBlendFunction !== this._blendFn) {
                     WebGLContext.setBlend(gl, true);
                     this._blendFn(gl);
                     BlendMode.activeBlendFunction = this._blendFn;
                 }
                 this.shaderValue.texture = source;
                 this.shaderValue.upload();
             }
             gl.drawElements(WebGLContext.TRIANGLES, this._numEle, WebGLContext.UNSIGNED_SHORT, this._startIdx);
             Stat.renderBatches++;
             Stat.trianglesFaces += this._numEle / 3;
             return 1;
         }
         /*
            create方法只传对submit设置的值
          */
         static create(context, mesh, sv) {
             var o = SubmitTexture._poolSize ? SubmitTexture.POOL[--SubmitTexture._poolSize] : new SubmitTexture(SubmitBase.TYPE_TEXTURE);
             o._mesh = mesh;
             o._key.clear();
             o._key.submitType = SubmitBase.KEY_DRAWTEXTURE;
             o._ref = 1;
             o._startIdx = mesh.indexNum * CONST3D2D.BYTES_PIDX;
             o._numEle = 0;
             var blendType = context._nBlendType;
             o._key.blendShader = blendType;
             o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
             o.shaderValue = sv;
             //sv.setValue(context._shader2D);
             if (context._colorFiler) {
                 var ft = context._colorFiler;
                 sv.defines.add(ft.type);
                 sv.colorMat = ft._mat;
                 sv.colorAlpha = ft._alpha;
             }
             return o;
         }
     }
     SubmitTexture._poolSize = 0;
     SubmitTexture.POOL = [];

     /**
      * ...
      * @author laoxie
      */
     class CharSubmitCache {
         constructor() {
             this._data = [];
             this._ndata = 0;
             this._clipid = -1;
             this._clipMatrix = new Matrix();
             this._enbale = false;
         }
         clear() {
             this._tex = null;
             this._imgId = -1;
             this._ndata = 0;
             this._enbale = false;
             this._colorFiler = null;
         }
         destroy() {
             this.clear();
             this._data.length = 0;
             this._data = null;
         }
         add(ctx, tex, imgid, pos, uv, color) {
             if (this._ndata > 0 && (this._tex != tex || this._imgId != imgid ||
                 (this._clipid >= 0 && this._clipid != ctx._clipInfoID))) {
                 this.submit(ctx);
             }
             this._clipid = ctx._clipInfoID;
             ctx._globalClipMatrix.copyTo(this._clipMatrix);
             this._tex = tex;
             this._imgId = imgid;
             this._colorFiler = ctx._colorFiler;
             this._data[this._ndata] = pos;
             this._data[this._ndata + 1] = uv;
             this._data[this._ndata + 2] = color;
             this._ndata += 3;
         }
         getPos() {
             if (CharSubmitCache.__nPosPool == 0)
                 return new Array(8);
             return CharSubmitCache.__posPool[--CharSubmitCache.__nPosPool];
         }
         enable(value, ctx) {
             if (value === this._enbale)
                 return;
             this._enbale = value;
             this._enbale || this.submit(ctx);
         }
         submit(ctx) {
             var n = this._ndata;
             if (!n)
                 return;
             var _mesh = ctx._mesh;
             var colorFiler = ctx._colorFiler;
             ctx._colorFiler = this._colorFiler;
             var submit = SubmitTexture.create(ctx, _mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
             ctx._submits[ctx._submits._length++] = ctx._curSubmit = submit;
             submit.shaderValue.textureHost = this._tex;
             submit._key.other = this._imgId;
             ctx._colorFiler = colorFiler;
             ctx._copyClipInfo(submit, this._clipMatrix);
             submit.clipInfoID = this._clipid;
             for (var i = 0; i < n; i += 3) {
                 _mesh.addQuad(this._data[i], this._data[i + 1], this._data[i + 2], true);
                 CharSubmitCache.__posPool[CharSubmitCache.__nPosPool++] = this._data[i];
             }
             n /= 3;
             submit._numEle += n * 6;
             _mesh.indexNum += n * 6;
             _mesh.vertNum += n * 4;
             ctx._drawCount += n;
             this._ndata = 0;
             if (RenderInfo.loopCount % 100 == 0)
                 this._data.length = 0;
         }
     }
     CharSubmitCache.__posPool = [];
     CharSubmitCache.__nPosPool = 0;

     // 注意长宽都不要超过256，一个是影响效率，一个是超出表达能力
     class AtlasGrid {
         // TODO type 是否有用
         //------------------------------------------------------------------------------
         constructor(width = 0, height = 0, id = 0) {
             this.atlasID = 0;
             this._width = 0;
             this._height = 0;
             this._texCount = 0;
             this._rowInfo = null; // 当前行的最大长度
             this._cells = null; // 每个格子的信息。{type,w,h} 相当于一个距离场. type =0 表示空闲的。不为0的情况下填充的是宽高（有什么用呢）
             this._used = 0; // 使用率
             this._cells = null;
             this._rowInfo = null;
             this.atlasID = id;
             this._init(width, height);
         }
         //------------------------------------------------------------------
         addRect(type, width, height, pt) {
             //调用获得应该放在哪 返回值有三个。。bRet是否成功，nX x位置，nY y位置
             if (!this._get(width, height, pt))
                 return false;
             //根据获得的x,y填充
             this._fill(pt.x, pt.y, width, height, type);
             this._texCount++;
             //返回是否成功，以及X位置和Y位置
             return true;
         }
         //------------------------------------------------------------------------------
         _release() {
             this._cells = null;
             this._rowInfo = null;
         }
         //------------------------------------------------------------------------------
         _init(width, height) {
             this._width = width;
             this._height = height;
             this._release();
             if (this._width == 0)
                 return false;
             this._cells = new Uint8Array(this._width * this._height * 3);
             this._rowInfo = new Uint8Array(this._height);
             this._used = 0;
             this._clear();
             return true;
         }
         //------------------------------------------------------------------
         _get(width, height, pt) {
             if (width > this._width || height > this._height) {
                 return false;
             }
             //定义返回的x,y的位置
             var rx = -1;
             var ry = -1;
             //为了效率先保存临时变量
             var nWidth = this._width;
             var nHeight = this._height;
             //定义一个变量为了指向 m_pCells
             var pCellBox = this._cells;
             //遍历查找合适的位置  //TODO 下面的方法应该可以优化
             for (var y = 0; y < nHeight; y++) {
                 //如果该行的空白数 小于 要放入的宽度返回
                 if (this._rowInfo[y] < width)
                     continue;
                 for (var x = 0; x < nWidth;) {
                     var tm = (y * nWidth + x) * 3;
                     if (pCellBox[tm] != 0 || pCellBox[tm + 1] < width || pCellBox[tm + 2] < height) {
                         x += pCellBox[tm + 1];
                         continue;
                     }
                     rx = x;
                     ry = y;
                     // 检查当前宽度是否能完全放下，即x方向的每个位置都有足够的高度。
                     for (var xx = 0; xx < width; xx++) {
                         if (pCellBox[3 * xx + tm + 2] < height) {
                             rx = -1;
                             break;
                         }
                     }
                     // 不行就x继续前进
                     if (rx < 0) {
                         x += pCellBox[tm + 1];
                         continue;
                     }
                     // 找到了
                     pt.x = rx;
                     pt.y = ry;
                     return true;
                 }
             }
             return false;
         }
         //------------------------------------------------------------------
         _fill(x, y, w, h, type) {
             //定义一些临时变量
             var nWidth = this._width;
             var nHeghit = this._height;
             //代码检查
             this._check((x + w) <= nWidth && (y + h) <= nHeghit);
             //填充
             for (var yy = y; yy < (h + y); ++yy) {
                 this._check(this._rowInfo[yy] >= w);
                 this._rowInfo[yy] -= w;
                 for (var xx = 0; xx < w; xx++) {
                     var tm = (x + yy * nWidth + xx) * 3;
                     this._check(this._cells[tm] == 0);
                     this._cells[tm] = type;
                     this._cells[tm + 1] = w;
                     this._cells[tm + 2] = h;
                 }
             }
             //调整我左方相邻空白格子的宽度连续信息描述
             if (x > 0) {
                 for (yy = 0; yy < h; ++yy) {
                     // TODO 下面应该可以优化
                     var s = 0;
                     for (xx = x - 1; xx >= 0; --xx, ++s) {
                         if (this._cells[((y + yy) * nWidth + xx) * 3] != 0)
                             break;
                     }
                     for (xx = s; xx > 0; --xx) {
                         this._cells[((y + yy) * nWidth + x - xx) * 3 + 1] = xx;
                         this._check(xx > 0);
                     }
                 }
             }
             //调整我上方相邻空白格子的高度连续信息描述
             if (y > 0) {
                 for (xx = x; xx < (x + w); ++xx) {
                     // TODO 下面应该可以优化
                     s = 0;
                     for (yy = y - 1; yy >= 0; --yy, s++) {
                         if (this._cells[(xx + yy * nWidth) * 3] != 0)
                             break;
                     }
                     for (yy = s; yy > 0; --yy) {
                         this._cells[(xx + (y - yy) * nWidth) * 3 + 2] = yy;
                         this._check(yy > 0);
                     }
                 }
             }
             this._used += (w * h) / (this._width * this._height);
         }
         _check(ret) {
             if (ret == false) {
                 console.log("xtexMerger 错误啦");
             }
         }
         //------------------------------------------------------------------
         _clear() {
             this._texCount = 0;
             for (var y = 0; y < this._height; y++) {
                 this._rowInfo[y] = this._width;
             }
             for (var i = 0; i < this._height; i++) {
                 for (var j = 0; j < this._width; j++) {
                     var tm = (i * this._width + j) * 3;
                     this._cells[tm] = 0;
                     this._cells[tm + 1] = this._width - j;
                     this._cells[tm + 2] = this._width - i;
                 }
             }
         }
     }

     //import { TextAtlas } from "././TextAtlas";
     class TextTexture extends Resource {
         //public var isIso:Boolean = false;
         constructor(textureW, textureH) {
             super();
             this._texW = 0;
             this._texH = 0;
             this.__destroyed = false; //父类有，但是private
             this._discardTm = 0; //释放的时间。超过一定时间会被真正删除
             this.genID = 0; // 这个对象会重新利用，为了能让引用他的人知道自己引用的是否有效，加个id
             this.bitmap = { id: 0, _glTexture: null }; //samekey的判断用的
             this.curUsedCovRate = 0; // 当前使用到的使用率。根据面积算的
             this.curUsedCovRateAtlas = 0; // 大图集中的占用率。由于大图集分辨率低，所以会浪费一些空间
             this.lastTouchTm = 0;
             this.ri = null; // 如果是独立文字贴图的话带有这个信息
             this._texW = textureW || TextTexture.gTextRender.atlasWidth;
             this._texH = textureH || TextTexture.gTextRender.atlasWidth;
             this.bitmap.id = this.id;
             this.lock = true; //防止被资源管理清除
         }
         recreateResource() {
             if (this._source)
                 return;
             var gl = ILaya.Render.isConchApp ? LayaGL.instance.getDefaultCommandEncoder() : WebGLContext.mainContext;
             var glTex = this._source = gl.createTexture();
             this.bitmap._glTexture = glTex;
             WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_2D, glTex);
             //gl.bindTexture(WebGLContext.TEXTURE_2D, glTex);
             //var sz:int = _width * _height * 4;
             //分配显存。
             gl.texImage2D(WebGLContext.TEXTURE_2D, 0, WebGLContext.RGBA, this._texW, this._texH, 0, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, null);
             gl.texParameteri(WebGLContext.TEXTURE_2D, WebGLContext.TEXTURE_MIN_FILTER, WebGLContext.LINEAR); //不能用点采样，否则旋转的时候，非常难看
             gl.texParameteri(WebGLContext.TEXTURE_2D, WebGLContext.TEXTURE_MAG_FILTER, WebGLContext.LINEAR);
             gl.texParameteri(WebGLContext.TEXTURE_2D, WebGLContext.TEXTURE_WRAP_S, WebGLContext.CLAMP_TO_EDGE);
             gl.texParameteri(WebGLContext.TEXTURE_2D, WebGLContext.TEXTURE_WRAP_T, WebGLContext.CLAMP_TO_EDGE);
             //TODO 预乘alpha
             if (TextTexture.gTextRender.debugUV) {
                 this.fillWhite();
             }
         }
         /**
          *
          * @param	data
          * @param	x			拷贝位置。
          * @param	y
          * @param  uv
          * @return uv数组  如果uv不为空就返回传入的uv，否则new一个数组
          */
         addChar(data, x, y, uv = null) {
             //if (!ILaya.Render.isConchApp &&  !__JS__('(data instanceof ImageData)')) {
             if (TextTexture.gTextRender.isWan1Wan) {
                 return this.addCharCanvas(data, x, y, uv);
             }
             !this._source && this.recreateResource();
             var gl = ILaya.Render.isConchApp ? LayaGL.instance.getDefaultCommandEncoder() : WebGLContext.mainContext;
             WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_2D, this._source);
             !ILaya.Render.isConchApp && gl.pixelStorei(WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
             var dt = data.data;
             if (data.data instanceof Uint8ClampedArray)
                 dt = new Uint8Array(dt.buffer);
             gl.texSubImage2D(WebGLContext.TEXTURE_2D, 0, x, y, data.width, data.height, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, dt);
             !ILaya.Render.isConchApp && gl.pixelStorei(WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
             var u0;
             var v0;
             var u1;
             var v1;
             if (ILaya.Render.isConchApp) {
                 u0 = x / this._texW; // +1 表示内缩一下，反正文字总是有留白。否则会受到旁边的一个像素的影响
                 v0 = y / this._texH;
                 u1 = (x + data.width) / this._texW; // 注意是-1,不是-2
                 v1 = (y + data.height) / this._texH;
             }
             else {
                 u0 = (x + 1) / this._texW; // +1 表示内缩一下，反正文字总是有留白。否则会受到旁边的一个像素的影响
                 v0 = (y) / this._texH;
                 u1 = (x + data.width - 1) / this._texW; // 注意是-1,不是-2
                 v1 = (y + data.height - 1) / this._texH;
             }
             uv = uv || new Array(8);
             uv[0] = u0, uv[1] = v0;
             uv[2] = u1, uv[3] = v0;
             uv[4] = u1, uv[5] = v1;
             uv[6] = u0, uv[7] = v1;
             return uv;
         }
         /**
          * 玩一玩不支持 getImageData
          * @param	canv
          * @param	x
          * @param	y
          */
         addCharCanvas(canv, x, y, uv = null) {
             !this._source && this.recreateResource();
             var gl = ILaya.Render.isConchApp ? LayaGL.instance.getDefaultCommandEncoder() : WebGLContext.mainContext;
             WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_2D, this._source);
             !ILaya.Render.isConchApp && gl.pixelStorei(WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
             gl.texSubImage2D(WebGLContext.TEXTURE_2D, 0, x, y, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, canv);
             !ILaya.Render.isConchApp && gl.pixelStorei(WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
             var u0;
             var v0;
             var u1;
             var v1;
             if (ILaya.Render.isConchApp) {
                 u0 = x / this._texW; // +1 表示内缩一下，反正文字总是有留白。否则会受到旁边的一个像素的影响
                 v0 = y / this._texH;
                 u1 = (x + canv.width) / this._texW;
                 v1 = (y + canv.height) / this._texH;
             }
             else {
                 u0 = (x + 1) / this._texW; // +1 表示内缩一下，反正文字总是有留白。否则会受到旁边的一个像素的影响
                 v0 = (y + 1) / this._texH;
                 u1 = (x + canv.width - 1) / this._texW;
                 v1 = (y + canv.height - 1) / this._texH;
             }
             uv = uv || new Array(8);
             uv[0] = u0, uv[1] = v0;
             uv[2] = u1, uv[3] = v0;
             uv[4] = u1, uv[5] = v1;
             uv[6] = u0, uv[7] = v1;
             return uv;
         }
         /**
          * 填充白色。调试用。
          */
         fillWhite() {
             !this._source && this.recreateResource();
             var gl = ILaya.Render.isConchApp ? LayaGL.instance.getDefaultCommandEncoder() : WebGLContext.mainContext;
             var dt = new Uint8Array(this._texW * this._texH * 4);
             dt.fill(0xff);
             gl.texSubImage2D(WebGLContext.TEXTURE_2D, 0, 0, 0, this._texW, this._texH, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, dt);
         }
         discard() {
             // 非标准大小不回收。
             if (this._texW != TextTexture.gTextRender.atlasWidth || this._texH != TextTexture.gTextRender.atlasWidth) {
                 this.destroy();
                 return;
             }
             this.genID++;
             if (TextTexture.poolLen >= TextTexture.pool.length) {
                 TextTexture.pool = TextTexture.pool.concat(new Array(10));
             }
             this._discardTm = RenderInfo.loopStTm;
             TextTexture.pool[TextTexture.poolLen++] = this;
         }
         static getTextTexture(w, h) {
             if (w != TextTexture.gTextRender.atlasWidth || w != TextTexture.gTextRender.atlasWidth)
                 return new TextTexture(w, h);
             // 否则从回收池中取
             if (TextTexture.poolLen > 0) {
                 var ret = TextTexture.pool[--TextTexture.poolLen];
                 if (TextTexture.poolLen > 0)
                     TextTexture.clean(); //给个clean的机会。
                 return ret;
             }
             return new TextTexture(w, h);
         }
         /*override*/ destroy() {
             //console.log('destroy TextTexture');
             this.__destroyed = true;
             var gl = ILaya.Render.isConchApp ? LayaGL.instance.getDefaultCommandEncoder() : WebGLContext.mainContext;
             this._source && gl.deleteTexture(this._source);
             this._source = null;
         }
         /**
          * 定期清理
          * 为了简单，只有发生 getAPage 或者 discardPage的时候才检测是否需要清理
          */
         static clean() {
             var curtm = RenderInfo.loopStTm; // Laya.stage.getFrameTm();
             if (TextTexture.cleanTm === 0)
                 TextTexture.cleanTm = curtm;
             if (curtm - TextTexture.cleanTm >= TextTexture.gTextRender.checkCleanTextureDt) { //每10秒看看pool中的贴图有没有很老的可以删除的
                 for (var i = 0; i < TextTexture.poolLen; i++) {
                     var p = TextTexture.pool[i];
                     if (curtm - p._discardTm >= TextTexture.gTextRender.destroyUnusedTextureDt) { //超过20秒没用的删掉
                         p.destroy(); //真正删除贴图
                         TextTexture.pool[i] = TextTexture.pool[TextTexture.poolLen - 1];
                         TextTexture.poolLen--;
                         i--; //这个还要处理，用来抵消i++
                     }
                 }
                 TextTexture.cleanTm = curtm;
             }
         }
         touchRect(ri, curloop) {
             if (this.lastTouchTm != curloop) {
                 this.curUsedCovRate = 0;
                 this.curUsedCovRateAtlas = 0;
                 this.lastTouchTm = curloop;
             }
             var texw2 = TextTexture.gTextRender.atlasWidth * TextTexture.gTextRender.atlasWidth;
             var gridw2 = ILaya.TextAtlas.atlasGridW * ILaya.TextAtlas.atlasGridW;
             this.curUsedCovRate += (ri.bmpWidth * ri.bmpHeight) / texw2;
             this.curUsedCovRateAtlas += (Math.ceil(ri.bmpWidth / ILaya.TextAtlas.atlasGridW) * Math.ceil(ri.bmpHeight / ILaya.TextAtlas.atlasGridW)) / (texw2 / gridw2);
         }
         // 为了与当前的文字渲染兼容的补丁
         get texture() {
             return this;
         }
         _getSource() {
             return this._source;
         }
         // for debug
         drawOnScreen(x, y) {
         }
     }
     TextTexture.gTextRender = null;
     TextTexture.pool = new Array(10); // 回收用
     TextTexture.poolLen = 0;
     TextTexture.cleanTm = 0;

     /**
      *  文字贴图的大图集。
      */
     class TextAtlas {
         constructor() {
             this.texWidth = 1024;
             this.texHeight = 1024;
             this.protectDist = 1;
             this.texture = null;
             this.charMaps = {}; // 保存文字信息的字典
             this.texHeight = this.texWidth = ILaya.TextRender.atlasWidth;
             this.texture = TextTexture.getTextTexture(this.texWidth, this.texHeight);
             if (this.texWidth / TextAtlas.atlasGridW > 256) {
                 TextAtlas.atlasGridW = Math.ceil(this.texWidth / 256);
             }
             this.atlasgrid = new AtlasGrid(this.texWidth / TextAtlas.atlasGridW, this.texHeight / TextAtlas.atlasGridW, this.texture.id);
         }
         setProtecteDist(d) {
             this.protectDist = d;
         }
         /**
          * 如果返回null，则表示无法加入了
          * 分配的时候优先选择最接近自己高度的节点
          * @param	w
          * @param	h
          * @return
          */
         getAEmpty(w, h, pt) {
             var find = this.atlasgrid.addRect(1, Math.ceil(w / TextAtlas.atlasGridW), Math.ceil(h / TextAtlas.atlasGridW), pt);
             if (find) {
                 pt.x *= TextAtlas.atlasGridW;
                 pt.y *= TextAtlas.atlasGridW;
             }
             return find;
         }
         /**
          * 大图集格子单元的占用率，老的也算上了。只是表示这个大图集还能插入多少东西。
          */
         get usedRate() {
             return this.atlasgrid._used;
         }
         //data 也可能是canvas
         /*
         public function pushData(data:ImageData, node:TextAtlasNode):void {
             texture.addChar(data, node.x, node.y);
         }
         */
         destroy() {
             for (var k in this.charMaps) {
                 var ri = this.charMaps[k];
                 ri.deleted = true;
             }
             this.texture.discard();
         }
         printDebugInfo() {
         }
     }
     TextAtlas.atlasGridW = 16;

     /**
      * <code>Event</code> 是事件类型的集合。一般当发生事件时，<code>Event</code> 对象将作为参数传递给事件侦听器。
      */
     class Event {
         /**
          * 设置事件数据。
          * @param	type 事件类型。
          * @param	currentTarget 事件目标触发对象。
          * @param	target 事件当前冒泡对象。
          * @return 返回当前 Event 对象。
          */
         setTo(type, currentTarget, target) {
             this.type = type;
             this.currentTarget = currentTarget;
             this.target = target;
             return this;
         }
         /**
          * 阻止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget) 中的任何事件侦听器。
          */
         stopPropagation() {
             this._stoped = true;
         }
         /**
          * 触摸点列表。
          */
         get touches() {
             if (!this.nativeEvent)
                 return null;
             var arr = this.nativeEvent.touches;
             if (arr) {
                 var stage = ILaya.stage;
                 for (var i = 0, n = arr.length; i < n; i++) {
                     var e = arr[i];
                     var point = Point.TEMP;
                     point.setTo(e.clientX, e.clientY);
                     stage._canvasTransform.invertTransformPoint(point);
                     stage.transform.invertTransformPoint(point);
                     e.stageX = point.x;
                     e.stageY = point.y;
                 }
             }
             return arr;
         }
         /**
          * 表示 Alt 键是处于活动状态 (true) 还是非活动状态 (false)。
          */
         get altKey() {
             return this.nativeEvent.altKey;
         }
         /**
          * 表示 Ctrl 键是处于活动状态 (true) 还是非活动状态 (false)。
          */
         get ctrlKey() {
             return this.nativeEvent.ctrlKey;
         }
         /**
          * 表示 Shift 键是处于活动状态 (true) 还是非活动状态 (false)。
          */
         get shiftKey() {
             return this.nativeEvent.shiftKey;
         }
         /**
          * 包含按下或释放的键的字符代码值。字符代码值为英文键盘值。
          */
         get charCode() {
             return this.nativeEvent.charCode;
         }
         /**
          * 表示键在键盘上的位置。这对于区分在键盘上多次出现的键非常有用。<br>
          * 例如，您可以根据此属性的值来区分左 Shift 键和右 Shift 键：左 Shift 键的值为 KeyLocation.LEFT，右 Shift 键的值为 KeyLocation.RIGHT。另一个示例是区分标准键盘 (KeyLocation.STANDARD) 与数字键盘 (KeyLocation.NUM_PAD) 上按下的数字键。
          */
         get keyLocation() {
             return this.nativeEvent.location || this.nativeEvent.keyLocation;
         }
         /**鼠标在 Stage 上的 X 轴坐标*/
         get stageX() {
             return ILaya.stage.mouseX;
         }
         /**鼠标在 Stage 上的 Y 轴坐标*/
         get stageY() {
             return ILaya.stage.mouseY;
         }
     }
     /** 一个空的 Event 对象。用于事件派发中转使用。*/
     Event.EMPTY = new Event();
     /** 定义 mousedown 事件对象的 type 属性值。*/
     Event.MOUSE_DOWN = "mousedown";
     /** 定义 mouseup 事件对象的 type 属性值。*/
     Event.MOUSE_UP = "mouseup";
     /** 定义 click 事件对象的 type 属性值。*/
     Event.CLICK = "click";
     /** 定义 rightmousedown 事件对象的 type 属性值。*/
     Event.RIGHT_MOUSE_DOWN = "rightmousedown";
     /** 定义 rightmouseup 事件对象的 type 属性值。*/
     Event.RIGHT_MOUSE_UP = "rightmouseup";
     /** 定义 rightclick 事件对象的 type 属性值。*/
     Event.RIGHT_CLICK = "rightclick";
     /** 定义 mousemove 事件对象的 type 属性值。*/
     Event.MOUSE_MOVE = "mousemove";
     /** 定义 mouseover 事件对象的 type 属性值。*/
     Event.MOUSE_OVER = "mouseover";
     /** 定义 mouseout 事件对象的 type 属性值。*/
     Event.MOUSE_OUT = "mouseout";
     /** 定义 mousewheel 事件对象的 type 属性值。*/
     Event.MOUSE_WHEEL = "mousewheel";
     /** 定义 mouseover 事件对象的 type 属性值。*/
     Event.ROLL_OVER = "mouseover";
     /** 定义 mouseout 事件对象的 type 属性值。*/
     Event.ROLL_OUT = "mouseout";
     /** 定义 doubleclick 事件对象的 type 属性值。*/
     Event.DOUBLE_CLICK = "doubleclick";
     /** 定义 change 事件对象的 type 属性值。*/
     Event.CHANGE = "change";
     /** 定义 changed 事件对象的 type 属性值。*/
     Event.CHANGED = "changed";
     /** 定义 resize 事件对象的 type 属性值。*/
     Event.RESIZE = "resize";
     /** 定义 added 事件对象的 type 属性值。*/
     Event.ADDED = "added";
     /** 定义 removed 事件对象的 type 属性值。*/
     Event.REMOVED = "removed";
     /** 定义 display 事件对象的 type 属性值。*/
     Event.DISPLAY = "display";
     /** 定义 undisplay 事件对象的 type 属性值。*/
     Event.UNDISPLAY = "undisplay";
     /** 定义 error 事件对象的 type 属性值。*/
     Event.ERROR = "error";
     /** 定义 complete 事件对象的 type 属性值。*/
     Event.COMPLETE = "complete";
     /** 定义 loaded 事件对象的 type 属性值。*/
     Event.LOADED = "loaded";
     /** 定义 loaded 事件对象的 type 属性值。*/
     Event.READY = "ready";
     /** 定义 progress 事件对象的 type 属性值。*/
     Event.PROGRESS = "progress";
     /** 定义 input 事件对象的 type 属性值。*/
     Event.INPUT = "input";
     /** 定义 render 事件对象的 type 属性值。*/
     Event.RENDER = "render";
     /** 定义 open 事件对象的 type 属性值。*/
     Event.OPEN = "open";
     /** 定义 message 事件对象的 type 属性值。*/
     Event.MESSAGE = "message";
     /** 定义 close 事件对象的 type 属性值。*/
     Event.CLOSE = "close";
     /** 定义 keydown 事件对象的 type 属性值。*/
     Event.KEY_DOWN = "keydown";
     /** 定义 keypress 事件对象的 type 属性值。*/
     Event.KEY_PRESS = "keypress";
     /** 定义 keyup 事件对象的 type 属性值。*/
     Event.KEY_UP = "keyup";
     /** 定义 frame 事件对象的 type 属性值。*/
     Event.FRAME = "enterframe";
     /** 定义 dragstart 事件对象的 type 属性值。*/
     Event.DRAG_START = "dragstart";
     /** 定义 dragmove 事件对象的 type 属性值。*/
     Event.DRAG_MOVE = "dragmove";
     /** 定义 dragend 事件对象的 type 属性值。*/
     Event.DRAG_END = "dragend";
     /** 定义 enter 事件对象的 type 属性值。*/
     Event.ENTER = "enter";
     /** 定义 select 事件对象的 type 属性值。*/
     Event.SELECT = "select";
     /** 定义 blur 事件对象的 type 属性值。*/
     Event.BLUR = "blur";
     /** 定义 focus 事件对象的 type 属性值。*/
     Event.FOCUS = "focus";
     /** 定义 visibilitychange 事件对象的 type 属性值。*/
     Event.VISIBILITY_CHANGE = "visibilitychange";
     /** 定义 focuschange 事件对象的 type 属性值。*/
     Event.FOCUS_CHANGE = "focuschange";
     /** 定义 played 事件对象的 type 属性值。*/
     Event.PLAYED = "played";
     /** 定义 paused 事件对象的 type 属性值。*/
     Event.PAUSED = "paused";
     /** 定义 stopped 事件对象的 type 属性值。*/
     Event.STOPPED = "stopped";
     /** 定义 start 事件对象的 type 属性值。*/
     Event.START = "start";
     /** 定义 end 事件对象的 type 属性值。*/
     Event.END = "end";
     /** 定义 componentadded 事件对象的 type 属性值。*/
     Event.COMPONENT_ADDED = "componentadded";
     /** 定义 componentremoved 事件对象的 type 属性值。*/
     Event.COMPONENT_REMOVED = "componentremoved";
     /** 定义 released 事件对象的 type 属性值。*/
     Event.RELEASED = "released";
     /** 定义 link 事件对象的 type 属性值。*/
     Event.LINK = "link";
     /** 定义 label 事件对象的 type 属性值。*/
     Event.LABEL = "label";
     /**浏览器全屏更改时触发*/
     Event.FULL_SCREEN_CHANGE = "fullscreenchange";
     /**显卡设备丢失时触发*/
     Event.DEVICE_LOST = "devicelost";
     /**世界矩阵更新时触发。*/
     Event.TRANSFORM_CHANGED = "transformchanged";
     /**更换动作时触发。*/
     Event.ANIMATION_CHANGED = "animationchanged";
     /**拖尾渲染节点改变时触发。*/
     Event.TRAIL_FILTER_CHANGE = "trailfilterchange";
     /**物理碰撞开始*/
     Event.TRIGGER_ENTER = "triggerenter";
     /**物理碰撞持续*/
     Event.TRIGGER_STAY = "triggerstay";
     /**物理碰撞结束*/
     Event.TRIGGER_EXIT = "triggerexit";

     /**
      * 资源加载完成后调度。
      * @eventType Event.READY
      */
     /*[Event(name = "ready", type = "laya.events.Event")]*/
     /**
      * <code>Texture</code> 是一个纹理处理类。
      */
     class Texture extends EventDispatcher {
         /**
          * 创建一个 <code>Texture</code> 实例。
          * @param	bitmap 位图资源。
          * @param	uv UV 数据信息。
          */
         constructor(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
             super();
             /**@private uv的范围*/
             this.uvrect = [0, 0, 1, 1]; //startu,startv, urange,vrange
             /**@private */
             this._destroyed = false;
             /**@private */
             this._referenceCount = 0;
             /**@private 唯一ID*/
             this.$_GID = 0;
             /**沿 X 轴偏移量。*/
             this.offsetX = 0;
             /**沿 Y 轴偏移量。*/
             this.offsetY = 0;
             /** @private */
             this._w = 0;
             /** @private */
             this._h = 0;
             /**原始宽度（包括被裁剪的透明区域）。*/
             this.sourceWidth = 0;
             /**原始高度（包括被裁剪的透明区域）。*/
             this.sourceHeight = 0;
             /**图片地址*/
             this.url = null;
             /** @private */
             this.scaleRate = 1;
             this.setTo(bitmap, uv, sourceWidth, sourceHeight);
         }
         /**
          * 平移 UV。
          * @param offsetX 沿 X 轴偏移量。
          * @param offsetY 沿 Y 轴偏移量。
          * @param uv 需要平移操作的的 UV。
          * @return 平移后的UV。
          */
         static moveUV(offsetX, offsetY, uv) {
             for (var i = 0; i < 8; i += 2) {
                 uv[i] += offsetX;
                 uv[i + 1] += offsetY;
             }
             return uv;
         }
         /**
          *  根据指定资源和坐标、宽高、偏移量等创建 <code>Texture</code> 对象。
          * @param	source 绘图资源 Texture2D 或者 Texture对象。
          * @param	x 起始绝对坐标 x 。
          * @param	y 起始绝对坐标 y 。
          * @param	width 宽绝对值。
          * @param	height 高绝对值。
          * @param	offsetX X 轴偏移量（可选）。	就是[x,y]相对于原始小图片的位置。一般都是正的，表示裁掉了空白边的大小，如果是负的一般表示加了保护边
          * @param	offsetY Y 轴偏移量（可选）。
          * @param	sourceWidth 原始宽度，包括被裁剪的透明区域（可选）。
          * @param	sourceHeight 原始高度，包括被裁剪的透明区域（可选）。
          * @return  <code>Texture</code> 对象。
          */
         static create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0) {
             return Texture._create(source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight);
         }
         /**
          * @private
          * 根据指定资源和坐标、宽高、偏移量等创建 <code>Texture</code> 对象。
          * @param	source 绘图资源 Texture2D 或者 Texture 对象。
          * @param	x 起始绝对坐标 x 。
          * @param	y 起始绝对坐标 y 。
          * @param	width 宽绝对值。
          * @param	height 高绝对值。
          * @param	offsetX X 轴偏移量（可选）。
          * @param	offsetY Y 轴偏移量（可选）。
          * @param	sourceWidth 原始宽度，包括被裁剪的透明区域（可选）。
          * @param	sourceHeight 原始高度，包括被裁剪的透明区域（可选）。
          * @param	outTexture 返回的Texture对象。
          * @return  <code>Texture</code> 对象。
          */
         static _create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0, outTexture = null) {
             var btex = source instanceof Texture;
             var uv = btex ? source.uv : Texture.DEF_UV;
             var bitmap = btex ? source.bitmap : source;
             if (bitmap.width && (x + width) > bitmap.width)
                 width = bitmap.width - x;
             if (bitmap.height && (y + height) > bitmap.height)
                 height = bitmap.height - y;
             var tex;
             if (outTexture) {
                 tex = outTexture;
                 tex.setTo(bitmap, null, sourceWidth || width, sourceHeight || height);
             }
             else {
                 tex = new Texture(bitmap, null, sourceWidth || width, sourceHeight || height);
             }
             tex.width = width;
             tex.height = height;
             tex.offsetX = offsetX;
             tex.offsetY = offsetY;
             var dwidth = 1 / bitmap.width;
             var dheight = 1 / bitmap.height;
             x *= dwidth;
             y *= dheight;
             width *= dwidth;
             height *= dheight;
             var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5];
             var inAltasUVWidth = (u2 - u1), inAltasUVHeight = (v2 - v1);
             var oriUV = Texture.moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);
             tex.uv = new Float32Array([u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight,
                 u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight,
                 u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight,
                 u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight]);
             var bitmapScale = bitmap.scaleRate;
             if (bitmapScale && bitmapScale != 1) {
                 tex.sourceWidth /= bitmapScale;
                 tex.sourceHeight /= bitmapScale;
                 tex.width /= bitmapScale;
                 tex.height /= bitmapScale;
                 tex.scaleRate = bitmapScale;
             }
             else {
                 tex.scaleRate = 1;
             }
             return tex;
         }
         /**
          * 截取Texture的一部分区域，生成新的Texture，如果两个区域没有相交，则返回null。
          * @param	texture	目标Texture。
          * @param	x		相对于目标Texture的x位置。
          * @param	y		相对于目标Texture的y位置。
          * @param	width	截取的宽度。
          * @param	height	截取的高度。
          * @return 返回一个新的Texture。
          */
         static createFromTexture(texture, x, y, width, height) {
             var texScaleRate = texture.scaleRate;
             if (texScaleRate != 1) {
                 x *= texScaleRate;
                 y *= texScaleRate;
                 width *= texScaleRate;
                 height *= texScaleRate;
             }
             var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height);
             var result = rect.intersection(Texture._rect1.setTo(0, 0, texture.width, texture.height), Texture._rect2);
             if (result)
                 var tex = Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height);
             else
                 return null;
             return tex;
         }
         get uv() {
             return this._uv;
         }
         set uv(value) {
             this.uvrect[0] = Math.min(value[0], value[2], value[4], value[6]);
             this.uvrect[1] = Math.min(value[1], value[3], value[5], value[7]);
             this.uvrect[2] = Math.max(value[0], value[2], value[4], value[6]) - this.uvrect[0];
             this.uvrect[3] = Math.max(value[1], value[3], value[5], value[7]) - this.uvrect[1];
             this._uv = value;
         }
         /** 实际宽度。*/
         get width() {
             if (this._w)
                 return this._w;
             if (!this.bitmap)
                 return 0;
             return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width;
         }
         set width(value) {
             this._w = value;
             this.sourceWidth || (this.sourceWidth = value);
         }
         /** 实际高度。*/
         get height() {
             if (this._h)
                 return this._h;
             if (!this.bitmap)
                 return 0;
             return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height;
         }
         set height(value) {
             this._h = value;
             this.sourceHeight || (this.sourceHeight = value);
         }
         /**
          * 获取位图。
          * @return 位图。
          */
         get bitmap() {
             return this._bitmap;
         }
         /**
          * 设置位图。
          * @param 位图。
          */
         set bitmap(value) {
             this._bitmap && this._bitmap._removeReference(this._referenceCount);
             this._bitmap = value;
             value && (value._addReference(this._referenceCount));
         }
         /**
          * 获取是否已经销毁。
          * @return 是否已经销毁。
          */
         get destroyed() {
             return this._destroyed;
         }
         /**
          * @private
          */
         _addReference() {
             this._bitmap && this._bitmap._addReference();
             this._referenceCount++;
         }
         /**
          * @private
          */
         _removeReference() {
             this._bitmap && this._bitmap._removeReference();
             this._referenceCount--;
         }
         /**
          * @private
          */
         _getSource(cb = null) {
             if (this._destroyed || !this._bitmap)
                 return null;
             this.recoverBitmap(cb);
             return this._bitmap.destroyed ? null : this.bitmap._getSource();
         }
         /**
          * @private
          */
         _onLoaded(complete, context) {
             if (!context) ;
             else if (context == this) ;
             else if (context instanceof Texture) {
                 var tex = context;
                 Texture._create(context, 0, 0, tex.width, tex.height, 0, 0, tex.sourceWidth, tex.sourceHeight, this);
             }
             else {
                 this.bitmap = context;
                 this.sourceWidth = this._w = context.width;
                 this.sourceHeight = this._h = context.height;
             }
             complete && complete.run();
             this.event(Event.READY, this);
         }
         /**
          * 获取是否可以使用。
          */
         getIsReady() {
             return this._destroyed ? false : (this._bitmap ? true : false);
         }
         /**
          * 设置此对象的位图资源、UV数据信息。
          * @param	bitmap 位图资源
          * @param	uv UV数据信息
          */
         setTo(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
             this.bitmap = bitmap;
             this.sourceWidth = sourceWidth;
             this.sourceHeight = sourceHeight;
             if (bitmap) {
                 this._w = bitmap.width;
                 this._h = bitmap.height;
                 this.sourceWidth = this.sourceWidth || bitmap.width;
                 this.sourceHeight = this.sourceHeight || bitmap.height;
             }
             this.uv = uv || Texture.DEF_UV;
         }
         /**
          * 加载指定地址的图片。
          * @param	url 图片地址。
          * @param	complete 加载完成回调
          */
         load(url, complete = null) {
             if (!this._destroyed)
                 ILaya.loader.load(url, Handler.create(this, this._onLoaded, [complete]), null, "htmlimage", 1, false, null, true);
         }
         getTexturePixels(x, y, width, height) {
             var st, dst, i;
             var tex2d = this.bitmap;
             var texw = tex2d.width;
             var texh = tex2d.height;
             if (x + width > texw)
                 width -= (x + width) - texw;
             if (y + height > texh)
                 height -= (y + height) - texh;
             if (width <= 0 || height <= 0)
                 return null;
             var wstride = width * 4;
             var pix = null;
             try {
                 pix = tex2d.getPixels();
             }
             catch (e) {
             }
             if (pix) {
                 if (x == 0 && y == 0 && width == texw && height == texh)
                     return pix;
                 //否则只取一部分
                 var ret = new Uint8Array(width * height * 4);
                 wstride = texw * 4;
                 st = x * 4;
                 dst = (y + height - 1) * wstride + x * 4;
                 for (i = height - 1; i >= 0; i--) {
                     ret.set(dt.slice(dst, dst + width * 4), st);
                     st += wstride;
                     dst -= wstride;
                 }
                 return ret;
             }
             // 如果无法直接获取，只能先渲染出来
             var ctx = new ILaya.Context();
             ctx.size(width, height);
             ctx.asBitmap = true;
             var uv = null;
             if (x != 0 || y != 0 || width != texw || height != texh) {
                 uv = uv.concat(); // 复制一份uv
                 var stu = uv[0];
                 var stv = uv[1];
                 var uvw = uv[2] - stu;
                 var uvh = uv[7] - stv;
                 var uk = uvw / texw;
                 var vk = uvh / texh;
                 uv = [stu + x * uk, stv + y * vk,
                     stu + (x + width) * uk, stv + y * vk,
                     stu + (x + width) * uk, stv + (y + height) * vk,
                     stu + x * uk, stv + (y + height) * vk];
             }
             ctx._drawTextureM(this, 0, 0, width, height, null, 1.0, uv);
             //ctx.drawTexture(value, -x, -y, x + width, y + height);
             ctx._targets.start();
             ctx.flush();
             ctx._targets.end();
             ctx._targets.restore();
             var dt = ctx._targets.getData(0, 0, width, height);
             ctx.destroy();
             // 上下颠倒一下
             ret = new Uint8Array(width * height * 4);
             st = 0;
             dst = (height - 1) * wstride;
             for (i = height - 1; i >= 0; i--) {
                 ret.set(dt.slice(dst, dst + wstride), st);
                 st += wstride;
                 dst -= wstride;
             }
             return ret;
         }
         /**
          * 获取Texture上的某个区域的像素点
          * @param	x
          * @param	y
          * @param	width
          * @param	height
          * @return  返回像素点集合
          */
         getPixels(x, y, width, height) {
             if (window.conch) {
                 return this._nativeObj.getImageData(x, y, width, height);
             }
             else {
                 return this.getTexturePixels(x, y, width, height);
             } // canvas 不支持
         }
         /**
          * 通过url强制恢复bitmap。
          */
         recoverBitmap(onok = null) {
             var url = this._bitmap.url;
             if (!this._destroyed && (!this._bitmap || this._bitmap.destroyed) && url) {
                 ILaya.loader.load(url, Handler.create(this, function (bit) {
                     this.bitmap = bit;
                     onok && onok();
                 }), null, "htmlimage", 1, false, null, true);
             }
         }
         /**
          * 强制释放Bitmap,无论是否被引用。
          */
         disposeBitmap() {
             if (!this._destroyed && this._bitmap) {
                 this._bitmap.destroy();
             }
         }
         /**
          * 销毁纹理。
          */
         destroy(force = false) {
             if (!this._destroyed) {
                 this._destroyed = true;
                 var bit = this._bitmap;
                 if (bit) {
                     bit._removeReference(this._referenceCount);
                     if (bit.referenceCount === 0 || force)
                         bit.destroy();
                     bit = null;
                 }
                 if (this.url && this === ILaya.loader.getRes(this.url))
                     ILaya.loader.clearRes(this.url);
             }
         }
     }
     /**@private 默认 UV 信息。*/
     Texture.DEF_UV = new Float32Array([0, 0, 1.0, 0, 1.0, 1.0, 0, 1.0]);
     /**@private */
     Texture.NO_UV = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]);
     /**@private 反转 UV 信息。*/
     Texture.INV_UV = new Float32Array([0, 1, 1.0, 1, 1.0, 0.0, 0, 0.0]);
     /**@private */
     Texture._rect1 = new Rectangle();
     /**@private */
     Texture._rect2 = new Rectangle();

     class FontInfo {
         constructor(font) {
             this._font = "14px Arial";
             this._family = "Arial";
             this._size = 14;
             this._italic = false;
             this._bold = false;
             this._id = FontInfo._gfontID++;
             this.setFont(font || this._font);
         }
         static Parse(font) {
             if (font === FontInfo._lastFont) {
                 return FontInfo._lastFontInfo;
             }
             var r = FontInfo._cache[font];
             if (!r) {
                 r = FontInfo._cache[font] = new FontInfo(font);
             }
             FontInfo._lastFont = font;
             FontInfo._lastFontInfo = r;
             return r;
         }
         setFont(value) {
             this._font = value;
             var _words = value.split(' ');
             var l = _words.length;
             if (l < 2) {
                 if (l == 1) {
                     if (_words[0].indexOf('px') > 0) {
                         this._size = parseInt(_words[0]);
                     }
                 }
                 return;
             }
             var szpos = -1;
             //由于字体可能有空格，例如Microsoft YaHei 所以不能直接取倒数第二个，要先找到px
             for (var i = 0; i < l; i++) {
                 if (_words[i].indexOf('px') > 0 || _words[i].indexOf('pt') > 0) {
                     szpos = i;
                     this._size = parseInt(_words[i]);
                     if (this._size <= 0) {
                         console.error('font parse error:' + value);
                         this._size = 14;
                     }
                     break;
                 }
             }
             //最后一个是用逗号分开的family
             var fpos = szpos + 1;
             var familys = _words[fpos];
             fpos++; //下一个
             for (; fpos < l; fpos++) {
                 familys += ' ' + _words[fpos];
             }
             this._family = (familys.split(','))[0];
             this._italic = _words.indexOf('italic') >= 0;
             this._bold = _words.indexOf('bold') >= 0;
         }
     }
     FontInfo.EMPTY = new FontInfo(null);
     FontInfo._cache = {};
     FontInfo._gfontID = 0;
     FontInfo._lastFont = '';

     /**
          * @private
          */
     class WordText {
         constructor() {
             this.save = [];
             this.toUpperCase = null;
             this.width = -1; //整个WordText的长度。-1表示没有计算还。
             this.pageChars = []; //把本对象的字符按照texture分组保存的文字信息。里面又是一个数组。具体含义见使用的地方。
             this.startID = 0; //上面的是个数组，但是可能前面都是空的，加个起始位置
             this.startIDStroke = 0;
             this.lastGCCnt = 0; //如果文字gc了，需要检查缓存是否有效，这里记录上次检查对应的gc值。
             this.splitRender = false; // 强制拆分渲染
         }
         setText(txt) {
             this.changed = true;
             this._text = txt;
             this.width = -1;
             this.cleanCache();
             //pageChars = [];//需要重新更新
         }
         //TODO:coverage
         toString() {
             return this._text;
         }
         get length() {
             return this._text ? this._text.length : 0;
         }
         //TODO:coverage
         charCodeAt(i) {
             return this._text ? this._text.charCodeAt(i) : NaN;
         }
         //TODO:coverage
         charAt(i) {
             return this._text ? this._text.charAt(i) : null;
         }
         /**
          * 自己主动清理缓存，需要把关联的贴图删掉
          * 不做也可以，textrender会自动清理不用的
          * TODO 重用
          */
         cleanCache() {
             // 如果是独占文字贴图的，需要删掉
             this.pageChars.forEach(function (p) {
                 var tex = p.tex;
                 var words = p.words;
                 if (p.words.length == 1 && tex && tex.ri) { // 如果有ri表示是独立贴图
                     tex.destroy();
                 }
             });
             this.pageChars = [];
             this.startID = 0;
         }
     }

     /**
      * TODO如果占用内存较大,这个结构有很多成员可以临时计算
      */
     class CharRenderInfo {
         constructor() {
             this.char = ''; // 调试用
             this.deleted = false; // 已经被删除了
             this.uv = new Array(8); // [0, 0, 1, 1];		//uv
             this.pos = 0; //数组下标
             this.orix = 0; // 原点位置，通常都是所在区域的左上角
             this.oriy = 0;
             this.touchTick = 0; //
             this.isSpace = false; //是否是空格，如果是空格，则只有width有效
         }
         touch() {
             var curLoop = RenderInfo.loopCount;
             if (this.touchTick != curLoop) { // 这个保证每帧只调用一次
                 this.tex.touchRect(this, curLoop);
             }
             this.touchTick = curLoop;
         }
     }

     class ICharRender {
         getWidth(font, str) { return 0; }
         scale(sx, sy) {
         }
         get canvasWidth() {
             return 0;
         }
         set canvasWidth(w) {
         }
         /**
          *TODO stroke
          * @param	char
          * @param	font
          * @param	size  返回宽高
          * @return
          */
         getCharBmp(char, font, lineWidth, colStr, strokeColStr, size, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
             return null;
         }
     }

     class CharRender_Canvas extends ICharRender {
         constructor(maxw, maxh, scalefont = true, useImageData = true, showdbg = false) {
             super();
             this.ctx = null;
             this.lastScaleX = 1.0;
             this.lastScaleY = 1.0;
             this.needResetScale = false;
             this.maxTexW = 0;
             this.maxTexH = 0;
             this.scaleFontSize = true;
             this.showDbgInfo = false;
             this.supportImageData = true;
             this.maxTexW = maxw;
             this.maxTexH = maxh;
             this.scaleFontSize = scalefont;
             this.supportImageData = useImageData;
             this.showDbgInfo = showdbg;
             if (!CharRender_Canvas.canvas) {
                 CharRender_Canvas.canvas = window.document.createElement('canvas');
                 CharRender_Canvas.canvas.width = 1024;
                 CharRender_Canvas.canvas.height = 512;
                 //这个canvas是用来获取字体渲染结果的。由于不可见canvas的字体不能小于12，所以要加到body上
                 //为了避免被发现，设一个在屏幕外的绝对位置。
                 CharRender_Canvas.canvas.style.left = "-10000px";
                 CharRender_Canvas.canvas.style.position = "absolute";
                 document.body.appendChild(CharRender_Canvas.canvas);
                 this.ctx = CharRender_Canvas.canvas.getContext('2d');
             }
         }
         /*override*/ get canvasWidth() {
             return CharRender_Canvas.canvas.width;
         }
         /*override*/ set canvasWidth(w) {
             if (CharRender_Canvas.canvas.width == w)
                 return;
             CharRender_Canvas.canvas.width = w;
             if (w > 2048) {
                 console.warn("画文字设置的宽度太大，超过2048了");
             }
             // 重新恢复一下缩放
             this.ctx.setTransform(1, 0, 0, 1, 0, 0); // 强制清理缩放			
             this.ctx.scale(this.lastScaleX, this.lastScaleY);
         }
         /*override*/ getWidth(font, str) {
             if (!this.ctx)
                 return 0;
             //由于大家公用一个canvas，所以需要在选中的时候做一些配置。
             if (this.ctx._lastFont != font) {
                 this.ctx.font = font;
                 this.ctx._lastFont = font;
                 //console.log('use font ' + font);
             }
             return this.ctx.measureText(str).width;
         }
         /*override*/ scale(sx, sy) {
             if (!this.supportImageData) { // supportImageData==false表示用 getCharCanvas，这个自己管理缩放
                 this.lastScaleX = sx;
                 this.lastScaleY = sy;
                 return;
             }
             if (this.lastScaleX != sx || this.lastScaleY != sy) {
                 this.ctx.setTransform(sx, 0, 0, sy, 0, 0); // 强制清理缩放			
                 this.lastScaleX = sx;
                 this.lastScaleY = sy;
             }
         }
         /**
          *TODO stroke
          * @param	char
          * @param	font
          * @param	cri  修改里面的width。
          * @return
          */
         /*override*/ getCharBmp(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
             if (!this.supportImageData)
                 return this.getCharCanvas(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom);
             var ctx = this.ctx;
             //ctx.save();
             //由于大家公用一个canvas，所以需要在选中的时候做一些配置。
             //跟_lastFont比较容易出错，所以比较ctx.font
             if (ctx.font != font) { // ctx._lastFont != font) {	问题：ctx.font=xx 然后ctx==xx可能返回false，例如可能会给自己加"",当字体有空格的时候
                 ctx.font = font;
                 ctx._lastFont = font;
                 //console.log('use font ' + font);
             }
             cri.width = ctx.measureText(char).width; //排版用的width是没有缩放的。后面会用矩阵缩放
             var w = cri.width * this.lastScaleX; //w h 只是clear用的。所以要缩放
             var h = cri.height * this.lastScaleY;
             w += (margin_left + margin_right) * this.lastScaleX;
             h += (margin_top + margin_bottom) * this.lastScaleY;
             w = Math.ceil(w);
             h = Math.ceil(h);
             w = Math.min(w, CharRender_Canvas.canvas.width);
             h = Math.min(h, CharRender_Canvas.canvas.height);
             var clearW = w + lineWidth * 2 + 1;
             var clearH = h + lineWidth * 2 + 1;
             if (rect) { // measureText可能会小于请求的区域。 rect[2]可能为-1
                 clearW = Math.max(clearW, rect[0] + rect[2] + 1);
                 clearH = Math.max(clearH, rect[1] + rect[3] + 1);
             }
             ctx.clearRect(0, 0, clearW, clearH);
             ctx.save();
             //ctx.textAlign = "end";
             ctx.textBaseline = "top";
             //ctx.translate(CborderSize, CborderSize);
             //ctx.scale(xs, ys);
             if (lineWidth > 0) {
                 ctx.strokeStyle = strokeColStr;
                 ctx.lineWidth = lineWidth;
                 ctx.strokeText(char, margin_left, margin_top);
             }
             ctx.fillStyle = colStr;
             ctx.fillText(char, margin_left, margin_top);
             if (this.showDbgInfo) {
                 ctx.strokeStyle = '#ff0000';
                 ctx.strokeRect(0, 0, w, h);
                 ctx.strokeStyle = '#00ff00';
                 ctx.strokeRect(margin_left, margin_top, cri.width, cri.height); //原始大小，没有缩放的
             }
             //ctx.restore();
             if (rect) {
                 if (rect[2] == -1)
                     rect[2] = Math.ceil((cri.width + lineWidth * 2) * this.lastScaleX); // 这个没有考虑左右margin
             }
             var imgdt = rect ? (ctx.getImageData(rect[0], rect[1], rect[2], rect[3])) : (ctx.getImageData(0, 0, w, h));
             ctx.restore();
             cri.bmpWidth = imgdt.width;
             cri.bmpHeight = imgdt.height;
             return imgdt;
         }
         getCharCanvas(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom) {
             var ctx = this.ctx;
             //ctx.save();
             //由于大家公用一个canvas，所以需要在选中的时候做一些配置。
             //跟_lastFont比较容易出错，所以比较ctx.font
             if (ctx.font != font) { // ctx._lastFont != font) {	问题：ctx.font=xx 然后ctx==xx可能返回false，例如可能会给自己加"",当字体有空格的时候
                 ctx.font = font;
                 ctx._lastFont = font;
                 //console.log('use font ' + font);
             }
             cri.width = ctx.measureText(char).width; //排版用的width是没有缩放的。后面会用矩阵缩放
             var w = cri.width * this.lastScaleX; //w h 只是clear用的。所以要缩放
             var h = cri.height * this.lastScaleY;
             w += (margin_left + margin_right) * this.lastScaleX;
             h += ((margin_top + margin_bottom) * this.lastScaleY + 1); // 这个+1只是为了让测试能通过。确实应该加点高度，否则会被裁掉一部分，但是加多少还没找到方法。
             w = Math.min(w, this.maxTexW);
             h = Math.min(h, this.maxTexH);
             //if (canvas.width != (w + 1) || canvas.height != (h + 1)) {
             CharRender_Canvas.canvas.width = Math.min(w + 1, this.maxTexW);
             CharRender_Canvas.canvas.height = Math.min(h + 1, this.maxTexH);
             ctx.font = font;
             //}
             ctx.clearRect(0, 0, w + 1 + lineWidth, h + 1 + lineWidth);
             ctx.setTransform(1, 0, 0, 1, 0, 0); // 强制清理缩放
             ctx.save();
             if (this.scaleFontSize) {
                 //这里的缩放会导致与上面的缩放同时起作用。所以上面保护
                 ctx.scale(this.lastScaleX, this.lastScaleY);
             }
             ctx.translate(margin_left, margin_top);
             ctx.textAlign = "left";
             ctx.textBaseline = "top";
             //ctx.translate(CborderSize, CborderSize);
             //ctx.scale(xs, ys);
             if (lineWidth > 0) {
                 ctx.strokeStyle = strokeColStr;
                 ctx.fillStyle = colStr;
                 ctx.lineWidth = lineWidth;
                 //ctx.strokeText(char, margin_left, margin_top);
                 if (ctx.fillAndStrokeText) {
                     ctx.fillAndStrokeText(char, 0, 0);
                 }
                 else {
                     ctx.strokeText(char, 0, 0);
                     ctx.fillText(char, 0, 0);
                 }
             }
             else {
                 ctx.fillStyle = colStr;
                 ctx.fillText(char, 0, 0);
             }
             if (this.showDbgInfo) {
                 ctx.strokeStyle = '#ff0000';
                 ctx.strokeRect(0, 0, w, h);
                 ctx.strokeStyle = '#00ff00';
                 ctx.strokeRect(0, 0, cri.width, cri.height); //原始大小，没有缩放的
             }
             ctx.restore();
             cri.bmpWidth = CharRender_Canvas.canvas.width;
             cri.bmpHeight = CharRender_Canvas.canvas.height;
             return CharRender_Canvas.canvas;
         }
     }
     CharRender_Canvas.canvas = null; // HTMLCanvasElement;

     class CharRender_Native extends ICharRender {
         //TODO:coverage
         constructor() {
             super();
             this.lastFont = '';
         }
         //TODO:coverage
         /*override*/ getWidth(font, str) {
             if (!window.conchTextCanvas)
                 return 0;
             //TODO 先取消判断，保证字体信息一致
             //if (lastFont != font) { 
             window.conchTextCanvas.font = font;
             this.lastFont = font;
             //console.log('use font ' + font);
             //}					
             //getTextBitmapData
             return window.conchTextCanvas.measureText(str).width;
         }
         /*override*/ scale(sx, sy) {
         }
         /**
          *TODO stroke
          * @param	char
          * @param	font
          * @param	size  返回宽高
          * @return
          */
         //TODO:coverage
         /*override*/ getCharBmp(char, font, lineWidth, colStr, strokeColStr, size, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
             if (!window.conchTextCanvas)
                 return null;
             //window.conchTextCanvas.getTextBitmapData();
             //TODO 先取消判断，保证字体信息一致
             //if(lastFont!=font){
             window.conchTextCanvas.font = font;
             this.lastFont = font;
             //}						
             var w = size.width = window.conchTextCanvas.measureText(char).width;
             var h = size.height;
             w += (margin_left + margin_right);
             h += (margin_top + margin_bottom);
             var c1 = ColorUtils.create(strokeColStr);
             var nStrokeColor = c1.numColor;
             var c2 = ColorUtils.create(colStr);
             var nTextColor = c2.numColor;
             var textInfo = window.conchTextCanvas.getTextBitmapData(char, nTextColor, lineWidth > 2 ? 2 : lineWidth, nStrokeColor);
             //window.Laya.LayaGL.instance.texSubImage2D(1,2,0,0,textInfo.width,textInfo.height,0,0,textInfo.bitmapData);
             //var ret = new ImageData();
             size.bmpWidth = textInfo.width;
             size.bmpHeight = textInfo.height;
             return textInfo;
             /*
             ctx.clearRect(0,0, w, h);
             //ctx.textAlign = "end";
             ctx.textBaseline = "top";
             if (lineWidth > 0) {
                 ctx.strokeStyle = colStr;
                 ctx.lineWidth = lineWidth;
                 ctx.strokeText(char, margin_left, margin_top);
             } else {
                 ctx.fillStyle = colStr;
                 ctx.fillText(char, margin_left, margin_top);
             }
             if ( CharBook.debug) {
                 ctx.strokeStyle = '#ff0000';
                 ctx.strokeRect(0, 0, w, h);
                 ctx.strokeStyle = '#00ff00';
                 ctx.strokeRect(margin_left, margin_top, size.width, size.height);
             }
             //ctx.restore();
             return ctx.getImageData( 0,0, w, h );
             */
         }
     }

     class TextRender {
         constructor() {
             //config
             /**
              * fontSizeInfo
              * 记录每种字体的像素的大小。标准是32px的字体。由4个byte组成，分别表示[xdist,ydist,w,h]。
              * xdist,ydist 是像素起点到排版原点的距离，都是正的，表示实际数据往左和上偏多少，如果实际往右和下偏，则算作0，毕竟这个只是一个大概
              * 例如 [Arial]=0x00002020, 表示宽高都是32
              */
             this.fontSizeInfo = {};
             this.charRender = null;
             this.mapFont = {}; // 把font名称映射到数字
             this.fontID = 0;
             this.mapColor = []; // 把color映射到数字
             this.colorID = 0;
             this.fontScaleX = 1.0; //临时缩放。
             this.fontScaleY = 1.0;
             //private var charMaps:Object = {};	// 所有的都放到一起
             this._curStrPos = 0; //解开一个字符串的时候用的。表示当前解到什么位置了
             this.textAtlases = []; // 所有的大图集
             this.isoTextures = []; // 所有的独立贴图
             // 当前字体的测量信息。
             this.lastFont = null;
             this.fontSizeW = 0;
             this.fontSizeH = 0;
             this.fontSizeOffX = 0;
             this.fontSizeOffY = 0;
             this.renderPerChar = true; // 是否是单个字符渲染。这个是结果，上面的是配置
             this.tmpAtlasPos = new Point();
             this.textureMem = 0; // 当前贴图所占用的内存
             ILaya.TextAtlas = TextAtlas;
             var bugIOS = false; //是否是有bug的ios版本
             //在微信下有时候不显示文字，所以采用canvas模式，现在测试微信好像都好了，所以去掉了。
             var miniadp = ILaya.Laya['MiniAdpter'];
             if (miniadp && miniadp.systemInfo && miniadp.systemInfo.system) {
                 bugIOS = miniadp.systemInfo.system.toLowerCase() === 'ios 10.1.1';
             }
             if (ILaya.Browser.onMiniGame /*&& !Browser.onAndroid*/ && !bugIOS)
                 TextRender.isWan1Wan = true; //android 微信下 字边缘发黑，所以不用getImageData了
             if (ILaya.Browser.onLimixiu)
                 TextRender.isWan1Wan = true;
             //isWan1Wan = true;
             this.charRender = ILaya.Render.isConchApp ? (new CharRender_Native()) : (new CharRender_Canvas(TextRender.atlasWidth, TextRender.atlasWidth, TextRender.scaleFontWithCtx, !TextRender.isWan1Wan, false));
             TextRender.textRenderInst = this;
             ILaya.Laya['textRender'] = this;
             TextRender.atlasWidth2 = TextRender.atlasWidth * TextRender.atlasWidth;
             //TEST
             //forceSplitRender = true;
             //noAtlas = true;
             //forceWholeRender = true;
             //TEST
         }
         /**
          * 设置当前字体，获得字体的大小信息。
          * @param	font
          */
         setFont(font) {
             if (this.lastFont == font)
                 return;
             this.lastFont = font;
             var fontsz = this.getFontSizeInfo(font._family);
             var offx = fontsz >> 24;
             var offy = (fontsz >> 16) & 0xff;
             var fw = (fontsz >> 8) & 0xff;
             var fh = fontsz & 0xff;
             var k = font._size / TextRender.standardFontSize;
             this.fontSizeOffX = Math.ceil(offx * k);
             this.fontSizeOffY = Math.ceil(offy * k);
             this.fontSizeW = Math.ceil(fw * k);
             this.fontSizeH = Math.ceil(fh * k);
             if (font._font.indexOf('italic') >= 0) { // 先判断一下效率会高一些
                 this.fontStr = font._font.replace('italic', '');
             }
             else {
                 this.fontStr = font._font;
             }
         }
         /**
          * 从string中取出一个完整的char，例如emoji的话要多个
          * 会修改 _curStrPos
          * TODO 由于各种文字中的组合写法，这个需要能扩展，以便支持泰文等
          * @param	str
          * @param	start	开始位置
          */
         getNextChar(str) {
             var len = str.length;
             var start = this._curStrPos;
             if (start >= len)
                 return null;
             var i = start;
             var state = 0; //0 初始化 1  正常 2 连续中
             for (; i < len; i++) {
                 var c = str.charCodeAt(i);
                 if ((c >>> 11) == 0x1b) { //可能是0b110110xx或者0b110111xx。 这都表示2个u16组成一个emoji
                     if (state == 1)
                         break; //新的字符了，要截断
                     state = 1; // 其他状态都转成正常读取字符状态，只是一次读两个
                     i++; //跨过一个。
                 }
                 else if (c === 0xfe0e || c === 0xfe0f) ;
                 else if (c == 0x200d) { //zero width joiner
                     state = 2; // 继续
                 }
                 else {
                     if (state == 0)
                         state = 1;
                     else if (state == 1)
                         break;
                 }
             }
             this._curStrPos = i;
             return str.substring(start, i);
         }
         filltext(ctx, data, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {
             if (data.length <= 0)
                 return;
             //以后保存到wordtext中
             var font = FontInfo.Parse(fontStr);
             var nTextAlign = 0;
             switch (textAlign) {
                 case 'center':
                     nTextAlign = ILaya.Context.ENUM_TEXTALIGN_CENTER;
                     break;
                 case 'right':
                     nTextAlign = ILaya.Context.ENUM_TEXTALIGN_RIGHT;
                     break;
             }
             this._fast_filltext(ctx, data, null, x, y, font, color, strokeColor, lineWidth, nTextAlign, underLine);
         }
         fillWords(ctx, data, x, y, fontStr, color, strokeColor, lineWidth) {
             if (!data)
                 return;
             if (data.length <= 0)
                 return;
             var font = FontInfo.Parse(fontStr);
             this._fast_filltext(ctx, null, data, x, y, font, color, strokeColor, lineWidth, 0, 0);
         }
         _fast_filltext(ctx, data, htmlchars, x, y, font, color, strokeColor, lineWidth, textAlign, underLine = 0) {
             if (data && data.length < 1)
                 return;
             if (htmlchars && htmlchars.length < 1)
                 return;
             if (lineWidth < 0)
                 lineWidth = 0;
             this.setFont(font);
             this.fontScaleX = this.fontScaleY = 1.0;
             if (!ILaya.Render.isConchApp && TextRender.scaleFontWithCtx) {
                 var sx = 1;
                 var sy = 1;
                 if (ILaya.Render.isConchApp) {
                     sx = ctx._curMat.getScaleX();
                     sy = ctx._curMat.getScaleY();
                 }
                 else {
                     sx = ctx.getMatScaleX();
                     sy = ctx.getMatScaleY();
                 }
                 if (sx < 1e-4 || sy < 1e-1)
                     return;
                 if (sx > 1)
                     this.fontScaleX = sx;
                 if (sy > 1)
                     this.fontScaleY = sy;
             }
             font._italic && (ctx._italicDeg = 13);
             //准备bmp
             //拷贝到texture上,得到一个gltexture和uv
             var wt = data;
             var isWT = !htmlchars && (data instanceof WordText);
             var str = data;
             var isHtmlChar = !!htmlchars;
             /**
              * sameTexData
              * WordText 中保存了一个数组，这个数组是根据贴图排序的，目的是为了能相同的贴图合并。
              * 类型是 {ri:CharRenderInfo,stx:int,sty:int,...}[文字个数][贴图分组]
              */
             var sameTexData = isWT ? wt.pageChars : [];
             //总宽度，下面的对齐需要
             var strWidth = 0;
             if (isWT) {
                 str = wt._text;
                 strWidth = wt.width;
                 if (strWidth < 0) {
                     strWidth = wt.width = this.charRender.getWidth(this.fontStr, str); // 字符串长度是原始的。
                 }
             }
             else {
                 strWidth = str ? this.charRender.getWidth(this.fontStr, str) : 0;
             }
             //水平对齐方式
             switch (textAlign) {
                 case ILaya.Context.ENUM_TEXTALIGN_CENTER:
                     x -= strWidth / 2;
                     break;
                 case ILaya.Context.ENUM_TEXTALIGN_RIGHT:
                     x -= strWidth;
                     break;
             }
             //检查保存的数据是否有的已经被释放了
             if (wt && sameTexData) { // TODO 能利用lastGCCnt么
                 //wt.lastGCCnt = _curPage.gcCnt;
                 if (this.hasFreedText(sameTexData)) {
                     sameTexData = wt.pageChars = [];
                 }
             }
             var ri = null;
             var splitTex = this.renderPerChar = (!isWT) || TextRender.forceSplitRender || isHtmlChar || (isWT && wt.splitRender); // 拆分字符串渲染，这个优先级高
             if (!sameTexData || sameTexData.length < 1) {
                 // 重新构建缓存的贴图信息
                 // TODO 还是要ctx.scale么
                 if (splitTex) {
                     // 如果要拆分字符渲染
                     var stx = 0;
                     var sty = 0;
                     this._curStrPos = 0;
                     var curstr;
                     while (true) {
                         if (isHtmlChar) {
                             var chc = htmlchars[this._curStrPos++];
                             if (chc) {
                                 curstr = chc.char;
                                 stx = chc.x;
                                 sty = chc.y;
                             }
                             else {
                                 curstr = null;
                             }
                         }
                         else {
                             curstr = this.getNextChar(str);
                         }
                         if (!curstr)
                             break;
                         ri = this.getCharRenderInfo(curstr, font, color, strokeColor, lineWidth, false);
                         if (!ri) {
                             // 没有分配到。。。
                             break;
                         }
                         if (ri.isSpace) ;
                         else {
                             //分组保存
                             var add = sameTexData[ri.tex.id];
                             if (!add) {
                                 var o1 = { texgen: ri.tex.genID, tex: ri.tex, words: [] }; // 根据genid来减少是否释放的判断量
                                 sameTexData[ri.tex.id] = o1;
                                 add = o1.words;
                             }
                             else {
                                 add = add.words;
                             }
                             //不能直接修改ri.bmpWidth, 否则会累积缩放，所以把缩放保存到独立的变量中
                             if (ILaya.Render.isConchApp) {
                                 add.push({ ri: ri, x: stx, y: sty, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY });
                             }
                             else {
                                 add.push({ ri: ri, x: stx + 1 / this.fontScaleX, y: sty, w: (ri.bmpWidth - 2) / this.fontScaleX, h: (ri.bmpHeight - 1) / this.fontScaleY }); // 为了避免边缘像素采样错误，内缩一个像素
                             }
                             stx += ri.width; // TODO 缩放
                         }
                     }
                 }
                 else {
                     // 如果要整句话渲染
                     var isotex = TextRender.noAtlas || strWidth * this.fontScaleX > TextRender.atlasWidth; // 独立贴图还是大图集
                     ri = this.getCharRenderInfo(str, font, color, strokeColor, lineWidth, isotex);
                     // 整句渲染，则只有一个贴图
                     if (ILaya.Render.isConchApp) {
                         sameTexData[0] = { texgen: ri.tex.genID, tex: ri.tex, words: [{ ri: ri, x: 0, y: 0, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY }] };
                     }
                     else {
                         sameTexData[0] = { texgen: ri.tex.genID, tex: ri.tex, words: [{ ri: ri, x: 1 / this.fontScaleX, y: 0 / this.fontScaleY, w: (ri.bmpWidth - 2) / this.fontScaleX, h: (ri.bmpHeight - 1) / this.fontScaleY }] }; // 为了避免边缘像素采样错误，内缩一个像素
                     }
                 }
                 //TODO getbmp 考虑margin 字体与标准字体的关系
             }
             this._drawResortedWords(ctx, x, y, sameTexData);
             ctx._italicDeg = 0;
         }
         /**
          * 画出重新按照贴图顺序分组的文字。
          * @param	samePagesData
          * @param  startx 保存的数据是相对位置，所以需要加上这个偏移。用相对位置更灵活一些。
          * @param y {int} 因为这个只能画在一行上所以没有必要保存y。所以这里再把y传进来
          */
         _drawResortedWords(ctx, startx, starty, samePagesData) {
             var isLastRender = ctx._charSubmitCache && ctx._charSubmitCache._enbale;
             var mat = ctx._curMat;
             var slen = samePagesData.length;
             for (var id = 0; id < slen; id++) {
                 var dt = samePagesData[id];
                 if (!dt)
                     continue;
                 var pri = dt.words;
                 var pisz = pri.length;
                 if (pisz <= 0)
                     continue;
                 var tex = samePagesData[id].tex;
                 for (var j = 0; j < pisz; j++) {
                     var riSaved = pri[j];
                     var ri = riSaved.ri;
                     if (ri.isSpace)
                         continue;
                     ri.touch();
                     ctx.drawTexAlign = true;
                     //ctx._drawTextureM(ri.tex.texture as Texture, startx +riSaved.x -ri.orix / fontScaleX , starty + riSaved.y -ri.oriy / fontScaleY , riSaved.w, riSaved.h, null, 1.0, ri.uv);
                     if (ILaya.Render.isConchApp) {
                         ctx._drawTextureM(tex.texture, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, null, 1.0, ri.uv);
                     }
                     else {
                         let t = tex;
                         ctx._inner_drawTexture(t.texture, t.id, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, mat, ri.uv, 1.0, isLastRender);
                     }
                     if (ctx.touches) {
                         ctx.touches.push(ri);
                     }
                 }
             }
             //不要影响别人
             //ctx._curSubmit._key.other = -1;
         }
         /**
          * 检查 txts数组中有没有被释放的资源
          * @param	txts {{ri:CharRenderInfo,...}[][]}
          * @param	startid
          * @return
          */
         hasFreedText(txts) {
             var sz = txts.length;
             for (var i = 0; i < sz; i++) {
                 var pri = txts[i];
                 if (!pri)
                     continue;
                 var tex = pri.tex;
                 if (tex.__destroyed || tex.genID != pri.texgen) {
                     return true;
                 }
             }
             return false;
         }
         getCharRenderInfo(str, font, color, strokeColor, lineWidth, isoTexture = false) {
             var fid = this.mapFont[font._family];
             if (fid == undefined) {
                 this.mapFont[font._family] = fid = this.fontID++;
             }
             /*
             var cid:int = mapColor[color];
             if (cid == undefined) {
                 mapColor[color] = cid = colorID++;
             }
             var scid:int = mapColor[strokeColor];
             */
             var key = str + '_' + fid + '_' + font._size + '_' + color;
             if (lineWidth > 0)
                 key += '_' + strokeColor + lineWidth;
             if (font._bold)
                 key += 'P';
             if (this.fontScaleX != 1 || this.fontScaleY != 1) {
                 key += (this.fontScaleX * 20 | 0) + '_' + (this.fontScaleY * 20 | 0); // 这个精度可以控制占用资源的大小，精度越高越能细分缩放。
             }
             var i = 0;
             // 遍历所有的大图集看是否存在
             var sz = this.textAtlases.length;
             var ri = null;
             var atlas = null;
             if (!isoTexture) {
                 for (i = 0; i < sz; i++) {
                     atlas = this.textAtlases[i];
                     ri = atlas.charMaps[key];
                     if (ri) {
                         ri.touch();
                         return ri;
                     }
                 }
             }
             // 没有找到，要创建一个
             ri = new CharRenderInfo();
             this.charRender.scale(this.fontScaleX, this.fontScaleY);
             ri.char = str;
             ri.height = font._size;
             var margin = font._size / 3 | 0; // 凑的。 注意这里不能乘以缩放，因为ctx会自动处理
             // 如果不存在，就要插入已有的，或者创建新的
             var imgdt = null;
             // 先大约测量文字宽度 
             var w1 = Math.ceil(this.charRender.getWidth(this.fontStr, str) * this.fontScaleX);
             if (w1 > this.charRender.canvasWidth) {
                 this.charRender.canvasWidth = Math.min(2048, w1 + margin * 2);
             }
             if (isoTexture) {
                 // 独立贴图
                 imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, null);
                 // 这里可以直接
                 var tex = TextTexture.getTextTexture(imgdt.width, imgdt.height);
                 tex.addChar(imgdt, 0, 0, ri.uv);
                 ri.tex = tex;
                 ri.orix = margin; // 这里是原始的，不需要乘scale,因为scale的会创建一个scale之前的rect
                 ri.oriy = margin;
                 tex.ri = ri;
                 this.isoTextures.push(tex);
             }
             else {
                 // 大图集
                 var len = str.length;
                 var lineExt = lineWidth * 1; // 这里，包括下面的*2 都尽量用整数。否则在取整以后可能有有偏移。
                 var fw = Math.ceil((this.fontSizeW + lineExt * 2) * this.fontScaleX); //本来只要 lineWidth就行，但是这样安全一些
                 var fh = Math.ceil((this.fontSizeH + lineExt * 2) * this.fontScaleY);
                 TextRender.imgdtRect[0] = ((margin - this.fontSizeOffX - lineExt) * this.fontScaleX) | 0; // 本来要 lineWidth/2 但是这样一些尖角会有问题，所以大一点
                 TextRender.imgdtRect[1] = ((margin - this.fontSizeOffY - lineExt) * this.fontScaleY) | 0;
                 if (this.renderPerChar || len == 1) {
                     // 单个字符的处理
                     TextRender.imgdtRect[2] = Math.max(w1, fw);
                     TextRender.imgdtRect[3] = Math.max(w1, fh); // 高度也要取大的。 例如emoji
                 }
                 else {
                     // 多个字符的处理
                     TextRender.imgdtRect[2] = -1; // -1 表示宽度要测量
                     TextRender.imgdtRect[3] = fh; // TODO 如果被裁剪了，可以考虑把这个加大一点点
                 }
                 imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, TextRender.imgdtRect);
                 atlas = this.addBmpData(imgdt, ri);
                 if (TextRender.isWan1Wan) {
                     // 这时候 imgdtRect 是不好使的，要自己设置
                     ri.orix = margin; // 不要乘缩放。要不后面也要除。
                     ri.oriy = margin;
                 }
                 else {
                     // 取下来的imagedata的原点在哪
                     ri.orix = (this.fontSizeOffX + lineExt); // 由于是相对于imagedata的，上面会根据包边调整左上角，所以原点也要相应反向调整
                     ri.oriy = (this.fontSizeOffY + lineExt);
                 }
                 atlas.charMaps[key] = ri;
             }
             return ri;
         }
         /**
          * 添加数据到大图集
          * @param	w
          * @param	h
          * @return
          */
         addBmpData(data, ri) {
             var w = data.width;
             var h = data.height;
             var sz = this.textAtlases.length;
             var atlas = null;
             var find = false;
             for (var i = 0; i < sz; i++) {
                 atlas = this.textAtlases[i];
                 find = atlas.getAEmpty(w, h, this.tmpAtlasPos);
                 if (find) {
                     break;
                 }
             }
             if (!find) {
                 // 创建一个新的
                 atlas = new TextAtlas();
                 this.textAtlases.push(atlas);
                 find = atlas.getAEmpty(w, h, this.tmpAtlasPos);
                 if (!find) {
                     throw 'err1'; //TODO
                 }
                 // 清理旧的
                 this.cleanAtlases();
             }
             if (find) {
                 atlas.texture.addChar(data, this.tmpAtlasPos.x, this.tmpAtlasPos.y, ri.uv);
                 ri.tex = atlas.texture;
             }
             return atlas;
         }
         /**
          * 清理利用率低的大图集
          */
         GC() {
             var i = 0;
             var sz = this.textAtlases.length;
             var dt = 0;
             var destroyDt = TextRender.destroyAtlasDt;
             var totalUsedRate = 0; // 总使用率
             var totalUsedRateAtlas = 0;
             var curloop = RenderInfo.loopCount;
             //var minUsedRateID:int = -1;
             //var minUsedRate:Number = 1;
             var maxWasteRateID = -1;
             var maxWasteRate = 0;
             var tex = null;
             var curatlas = null;
             // 图集的清理
             for (; i < sz; i++) {
                 curatlas = this.textAtlases[i];
                 tex = curatlas.texture;
                 if (tex) {
                     totalUsedRate += tex.curUsedCovRate;
                     totalUsedRateAtlas += tex.curUsedCovRateAtlas;
                     // 浪费掉的图集
                     // (已经占用的图集和当前使用的图集的差。图集不可局部重用，所以有占用的和使用的的区别)
                     var waste = curatlas.usedRate - tex.curUsedCovRateAtlas;
                     // 记录哪个图集浪费的最多
                     if (maxWasteRate < waste) {
                         maxWasteRate = waste;
                         maxWasteRateID = i;
                     }
                     /*
                     if (minUsedRate > tex.curUsedCovRate) {
                         minUsedRate = tex.curUsedCovRate;
                         minUsedRateID = i;
                     }
                     */
                 }
                 // 如果当前贴图的touch时间超出了指定的间隔（单位是帧，例如），则设置回收
                 // 可能同时会有多个图集被回收
                 dt = curloop - curatlas.texture.lastTouchTm;
                 if (dt > destroyDt) {
                     TextRender.showLog && console.log('TextRender GC delete atlas ' + tex ? curatlas.texture.id : 'unk');
                     curatlas.destroy();
                     this.textAtlases[i] = this.textAtlases[sz - 1]; // 把最后的拿过来冲掉
                     sz--;
                     i--;
                     maxWasteRateID = -1;
                 }
             }
             // 缩减图集数组的长度
             this.textAtlases.length = sz;
             // 独立贴图的清理 TODO 如果多的话，要不要分开处理
             sz = this.isoTextures.length;
             for (i = 0; i < sz; i++) {
                 tex = this.isoTextures[i];
                 dt = curloop - tex.lastTouchTm;
                 if (dt > TextRender.destroyUnusedTextureDt) {
                     tex.ri.deleted = true;
                     tex.ri.tex = null;
                     // 直接删除，不回收
                     tex.destroy();
                     this.isoTextures[i] = this.isoTextures[sz - 1];
                     sz--;
                     i--;
                 }
             }
             this.isoTextures.length = sz;
             // 如果超出内存需要清理不常用
             var needGC = this.textAtlases.length > 1 && this.textAtlases.length - totalUsedRateAtlas >= 2; // 总量浪费了超过2张
             if (TextRender.atlasWidth * TextRender.atlasWidth * 4 * this.textAtlases.length > TextRender.cleanMem || needGC || TextRender.simClean) {
                 TextRender.simClean = false;
                 TextRender.showLog && console.log('清理使用率低的贴图。总使用率:', totalUsedRateAtlas, ':', this.textAtlases.length, '最差贴图:' + maxWasteRateID);
                 if (maxWasteRateID >= 0) {
                     curatlas = this.textAtlases[maxWasteRateID];
                     curatlas.destroy();
                     this.textAtlases[maxWasteRateID] = this.textAtlases[this.textAtlases.length - 1];
                     this.textAtlases.length = this.textAtlases.length - 1;
                 }
             }
             TextTexture.clean();
         }
         /**
          * 尝试清理大图集
          */
         cleanAtlases() {
             // TODO 根据覆盖率决定是否清理
         }
         getCharBmp(c) {
         }
         /**
          * 检查当前线是否存在数据
          * @param	data
          * @param	l
          * @param	sx
          * @param	ex
          * @return
          */
         checkBmpLine(data, l, sx, ex) {
             if (this.bmpData32.buffer != data.data.buffer) {
                 this.bmpData32 = new Uint32Array(data.data.buffer);
             }
             var stpos = data.width * l + sx;
             for (var x = sx; x < ex; x++) {
                 if (this.bmpData32[stpos++] != 0)
                     return true;
             }
             return false;
         }
         /**
          * 根据bmp数据和当前的包围盒，更新包围盒
          * 由于选择的文字是连续的，所以可以用二分法
          * @param	data
          * @param	curbbx 	[l,t,r,b]
          * @param   onlyH 不检查左右
          */
         updateBbx(data, curbbx, onlyH = false) {
             var w = data.width;
             var h = data.height;
             var x = 0;
             // top
             var sy = curbbx[1]; //从t到0 sy表示有数据的行
             var ey = 0;
             var y = sy;
             if (this.checkBmpLine(data, sy, 0, w)) {
                 // 如果当前行有数据，就要往上找
                 while (true) {
                     y = (sy + ey) / 2 | 0; // 必须是int
                     if (y + 1 >= sy) { // 
                         // 找到了。严格来说还不知道这个是否有像素，不过这里要求不严格，可以认为有
                         curbbx[1] = y;
                         break;
                     }
                     if (this.checkBmpLine(data, y, 0, w)) {
                         //中间线有数据，搜索上半部分
                         sy = y;
                     }
                     else {
                         //中间线没有有数据，搜索下半部分
                         ey = y;
                     }
                 }
             }
             // 下半部分
             if (curbbx[3] > h)
                 curbbx[3] = h;
             else {
                 y = sy = curbbx[3];
                 ey = h;
                 if (this.checkBmpLine(data, sy, 0, w)) {
                     while (true) {
                         y = (sy + ey) / 2 | 0;
                         if (y - 1 <= sy) {
                             curbbx[3] = y;
                             break;
                         }
                         if (this.checkBmpLine(data, y, 0, w)) {
                             sy = y;
                         }
                         else {
                             ey = y;
                         }
                     }
                 }
             }
             if (onlyH)
                 return;
             // 左半部分
             var minx = curbbx[0];
             var stpos = w * curbbx[1]; //w*cy+0
             for (y = curbbx[1]; y < curbbx[3]; y++) {
                 for (x = 0; x < minx; x++) {
                     if (this.bmpData32[stpos + x] != 0) {
                         minx = x;
                         break;
                     }
                 }
                 stpos += w;
             }
             curbbx[0] = minx;
             // 右半部分
             var maxx = curbbx[2];
             stpos = w * curbbx[1]; //w*cy
             for (y = curbbx[1]; y < curbbx[3]; y++) {
                 for (x = maxx; x < w; x++) {
                     if (this.bmpData32[stpos + x] != 0) {
                         maxx = x;
                         break;
                     }
                 }
                 stpos += w;
             }
             curbbx[2] = maxx;
         }
         getFontSizeInfo(font) {
             var finfo = this.fontSizeInfo[font];
             if (finfo != undefined)
                 return finfo;
             var fontstr = 'bold ' + TextRender.standardFontSize + 'px ' + font;
             if (TextRender.isWan1Wan) {
                 // 这时候无法获得imagedata，只能采取保险测量
                 this.fontSizeW = this.charRender.getWidth(fontstr, '有') * 1.5;
                 this.fontSizeH = TextRender.standardFontSize * 1.5;
                 var szinfo = this.fontSizeW << 8 | this.fontSizeH;
                 this.fontSizeInfo[font] = szinfo;
                 return szinfo;
             }
             // bbx初始大小
             TextRender.pixelBBX[0] = TextRender.standardFontSize / 2; // 16;
             TextRender.pixelBBX[1] = TextRender.standardFontSize / 2; // 16;
             TextRender.pixelBBX[2] = TextRender.standardFontSize; // 32;
             TextRender.pixelBBX[3] = TextRender.standardFontSize; // 32;
             var orix = 16; // 左边留白，也就是x原点的位置
             var oriy = 16;
             var marginr = 16;
             var marginb = 16;
             this.charRender.scale(1, 1);
             TextRender.tmpRI.height = TextRender.standardFontSize;
             var bmpdt = this.charRender.getCharBmp('g', fontstr, 0, 'red', null, TextRender.tmpRI, orix, oriy, marginr, marginb);
             // native 返回的是 textBitmap。 data直接是ArrayBuffer 
             if (ILaya.Render.isConchApp) {
                 //bmpdt.data.buffer = bmpdt.data;
                 bmpdt.data = new Uint8ClampedArray(bmpdt.data);
             }
             this.bmpData32 = new Uint32Array(bmpdt.data.buffer);
             //测量宽度是 tmpRI.width
             this.updateBbx(bmpdt, TextRender.pixelBBX, false);
             bmpdt = this.charRender.getCharBmp('有', fontstr, 0, 'red', null, TextRender.tmpRI, oriy, oriy, marginr, marginb); // '有'比'国'大
             if (ILaya.Render.isConchApp) {
                 //bmpdt.data.buffer = bmpdt.data;
                 bmpdt.data = new Uint8ClampedArray(bmpdt.data);
             }
             this.bmpData32 = new Uint32Array(bmpdt.data.buffer);
             // 国字的宽度就用系统测量的，不再用像素检测
             if (TextRender.pixelBBX[2] < orix + TextRender.tmpRI.width)
                 TextRender.pixelBBX[2] = orix + TextRender.tmpRI.width;
             this.updateBbx(bmpdt, TextRender.pixelBBX, false); //TODO 改成 true
             // 原点在 16,16
             if (ILaya.Render.isConchApp) {
                 //runtime 的接口好像有问题，不认orix，oriy
                 orix = 0;
                 oriy = 0;
             }
             var xoff = Math.max(orix - TextRender.pixelBBX[0], 0);
             var yoff = Math.max(oriy - TextRender.pixelBBX[1], 0);
             var bbxw = TextRender.pixelBBX[2] - TextRender.pixelBBX[0];
             var bbxh = TextRender.pixelBBX[3] - TextRender.pixelBBX[1];
             var sizeinfo = xoff << 24 | yoff << 16 | bbxw << 8 | bbxh;
             this.fontSizeInfo[font] = sizeinfo;
             return sizeinfo;
         }
         printDbgInfo() {
             console.log('图集个数:' + this.textAtlases.length + ',每个图集大小:' + TextRender.atlasWidth + 'x' + TextRender.atlasWidth, ' 用canvas:', TextRender.isWan1Wan);
             console.log('图集占用空间:' + (TextRender.atlasWidth * TextRender.atlasWidth * 4 / 1024 / 1024 * this.textAtlases.length) + 'M');
             console.log('缓存用到的字体:');
             for (var f in this.mapFont) {
                 var fontsz = this.getFontSizeInfo(f);
                 var offx = fontsz >> 24;
                 var offy = (fontsz >> 16) & 0xff;
                 var fw = (fontsz >> 8) & 0xff;
                 var fh = fontsz & 0xff;
                 console.log('    ' + f, ' off:', offx, offy, ' size:', fw, fh);
             }
             var num = 0;
             console.log('缓存数据:');
             var totalUsedRate = 0; // 总使用率
             var totalUsedRateAtlas = 0;
             this.textAtlases.forEach(function (a) {
                 var id = a.texture.id;
                 var dt = RenderInfo.loopCount - a.texture.lastTouchTm;
                 var dtstr = dt > 0 ? ('' + dt + '帧以前') : '当前帧';
                 totalUsedRate += a.texture.curUsedCovRate;
                 totalUsedRateAtlas += a.texture.curUsedCovRateAtlas;
                 console.log('--图集(id:' + id + ',当前使用率:' + (a.texture.curUsedCovRate * 1000 | 0) + '‰', '当前图集使用率:', (a.texture.curUsedCovRateAtlas * 100 | 0) + '%', '图集使用率:', (a.usedRate * 100 | 0), '%, 使用于:' + dtstr + ')--:');
                 for (var k in a.charMaps) {
                     var ri = a.charMaps[k];
                     console.log('     off:', ri.orix, ri.oriy, ' bmp宽高:', ri.bmpWidth, ri.bmpHeight, '无效:', ri.deleted, 'touchdt:', (RenderInfo.loopCount - ri.touchTick), '位置:', ri.uv[0] * TextRender.atlasWidth | 0, ri.uv[1] * TextRender.atlasWidth | 0, '字符:', ri.char, 'key:', k);
                     num++;
                 }
             });
             console.log('独立贴图文字(' + this.isoTextures.length + '个):');
             this.isoTextures.forEach(function (tex) {
                 console.log('    size:', tex._texW, tex._texH, 'touch间隔:', (RenderInfo.loopCount - tex.lastTouchTm), 'char:', tex.ri.char);
             });
             console.log('总缓存:', num, '总使用率:', totalUsedRate, '总当前图集使用率:', totalUsedRateAtlas);
         }
         // 在屏幕上显示某个大图集
         showAtlas(n, bgcolor, x, y, w, h) {
             if (!this.textAtlases[n]) {
                 console.log('没有这个图集');
                 return null;
             }
             var sp = new ILaya.Sprite();
             var texttex = this.textAtlases[n].texture;
             var texture = {
                 width: TextRender.atlasWidth,
                 height: TextRender.atlasWidth,
                 sourceWidth: TextRender.atlasWidth,
                 sourceHeight: TextRender.atlasWidth,
                 offsetX: 0,
                 offsetY: 0,
                 getIsReady: function () { return true; },
                 _addReference: function () { },
                 _removeReference: function () { },
                 _getSource: function () { return texttex._getSource(); },
                 bitmap: { id: texttex.id },
                 _uv: Texture.DEF_UV
             };
             sp.size = function (w, h) {
                 this.width = w;
                 this.height = h;
                 sp.graphics.clear();
                 sp.graphics.drawRect(0, 0, sp.width, sp.height, bgcolor);
                 sp.graphics.drawTexture(texture, 0, 0, sp.width, sp.height);
                 return this;
             };
             sp.graphics.drawRect(0, 0, w, h, bgcolor);
             sp.graphics.drawTexture(texture, 0, 0, w, h);
             sp.pos(x, y);
             window.Laya.stage.addChild(sp);
             return sp;
         }
         /////// native ///////
         filltext_native(ctx, data, htmlchars, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {
             if (data && data.length <= 0)
                 return;
             if (htmlchars && htmlchars.length < 1)
                 return;
             var font = FontInfo.Parse(fontStr);
             var nTextAlign = 0;
             switch (textAlign) {
                 case 'center':
                     nTextAlign = ILaya.Context.ENUM_TEXTALIGN_CENTER;
                     break;
                 case 'right':
                     nTextAlign = ILaya.Context.ENUM_TEXTALIGN_RIGHT;
                     break;
             }
             return this._fast_filltext(ctx, data, htmlchars, x, y, font, color, strokeColor, lineWidth, nTextAlign, underLine);
         }
     }
     //config
     TextRender.useOldCharBook = false;
     TextRender.atlasWidth = 2048;
     TextRender.noAtlas = false; // 一串文字用独立贴图
     TextRender.forceSplitRender = false; // 强制把一句话拆开渲染
     TextRender.forceWholeRender = false; // 强制整句话渲染
     TextRender.scaleFontWithCtx = true; // 如果有缩放，则修改字体，以保证清晰度
     TextRender.standardFontSize = 32; // 测量的时候使用的字体大小
     TextRender.destroyAtlasDt = 10; // 回收图集贴图的时间
     TextRender.checkCleanTextureDt = 2000; // 检查是否要真正删除纹理的时间。单位是ms
     TextRender.destroyUnusedTextureDt = 3000; // 长时间不用的纹理删除的时间。单位是ms
     TextRender.cleanMem = 100 * 1024 * 1024; // 多大内存触发清理图集。这时候占用率低的图集会被清理
     TextRender.isWan1Wan = false;
     TextRender.showLog = false;
     TextRender.debugUV = false; // 文字纹理需要保护边。当像素没有对齐的时候，可能会采样到旁边的贴图。true则填充texture为白色，模拟干扰
     TextRender.atlasWidth2 = 2048 * 2048;
     TextRender.tmpRI = new CharRenderInfo();
     TextRender.pixelBBX = [0, 0, 0, 0];
     TextRender.textRenderInst = null; //debug
     TextRender.imgdtRect = [0, 0, 0, 0];
     TextRender.simClean = false; // 测试用。强制清理占用低的图集
     TextTexture.gTextRender = TextRender;

     /**
      * @private
      * Context扩展类
      */
     class Context {
         constructor() {
             this._tmpMatrix = new Matrix(); // chrome下静态的访问比从this访问要慢
             this._drawTexToDrawTri_Vert = new Float32Array(8); // 从速度考虑，不做成static了
             this._drawTexToDrawTri_Index = new Uint16Array([0, 1, 2, 0, 2, 3]);
             this._tempUV = new Float32Array(8);
             this._drawTriUseAbsMatrix = false; //drawTriange函数的矩阵是全局的，不用再乘以当前矩阵了。这是一个补丁。
             this._id = ++Context._COUNT;
             this._other = null;
             this._renderNextSubmitIndex = 0;
             this._path = null;
             this._drawCount = 1;
             this._width = Context._MAXSIZE;
             this._height = Context._MAXSIZE;
             this._renderCount = 0;
             this._isConvexCmd = true; //arc等是convex的，moveTo,linTo就不是了
             this._submits = null;
             this._curSubmit = null;
             this._submitKey = new SubmitKey(); //当前将要使用的设置。用来跟上一次的_curSubmit比较
             this._mesh = null; //用Mesh2D代替_vb,_ib. 当前使用的mesh
             this._pathMesh = null; //矢量专用mesh。
             this._triangleMesh = null; //drawTriangles专用mesh。由于ib不固定，所以不能与_mesh通用
             this.meshlist = []; //本context用到的mesh
             //public var _vbs:Array = [];	//双buffer管理。TODO 临时删掉，需要mesh中加上
             this._transedPoints = new Array(8); //临时的数组，用来计算4个顶点的转换后的位置。
             this._temp4Points = new Array(8); //临时数组。用来保存4个顶点的位置。
             this._clipRect = Context.MAXCLIPRECT;
             //public var _transedClipInfo:Array = [0, 0, Context._MAXSIZE, 0, 0, Context._MAXSIZE];	//应用矩阵后的clip。ox,oy, xx,xy,yx,yy 	xx,xy等是缩放*宽高
             this._globalClipMatrix = new Matrix(Context._MAXSIZE, 0, 0, Context._MAXSIZE, 0, 0); //用矩阵描述的clip信息。最终的点投影到这个矩阵上，在0~1之间就可见。
             this._clipInCache = false; // 当前记录的clipinfo是在cacheas normal后赋值的，因为cacheas normal会去掉当前矩阵的tx，ty，所以需要记录一下，以便在是shader中恢复
             this._clipInfoID = 0; //用来区分是不是clipinfo已经改变了
             this._curMat = null;
             //计算矩阵缩放的缓存
             this._lastMatScaleX = 1.0;
             this._lastMatScaleY = 1.0;
             this._lastMat_a = 1.0;
             this._lastMat_b = 0.0;
             this._lastMat_c = 0.0;
             this._lastMat_d = 1.0;
             this._nBlendType = 0;
             this._save = null;
             this._targets = null;
             this._charSubmitCache = null;
             this._saveMark = null;
             this._shader2D = new Shader2D(); //
             /**
              * 所cacheAs精灵
              * 对于cacheas bitmap的情况，如果图片还没准备好，需要有机会重画，所以要保存sprite。例如在图片
              * 加载完成后，调用repaint
              */
             this.sprite = null;
             this._italicDeg = 0; //文字的倾斜角度
             this._lastTex = null; //上次使用的texture。主要是给fillrect用，假装自己也是一个drawtexture
             this._fillColor = 0;
             this._flushCnt = 0;
             this.defTexture = null; //给fillrect用
             this._colorFiler = null;
             this.drawTexAlign = false; // 按照像素对齐
             this._incache = false; // 正处在cacheas normal过程中
             this.isMain = false; // 是否是主context
             Context._contextcount++;
             Context._textRender = Context._textRender || new TextRender();
             //_ib = IndexBuffer2D.QuadrangleIB;
             if (!this.defTexture) {
                 var defTex2d = new Texture2D(2, 2);
                 defTex2d.setPixels(new Uint8Array(16));
                 defTex2d.lock = true;
                 this.defTexture = new Texture(defTex2d);
             }
             this._lastTex = this.defTexture;
             this.clear();
         }
         static __init__() {
             Context.MAXCLIPRECT = new Rectangle(0, 0, Context._MAXSIZE, Context._MAXSIZE);
             ContextParams.DEFAULT = new ContextParams();
         }
         /**@private */
         drawImage(...args) {
         }
         /**@private */
         getImageData(...args) {
         }
         /**@private */
         measureText(text) {
             return null;
         }
         /**@private */
         setTransform(...args) {
         }
         /**@private */
         $transform(a, b, c, d, tx, ty) {
         }
         /**@private */
         get lineJoin() {
             return null;
         }
         /**@private */
         set lineJoin(value) {
         }
         /**@private */
         get lineCap() {
             return null;
         }
         /**@private */
         set lineCap(value) {
         }
         /**@private */
         get miterLimit() {
             return null;
         }
         /**@private */
         set miterLimit(value) {
         }
         /**@private */
         clearRect(x, y, width, height) {
         }
         /**@private */
         //TODO:coverage
         _drawRect(x, y, width, height, style) {
             Stat.renderBatches++;
             style && (this.fillStyle = style);
             this.fillRect(x, y, width, height, null);
         }
         ///**@private */
         //public function transformByMatrix(value:Matrix):void {
         //this.transform(value.a, value.b, value.c, value.d, value.tx, value.ty);
         //}
         /**@private */
         //TODO:coverage
         //public function setTransformByMatrix(value:Matrix):void {
         //	this.setTransform(value.a, value.b, value.c, value.d, value.tx, value.ty);
         //}
         /**@private */
         //TODO:coverage
         drawTexture2(x, y, pivotX, pivotY, m, args2) {
         }
         //=============新增==================
         transformByMatrix(matrix, tx, ty) {
             this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx + tx, matrix.ty + ty);
         }
         saveTransform(matrix) {
             this.save();
         }
         restoreTransform(matrix) {
             this.restore();
         }
         drawRect(x, y, width, height, fillColor, lineColor, lineWidth) {
             var ctx = this;
             //填充矩形
             if (fillColor != null) {
                 ctx.fillStyle = fillColor;
                 ctx.fillRect(x, y, width, height);
             }
             //绘制矩形边框
             if (lineColor != null) {
                 ctx.strokeStyle = lineColor;
                 ctx.lineWidth = lineWidth;
                 ctx.strokeRect(x, y, width, height);
             }
         }
         alpha(value) {
             this.globalAlpha *= value;
         }
         //TODO:coverage
         _transform(mat, pivotX, pivotY) {
             this.translate(pivotX, pivotY);
             this.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);
             this.translate(-pivotX, -pivotY);
         }
         _rotate(angle, pivotX, pivotY) {
             this.translate(pivotX, pivotY);
             this.rotate(angle);
             this.translate(-pivotX, -pivotY);
         }
         _scale(scaleX, scaleY, pivotX, pivotY) {
             this.translate(pivotX, pivotY);
             this.scale(scaleX, scaleY);
             this.translate(-pivotX, -pivotY);
         }
         _drawLine(x, y, fromX, fromY, toX, toY, lineColor, lineWidth, vid) {
             this.beginPath();
             this.strokeStyle = lineColor;
             this.lineWidth = lineWidth;
             this.moveTo(x + fromX, y + fromY);
             this.lineTo(x + toX, y + toY);
             this.stroke();
         }
         _drawLines(x, y, points, lineColor, lineWidth, vid) {
             this.beginPath();
             //x += args[0], y += args[1];
             this.strokeStyle = lineColor;
             this.lineWidth = lineWidth;
             //var points:Array = args[2];
             var n = points.length;
             this.addPath(points.slice(), false, false, x, y);
             this.stroke();
         }
         drawCurves(x, y, points, lineColor, lineWidth) {
             this.beginPath();
             this.strokeStyle = lineColor;
             this.lineWidth = lineWidth;
             //var points:Array = args[2];
             //x += args[0], y += args[1];
             this.moveTo(x + points[0], y + points[1]);
             var i = 2, n = points.length;
             while (i < n) {
                 this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);
             }
             this.stroke();
         }
         _fillAndStroke(fillColor, strokeColor, lineWidth, isConvexPolygon = false) {
             //绘制填充区域
             if (fillColor != null) {
                 this.fillStyle = fillColor;
                 this.fill();
             }
             //绘制边框
             if (strokeColor != null && lineWidth > 0) {
                 this.strokeStyle = strokeColor;
                 this.lineWidth = lineWidth;
                 this.stroke();
             }
         }
         _drawCircle(x, y, radius, fillColor, lineColor, lineWidth, vid) {
             Stat.renderBatches++;
             this.beginPath(true);
             this.arc(x, y, radius, 0, Context.PI2);
             this.closePath();
             //绘制
             this._fillAndStroke(fillColor, lineColor, lineWidth);
         }
         //矢量方法		
         _drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {
             //移动中心点
             //ctx.translate(x + args[0], y + args[1]);
             //形成路径
             this.beginPath();
             this.moveTo(x, y);
             this.arc(x, y, radius, startAngle, endAngle);
             this.closePath();
             //绘制
             this._fillAndStroke(fillColor, lineColor, lineWidth);
             //恢复中心点
             //ctx.translate(-x - args[0], -y - args[1]);
         }
         _drawPoly(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {
             //var points:Array = args[2];
             var n = points.length;
             this.beginPath();
             //poly一定是close的
             this.addPath(points.slice(), true, isConvexPolygon, x, y);
             this.closePath();
             this._fillAndStroke(fillColor, lineColor, lineWidth, isConvexPolygon);
         }
         _drawPath(x, y, paths, brush, pen) {
             //形成路径
             this.beginPath();
             //x += args[0], y += args[1];
             //var paths:Array = args[2];
             for (var i = 0, n = paths.length; i < n; i++) {
                 var path = paths[i];
                 switch (path[0]) {
                     case "moveTo":
                         this.moveTo(x + path[1], y + path[2]);
                         break;
                     case "lineTo":
                         this.lineTo(x + path[1], y + path[2]);
                         break;
                     case "arcTo":
                         this.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
                         break;
                     case "closePath":
                         this.closePath();
                         break;
                 }
             }
             //var brush:Object = args[3];
             if (brush != null) {
                 this.fillStyle = brush.fillStyle;
                 this.fill();
             }
             //var pen:Object = args[4];
             if (pen != null) {
                 this.strokeStyle = pen.strokeStyle;
                 this.lineWidth = pen.lineWidth || 1;
                 this.lineJoin = pen.lineJoin;
                 this.lineCap = pen.lineCap;
                 this.miterLimit = pen.miterLimit;
                 this.stroke();
             }
         }
         static set2DRenderConfig() {
             var gl = LayaGL.instance;
             WebGLContext.setBlend(gl, true); //还原2D设置
             WebGLContext.setBlendFunc(gl, WebGLContext.ONE, WebGLContext.ONE_MINUS_SRC_ALPHA);
             WebGLContext.setDepthTest(gl, false);
             WebGLContext.setCullFace(gl, false);
             WebGLContext.setDepthMask(gl, true);
             WebGLContext.setFrontFace(gl, WebGLContext.CCW);
             gl.viewport(0, 0, RenderState2D.width, RenderState2D.height); //还原2D视口
         }
         clearBG(r, g, b, a) {
             var gl = WebGLContext.mainContext;
             gl.clearColor(r, g, b, a);
             gl.clear(WebGLContext.COLOR_BUFFER_BIT);
         }
         //TODO:coverage
         _getSubmits() {
             return this._submits;
         }
         /**
          * 释放占用内存
          * @param	keepRT  是否保留rendertarget
          */
         _releaseMem(keepRT = false) {
             if (!this._submits)
                 return;
             this._curMat.destroy();
             this._curMat = null;
             this._shader2D.destroy();
             this._shader2D = null;
             this._charSubmitCache.clear();
             for (var i = 0, n = this._submits._length; i < n; i++) {
                 this._submits[i].releaseRender();
             }
             this._submits.length = 0;
             this._submits._length = 0;
             this._submits = null;
             this._curSubmit = null;
             this._path = null;
             //_other && (_other.font = null);
             this._save = null;
             var sz;
             for (i = 0, sz = this.meshlist.length; i < sz; i++) {
                 var curm = this.meshlist[i];
                 curm.destroy();
             }
             this.meshlist.length = 0;
             this.sprite = null;
             if (!keepRT) {
                 this._targets && (this._targets.destroy());
                 this._targets = null;
             }
             //TODO mesh 暂时releaseMem了
         }
         /**
          * 释放所有资源
          * @param	keepRT  是否保留rendertarget
          */
         destroy(keepRT = false) {
             --Context._contextcount;
             this.sprite = null;
             this._releaseMem(keepRT);
             this._charSubmitCache.destroy();
             //_ib && (_ib != IndexBuffer2D.QuadrangleIB) && _ib.releaseResource();
             this._mesh.destroy();
             if (!keepRT) {
                 this._targets && this._targets.destroy(); //用回收么？可能没什么重复利用的价值
                 this._targets = null;
             }
         }
         clear() {
             if (!this._submits) { //第一次
                 this._other = ContextParams.DEFAULT;
                 this._curMat = Matrix.create();
                 this._charSubmitCache = new CharSubmitCache();
                 //_vb = _vbs[0] = VertexBuffer2D.create( -1);
                 this._mesh = MeshQuadTexture.getAMesh(this.isMain);
                 this.meshlist.push(this._mesh);
                 this._pathMesh = MeshVG.getAMesh(this.isMain);
                 this.meshlist.push(this._pathMesh);
                 this._triangleMesh = MeshTexture.getAMesh(this.isMain);
                 this.meshlist.push(this._triangleMesh);
                 //if(Config.smartCache) _vbs[1] = VertexBuffer2D.create( -1);
                 this._submits = [];
                 this._save = [SaveMark.Create(this)];
                 this._save.length = 10;
                 this._shader2D = new Shader2D();
             }
             this._submitKey.clear();
             //_vb = _vbs[_renderCount%2];
             //_vb.clear();
             this._mesh.clearVB();
             this._renderCount++;
             //_targets && (_targets.repaint = true);
             this._drawCount = 1;
             this._other = ContextParams.DEFAULT;
             this._other.lineWidth = this._shader2D.ALPHA = 1.0;
             this._nBlendType = 0;
             this._clipRect = Context.MAXCLIPRECT;
             this._curSubmit = SubmitBase.RENDERBASE;
             SubmitBase.RENDERBASE._ref = 0xFFFFFF;
             SubmitBase.RENDERBASE._numEle = 0;
             this._shader2D.fillStyle = this._shader2D.strokeStyle = DrawStyle.DEFAULT;
             for (var i = 0, n = this._submits._length; i < n; i++)
                 this._submits[i].releaseRender();
             this._submits._length = 0;
             this._curMat.identity();
             this._other.clear();
             this._saveMark = this._save[0];
             this._save._length = 1;
         }
         /**
          * 设置ctx的size，这个不允许直接设置，必须是canvas调过来的。所以这个函数里也不用考虑canvas相关的东西
          * @param	w
          * @param	h
          */
         size(w, h) {
             if (this._width != w || this._height != h) {
                 this._width = w;
                 this._height = h;
                 //TODO 问题：如果是rendertarget 计算内存会有问题，即canvas算一次，rt又算一次,所以这里要修改
                 //这种情况下canvas应该不占内存
                 if (this._targets) {
                     this._targets.destroy();
                     this._targets = new RenderTexture2D(w, h, BaseTexture.FORMAT_R8G8B8A8, -1);
                 }
                 //如果是主画布，要记录窗口大小
                 //如果不是 TODO
                 if (this.isMain) {
                     WebGLContext.mainContext.viewport(0, 0, w, h);
                     RenderState2D.width = w;
                     RenderState2D.height = h;
                 }
             }
             if (w === 0 && h === 0)
                 this._releaseMem();
         }
         /**
          * 当前canvas请求保存渲染结果。
          * 实现：
          * 如果value==true，就要给_target赋值
          * @param value {Boolean}
          */
         set asBitmap(value) {
             if (value) {
                 //缺省的RGB没有a，不合理把。况且没必要自定义一个常量。
                 //深度格式为-1表示不用深度缓存。
                 this._targets || (this._targets = new RenderTexture2D(this._width, this._height, BaseTexture.FORMAT_R8G8B8A8, -1));
                 if (!this._width || !this._height)
                     throw Error("asBitmap no size!");
             }
             else {
                 this._targets && this._targets.destroy();
                 this._targets = null;
             }
         }
         /**
          * 获得当前矩阵的缩放值
          * 避免每次都计算getScaleX
          * @return
          */
         getMatScaleX() {
             if (this._lastMat_a == this._curMat.a && this._lastMat_b == this._curMat.b)
                 return this._lastMatScaleX;
             this._lastMatScaleX = this._curMat.getScaleX();
             this._lastMat_a = this._curMat.a;
             this._lastMat_b = this._curMat.b;
             return this._lastMatScaleX;
         }
         getMatScaleY() {
             if (this._lastMat_c == this._curMat.c && this._lastMat_d == this._curMat.d)
                 return this._lastMatScaleY;
             this._lastMatScaleY = this._curMat.getScaleY();
             this._lastMat_c = this._curMat.c;
             this._lastMat_d = this._curMat.d;
             return this._lastMatScaleY;
         }
         //TODO
         setFillColor(color) {
             this._fillColor = color;
         }
         getFillColor() {
             return this._fillColor;
         }
         set fillStyle(value) {
             if (!this._shader2D.fillStyle.equal(value)) {
                 SaveBase.save(this, SaveBase.TYPE_FILESTYLE, this._shader2D, false);
                 this._shader2D.fillStyle = DrawStyle.create(value);
                 this._submitKey.other = -this._shader2D.fillStyle.toInt();
             }
         }
         get fillStyle() {
             return this._shader2D.fillStyle;
         }
         set globalAlpha(value) {
             value = Math.floor(value * 1000) / 1000;
             if (value != this._shader2D.ALPHA) {
                 SaveBase.save(this, SaveBase.TYPE_ALPHA, this._shader2D, false);
                 this._shader2D.ALPHA = value;
             }
         }
         get globalAlpha() {
             return this._shader2D.ALPHA;
         }
         set textAlign(value) {
             (this._other.textAlign === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTALIGN, this._other, false), this._other.textAlign = value);
         }
         get textAlign() {
             return this._other.textAlign;
         }
         set textBaseline(value) {
             (this._other.textBaseline === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTBASELINE, this._other, false), this._other.textBaseline = value);
         }
         get textBaseline() {
             return this._other.textBaseline;
         }
         set globalCompositeOperation(value) {
             var n = BlendMode.TOINT[value];
             n == null || (this._nBlendType === n) || (SaveBase.save(this, SaveBase.TYPE_GLOBALCOMPOSITEOPERATION, this, true), this._curSubmit = SubmitBase.RENDERBASE, this._nBlendType = n /*, _shader2D.ALPHA = 1*/);
         }
         get globalCompositeOperation() {
             return BlendMode.NAMES[this._nBlendType];
         }
         set strokeStyle(value) {
             this._shader2D.strokeStyle.equal(value) || (SaveBase.save(this, SaveBase.TYPE_STROKESTYLE, this._shader2D, false), this._shader2D.strokeStyle = DrawStyle.create(value), this._submitKey.other = -this._shader2D.strokeStyle.toInt());
         }
         get strokeStyle() {
             return this._shader2D.strokeStyle;
         }
         translate(x, y) {
             if (x !== 0 || y !== 0) {
                 SaveTranslate.save(this);
                 if (this._curMat._bTransform) {
                     SaveTransform.save(this);
                     //_curMat.transformPointN(Point.TEMP.setTo(x, y));
                     //x = Point.TEMP.x;
                     //y = Point.TEMP.y;
                     //translate的话，相当于在当前坐标系下移动x,y，所以直接修改_curMat,然后x,y就消失了。
                     this._curMat.tx += (x * this._curMat.a + y * this._curMat.c);
                     this._curMat.ty += (x * this._curMat.b + y * this._curMat.d);
                 }
                 else {
                     this._curMat.tx = x;
                     this._curMat.ty = y;
                 }
             }
         }
         set lineWidth(value) {
             (this._other.lineWidth === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_LINEWIDTH, this._other, false), this._other.lineWidth = value);
         }
         get lineWidth() {
             return this._other.lineWidth;
         }
         save() {
             this._save[this._save._length++] = SaveMark.Create(this);
         }
         restore() {
             var sz = this._save._length;
             var lastBlend = this._nBlendType;
             if (sz < 1)
                 return;
             for (var i = sz - 1; i >= 0; i--) {
                 var o = this._save[i];
                 o.restore(this);
                 if (o.isSaveMark()) {
                     this._save._length = i;
                     return;
                 }
             }
             if (lastBlend != this._nBlendType) {
                 //阻止合并
                 this._curSubmit = SubmitBase.RENDERBASE;
             }
         }
         set font(str) {
             //if (str == _other.font.toString())
             //	return;
             this._other = this._other.make();
             SaveBase.save(this, SaveBase.TYPE_FONT, this._other, false);
             //_other.font === FontInContext.EMPTY ? (_other.font = new FontInContext(str)) : (_other.font.setFont(str));
         }
         //TODO:coverage
         fillText(txt, x, y, fontStr, color, align) {
             this._fillText(txt, null, x, y, fontStr, color, null, 0, null);
         }
         /**
          *
          * @param	txt
          * @param	words		HTMLChar 数组，是已经在外面排好版的一个数组
          * @param	x
          * @param	y
          * @param	fontStr
          * @param	color
          * @param	strokeColor
          * @param	lineWidth
          * @param	textAlign
          * @param	underLine
          */
         _fillText(txt, words, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {
             /*
             if (!window.testft) {
                 //测试文字
                 var teststr = 'a丠両丢丣两严並丧丨丩个丫丬中丮丯';
                 _charBook.filltext(this, teststr, 0, 0, 'normal 100 66px 华文行楷', '#ff0000');
                 window.testft = true;
             }
             */
             if (txt)
                 Context._textRender.filltext(this, txt, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine);
             else if (words)
                 Context._textRender.fillWords(this, words, x, y, fontStr, color, strokeColor, lineWidth);
         }
         _fast_filltext(data, x, y, fontObj, color, strokeColor, lineWidth, textAlign, underLine = 0) {
             Context._textRender._fast_filltext(this, data, null, x, y, fontObj, color, strokeColor, lineWidth, textAlign, underLine);
         }
         //TODO:coverage
         fillWords(words, x, y, fontStr, color) {
             this._fillText(null, words, x, y, fontStr, color, null, -1, null, 0);
         }
         //TODO:coverage
         fillBorderWords(words, x, y, font, color, borderColor, lineWidth) {
             this._fillBorderText(null, words, x, y, font, color, borderColor, lineWidth, null);
         }
         drawText(text, x, y, font, color, textAlign) {
             this._fillText(text, null, x, y, font, ColorUtils.create(color).strColor, null, -1, textAlign);
         }
         //public function fillText(txt:*, x:Number, y:Number, fontStr:String, color:String, textAlign:String):void {
         //_fillText(txt, null, x, y, fontStr, color, null, -1, textAlign);
         //}
         /**
          * 只画边框
          * @param	text
          * @param	x
          * @param	y
          * @param	font
          * @param	color
          * @param	lineWidth
          * @param	textAlign
          */
         strokeWord(text, x, y, font, color, lineWidth, textAlign) {
             //webgl绘制不了，需要解决
             this._fillText(text, null, x, y, font, null, ColorUtils.create(color).strColor, lineWidth || 1, textAlign);
         }
         /**
          * 即画文字又画边框
          * @param	txt
          * @param	x
          * @param	y
          * @param	fontStr
          * @param	fillColor
          * @param	borderColor
          * @param	lineWidth
          * @param	textAlign
          */
         fillBorderText(txt, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
             //webgl绘制不了，需要解决
             this._fillBorderText(txt, null, x, y, fontStr, ColorUtils.create(fillColor).strColor, ColorUtils.create(borderColor).strColor, lineWidth, textAlign);
         }
         _fillBorderText(txt, words, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
             this._fillText(txt, words, x, y, fontStr, fillColor, borderColor, lineWidth || 1, textAlign);
         }
         _fillRect(x, y, width, height, rgba) {
             var submit = this._curSubmit;
             var sameKey = submit && (submit._key.submitType === SubmitBase.KEY_DRAWTEXTURE && submit._key.blendShader === this._nBlendType);
             if (this._mesh.vertNum + 4 > Context._MAXVERTNUM) {
                 this._mesh = MeshQuadTexture.getAMesh(this.isMain); //创建新的mesh  TODO 如果_mesh不是常见格式，这里就不能这么做了。以后把_mesh单独表示成常用模式 
                 this.meshlist.push(this._mesh);
                 sameKey = false;
             }
             //clipinfo
             sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));
             this.transformQuad(x, y, width, height, 0, this._curMat, this._transedPoints);
             if (!this.clipedOff(this._transedPoints)) {
                 this._mesh.addQuad(this._transedPoints, Texture.NO_UV, rgba, false);
                 //if (GlUtils.fillRectImgVb(_mesh._vb, _clipRect, x, y, width, height, Texture.DEF_UV, _curMat, rgba,this)){
                 if (!sameKey) {
                     submit = this._curSubmit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                     this._submits[this._submits._length++] = submit;
                     this._copyClipInfo(submit, this._globalClipMatrix);
                     submit.shaderValue.textureHost = this._lastTex;
                     //这里有一个问题。例如 clip1, drawTex(tex1), clip2, fillRect, drawTex(tex2)	会被分成3个submit，
                     //submit._key.copyFrom2(_submitKey, SubmitBase.KEY_DRAWTEXTURE, (_lastTex && _lastTex.bitmap)?_lastTex.bitmap.id: -1);
                     submit._key.other = (this._lastTex && this._lastTex.bitmap) ? this._lastTex.bitmap.id : -1;
                     submit._renderType = SubmitBase.TYPE_TEXTURE;
                 }
                 this._curSubmit._numEle += 6;
                 this._mesh.indexNum += 6;
                 this._mesh.vertNum += 4;
             }
         }
         fillRect(x, y, width, height, fillStyle) {
             var drawstyle = fillStyle ? DrawStyle.create(fillStyle) : this._shader2D.fillStyle;
             //var rgb = drawstyle.toInt() ;
             //由于显卡的格式是 rgba，所以需要处理一下
             //var rgba:uint = ((rgb & 0xff0000) >> 16) | (rgb & 0x00ff00) | ((rgb & 0xff) << 16) | (_shader2D.ALPHA * 255) << 24;
             var rgba = this.mixRGBandAlpha(drawstyle.toInt());
             this._fillRect(x, y, width, height, rgba);
         }
         //TODO:coverage
         fillTexture(texture, x, y, width, height, type, offset, other) {
             //test
             /*
             var aa = 95 / 274, bb = 136 / 341, cc = (95 + 41) / 274, dd = (136 + 48) / 341;
             texture.uv = [aa,bb, cc,bb, cc,dd, aa,dd];
             texture.width = 41;
             texture.height = 48;
             */
             //test
             if (!texture._getSource()) {
                 this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);
                 return;
             }
             this._fillTexture(texture, texture.width, texture.height, texture.uvrect, x, y, width, height, type, offset.x, offset.y);
         }
         _fillTexture(texture, texw, texh, texuvRect, x, y, width, height, type, offsetx, offsety) {
             var submit = this._curSubmit;
             if (this._mesh.vertNum + 4 > Context._MAXVERTNUM) {
                 this._mesh = MeshQuadTexture.getAMesh(this.isMain);
                 this.meshlist.push(this._mesh);
             }
             //filltexture相关逻辑。计算rect大小以及对应的uv
             var repeatx = true;
             var repeaty = true;
             switch (type) {
                 case "repeat": break;
                 case "repeat-x":
                     repeaty = false;
                     break;
                 case "repeat-y":
                     repeatx = false;
                     break;
                 case "no-repeat":
                     repeatx = repeaty = false;
                     break;
                 default: break;
             }
             //用 _temp4Points 来存计算出来的顶点的uv。这里的uv用0到1表示纹理的uv区域。这样便于计算，直到shader中才真的转成了实际uv
             var uv = this._temp4Points;
             var stu = 0; //uv起点
             var stv = 0;
             var stx = 0, sty = 0, edx = 0, edy = 0;
             if (offsetx < 0) {
                 stx = x;
                 stu = (-offsetx % texw) / texw; //有偏移的情况下的u不是从头开始
             }
             else {
                 stx = x + offsetx;
             }
             if (offsety < 0) {
                 sty = y;
                 stv = (-offsety % texh) / texh; //有偏移的情况下的v不是从头开始
             }
             else {
                 sty = y + offsety;
             }
             edx = x + width;
             edy = y + height;
             (!repeatx) && (edx = Math.min(edx, x + offsetx + texw)); //x不重复的话，最多只画一个
             (!repeaty) && (edy = Math.min(edy, y + offsety + texh)); //y不重复的话，最多只画一个
             if (edx < x || edy < y)
                 return;
             if (stx > edx || sty > edy)
                 return;
             //计算最大uv
             var edu = (edx - x - offsetx) / texw;
             var edv = (edy - y - offsety) / texh;
             this.transformQuad(stx, sty, edx - stx, edy - sty, 0, this._curMat, this._transedPoints);
             //四个点对应的uv。必须在transformQuad后面，因为共用了_temp4Points
             uv[0] = stu;
             uv[1] = stv;
             uv[2] = edu;
             uv[3] = stv;
             uv[4] = edu;
             uv[5] = edv;
             uv[6] = stu;
             uv[7] = edv;
             if (!this.clipedOff(this._transedPoints)) {
                 //不依赖于wrapmode了，都走filltexture流程，自己修改纹理坐标
                 //tex2d.wrapModeU = BaseTexture.WARPMODE_REPEAT;	//这里会有重复判断
                 //tex2d.wrapModeV = BaseTexture.WARPMODE_REPEAT;
                 //var rgba:int = mixRGBandAlpha(0xffffffff);
                 //rgba = _mixRGBandAlpha(rgba, alpha);	这个函数有问题，不能连续调用，输出作为输入
                 var rgba = this._mixRGBandAlpha(0xffffffff, this._shader2D.ALPHA);
                 this._mesh.addQuad(this._transedPoints, uv, rgba, true);
                 var sv = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
                 //这个优化先不要了，因为没太弄明白wrapmode的设置，总是不起作用。
                 //if(texture.uvrect[2]<1.0||texture.uvrect[3]<1.0)//这表示是大图集中的一部分，只有这时候才用特殊shader
                 sv.defines.add(ShaderDefines2D.FILLTEXTURE);
                 sv.u_TexRange = texuvRect;
                 submit = this._curSubmit = SubmitTexture.create(this, this._mesh, sv);
                 this._submits[this._submits._length++] = submit;
                 this._copyClipInfo(submit, this._globalClipMatrix);
                 submit.shaderValue.textureHost = texture;
                 submit._renderType = SubmitBase.TYPE_TEXTURE;
                 this._curSubmit._numEle += 6;
                 this._mesh.indexNum += 6;
                 this._mesh.vertNum += 4;
             }
             this.breakNextMerge(); //暂不合并
         }
         /**
          * 反正只支持一种filter，就不要叫setFilter了，直接叫setColorFilter
          * @param	value
          */
         setColorFilter(filter) {
             SaveBase.save(this, SaveBase.TYPE_COLORFILTER, this, true);
             //_shader2D.filters = value;
             this._colorFiler = filter;
             this._curSubmit = SubmitBase.RENDERBASE;
             //_reCalculateBlendShader();
         }
         drawTexture(tex, x, y, width, height) {
             this._drawTextureM(tex, x, y, width, height, null, 1, null);
         }
         drawTextures(tex, pos, tx, ty) {
             if (!tex._getSource()) //source内调用tex.active();
              {
                 this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);
                 return;
             }
             //TODO 还没实现
             var n = pos.length / 2;
             var ipos = 0;
             var bmpid = tex.bitmap.id;
             for (var i = 0; i < n; i++) {
                 this._inner_drawTexture(tex, bmpid, pos[ipos++] + tx, pos[ipos++] + ty, 0, 0, null, null, 1.0, false);
             }
             /*
             var pre:Rectangle = _clipRect;
             _clipRect = MAXCLIPRECT;
             if (!_drawTextureM(tex, pos[0], pos[1], tex.width, tex.height,null, 1)) {
                 throw "drawTextures err";
                 return;
             }
             _clipRect = pre;
             
             Stat.drawCall++;//= pos.length / 2;
             
             if (pos.length < 4)
                 return;
             
             var finalVB:VertexBuffer2D = _curSubmit._vb || _vb;
             var sx:Number = _curMat.a, sy:Number = _curMat.d;
             var vpos:int = finalVB._byteLength >> 2;// + Context._RECTVBSIZE;
             finalVB.byteLength = finalVB._byteLength + (pos.length / 2 - 1) * Context._RECTVBSIZEBYTE;
             var vbdata:Float32Array = finalVB.getFloat32Array();
             for (var i:int = 2, sz:int = pos.length; i < sz; i += 2) {
                 GlUtils.copyPreImgVb(finalVB,vpos, (pos[i] - pos[i - 2]) * sx, (pos[i + 1] - pos[i - 1]) * sy,vbdata);
                 _curSubmit._numEle += 6;
                 vpos += Context._RECTVBSIZE;
             }
             */
         }
         /**
          * 为drawTexture添加一个新的submit。类型是 SubmitTexture
          * @param	vbSize
          * @param	alpha
          * @param	webGLImg
          * @param	tex
          */
         //TODO:coverage
         _drawTextureAddSubmit(imgid, tex) {
             //var alphaBack:Number = shader.ALPHA;
             //shader.ALPHA *= alpha;
             var submit = null;
             submit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
             this._submits[this._submits._length++] = submit;
             submit.shaderValue.textureHost = tex;
             //submit._key.copyFrom2(_submitKey, SubmitBase.KEY_DRAWTEXTURE, imgid);
             submit._key.other = imgid;
             //submit._key.alpha = shader.ALPHA;
             submit._renderType = SubmitBase.TYPE_TEXTURE;
             this._curSubmit = submit;
             //shader.ALPHA = alphaBack;
         }
         _drawTextureM(tex, x, y, width, height, m, alpha, uv) {
             // 注意sprite要保存，因为后面会被冲掉
             var cs = this.sprite;
             if (!tex._getSource(function () {
                 if (cs) {
                     cs.repaint(); // 原来是calllater，callater对于cacheas normal是没有机会执行的
                 }
             })) { //source内调用tex.active();
                 return false;
             }
             return this._inner_drawTexture(tex, tex.bitmap.id, x, y, width, height, m, uv, alpha, false);
         }
         _drawRenderTexture(tex, x, y, width, height, m, alpha, uv) {
             return this._inner_drawTexture(tex, -1, x, y, width, height, m, uv, 1.0, false);
         }
         //TODO:coverage
         submitDebugger() {
             this._submits[this._submits._length++] = SubmitCMD.create([], function () { debugger; }, this);
         }
         /*
         private function copyClipInfo(submit:Submit, clipInfo:Array):void {
             var cd:Array = submit.shaderValue.clipDir;
             cd[0] = clipInfo[2]; cd[1] = clipInfo[3]; cd[2] = clipInfo[4]; cd[3] = clipInfo[5];
             var cp:Array = submit.shaderValue.clipRect;
             cp[0] = clipInfo[0]; cp[1] = clipInfo[1];
             submit.clipInfoID = this._clipInfoID;
         }
         */
         _copyClipInfo(submit, clipInfo) {
             var cm = submit.shaderValue.clipMatDir;
             cm[0] = clipInfo.a;
             cm[1] = clipInfo.b;
             cm[2] = clipInfo.c;
             cm[3] = clipInfo.d;
             var cmp = submit.shaderValue.clipMatPos;
             cmp[0] = clipInfo.tx;
             cmp[1] = clipInfo.ty;
             submit.clipInfoID = this._clipInfoID;
             if (this._clipInCache) {
                 submit.shaderValue.clipOff[0] = 1;
             }
         }
         isSameClipInfo(submit) {
             return (submit.clipInfoID === this._clipInfoID);
             /*
             var cd:Array = submit.shaderValue.clipDir;
             var cp:Array = submit.shaderValue.clipRect;
             
             if (clipInfo[0] != cp[0] || clipInfo[1] != cp[1] || clipInfo[2] != cd[0] || clipInfo[3] != cd[1] || clipInfo[4] != cd[2] || clipInfo[5] != cd[3] )
                 return false;
             return true;
             */
         }
         /**
          * 这个还是会检查是否合并
          * @param	tex
          * @param	minVertNum
          */
         _useNewTex2DSubmit(tex, minVertNum) {
             //var sameKey:Boolean = tex.bitmap.id >= 0 && preKey.submitType === SubmitBase.KEY_DRAWTEXTURE && preKey.other === tex.bitmap.id ;
             if (this._mesh.vertNum + minVertNum > Context._MAXVERTNUM) {
                 this._mesh = MeshQuadTexture.getAMesh(this.isMain); //创建新的mesh  TODO 如果_mesh不是常见格式，这里就不能这么做了。以后把_mesh单独表示成常用模式 
                 this.meshlist.push(this._mesh);
                 //sameKey = false;
             }
             var submit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
             this._submits[this._submits._length++] = this._curSubmit = submit;
             submit.shaderValue.textureHost = tex;
             this._copyClipInfo(submit, this._globalClipMatrix);
         }
         /**
          * 使用上面的设置（texture，submit，alpha，clip），画一个rect
          */
         _drawTexRect(x, y, w, h, uv) {
             this.transformQuad(x, y, w, h, this._italicDeg, this._curMat, this._transedPoints);
             //这个是给文字用的，为了清晰，必须要按照屏幕像素对齐，并且四舍五入。
             var ops = this._transedPoints;
             ops[0] = (ops[0] + 0.5) | 0;
             ops[1] = (ops[1] + 0.5) | 0;
             ops[2] = (ops[2] + 0.5) | 0;
             ops[3] = (ops[3] + 0.5) | 0;
             ops[4] = (ops[4] + 0.5) | 0;
             ops[5] = (ops[5] + 0.5) | 0;
             ops[6] = (ops[6] + 0.5) | 0;
             ops[7] = (ops[7] + 0.5) | 0;
             if (!this.clipedOff(this._transedPoints)) {
                 this._mesh.addQuad(this._transedPoints, uv, this._fillColor, true);
                 this._curSubmit._numEle += 6;
                 this._mesh.indexNum += 6;
                 this._mesh.vertNum += 4;
             }
         }
         drawCallOptimize(enbale) {
             this._charSubmitCache.enable(enbale, this);
             return enbale;
         }
         /**
          *
          * @param	tex {Texture | RenderTexture }
          * @param  imgid 图片id用来比较合并的
          * @param	x
          * @param	y
          * @param	width
          * @param	height
          * @param	m
          * @param	alpha
          * @param	uv
          * @return
          */
         _inner_drawTexture(tex, imgid, x, y, width, height, m, uv, alpha, lastRender) {
             var preKey = this._curSubmit._key;
             uv = uv || tex._uv;
             //为了优化，如果上次是画三角形，并且贴图相同，会认为他们是一组的，把这个也转成三角形，以便合并。
             //因为好多动画是drawTexture和drawTriangle混用的
             if (preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === imgid) {
                 var tv = this._drawTexToDrawTri_Vert;
                 tv[0] = x;
                 tv[1] = y;
                 tv[2] = x + width, tv[3] = y, tv[4] = x + width, tv[5] = y + height, tv[6] = x, tv[7] = y + height;
                 this._drawTriUseAbsMatrix = true;
                 var tuv = this._tempUV;
                 tuv[0] = uv[0];
                 tuv[1] = uv[1];
                 tuv[2] = uv[2];
                 tuv[3] = uv[3];
                 tuv[4] = uv[4];
                 tuv[5] = uv[5];
                 tuv[6] = uv[6];
                 tuv[7] = uv[7];
                 this.drawTriangles(tex, 0, 0, tv, tuv, this._drawTexToDrawTri_Index, m, alpha, null, null); //用tuv而不是uv会提高效率
                 this._drawTriUseAbsMatrix = false;
                 return true;
             }
             var mesh = this._mesh;
             var submit = this._curSubmit;
             var ops = lastRender ? this._charSubmitCache.getPos() : this._transedPoints;
             //凡是这个都是在_mesh上操作，不用考虑samekey
             this.transformQuad(x, y, width || tex.width, height || tex.height, this._italicDeg, m || this._curMat, ops);
             if (this.drawTexAlign) {
                 var round = Math.round;
                 ops[0] = round(ops[0]); //  (ops[0] + 0.5) | 0;	// 这么计算负的时候会有问题
                 ops[1] = round(ops[1]);
                 ops[2] = round(ops[2]);
                 ops[3] = round(ops[3]);
                 ops[4] = round(ops[4]);
                 ops[5] = round(ops[5]);
                 ops[6] = round(ops[6]);
                 ops[7] = round(ops[7]);
                 this.drawTexAlign = false; //一次性的
             }
             var rgba = this._mixRGBandAlpha(0xffffffff, this._shader2D.ALPHA * alpha);
             //lastRender = false;
             if (lastRender) {
                 this._charSubmitCache.add(this, tex, imgid, ops, uv, rgba);
                 return true;
             }
             this._drawCount++;
             var sameKey = imgid >= 0 && preKey.submitType === SubmitBase.KEY_DRAWTEXTURE && preKey.other === imgid;
             //clipinfo
             sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));
             this._lastTex = tex;
             if (mesh.vertNum + 4 > Context._MAXVERTNUM) {
                 mesh = this._mesh = MeshQuadTexture.getAMesh(this.isMain); //创建新的mesh  TODO 如果_mesh不是常见格式，这里就不能这么做了。以后把_mesh单独表示成常用模式 
                 this.meshlist.push(mesh);
                 sameKey = false; //新的mesh不能算samekey了
             }
             {
                 mesh.addQuad(ops, uv, rgba, true);
                 if (!sameKey) {
                     this._submits[this._submits._length++] = this._curSubmit = submit = SubmitTexture.create(this, mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                     submit.shaderValue.textureHost = tex;
                     submit._key.other = imgid;
                     this._copyClipInfo(submit, this._globalClipMatrix);
                 }
                 submit._numEle += 6;
                 mesh.indexNum += 6;
                 mesh.vertNum += 4;
                 return true;
             }
             return false;
         }
         /**
          * 转换4个顶点。为了效率这个不做任何检查。需要调用者的配合。
          * @param	a		输入。8个元素表示4个点
          * @param	out		输出
          */
         transform4Points(a, m, out) {
             /*
                 out[0] = 846;
                 out[1] = 656;
                 out[2] = 881;
                 out[3] = 657;
                 out[4] = 880;
                 out[5] = 732;
                 out[6] = 844;
                 out[7] = 731;
                 return ;
             */
             //var m:Matrix = _curMat;
             var tx = m.tx;
             var ty = m.ty;
             var ma = m.a;
             var mb = m.b;
             var mc = m.c;
             var md = m.d;
             var a0 = a[0];
             var a1 = a[1];
             var a2 = a[2];
             var a3 = a[3];
             var a4 = a[4];
             var a5 = a[5];
             var a6 = a[6];
             var a7 = a[7];
             if (m._bTransform) {
                 out[0] = a0 * ma + a1 * mc + tx;
                 out[1] = a0 * mb + a1 * md + ty;
                 out[2] = a2 * ma + a3 * mc + tx;
                 out[3] = a2 * mb + a3 * md + ty;
                 out[4] = a4 * ma + a5 * mc + tx;
                 out[5] = a4 * mb + a5 * md + ty;
                 out[6] = a6 * ma + a7 * mc + tx;
                 out[7] = a6 * mb + a7 * md + ty;
             }
             else {
                 out[0] = a0 + tx;
                 out[1] = a1 + ty;
                 out[2] = a2 + tx;
                 out[3] = a3 + ty;
                 out[4] = a4 + tx;
                 out[5] = a5 + ty;
                 out[6] = a6 + tx;
                 out[7] = a7 + ty;
             }
         }
         /**
          * pt所描述的多边形完全在clip外边，整个被裁掉了
          * @param	pt
          * @return
          */
         clipedOff(pt) {
             //TODO
             if (this._clipRect.width <= 0 || this._clipRect.height <= 0)
                 return true;
             return false;
         }
         /**
          * 应用当前矩阵。把转换后的位置放到输出数组中。
          * @param	x
          * @param	y
          * @param	w
          * @param	h
          * @param   italicDeg 倾斜角度，单位是度。0度无，目前是下面不动。以后要做成可调的
          */
         transformQuad(x, y, w, h, italicDeg, m, out) {
             /*
             out[0] = 100.1; out[1] = 100.1;
             out[2] = 101.1; out[3] = 100.1;
             out[4] = 101.1; out[5] = 101.1;
             out[6] = 100.1; out[7] = 101.1;
             return;
             */
             var xoff = 0;
             if (italicDeg != 0) {
                 xoff = Math.tan(italicDeg * Math.PI / 180) * h;
             }
             var maxx = x + w;
             var maxy = y + h;
             var tx = m.tx;
             var ty = m.ty;
             var ma = m.a;
             var mb = m.b;
             var mc = m.c;
             var md = m.d;
             var a0 = x + xoff;
             var a1 = y;
             var a2 = maxx + xoff;
             var a3 = y;
             var a4 = maxx;
             var a5 = maxy;
             var a6 = x;
             var a7 = maxy;
             if (m._bTransform) {
                 out[0] = a0 * ma + a1 * mc + tx;
                 out[1] = a0 * mb + a1 * md + ty;
                 out[2] = a2 * ma + a3 * mc + tx;
                 out[3] = a2 * mb + a3 * md + ty;
                 out[4] = a4 * ma + a5 * mc + tx;
                 out[5] = a4 * mb + a5 * md + ty;
                 out[6] = a6 * ma + a7 * mc + tx;
                 out[7] = a6 * mb + a7 * md + ty;
             }
             else {
                 out[0] = a0 + tx;
                 out[1] = a1 + ty;
                 out[2] = a2 + tx;
                 out[3] = a3 + ty;
                 out[4] = a4 + tx;
                 out[5] = a5 + ty;
                 out[6] = a6 + tx;
                 out[7] = a7 + ty;
             }
         }
         pushRT() {
             this.addRenderObject(SubmitCMD.create(null, RenderTexture2D.pushRT, this));
         }
         popRT() {
             this.addRenderObject(SubmitCMD.create(null, RenderTexture2D.popRT, this));
             this.breakNextMerge();
         }
         //TODO:coverage
         useRT(rt) {
             //这里并没有做cliprect的保存恢复。因为认为调用这个函数的话，就是完全不走context流程了，完全自己控制。
             function _use(rt) {
                 if (!rt) {
                     throw 'error useRT';
                 }
                 else {
                     rt.start();
                     rt.clear(0, 0, 0, 0);
                 }
             }
             this.addRenderObject(SubmitCMD.create([rt], _use, this));
             this.breakNextMerge();
         }
         /**
          * 异步执行rt的restore函数
          * @param	rt
          */
         //TODO:coverage
         RTRestore(rt) {
             function _restore(rt) {
                 rt.restore();
             }
             this.addRenderObject(SubmitCMD.create([rt], _restore, this));
             this.breakNextMerge();
         }
         /**
          * 强制拒绝submit合并
          * 例如切换rt的时候
          */
         breakNextMerge() {
             this._curSubmit = SubmitBase.RENDERBASE;
         }
         //TODO:coverage
         _repaintSprite() {
             this.sprite && this.sprite.repaint();
         }
         /**
          *
          * @param	tex
          * @param	x
          * @param	y
          * @param	width
          * @param	height
          * @param	transform	图片本身希望的矩阵
          * @param	tx			节点的位置
          * @param	ty
          * @param	alpha
          */
         drawTextureWithTransform(tex, x, y, width, height, transform, tx, ty, alpha, blendMode, colorfilter = null) {
             var oldcomp = null;
             var curMat = this._curMat;
             if (blendMode) {
                 oldcomp = this.globalCompositeOperation;
                 this.globalCompositeOperation = blendMode;
             }
             var oldColorFilter = this._colorFiler;
             if (colorfilter) {
                 this.setColorFilter(colorfilter);
             }
             if (!transform) {
                 this._drawTextureM(tex, x + tx, y + ty, width, height, curMat, alpha, null);
                 if (blendMode) {
                     this.globalCompositeOperation = oldcomp;
                 }
                 if (colorfilter) {
                     this.setColorFilter(oldColorFilter);
                 }
                 return;
             }
             var tmpMat = this._tmpMatrix;
             //克隆transform,因为要应用tx，ty，这里不能修改原始的transform
             tmpMat.a = transform.a;
             tmpMat.b = transform.b;
             tmpMat.c = transform.c;
             tmpMat.d = transform.d;
             tmpMat.tx = transform.tx + tx;
             tmpMat.ty = transform.ty + ty;
             tmpMat._bTransform = transform._bTransform;
             if (transform && curMat._bTransform) {
                 // 如果当前矩阵不是只有平移，则只能用mul的方式
                 Matrix.mul(tmpMat, curMat, tmpMat);
                 transform = tmpMat;
                 transform._bTransform = true;
             }
             else {
                 //如果curmat没有旋转。
                 tmpMat.tx += curMat.tx;
                 tmpMat.ty += curMat.ty;
                 transform = tmpMat;
             }
             this._drawTextureM(tex, x, y, width, height, transform, alpha, null);
             if (blendMode) {
                 this.globalCompositeOperation = oldcomp;
             }
             if (colorfilter) {
                 this.setColorFilter(oldColorFilter);
             }
         }
         /**
          * * 把ctx中的submits提交。结果渲染到target上
          * @param	ctx
          * @param	target
          */
         _flushToTarget(context, target) {
             //if (target._destroy) return;
             //var preworldClipRect:Rectangle = RenderState2D.worldClipRect;
             //裁剪不用考虑，现在是在context内部自己维护，不会乱窜
             RenderState2D.worldScissorTest = false;
             WebGLContext.mainContext.disable(WebGLContext.SCISSOR_TEST);
             var preAlpha = RenderState2D.worldAlpha;
             var preMatrix4 = RenderState2D.worldMatrix4;
             var preMatrix = RenderState2D.worldMatrix;
             RenderState2D.worldMatrix = Matrix.EMPTY;
             RenderState2D.restoreTempArray();
             RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
             RenderState2D.worldAlpha = 1;
             //RenderState2D.worldFilters = null;
             //RenderState2D.worldShaderDefines = null;
             BaseShader.activeShader = null;
             target.start();
             // 如果没有命令就不要clear。这么改是因为嵌套cacheas出问题了
             // 如果一个sprite cacheas normal ，他的子节点有cacheas bitmap的（包括mask等）就会不断的执行 _flushToTarget和drawCamvase,从而把target上的内容清掉
             // 由于cacheas normal 导致 RenderSprite没有机会执行 _cacheStyle.canvas 存在的分支。在
             if (context._submits._length > 0)
                 target.clear(0, 0, 0, 0);
             context._curSubmit = SubmitBase.RENDERBASE;
             context.flush();
             context.clear();
             target.restore();
             context._curSubmit = SubmitBase.RENDERBASE;
             //context._canvas
             BaseShader.activeShader = null;
             RenderState2D.worldAlpha = preAlpha;
             RenderState2D.worldMatrix4 = preMatrix4;
             RenderState2D.worldMatrix = preMatrix;
             //RenderState2D.worldFilters = preFilters;
             //RenderState2D.worldShaderDefines = preShaderDefines;
         }
         drawCanvas(canvas, x, y, width, height) {
             if (!canvas)
                 return;
             var src = canvas.context;
             var submit;
             if (src._targets) {
                 //生成渲染结果到src._targets上
                 /*
                 this._submits[this._submits._length++] = SubmitCanvas.create(src, 0, null);
                 _curSubmit = SubmitBase.RENDERBASE;
                 //画出src._targets
                 //drawTexture(src._targets.target.getTexture(), x, y, width, height, 0, 0);
                 */
                 //应用并清空canvas中的指令。如果内容需要重画，RenderSprite会给他重新加入submit
                 if (src._submits._length > 0) {
                     submit = SubmitCMD.create([src, src._targets], this._flushToTarget, this);
                     this._submits[this._submits._length++] = submit;
                 }
                 //在这之前就已经渲染出结果了。
                 this._drawRenderTexture(src._targets, x, y, width, height, null, 1.0, RenderTexture2D.flipyuv);
                 this._curSubmit = SubmitBase.RENDERBASE;
                 /*
                 this._submits[this._submits._length++] = SubmitCanvas.create(src, 0, null);
                 //src._targets.flush(src);
                 _curSubmit = SubmitBase.RENDERBASE;
                 //src._targets.drawTo(this, x, y, width, height);
                 //drawTexture(src._targets.target.getTexture(), x, y, width, height, 0, 0);
                 _drawRenderTexture(src._targets, x, y, width, height,null,1.0, RenderTexture.flipyuv);
                 */
             }
             else {
                 var canv = canvas;
                 if (canv.touches) {
                     canv.touches.forEach(function (v) { v.touch(); });
                 }
                 submit = SubmitCanvas.create(canvas, this._shader2D.ALPHA, this._shader2D.filters);
                 this._submits[this._submits._length++] = submit;
                 submit._key.clear();
                 //var sx:Number = width / canvas.width;
                 //var sy:Number = height / canvas.height;
                 var mat = submit._matrix;
                 this._curMat.copyTo(mat);
                 //sx != 1 && sy != 1 && mat.scale(sx, sy);
                 // 先加上位置，最后再乘逆
                 var tx = mat.tx, ty = mat.ty;
                 mat.tx = mat.ty = 0;
                 mat.transformPoint(Point.TEMP.setTo(x, y)); // 用当前矩阵变换 (x,y)
                 mat.translate(Point.TEMP.x + tx, Point.TEMP.y + ty); // 加上原来的 (tx,ty)
                 Matrix.mul(canv.invMat, mat, mat);
                 this._curSubmit = SubmitBase.RENDERBASE;
             }
         }
         drawTarget(rt, x, y, width, height, m, shaderValue, uv = null, blend = -1) {
             this._drawCount++;
             if (this._mesh.vertNum + 4 > Context._MAXVERTNUM) {
                 this._mesh = MeshQuadTexture.getAMesh(this.isMain); //创建新的mesh  TODO 如果_mesh不是常见格式，这里就不能这么做了。以后把_mesh单独表示成常用模式 
                 this.meshlist.push(this._mesh);
             }
             //凡是这个都是在_mesh上操作，不用考虑samekey
             this.transformQuad(x, y, width, height, 0, m || this._curMat, this._transedPoints);
             if (!this.clipedOff(this._transedPoints)) {
                 this._mesh.addQuad(this._transedPoints, uv || Texture.DEF_UV, 0xffffffff, true);
                 //if (GlUtils.fillRectImgVb( _mesh._vb, _clipRect, x, y, width , height , uv || Texture.DEF_UV, m || _curMat, rgba, this)) {
                 var submit = this._curSubmit = SubmitTarget.create(this, this._mesh, shaderValue, rt);
                 submit.blendType = (blend == -1) ? this._nBlendType : blend;
                 this._copyClipInfo(submit, this._globalClipMatrix);
                 submit._numEle = 6;
                 this._mesh.indexNum += 6;
                 this._mesh.vertNum += 4;
                 this._submits[this._submits._length++] = submit;
                 //暂时drawTarget不合并
                 this._curSubmit = SubmitBase.RENDERBASE;
                 return true;
             }
             //暂时drawTarget不合并
             this._curSubmit = SubmitBase.RENDERBASE;
             return false;
         }
         drawTriangles(tex, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
             if (!tex._getSource()) { //source内调用tex.active();
                 if (this.sprite) {
                     ILaya.systemTimer.callLater(this, this._repaintSprite);
                 }
                 return;
             }
             this._drawCount++;
             // 为了提高效率，把一些变量放到这里
             var tmpMat = this._tmpMatrix;
             var triMesh = this._triangleMesh;
             var oldColorFilter = null;
             var needRestorFilter = false;
             if (color) {
                 oldColorFilter = this._colorFiler;
                 //这个不用save，直接修改就行
                 this._colorFiler = color;
                 this._curSubmit = SubmitBase.RENDERBASE;
                 needRestorFilter = oldColorFilter != color;
             }
             var webGLImg = tex.bitmap;
             var preKey = this._curSubmit._key;
             var sameKey = preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === webGLImg.id && preKey.blendShader == this._nBlendType;
             //var rgba:int = mixRGBandAlpha(0xffffffff);
             //rgba = _mixRGBandAlpha(rgba, alpha);	这个函数有问题，不能连续调用，输出作为输入
             if (triMesh.vertNum + vertices.length / 2 > Context._MAXVERTNUM) {
                 triMesh = this._triangleMesh = MeshTexture.getAMesh(this.isMain); //创建新的mesh  TODO 如果_mesh不是常见格式，这里就不能这么做了。以后把_mesh单独表示成常用模式 
                 this.meshlist.push(triMesh);
                 sameKey = false; //新的mesh不能算samekey了
             }
             if (!sameKey) {
                 //添加一个新的submit
                 var submit = this._curSubmit = SubmitTexture.create(this, triMesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                 submit.shaderValue.textureHost = tex;
                 submit._renderType = SubmitBase.TYPE_TEXTURE;
                 submit._key.submitType = SubmitBase.KEY_TRIANGLES;
                 submit._key.other = webGLImg.id;
                 this._copyClipInfo(submit, this._globalClipMatrix);
                 this._submits[this._submits._length++] = submit;
             }
             var rgba = this._mixRGBandAlpha(0xffffffff, this._shader2D.ALPHA * alpha);
             if (!this._drawTriUseAbsMatrix) {
                 if (!matrix) {
                     tmpMat.a = 1;
                     tmpMat.b = 0;
                     tmpMat.c = 0;
                     tmpMat.d = 1;
                     tmpMat.tx = x;
                     tmpMat.ty = y;
                 }
                 else {
                     tmpMat.a = matrix.a;
                     tmpMat.b = matrix.b;
                     tmpMat.c = matrix.c;
                     tmpMat.d = matrix.d;
                     tmpMat.tx = matrix.tx + x;
                     tmpMat.ty = matrix.ty + y;
                 }
                 Matrix.mul(tmpMat, this._curMat, tmpMat);
                 triMesh.addData(vertices, uvs, indices, tmpMat, rgba);
             }
             else {
                 // 这种情况是drawtexture转成的drawTriangle，直接使用matrix就行，传入的xy都是0
                 triMesh.addData(vertices, uvs, indices, matrix, rgba);
             }
             this._curSubmit._numEle += indices.length;
             if (needRestorFilter) {
                 this._colorFiler = oldColorFilter;
                 this._curSubmit = SubmitBase.RENDERBASE;
             }
             //return true;
         }
         transform(a, b, c, d, tx, ty) {
             SaveTransform.save(this);
             Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat); //TODO 这里会有效率问题。一堆的set
             this._curMat._checkTransform();
         }
         //TODO:coverage
         _transformByMatrix(matrix, tx, ty) {
             matrix.setTranslate(tx, ty);
             Matrix.mul(matrix, this._curMat, this._curMat);
             matrix.setTranslate(0, 0);
             this._curMat._bTransform = true;
         }
         //TODO:coverage
         setTransformByMatrix(value) {
             value.copyTo(this._curMat);
         }
         rotate(angle) {
             SaveTransform.save(this);
             this._curMat.rotateEx(angle);
         }
         scale(scaleX, scaleY) {
             SaveTransform.save(this);
             this._curMat.scaleEx(scaleX, scaleY);
         }
         clipRect(x, y, width, height) {
             SaveClipRect.save(this);
             if (this._clipRect == Context.MAXCLIPRECT) {
                 this._clipRect = new Rectangle(x, y, width, height);
             }
             else {
                 this._clipRect.width = width;
                 this._clipRect.height = height;
                 //把xy转换到当前矩阵空间。宽高不用转换，这样在shader中计算的时候就不用把方向normalize了
                 this._clipRect.x = x;
                 this._clipRect.y = y;
             }
             Context._clipID_Gen++;
             Context._clipID_Gen %= 10000;
             this._clipInfoID = Context._clipID_Gen;
             var cm = this._globalClipMatrix;
             //TEMP 处理clip交集问题，这里有点问题，无法处理旋转，翻转 是临时瞎写的
             var minx = cm.tx;
             var miny = cm.ty;
             var maxx = minx + cm.a;
             var maxy = miny + cm.d;
             //TEMP end
             if (this._clipRect.width >= Context._MAXSIZE) {
                 cm.a = cm.d = Context._MAXSIZE;
                 cm.b = cm.c = cm.tx = cm.ty = 0;
             }
             else {
                 //其实就是矩阵相乘
                 if (this._curMat._bTransform) {
                     cm.tx = this._clipRect.x * this._curMat.a + this._clipRect.y * this._curMat.c + this._curMat.tx;
                     cm.ty = this._clipRect.x * this._curMat.b + this._clipRect.y * this._curMat.d + this._curMat.ty;
                     cm.a = this._clipRect.width * this._curMat.a;
                     cm.b = this._clipRect.width * this._curMat.b;
                     cm.c = this._clipRect.height * this._curMat.c;
                     cm.d = this._clipRect.height * this._curMat.d;
                 }
                 else {
                     cm.tx = this._clipRect.x + this._curMat.tx;
                     cm.ty = this._clipRect.y + this._curMat.ty;
                     cm.a = this._clipRect.width;
                     cm.b = cm.c = 0;
                     cm.d = this._clipRect.height;
                 }
                 if (this._incache) {
                     this._clipInCache = true;
                 }
             }
             //TEMP 处理clip交集问题，这里有点问题，无法处理旋转,翻转
             if (cm.a > 0 && cm.d > 0) {
                 var cmaxx = cm.tx + cm.a;
                 var cmaxy = cm.ty + cm.d;
                 if (cmaxx <= minx || cmaxy <= miny || cm.tx >= maxx || cm.ty >= maxy) {
                     //超出范围了
                     cm.a = -0.1;
                     cm.d = -0.1;
                 }
                 else {
                     if (cm.tx < minx) {
                         cm.a -= (minx - cm.tx);
                         cm.tx = minx;
                     }
                     if (cmaxx > maxx) {
                         cm.a -= (cmaxx - maxx);
                     }
                     if (cm.ty < miny) {
                         cm.d -= (miny - cm.ty);
                         cm.ty = miny;
                     }
                     if (cmaxy > maxy) {
                         cm.d -= (cmaxy - maxy);
                     }
                     if (cm.a <= 0)
                         cm.a = -0.1;
                     if (cm.d <= 0)
                         cm.d = -0.1;
                 }
             }
             //TEMP end
         }
         /**
          * 从setIBVB改为drawMesh
          * type 参数不知道是干什么的，先删掉。offset好像跟attribute有关，删掉
          * @param	x
          * @param	y
          * @param	ib
          * @param	vb
          * @param	numElement
          * @param	mat
          * @param	shader
          * @param	shaderValues
          * @param	startIndex
          * @param	offset
          */
         //TODO:coverage
         drawMesh(x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex = 0) {
         }
         addRenderObject(o) {
             this._submits[this._submits._length++] = o;
         }
         /**
          *
          * @param	start
          * @param	end
          */
         submitElement(start, end) {
             //_ib._bind_upload() || _ib._bind();
             //_vb._bind_upload() || _vb._bind();
             var mainCtx = this.isMain;
             var renderList = this._submits;
             var ret = renderList._length;
             end < 0 && (end = renderList._length);
             var submit = SubmitBase.RENDERBASE;
             while (start < end) {
                 this._renderNextSubmitIndex = start + 1;
                 if (renderList[start] === SubmitBase.RENDERBASE) {
                     start++;
                     continue;
                 }
                 SubmitBase.preRender = submit;
                 submit = renderList[start];
                 //只有submitscissor才会返回多个
                 start += submit.renderSubmit();
                 //本来做了个优化，如果是主画布，用完立即releaseRender. 但是实际没有什么效果，且由于submit需要用来对比，即使用完也不能修改，所以这个优化又去掉了
             }
             return ret;
         }
         flush() {
             var ret = this.submitElement(0, this._submits._length);
             this._path && this._path.reset();
             SkinMeshBuffer.instance && SkinMeshBuffer.getInstance().reset();
             //Stat.mesh2DNum += meshlist.length;
             this._curSubmit = SubmitBase.RENDERBASE;
             for (var i = 0, sz = this.meshlist.length; i < sz; i++) {
                 var curm = this.meshlist[i];
                 curm.canReuse ? (curm.releaseMesh()) : (curm.destroy());
             }
             this.meshlist.length = 0;
             this._mesh = MeshQuadTexture.getAMesh(this.isMain); //TODO 不要这样。
             this._pathMesh = MeshVG.getAMesh(this.isMain);
             this._triangleMesh = MeshTexture.getAMesh(this.isMain);
             this.meshlist.push(this._mesh, this._pathMesh, this._triangleMesh);
             this._flushCnt++;
             //charbook gc
             if (this._flushCnt % 60 == 0 && this.isMain) {
                 if (TextRender.textRenderInst) {
                     TextRender.textRenderInst.GC();
                 }
             }
             return ret;
         }
         /*******************************************start矢量绘制***************************************************/
         beginPath(convex = false) {
             var tPath = this._getPath();
             tPath.beginPath(convex);
         }
         closePath() {
             //_path.closePath = true;
             this._path.closePath();
         }
         /**
          * 添加一个path。
          * @param	points [x,y,x,y....]	这个会被保存下来，所以调用者需要注意复制。
          * @param	close	是否闭合
          * @param   convex 是否是凸多边形。convex的优先级是这个最大。fill的时候的次之。其实fill的时候不应该指定convex，因为可以多个path
          * @param	dx  需要添加的平移。这个需要在应用矩阵之前应用。
          * @param	dy
          */
         addPath(points, close, convex, dx, dy) {
             var ci = 0;
             for (var i = 0, sz = points.length / 2; i < sz; i++) {
                 var x1 = points[ci] + dx, y1 = points[ci + 1] + dy;
                 points[ci] = x1;
                 points[ci + 1] = y1;
                 ci += 2;
             }
             this._getPath().push(points, convex);
         }
         fill() {
             var m = this._curMat;
             var tPath = this._getPath();
             var submit = this._curSubmit;
             var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType);
             sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));
             if (!sameKey) {
                 this._curSubmit = this.addVGSubmit(this._pathMesh);
             }
             var rgba = this.mixRGBandAlpha(this.fillStyle.toInt());
             var curEleNum = 0;
             var idx;
             //如果有多个path的话，要一起填充mesh，使用相同的颜色和alpha
             for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                 var p = tPath.paths[i];
                 var vertNum = p.path.length / 2;
                 if (vertNum < 3 || (vertNum == 3 && !p.convex))
                     continue;
                 var cpath = p.path.concat();
                 // 应用矩阵转换顶点
                 var pi = 0;
                 var xp, yp;
                 var _x, _y;
                 if (m._bTransform) {
                     for (pi = 0; pi < vertNum; pi++) {
                         xp = pi << 1;
                         yp = xp + 1;
                         _x = cpath[xp];
                         _y = cpath[yp];
                         cpath[xp] = m.a * _x + m.c * _y + m.tx;
                         cpath[yp] = m.b * _x + m.d * _y + m.ty;
                     }
                 }
                 else {
                     for (pi = 0; pi < vertNum; pi++) {
                         xp = pi << 1;
                         yp = xp + 1;
                         _x = cpath[xp];
                         _y = cpath[yp];
                         cpath[xp] = _x + m.tx;
                         cpath[yp] = _y + m.ty;
                     }
                 }
                 if (this._pathMesh.vertNum + vertNum > Context._MAXVERTNUM) {
                     //;
                     //顶点数超了，要先提交一次
                     this._curSubmit._numEle += curEleNum;
                     curEleNum = 0;
                     //然后用新的mesh，和新的submit。
                     this._pathMesh = MeshVG.getAMesh(this.isMain);
                     this._curSubmit = this.addVGSubmit(this._pathMesh);
                 }
                 var curvert = this._pathMesh.vertNum;
                 //生成 ib
                 if (p.convex) { //convex的ib比较容易
                     var faceNum = vertNum - 2;
                     idx = new Array(faceNum * 3);
                     var idxpos = 0;
                     for (var fi = 0; fi < faceNum; fi++) {
                         idx[idxpos++] = curvert;
                         idx[idxpos++] = fi + 1 + curvert;
                         idx[idxpos++] = fi + 2 + curvert;
                     }
                 }
                 else {
                     idx = Earcut.earcut(cpath, null, 2); //返回索引
                     if (curvert > 0) {
                         //修改ib
                         for (var ii = 0; ii < idx.length; ii++) {
                             idx[ii] += curvert;
                         }
                     }
                 }
                 //填充mesh
                 this._pathMesh.addVertAndIBToMesh(this, cpath, rgba, idx);
                 curEleNum += idx.length;
             }
             this._curSubmit._numEle += curEleNum;
         }
         addVGSubmit(mesh) {
             //elenum设为0，后面再加
             var submit = Submit.createShape(this, mesh, 0, Value2D.create(ShaderDefines2D.PRIMITIVE, 0));
             //submit._key.clear();
             //submit._key.blendShader = _submitKey.blendShader;	//TODO 这个在哪里赋值的啊
             submit._key.submitType = SubmitBase.KEY_VG;
             this._submits[this._submits._length++] = submit;
             this._copyClipInfo(submit, this._globalClipMatrix);
             return submit;
         }
         stroke() {
             if (this.lineWidth > 0) {
                 var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
                 var tPath = this._getPath();
                 var submit = this._curSubmit;
                 var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType);
                 sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));
                 if (!sameKey) {
                     this._curSubmit = this.addVGSubmit(this._pathMesh);
                 }
                 var curEleNum = 0;
                 //如果有多个path的话，要一起填充mesh，使用相同的颜色和alpha
                 for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                     var p = tPath.paths[i];
                     if (p.path.length <= 0)
                         continue;
                     var idx = [];
                     var vertex = []; //x,y
                     //p.path.loop;
                     //填充vbib
                     var maxVertexNum = p.path.length * 2; //最大可能产生的顶点数。这个需要考虑考虑
                     if (maxVertexNum < 2)
                         continue;
                     if (this._pathMesh.vertNum + maxVertexNum > Context._MAXVERTNUM) {
                         //;
                         //顶点数超了，要先提交一次
                         this._curSubmit._numEle += curEleNum;
                         curEleNum = 0;
                         //然后用新的mesh，和新的submit。
                         this._pathMesh = MeshVG.getAMesh(this.isMain);
                         this.meshlist.push(this._pathMesh);
                         this._curSubmit = this.addVGSubmit(this._pathMesh);
                     }
                     //这个需要放在创建新的mesh的后面，因为需要mesh.vertNum,否则如果先调用这个，再创建mesh，那么ib就不对了
                     BasePoly.createLine2(p.path, idx, this.lineWidth, this._pathMesh.vertNum, vertex, p.loop); //_pathMesh.vertNum 是要加到生成的ib上的
                     // 变换所有的点
                     var ptnum = vertex.length / 2;
                     var m = this._curMat;
                     var pi = 0;
                     var xp, yp;
                     var _x, _y;
                     if (m._bTransform) {
                         for (pi = 0; pi < ptnum; pi++) {
                             xp = pi << 1;
                             yp = xp + 1;
                             _x = vertex[xp];
                             _y = vertex[yp];
                             vertex[xp] = m.a * _x + m.c * _y + m.tx;
                             vertex[yp] = m.b * _x + m.d * _y + m.ty;
                         }
                     }
                     else {
                         for (pi = 0; pi < ptnum; pi++) {
                             xp = pi << 1;
                             yp = xp + 1;
                             _x = vertex[xp];
                             _y = vertex[yp];
                             vertex[xp] = _x + m.tx;
                             vertex[yp] = _y + m.ty;
                         }
                     }
                     //this.drawPoly(0, 0, p.path, fillStyle._color.numColor, 0, 0, p.convex);
                     //填充mesh
                     this._pathMesh.addVertAndIBToMesh(this, vertex, rgba, idx);
                     curEleNum += idx.length;
                 }
                 this._curSubmit._numEle += curEleNum;
             }
         }
         moveTo(x, y) {
             var tPath = this._getPath();
             tPath.newPath();
             tPath._lastOriX = x;
             tPath._lastOriY = y;
             tPath.addPoint(x, y);
         }
         /**
          *
          * @param	x
          * @param	y
          * @param	b 是否应用矩阵
          */
         lineTo(x, y) {
             var tPath = this._getPath();
             if (Math.abs(x - tPath._lastOriX) < 1e-3 && Math.abs(y - tPath._lastOriY) < 1e-3) //不判断的话，下面的画线算法受不了
                 return;
             tPath._lastOriX = x;
             tPath._lastOriY = y;
             tPath.addPoint(x, y);
         }
         /*
         public function drawCurves(x:Number, y:Number,points:Array, lineColor:*, lineWidth:Number = 1):void {
             //setPathId(-1);
             beginPath();
             strokeStyle = lineColor;
             this.lineWidth = lineWidth;
             var points:Array = points;
             //movePath(x, y); TODO 这个被去掉了
             moveTo(points[0], points[1]);
             var i:int = 2, n:int = points.length;
             while (i < n) {
                 quadraticCurveTo(points[i++], points[i++], points[i++], points[i++]);
             }
             stroke();
         }
         */
         arcTo(x1, y1, x2, y2, r) {
             /*
             if (mId != -1) {
                 if (mHaveKey) {
                     return;
                 }
             }
             */
             var i = 0;
             var x = 0, y = 0;
             var dx = this._path._lastOriX - x1;
             var dy = this._path._lastOriY - y1;
             var len1 = Math.sqrt(dx * dx + dy * dy);
             if (len1 <= 0.000001) {
                 return;
             }
             var ndx = dx / len1;
             var ndy = dy / len1;
             var dx2 = x2 - x1;
             var dy2 = y2 - y1;
             var len22 = dx2 * dx2 + dy2 * dy2;
             var len2 = Math.sqrt(len22);
             if (len2 <= 0.000001) {
                 return;
             }
             var ndx2 = dx2 / len2;
             var ndy2 = dy2 / len2;
             var odx = ndx + ndx2;
             var ody = ndy + ndy2;
             var olen = Math.sqrt(odx * odx + ody * ody);
             if (olen <= 0.000001) {
                 return;
             }
             var nOdx = odx / olen;
             var nOdy = ody / olen;
             var alpha = Math.acos(nOdx * ndx + nOdy * ndy);
             var halfAng = Math.PI / 2 - alpha;
             len1 = r / Math.tan(halfAng);
             var ptx1 = len1 * ndx + x1;
             var pty1 = len1 * ndy + y1;
             var orilen = Math.sqrt(len1 * len1 + r * r);
             //圆心
             var orix = x1 + nOdx * orilen;
             var oriy = y1 + nOdy * orilen;
             var dir = ndx * ndy2 - ndy * ndx2;
             var fChgAng = 0;
             var sinx = 0.0;
             var cosx = 0.0;
             if (dir >= 0) {
                 fChgAng = halfAng * 2;
                 var fda = fChgAng / Context.SEGNUM;
                 sinx = Math.sin(fda);
                 cosx = Math.cos(fda);
             }
             else {
                 fChgAng = -halfAng * 2;
                 fda = fChgAng / Context.SEGNUM;
                 sinx = Math.sin(fda);
                 cosx = Math.cos(fda);
             }
             //x = _curMat.a * ptx1 + _curMat.c * pty1 /*+ _curMat.tx*/;
             //y = _curMat.b * ptx1 + _curMat.d * pty1 /*+ _curMat.ty*/;
             var lastx = this._path._lastOriX, lasty = this._path._lastOriY; //没有矩阵转换的上一个点
             var _x1 = ptx1, _y1 = pty1;
             if (Math.abs(_x1 - this._path._lastOriX) > 0.1 || Math.abs(_y1 - this._path._lastOriY) > 0.1) {
                 x = _x1; // _curMat.a * _x1 + _curMat.c * _y1 + _curMat.tx;
                 y = _y1; //_curMat.b * _x1 + _curMat.d * _y1 + _curMat.ty;
                 lastx = _x1;
                 lasty = _y1;
                 this._path.addPoint(x, y);
             }
             var cvx = ptx1 - orix;
             var cvy = pty1 - oriy;
             for (i = 0; i < Context.SEGNUM; i++) {
                 var cx = cvx * cosx + cvy * sinx;
                 var cy = -cvx * sinx + cvy * cosx;
                 x = cx + orix;
                 y = cy + oriy;
                 //x1 = _curMat.a * x + _curMat.c * y /*+ _curMat.tx*/;
                 //y1 = _curMat.b * x + _curMat.d * y /*+ _curMat.ty*/;
                 //x = x1;
                 //y = y1;
                 if (Math.abs(lastx - x) > 0.1 || Math.abs(lasty - y) > 0.1) {
                     //var _tx1:Number = x, _ty1:Number = y;
                     //x = _curMat.a * _tx1 + _curMat.c * _ty1 + _curMat.tx;
                     //y = _curMat.b * _tx1 + _curMat.d * _ty1 + _curMat.ty;
                     this._path.addPoint(x, y);
                     lastx = x;
                     lasty = y;
                 }
                 cvx = cx;
                 cvy = cy;
             }
         }
         arc(cx, cy, r, startAngle, endAngle, counterclockwise = false, b = true) {
             /* TODO 缓存还没想好
             if (mId != -1) {
                 var tShape:IShape = VectorGraphManager.getInstance().shapeDic[this.mId];
                 if (tShape) {
                     if (mHaveKey && !tShape.needUpdate(_curMat))
                         return;
                 }
                 cx = 0;
                 cy = 0;
             }
             */
             var a = 0, da = 0;
             var dx = 0, dy = 0, x = 0, y = 0;
             var i, ndivs;
             // Clamp angles
             da = endAngle - startAngle;
             if (!counterclockwise) {
                 if (Math.abs(da) >= Math.PI * 2) {
                     da = Math.PI * 2;
                 }
                 else {
                     while (da < 0.0) {
                         da += Math.PI * 2;
                     }
                 }
             }
             else {
                 if (Math.abs(da) >= Math.PI * 2) {
                     da = -Math.PI * 2;
                 }
                 else {
                     while (da > 0.0) {
                         da -= Math.PI * 2;
                     }
                 }
             }
             var sx = this.getMatScaleX();
             var sy = this.getMatScaleY();
             var sr = r * (sx > sy ? sx : sy);
             var cl = 2 * Math.PI * sr;
             ndivs = (Math.max(cl / 10, 10)) | 0;
             var tPath = this._getPath();
             for (i = 0; i <= ndivs; i++) {
                 a = startAngle + da * (i / ndivs);
                 dx = Math.cos(a);
                 dy = Math.sin(a);
                 x = cx + dx * r;
                 y = cy + dy * r;
                 if (x != this._path._lastOriX || y != this._path._lastOriY) {
                     //var _tx1:Number = x, _ty1:Number = y;
                     //x = _curMat.a * _tx1 + _curMat.c * _ty1 + _curMat.tx;
                     //y = _curMat.b * _tx1 + _curMat.d * _ty1 + _curMat.ty;
                     tPath.addPoint(x, y);
                 }
             }
             dx = Math.cos(endAngle);
             dy = Math.sin(endAngle);
             x = cx + dx * r;
             y = cy + dy * r;
             if (x != this._path._lastOriX || y != this._path._lastOriY) {
                 //var _x2:Number = x, _y2:Number = y;
                 //x = _curMat.a * _x2 + _curMat.c * _y2 + _curMat.tx;
                 //y = _curMat.b * _x2 + _curMat.d * _y2 + _curMat.ty;
                 tPath.addPoint(x, y);
             }
         }
         quadraticCurveTo(cpx, cpy, x, y) {
             var tBezier = Bezier.I;
             //var _x1:Number = x, _y1:Number = y;
             //x = _curMat.a * _x1 + _curMat.c * _y1 ;// + _curMat.tx;
             //y = _curMat.b * _x1 + _curMat.d * _y1;// + _curMat.ty;
             //_x1 = cpx, _y1 = cpy;
             //cpx = _curMat.a * _x1 + _curMat.c * _y1;// + _curMat.tx;
             //cpy = _curMat.b * _x1 + _curMat.d * _y1;// + _curMat.ty;
             var tArray = tBezier.getBezierPoints([this._path._lastOriX, this._path._lastOriY, cpx, cpy, x, y], 30, 2);
             for (var i = 0, n = tArray.length / 2; i < n; i++) {
                 this.lineTo(tArray[i * 2], tArray[i * 2 + 1]);
             }
             this.lineTo(x, y);
         }
         /**
          * 把颜色跟当前设置的alpha混合
          * @return
          */
         mixRGBandAlpha(color) {
             return this._mixRGBandAlpha(color, this._shader2D.ALPHA);
         }
         _mixRGBandAlpha(color, alpha) {
             if (alpha >= 1) {
                 return color;
             }
             var a = ((color & 0xff000000) >>> 24);
             //TODO 这里容易出问题，例如颜色的alpha部分虽然为0，但是他的意义就是0，不能假设是没有设置alpha。例如级联多个alpha就会生成这种结果
             if (a != 0) {
                 a *= alpha;
             }
             else {
                 a = alpha * 255;
             }
             return (color & 0x00ffffff) | (a << 24);
         }
         strokeRect(x, y, width, height, parameterLineWidth) {
             //line(x - tW, y, x + width + tW, y, parameterLineWidth, _curMat);
             //line(x + width, y, x + width, y + height, parameterLineWidth, _curMat);
             //line(x, y, x, y + height, parameterLineWidth, _curMat);
             //line(x - tW, y + height, x + width + tW, y + height, parameterLineWidth, _curMat);
             /**
              * p1-------------------------------p2
              * |  x,y                      x+w,y|
              * |     p4--------------------p3   |
              * |     |                     |    |
              * |     p6--------------------p7   |
              * |  x,y+h                  x+w,y+h|
              * p5-------------------------------p8
              *
              * 不用了
              * 这个其实用4个fillrect拼起来更好，能与fillrect合并。虽然多了几个点。
              */
             //TODO 这里能不能与下面的stroke合并一下
             if (this.lineWidth > 0) {
                 var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
                 var hw = this.lineWidth / 2;
                 this._fillRect(x - hw, y - hw, width + this.lineWidth, this.lineWidth, rgba); //上
                 this._fillRect(x - hw, y - hw + height, width + this.lineWidth, this.lineWidth, rgba); //下
                 this._fillRect(x - hw, y + hw, this.lineWidth, height - this.lineWidth, rgba); //左
                 this._fillRect(x - hw + width, y + hw, this.lineWidth, height - this.lineWidth, rgba); //右
             }
         }
         clip() {
         }
         /*******************************************end矢量绘制***************************************************/
         //TODO:coverage
         drawParticle(x, y, pt) {
             pt.x = x;
             pt.y = y;
             this._submits[this._submits._length++] = pt;
         }
         _getPath() {
             return this._path || (this._path = new Path());
         }
         /**获取canvas*/
         //注意这个是对外接口
         get canvas() {
             return this._canvas;
         }
         /**
          * 专用函数。通过循环创建来水平填充
          * @param	tex
          * @param	bmpid
          * @param	uv		希望循环的部分的uv
          * @param	oriw
          * @param	orih
          * @param	x
          * @param	y
          * @param	w
          */
         _fillTexture_h(tex, imgid, uv, oriw, orih, x, y, w) {
             var stx = x;
             var num = Math.floor(w / oriw);
             var left = w % oriw;
             for (var i = 0; i < num; i++) {
                 this._inner_drawTexture(tex, imgid, stx, y, oriw, orih, this._curMat, uv, 1, false);
                 stx += oriw;
             }
             // 最后剩下的
             if (left > 0) {
                 var du = uv[2] - uv[0];
                 var uvr = uv[0] + du * (left / oriw);
                 var tuv = Context.tmpuv1;
                 tuv[0] = uv[0];
                 tuv[1] = uv[1];
                 tuv[2] = uvr;
                 tuv[3] = uv[3];
                 tuv[4] = uvr;
                 tuv[5] = uv[5];
                 tuv[6] = uv[6];
                 tuv[7] = uv[7];
                 this._inner_drawTexture(tex, imgid, stx, y, left, orih, this._curMat, tuv, 1, false);
             }
         }
         /**
          * 专用函数。通过循环创建来垂直填充
          * @param	tex
          * @param	imgid
          * @param	uv
          * @param	oriw
          * @param	orih
          * @param	x
          * @param	y
          * @param	h
          */
         _fillTexture_v(tex, imgid, uv, oriw, orih, x, y, h) {
             var sty = y;
             var num = Math.floor(h / orih);
             var left = h % orih;
             for (var i = 0; i < num; i++) {
                 this._inner_drawTexture(tex, imgid, x, sty, oriw, orih, this._curMat, uv, 1, false);
                 sty += orih;
             }
             // 最后剩下的
             if (left > 0) {
                 var dv = uv[7] - uv[1];
                 var uvb = uv[1] + dv * (left / orih);
                 var tuv = Context.tmpuv1;
                 tuv[0] = uv[0];
                 tuv[1] = uv[1];
                 tuv[2] = uv[2];
                 tuv[3] = uv[3];
                 tuv[4] = uv[4];
                 tuv[5] = uvb;
                 tuv[6] = uv[6];
                 tuv[7] = uvb;
                 this._inner_drawTexture(tex, imgid, x, sty, oriw, left, this._curMat, tuv, 1, false);
             }
         }
         drawTextureWithSizeGrid(tex, tx, ty, width, height, sizeGrid, gx, gy) {
             if (!tex._getSource())
                 return;
             tx += gx;
             ty += gy;
             var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
             var top = sizeGrid[0];
             var left = sizeGrid[3];
             var d_top = top / h;
             var d_left = left / w;
             var right = sizeGrid[1];
             var bottom = sizeGrid[2];
             var d_right = right / w;
             var d_bottom = bottom / h;
             var repeat = sizeGrid[4];
             var needClip = false;
             if (width == w) {
                 left = right = 0;
             }
             if (height == h) {
                 top = bottom = 0;
             }
             //处理进度条不好看的问题
             if (left + right > width) {
                 var clipWidth = width;
                 needClip = true;
                 width = left + right;
                 this.save();
                 this.clipRect(0 + tx, 0 + ty, clipWidth, height);
             }
             var imgid = tex.bitmap.id;
             var mat = this._curMat;
             var tuv = this._tempUV;
             // 整图的uv
             // 一定是方的，所以uv只要左上右下就行
             var uvl = uv[0];
             var uvt = uv[1];
             var uvr = uv[4];
             var uvb = uv[5];
             // 小图的uv
             var uvl_ = uvl;
             var uvt_ = uvt;
             var uvr_ = uvr;
             var uvb_ = uvb;
             //绘制四个角
             // 构造uv
             if (left && top) {
                 uvr_ = uvl + d_left;
                 uvb_ = uvt + d_top;
                 tuv[0] = uvl, tuv[1] = uvt, tuv[2] = uvr_, tuv[3] = uvt,
                     tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl, tuv[7] = uvb_;
                 this._inner_drawTexture(tex, imgid, tx, ty, left, top, mat, tuv, 1, false);
             }
             if (right && top) {
                 uvl_ = uvr - d_right;
                 uvt_ = uvt;
                 uvr_ = uvr;
                 uvb_ = uvt + d_top;
                 tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                     tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                 this._inner_drawTexture(tex, imgid, width - right + tx, 0 + ty, right, top, mat, tuv, 1, false);
             }
             if (left && bottom) {
                 uvl_ = uvl;
                 uvt_ = uvb - d_bottom;
                 uvr_ = uvl + d_left;
                 uvb_ = uvb;
                 tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                     tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                 this._inner_drawTexture(tex, imgid, 0 + tx, height - bottom + ty, left, bottom, mat, tuv, 1, false);
             }
             if (right && bottom) {
                 uvl_ = uvr - d_right;
                 uvt_ = uvb - d_bottom;
                 uvr_ = uvr;
                 uvb_ = uvb;
                 tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                     tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                 this._inner_drawTexture(tex, imgid, width - right + tx, height - bottom + ty, right, bottom, mat, tuv, 1, false);
             }
             //绘制上下两个边
             if (top) {
                 uvl_ = uvl + d_left;
                 uvt_ = uvt;
                 uvr_ = uvr - d_right;
                 uvb_ = uvt + d_top;
                 tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                     tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                 if (repeat) {
                     this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, top, left + tx, ty, width - left - right);
                 }
                 else {
                     this._inner_drawTexture(tex, imgid, left + tx, ty, width - left - right, top, mat, tuv, 1, false);
                 }
             }
             if (bottom) {
                 uvl_ = uvl + d_left;
                 uvt_ = uvb - d_bottom;
                 uvr_ = uvr - d_right;
                 uvb_ = uvb;
                 tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                     tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                 if (repeat) {
                     this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, bottom, left + tx, height - bottom + ty, width - left - right);
                 }
                 else {
                     this._inner_drawTexture(tex, imgid, left + tx, height - bottom + ty, width - left - right, bottom, mat, tuv, 1, false);
                 }
             }
             //绘制左右两边
             if (left) {
                 uvl_ = uvl;
                 uvt_ = uvt + d_top;
                 uvr_ = uvl + d_left;
                 uvb_ = uvb - d_bottom;
                 tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                     tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                 if (repeat) {
                     this._fillTexture_v(tex, imgid, tuv, left, tex.height - top - bottom, tx, top + ty, height - top - bottom);
                 }
                 else {
                     this._inner_drawTexture(tex, imgid, tx, top + ty, left, height - top - bottom, mat, tuv, 1, false);
                 }
             }
             if (right) {
                 uvl_ = uvr - d_right;
                 uvt_ = uvt + d_top;
                 uvr_ = uvr;
                 uvb_ = uvb - d_bottom;
                 tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                     tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                 if (repeat) {
                     this._fillTexture_v(tex, imgid, tuv, right, tex.height - top - bottom, width - right + tx, top + ty, height - top - bottom);
                 }
                 else {
                     this._inner_drawTexture(tex, imgid, width - right + tx, top + ty, right, height - top - bottom, mat, tuv, 1, false);
                 }
             }
             //绘制中间
             uvl_ = uvl + d_left;
             uvt_ = uvt + d_top;
             uvr_ = uvr - d_right;
             uvb_ = uvb - d_bottom;
             tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                 tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
             if (repeat) {
                 var tuvr = Context.tmpUVRect;
                 tuvr[0] = uvl_;
                 tuvr[1] = uvt_;
                 tuvr[2] = uvr_ - uvl_;
                 tuvr[3] = uvb_ - uvt_;
                 // 这个如果用重复的可能比较多，所以采用filltexture的方法，注意这样会打断合并
                 this._fillTexture(tex, tex.width - left - right, tex.height - top - bottom, tuvr, left + tx, top + ty, width - left - right, height - top - bottom, 'repeat', 0, 0);
             }
             else {
                 this._inner_drawTexture(tex, imgid, left + tx, top + ty, width - left - right, height - top - bottom, mat, tuv, 1, false);
             }
             if (needClip)
                 this.restore();
         }
     }
     Context.ENUM_TEXTALIGN_DEFAULT = 0;
     Context.ENUM_TEXTALIGN_CENTER = 1;
     Context.ENUM_TEXTALIGN_RIGHT = 2;
     Context._SUBMITVBSIZE = 32000;
     Context._MAXSIZE = 99999999;
     Context._MAXVERTNUM = 65535;
     Context.MAXCLIPRECT = null;
     Context._COUNT = 0;
     Context.SEGNUM = 32;
     Context._contextcount = 0;
     /**Math.PI*2的结果缓存 */
     Context.PI2 = 2 * Math.PI;
     Context._clipID_Gen = 0; //生成clipid的，原来是  _clipInfoID=++_clipInfoID 这样会有问题，导致兄弟clip的id都相同
     Context._textRender = null; // new TextRender();
     //=============新增==================	
     /* 下面的方式是有bug的。canvas是直接save，restore，现在是为了优化，但是有bug，所以先不重载了
     public function saveTransform(matrix:Matrix):void {
         this._curMat.copyTo(matrix);
     }

     public function restoreTransform(matrix:Matrix):void {
         matrix.copyTo(this._curMat);
     }

     public function transformByMatrix(matrix:Matrix,tx:Number,ty:Number):void {
         var mat:Matrix = _curMat;
         matrix.setTranslate(tx, ty);
         Matrix.mul(matrix, mat, mat);
         matrix.setTranslate(0, 0);
         mat._bTransform = true;
     }
     */
     /* 下面的是错误的。位置没有被缩放
     public function transformByMatrix(matrix:Matrix, tx:Number, ty:Number):void {
         SaveTransform.save(this);
         Matrix.mul(matrix, _curMat, _curMat);
         _curMat.tx += tx;
         _curMat.ty += ty;
         _curMat._checkTransform();
     }
             
     public function transformByMatrixNoSave(matrix:Matrix, tx:Number, ty:Number):void {
         Matrix.mul(matrix, _curMat, _curMat);
         _curMat.tx += tx;
         _curMat.ty += ty;
         _curMat._checkTransform();
     }
     */
     Context.tmpuv1 = [0, 0, 0, 0, 0, 0, 0, 0];
     Context.tmpUV = [0, 0, 0, 0, 0, 0, 0, 0];
     Context.tmpUVRect = [0, 0, 0, 0];
     class ContextParams {
         constructor() {
             this.lineWidth = 1;
         }
         clear() {
             this.lineWidth = 1;
             this.textAlign = this.textBaseline = null;
         }
         make() {
             return this === ContextParams.DEFAULT ? new ContextParams() : this;
         }
     }

     /**
      * @private
      */
     class WebGL {
         //TODO:coverage
         static _uint8ArraySlice() {
             var _this = this;
             var sz = _this.length;
             var dec = new Uint8Array(_this.length);
             for (var i = 0; i < sz; i++)
                 dec[i] = _this[i];
             return dec;
         }
         //TODO:coverage
         static _float32ArraySlice() {
             var _this = this;
             var sz = _this.length;
             var dec = new Float32Array(_this.length);
             for (var i = 0; i < sz; i++)
                 dec[i] = _this[i];
             return dec;
         }
         //TODO:coverage
         static _uint16ArraySlice(...arg) {
             var _this = this;
             var sz;
             var dec;
             var i;
             if (arg.length === 0) {
                 sz = _this.length;
                 dec = new Uint16Array(sz);
                 for (i = 0; i < sz; i++)
                     dec[i] = _this[i];
             }
             else if (arg.length === 2) {
                 var start = arg[0];
                 var end = arg[1];
                 if (end > start) {
                     sz = end - start;
                     dec = new Uint16Array(sz);
                     for (i = start; i < end; i++)
                         dec[i - start] = _this[i];
                 }
                 else {
                     dec = new Uint16Array(0);
                 }
             }
             return dec;
         }
         static _nativeRender_enable() {
         }
         //使用webgl渲染器
         static enable() {
             return true;
         }
         static inner_enable() {
             Float32Array.prototype.slice || (Float32Array.prototype.slice = WebGL._float32ArraySlice);
             Uint16Array.prototype.slice || (Uint16Array.prototype.slice = WebGL._uint16ArraySlice);
             Uint8Array.prototype.slice || (Uint8Array.prototype.slice = WebGL._uint8ArraySlice);
             return true;
         }
         static onStageResize(width, height) {
             if (WebGLContext.mainContext == null)
                 return;
             WebGLContext.mainContext.viewport(0, 0, width, height);
             RenderState2D.width = width;
             RenderState2D.height = height;
         }
     }
     WebGL._isWebGL2 = false;
     WebGL.isNativeRender_enable = false;

     (function () {
         var glErrorShadow = {};
         function error(msg) {
             if (window.console && window.console.error) {
                 window.console.error(msg);
             }
         }
         function log(msg) {
             if (window.console && window.console.log) {
                 window.console.log(msg);
             }
         }
         function synthesizeGLError(err, opt_msg) {
             glErrorShadow[err] = true;
             if (opt_msg !== undefined) {
                 error(opt_msg);
             }
         }
         function wrapGLError(gl) {
             var f = gl.getError;
             gl.getError = function () {
                 var err;
                 do {
                     err = f.apply(gl);
                     if (err != gl.NO_ERROR) {
                         glErrorShadow[err] = true;
                     }
                 } while (err != gl.NO_ERROR);
                 for (var err1 in glErrorShadow) {
                     if (glErrorShadow[err1]) {
                         delete glErrorShadow[err1];
                         return parseInt(err1);
                     }
                 }
                 return gl.NO_ERROR;
             };
         }
         var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
             var gl = ext.gl;
             this.ext = ext;
             this.isAlive = true;
             this.hasBeenBound = false;
             this.elementArrayBuffer = null;
             this.attribs = new Array(ext.maxVertexAttribs);
             for (var n = 0; n < this.attribs.length; n++) {
                 var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
                 this.attribs[n] = attrib;
             }
             this.maxAttrib = 0;
         };
         WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
             this.enabled = false;
             this.buffer = null;
             this.size = 4;
             this.type = gl.FLOAT;
             this.normalized = false;
             this.stride = 16;
             this.offset = 0;
             this.cached = "";
             this.recache();
         };
         WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
             this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
         };
         var OESVertexArrayObject = function OESVertexArrayObject(gl) {
             var self = this;
             this.gl = gl;
             wrapGLError(gl);
             var original = this.original = {
                 getParameter: gl.getParameter,
                 enableVertexAttribArray: gl.enableVertexAttribArray,
                 disableVertexAttribArray: gl.disableVertexAttribArray,
                 bindBuffer: gl.bindBuffer,
                 getVertexAttrib: gl.getVertexAttrib,
                 vertexAttribPointer: gl.vertexAttribPointer
             };
             gl.getParameter = function getParameter(pname) {
                 if (pname == self.VERTEX_ARRAY_BINDING_OES) {
                     if (self.currentVertexArrayObject == self.defaultVertexArrayObject) {
                         return null;
                     }
                     else {
                         return self.currentVertexArrayObject;
                     }
                 }
                 return original.getParameter.apply(this, arguments);
             };
             gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
                 var vao = self.currentVertexArrayObject;
                 vao.maxAttrib = Math.max(vao.maxAttrib, index);
                 var attrib = vao.attribs[index];
                 attrib.enabled = true;
                 return original.enableVertexAttribArray.apply(this, arguments);
             };
             gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
                 var vao = self.currentVertexArrayObject;
                 vao.maxAttrib = Math.max(vao.maxAttrib, index);
                 var attrib = vao.attribs[index];
                 attrib.enabled = false;
                 return original.disableVertexAttribArray.apply(this, arguments);
             };
             gl.bindBuffer = function bindBuffer(target, buffer) {
                 switch (target) {
                     case gl.ARRAY_BUFFER:
                         self.currentArrayBuffer = buffer;
                         break;
                     case gl.ELEMENT_ARRAY_BUFFER:
                         self.currentVertexArrayObject.elementArrayBuffer = buffer;
                         break;
                 }
                 return original.bindBuffer.apply(this, arguments);
             };
             gl.getVertexAttrib = function getVertexAttrib(index, pname) {
                 var vao = self.currentVertexArrayObject;
                 var attrib = vao.attribs[index];
                 switch (pname) {
                     case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                         return attrib.buffer;
                     case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
                         return attrib.enabled;
                     case gl.VERTEX_ATTRIB_ARRAY_SIZE:
                         return attrib.size;
                     case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
                         return attrib.stride;
                     case gl.VERTEX_ATTRIB_ARRAY_TYPE:
                         return attrib.type;
                     case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                         return attrib.normalized;
                     default:
                         return original.getVertexAttrib.apply(this, arguments);
                 }
             };
             gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
                 var vao = self.currentVertexArrayObject;
                 vao.maxAttrib = Math.max(vao.maxAttrib, indx);
                 var attrib = vao.attribs[indx];
                 attrib.buffer = self.currentArrayBuffer;
                 attrib.size = size;
                 attrib.type = type;
                 attrib.normalized = normalized;
                 attrib.stride = stride;
                 attrib.offset = offset;
                 attrib.recache();
                 return original.vertexAttribPointer.apply(this, arguments);
             };
             if (gl.instrumentExtension) {
                 gl.instrumentExtension(this, "OES_vertex_array_object");
             }
             gl.canvas.addEventListener('webglcontextrestored', function () {
                 log("OESVertexArrayObject emulation library context restored");
                 self.reset_();
             }, true);
             this.reset_();
         };
         OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;
         OESVertexArrayObject.prototype.reset_ = function reset_() {
             var contextWasLost = this.vertexArrayObjects !== undefined;
             if (contextWasLost) {
                 for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
                     this.vertexArrayObjects.isAlive = false;
                 }
             }
             var gl = this.gl;
             this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
             this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
             this.currentVertexArrayObject = null;
             this.currentArrayBuffer = null;
             this.vertexArrayObjects = [this.defaultVertexArrayObject];
             this.bindVertexArrayOES(null);
         };
         OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
             var arrayObject = new WebGLVertexArrayObjectOES(this);
             this.vertexArrayObjects.push(arrayObject);
             return arrayObject;
         };
         OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
             arrayObject.isAlive = false;
             this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
             if (this.currentVertexArrayObject == arrayObject) {
                 this.bindVertexArrayOES(null);
             }
         };
         OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
             if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
                 if (arrayObject.hasBeenBound && arrayObject.ext == this) {
                     return true;
                 }
             }
             return false;
         };
         OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
             var gl = this.gl;
             if (arrayObject && !arrayObject.isAlive) {
                 synthesizeGLError(gl.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
                 return;
             }
             var original = this.original;
             var oldVAO = this.currentVertexArrayObject;
             this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
             this.currentVertexArrayObject.hasBeenBound = true;
             var newVAO = this.currentVertexArrayObject;
             if (oldVAO == newVAO) {
                 return;
             }
             if (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {
                 original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
             }
             var currentBinding = this.currentArrayBuffer;
             var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
             for (var n = 0; n <= maxAttrib; n++) {
                 var attrib = newVAO.attribs[n];
                 var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
                 if (!oldVAO || attrib.enabled != oldAttrib.enabled) {
                     if (attrib.enabled) {
                         original.enableVertexAttribArray.call(gl, n);
                     }
                     else {
                         original.disableVertexAttribArray.call(gl, n);
                     }
                 }
                 if (attrib.enabled) {
                     var bufferChanged = false;
                     if (!oldVAO || attrib.buffer != oldAttrib.buffer) {
                         if (currentBinding != attrib.buffer) {
                             original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
                             currentBinding = attrib.buffer;
                         }
                         bufferChanged = true;
                     }
                     if (bufferChanged || attrib.cached != oldAttrib.cached) {
                         original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
                     }
                 }
             }
             if (this.currentArrayBuffer != currentBinding) {
                 original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
             }
         };
         window._setupVertexArrayObject = function (gl) {
             var original_getSupportedExtensions = gl.getSupportedExtensions;
             gl.getSupportedExtensions = function getSupportedExtensions() {
                 var list = original_getSupportedExtensions.call(this) || [];
                 if (list.indexOf("OES_vertex_array_object") < 0) {
                     list.push("OES_vertex_array_object");
                 }
                 return list;
             };
             var original_getExtension = gl.getExtension;
             gl.getExtension = function getExtension(name) {
                 var ext = original_getExtension.call(this, name);
                 if (ext) {
                     return ext;
                 }
                 if (name !== "OES_vertex_array_object") {
                     return null;
                 }
                 if (!this.__OESVertexArrayObject) {
                     console.log("Setup OES_vertex_array_object polyfill");
                     this.__OESVertexArrayObject = new OESVertexArrayObject(this);
                 }
                 return this.__OESVertexArrayObject;
             };
         };
         window._forceSetupVertexArrayObject = function (gl) {
             var original_getSupportedExtensions = gl.getSupportedExtensions;
             gl.getSupportedExtensions = function getSupportedExtensions() {
                 var list = original_getSupportedExtensions.call(this) || [];
                 if (list.indexOf("OES_vertex_array_object") < 0) {
                     list.push("OES_vertex_array_object");
                 }
                 return list;
             };
             var original_getExtension = gl.getExtension;
             gl.getExtension = function getExtension(name) {
                 if (name === "OES_vertex_array_object") {
                     if (!this.__OESVertexArrayObject) {
                         console.log("Setup OES_vertex_array_object polyfill");
                         this.__OESVertexArrayObject = new OESVertexArrayObject(this);
                     }
                     return this.__OESVertexArrayObject;
                 }
                 else {
                     var ext = original_getExtension.call(this, name);
                     if (ext) {
                         return ext;
                     }
                     else {
                         return null;
                     }
                 }
             };
         };
     }());

     /**
      * @private
      */
     class LayaGPU {
         /**
          * @private
          */
         constructor(gl, isWebGL2) {
             /**@private */
             this._gl = null;
             /**@private */
             this._vaoExt = null;
             /**@private */
             this._angleInstancedArrays = null;
             /**@private */
             this._isWebGL2 = false;
             /**@private */
             this._oesTextureHalfFloat = null;
             /**@private */
             this._extTextureFilterAnisotropic = null;
             /**@private */
             this._compressedTextureS3tc = null;
             /**@private */
             this._compressedTexturePvrtc = null;
             /**@private */
             this._compressedTextureEtc1 = null;
             this._gl = gl;
             this._isWebGL2 = isWebGL2;
             try { //某些浏览器中未实现此函数，使用try catch增强兼容性。
                 var precisionFormat = gl.getShaderPrecisionFormat(WebGLContext.FRAGMENT_SHADER, WebGLContext.HIGH_FLOAT);
                 precisionFormat.precision ? (WebGL.shaderHighPrecision = true) : WebGL.shaderHighPrecision = false;
             }
             catch (e) {
             }
             if (!isWebGL2) {
                 var forceVAO = LayaGPU._forceSupportVAOPlatform();
                 if (!ILaya.Render.isConchApp) {
                     if (window._setupVertexArrayObject) { //兼容VAO
                         if (forceVAO)
                             window._forceSetupVertexArrayObject(gl);
                         else
                             window._setupVertexArrayObject(gl);
                     }
                 }
                 this._vaoExt = this._getExtension("OES_vertex_array_object");
                 if (!forceVAO)
                     this._angleInstancedArrays = this._getExtension("ANGLE_instanced_arrays"); //forceVAO会导致Instance有BUG
                 this._oesTextureHalfFloat = this._getExtension("OES_texture_half_float");
                 this._getExtension("OES_texture_half_float_linear");
                 //_getExtension("OES_texture_float");
                 //_getExtension("OES_texture_float_linear");
             }
             else {
                 this._getExtension("EXT_color_buffer_float");
                 //_getExtension("OES_texture_float_linear");
             }
             //_getExtension("EXT_float_blend");
             this._extTextureFilterAnisotropic = this._getExtension("EXT_texture_filter_anisotropic");
             this._compressedTextureS3tc = this._getExtension("WEBGL_compressed_texture_s3tc");
             this._compressedTexturePvrtc = this._getExtension("WEBGL_compressed_texture_pvrtc");
             this._compressedTextureEtc1 = this._getExtension("WEBGL_compressed_texture_etc1");
         }
         /**
          * @private
          */
         static _forceSupportVAOPlatform() {
             let Browser = ILaya.Browser;
             return (Browser.onMiniGame && Browser.onIOS) || Browser.onBDMiniGame || Browser.onQGMiniGame;
         }
         /**
          * @private
          */
         _getExtension(name) {
             var prefixes = LayaGPU._extentionVendorPrefixes;
             for (var k in prefixes) {
                 var ext = this._gl.getExtension(prefixes[k] + name);
                 if (ext)
                     return ext;
             }
             return null;
         }
         /**
          * @private
          */
         createVertexArray() {
             if (this._isWebGL2)
                 return this._gl.createVertexArray();
             else
                 return this._vaoExt.createVertexArrayOES();
         }
         /**
          * @private
          */
         bindVertexArray(vertexArray) {
             if (this._isWebGL2)
                 this._gl.bindVertexArray(vertexArray);
             else
                 this._vaoExt.bindVertexArrayOES(vertexArray);
         }
         /**
          * @private
          */
         deleteVertexArray(vertexArray) {
             if (this._isWebGL2)
                 this._gl.deleteVertexArray(vertexArray);
             else
                 this._vaoExt.deleteVertexArrayOES(vertexArray);
         }
         /**
          * @private
          */
         isVertexArray(vertexArray) {
             if (this._isWebGL2)
                 this._gl.isVertexArray(vertexArray);
             else
                 this._vaoExt.isVertexArrayOES(vertexArray);
         }
         /**
          * @private
          */
         drawElementsInstanced(mode, count, type, offset, instanceCount) {
             if (this._isWebGL2)
                 this._gl.drawElementsInstanced(mode, count, type, offset, instanceCount);
             else
                 this._angleInstancedArrays.drawElementsInstancedANGLE(mode, count, type, offset, instanceCount);
         }
         /**
          * @private
          */
         drawArraysInstanced(mode, first, count, instanceCount) {
             if (this._isWebGL2)
                 this._gl.drawArraysInstanced(mode, first, count, instanceCount);
             else
                 this._angleInstancedArrays.drawArraysInstancedANGLE(mode, first, count, instanceCount);
         }
         /**
          * @private
          */
         vertexAttribDivisor(index, divisor) {
             if (this._isWebGL2)
                 this._gl.vertexAttribDivisor(index, divisor);
             else
                 this._angleInstancedArrays.vertexAttribDivisorANGLE(index, divisor);
         }
         /**
          * @private
          */
         supportInstance() {
             if (this._isWebGL2 || this._angleInstancedArrays)
                 return true;
             else
                 return false;
         }
     }
     /**@private */
     LayaGPU._extentionVendorPrefixes = ["", "WEBKIT_", "MOZ_"];

     /**
      * @private
      * <code>Render</code> 是渲染管理类。它是一个单例，可以使用 Laya.render 访问。
      */
     class Render {
         /**
          * 初始化引擎。
          * @param	width 游戏窗口宽度。
          * @param	height	游戏窗口高度。
          */
         constructor(width, height, mainCanv) {
             /**@private */
             this._timeId = 0;
             Render._mainCanvas = mainCanv;
             //创建主画布。改到Browser中了，因为为了runtime，主画布必须是第一个
             Render._mainCanvas.source.id = "layaCanvas";
             Render._mainCanvas.source.width = width;
             Render._mainCanvas.source.height = height;
             if (Render.isConchApp) {
                 document.body.appendChild(Render._mainCanvas.source);
             }
             this.initRender(Render._mainCanvas, width, height);
             window.requestAnimationFrame(loop);
             function loop(stamp) {
                 ILaya.stage._loop();
                 window.requestAnimationFrame(loop);
             }
             ILaya.stage.on("visibilitychange", this, this._onVisibilitychange);
         }
         /**@private */
         _onVisibilitychange() {
             if (!ILaya.stage.isVisibility) {
                 this._timeId = window.setInterval(this._enterFrame, 1000);
             }
             else if (this._timeId != 0) {
                 window.clearInterval(this._timeId);
             }
         }
         initRender(canvas, w, h) {
             function getWebGLContext(canvas) {
                 var gl;
                 var names = ["webgl2", "webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
                 if (!Config.useWebGL2) {
                     names.shift();
                 }
                 for (var i = 0; i < names.length; i++) {
                     try {
                         gl = canvas.getContext(names[i], { stencil: Config.isStencil, alpha: Config.isAlpha, antialias: Config.isAntialias, premultipliedAlpha: Config.premultipliedAlpha, preserveDrawingBuffer: Config.preserveDrawingBuffer }); //antialias为true,premultipliedAlpha为false,IOS和部分安卓QQ浏览器有黑屏或者白屏底色BUG
                     }
                     catch (e) {
                     }
                     if (gl) {
                         (names[i] === 'webgl2') && (WebGL._isWebGL2 = true);
                         return gl;
                     }
                 }
                 return null;
             }
             var gl = LayaGL.instance = WebGLContext.mainContext = getWebGLContext(Render._mainCanvas.source);
             if (!gl)
                 return false;
             LayaGL.instance = gl;
             LayaGL.layaGPUInstance = new LayaGPU(gl, WebGL._isWebGL2);
             canvas.size(w, h); //在ctx之后调用。
             Context.__init__();
             SubmitBase.__init__();
             var ctx = new Context();
             ctx.isMain = true;
             Render._context = ctx;
             canvas._setContext(ctx);
             //TODO 现在有个问题是 gl.deleteTexture并没有走WebGLContex封装的
             ShaderDefines2D.__init__();
             Value2D.__init__();
             Shader2D.__init__();
             Buffer2D.__int__(gl);
             BlendMode._init_(gl);
             return true;
         }
         /**@private */
         _enterFrame(e = null) {
             ILaya.stage._loop();
         }
         /** 目前使用的渲染器。*/
         static get context() {
             return Render._context;
         }
         /** 渲染使用的原生画布引用。 */
         static get canvas() {
             return Render._mainCanvas.source;
         }
     }
     Render.supportWebGLPlusCulling = false;
     Render.supportWebGLPlusAnimation = false;
     Render.supportWebGLPlusRendering = false;
     /**是否是加速器 只读*/
     Render.isConchApp = false;
     {
         Render.isConchApp = (window.conch != null);
         if (Render.isConchApp) {
             Render.supportWebGLPlusCulling = true;
             Render.supportWebGLPlusAnimation = true;
             Render.supportWebGLPlusRendering = true;
         }
     }

     /**
      * @private
      * Graphic bounds数据类
      */
     class GraphicsBounds {
         constructor() {
             /**@private */
             this._cacheBoundsType = false;
         }
         /**
          * 销毁
          */
         destroy() {
             this._graphics = null;
             this._cacheBoundsType = false;
             if (this._temp)
                 this._temp.length = 0;
             if (this._rstBoundPoints)
                 this._rstBoundPoints.length = 0;
             if (this._bounds)
                 this._bounds.recover();
             this._bounds = null;
             Pool.recover("GraphicsBounds", this);
         }
         /**
          * 创建
          */
         static create() {
             return Pool.getItemByClass("GraphicsBounds", GraphicsBounds);
         }
         /**
          * 重置数据
          */
         reset() {
             this._temp && (this._temp.length = 0);
         }
         /**
          * 获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
          * @param realSize	（可选）使用图片的真实大小，默认为false
          * @return 位置与宽高组成的 一个 Rectangle 对象。
          */
         getBounds(realSize = false) {
             if (!this._bounds || !this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType) {
                 this._bounds = Rectangle._getWrapRec(this.getBoundPoints(realSize), this._bounds);
             }
             this._cacheBoundsType = realSize;
             return this._bounds;
         }
         /**
          * @private
          * @param realSize	（可选）使用图片的真实大小，默认为false
          * 获取端点列表。
          */
         getBoundPoints(realSize = false) {
             if (!this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType)
                 this._temp = this._getCmdPoints(realSize);
             this._cacheBoundsType = realSize;
             return this._rstBoundPoints = Utils.copyArray(this._rstBoundPoints, this._temp);
         }
         _getCmdPoints(realSize = false) {
             var cmds = this._graphics.cmds;
             var rst;
             rst = this._temp || (this._temp = []);
             rst.length = 0;
             if (!cmds && this._graphics._one != null) {
                 GraphicsBounds._tempCmds.length = 0;
                 GraphicsBounds._tempCmds.push(this._graphics._one);
                 cmds = GraphicsBounds._tempCmds;
             }
             if (!cmds)
                 return rst;
             var matrixs = GraphicsBounds._tempMatrixArrays;
             matrixs.length = 0;
             var tMatrix = GraphicsBounds._initMatrix;
             tMatrix.identity();
             var tempMatrix = GraphicsBounds._tempMatrix;
             var cmd;
             var tex;
             for (var i = 0, n = cmds.length; i < n; i++) {
                 cmd = cmds[i];
                 switch (cmd.cmdID) {
                     case AlphaCmd.ID: //save //TODO:是否还需要
                         matrixs.push(tMatrix);
                         tMatrix = tMatrix.clone();
                         break;
                     case RestoreCmd.ID: //restore
                         tMatrix = matrixs.pop();
                         break;
                     case ScaleCmd.ID: //scale
                         tempMatrix.identity();
                         tempMatrix.translate(-cmd.pivotX, -cmd.pivotY);
                         tempMatrix.scale(cmd.scaleX, cmd.scaleY);
                         tempMatrix.translate(cmd.pivotX, cmd.pivotY);
                         this._switchMatrix(tMatrix, tempMatrix);
                         break;
                     case RotateCmd.ID: //case context._rotate: 
                         tempMatrix.identity();
                         tempMatrix.translate(-cmd.pivotX, -cmd.pivotY);
                         tempMatrix.rotate(cmd.angle);
                         tempMatrix.translate(cmd.pivotX, cmd.pivotY);
                         this._switchMatrix(tMatrix, tempMatrix);
                         break;
                     case TranslateCmd.ID: //translate
                         tempMatrix.identity();
                         tempMatrix.translate(cmd.tx, cmd.ty);
                         this._switchMatrix(tMatrix, tempMatrix);
                         break;
                     case TransformCmd.ID: //context._transform:
                         tempMatrix.identity();
                         tempMatrix.translate(-cmd.pivotX, -cmd.pivotY);
                         tempMatrix.concat(cmd.matrix);
                         tempMatrix.translate(cmd.pivotX, cmd.pivotY);
                         this._switchMatrix(tMatrix, tempMatrix);
                         break;
                     case DrawImageCmd.ID: //case context._drawTexture: 
                     case FillTextureCmd.ID: //case context._fillTexture
                         GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix);
                         break;
                     case DrawTextureCmd.ID: //case context._drawTextureTransform: 
                         tMatrix.copyTo(tempMatrix);
                         if (cmd.matrix)
                             tempMatrix.concat(cmd.matrix);
                         GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tempMatrix);
                         break;
                     case DrawImageCmd.ID:
                         tex = cmd.texture;
                         if (realSize) {
                             if (cmd.width && cmd.height) {
                                 GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix);
                             }
                             else {
                                 GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, tex.width, tex.height), tMatrix);
                             }
                         }
                         else {
                             var wRate = (cmd.width || tex.sourceWidth) / tex.width;
                             var hRate = (cmd.height || tex.sourceHeight) / tex.height;
                             var oWidth = wRate * tex.sourceWidth;
                             var oHeight = hRate * tex.sourceHeight;
                             var offX = tex.offsetX > 0 ? tex.offsetX : 0;
                             var offY = tex.offsetY > 0 ? tex.offsetY : 0;
                             offX *= wRate;
                             offY *= hRate;
                             GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x - offX, cmd.y - offY, oWidth, oHeight), tMatrix);
                         }
                         break;
                     case FillTextureCmd.ID:
                         if (cmd.width && cmd.height) {
                             GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix);
                         }
                         else {
                             tex = cmd.texture;
                             GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, tex.width, tex.height), tMatrix);
                         }
                         break;
                     case DrawTextureCmd.ID:
                         var drawMatrix;
                         if (cmd.matrix) {
                             tMatrix.copyTo(tempMatrix);
                             tempMatrix.concat(cmd.matrix);
                             drawMatrix = tempMatrix;
                         }
                         else {
                             drawMatrix = tMatrix;
                         }
                         if (realSize) {
                             if (cmd.width && cmd.height) {
                                 GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), drawMatrix);
                             }
                             else {
                                 tex = cmd.texture;
                                 GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, tex.width, tex.height), drawMatrix);
                             }
                         }
                         else {
                             tex = cmd.texture;
                             wRate = (cmd.width || tex.sourceWidth) / tex.width;
                             hRate = (cmd.height || tex.sourceHeight) / tex.height;
                             oWidth = wRate * tex.sourceWidth;
                             oHeight = hRate * tex.sourceHeight;
                             offX = tex.offsetX > 0 ? tex.offsetX : 0;
                             offY = tex.offsetY > 0 ? tex.offsetY : 0;
                             offX *= wRate;
                             offY *= hRate;
                             GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x - offX, cmd.y - offY, oWidth, oHeight), drawMatrix);
                         }
                         break;
                     case DrawRectCmd.ID: //case context._drawRect:
                         GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix);
                         break;
                     case DrawCircleCmd.ID: //case context._drawCircle
                         GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x - cmd.radius, cmd.y - cmd.radius, cmd.radius + cmd.radius, cmd.radius + cmd.radius), tMatrix);
                         break;
                     case DrawLineCmd.ID: //drawLine
                         GraphicsBounds._tempPoints.length = 0;
                         var lineWidth;
                         lineWidth = cmd.lineWidth * 0.5;
                         if (cmd.fromX == cmd.toX) {
                             GraphicsBounds._tempPoints.push(cmd.fromX + lineWidth, cmd.fromY, cmd.toX + lineWidth, cmd.toY, cmd.fromX - lineWidth, cmd.fromY, cmd.toX - lineWidth, cmd.toY);
                         }
                         else if (cmd.fromY == cmd.toY) {
                             GraphicsBounds._tempPoints.push(cmd.fromX, cmd.fromY + lineWidth, cmd.toX, cmd.toY + lineWidth, cmd.fromX, cmd.fromY - lineWidth, cmd.toX, cmd.toY - lineWidth);
                         }
                         else {
                             GraphicsBounds._tempPoints.push(cmd.fromX, cmd.fromY, cmd.toX, cmd.toY);
                         }
                         GraphicsBounds._addPointArrToRst(rst, GraphicsBounds._tempPoints, tMatrix);
                         break;
                     case DrawCurvesCmd.ID: //context._drawCurves:					
                         GraphicsBounds._addPointArrToRst(rst, Bezier.I.getBezierPoints(cmd.points), tMatrix, cmd.x, cmd.y);
                         break;
                     case DrawLinesCmd.ID: //drawpoly
                     case DrawPolyCmd.ID: //drawpoly
                         GraphicsBounds._addPointArrToRst(rst, cmd.points, tMatrix, cmd.x, cmd.y);
                         break;
                     case DrawPathCmd.ID: //drawPath
                         GraphicsBounds._addPointArrToRst(rst, this._getPathPoints(cmd.paths), tMatrix, cmd.x, cmd.y);
                         break;
                     case DrawPieCmd.ID: //drawPie
                         GraphicsBounds._addPointArrToRst(rst, this._getPiePoints(cmd.x, cmd.y, cmd.radius, cmd.startAngle, cmd.endAngle), tMatrix);
                         break;
                 }
             }
             if (rst.length > 200) {
                 rst = Utils.copyArray(rst, Rectangle._getWrapRec(rst)._getBoundPoints());
             }
             else if (rst.length > 8)
                 rst = GrahamScan.scanPList(rst);
             return rst;
         }
         _switchMatrix(tMatix, tempMatrix) {
             tempMatrix.concat(tMatix);
             tempMatrix.copyTo(tMatix);
         }
         static _addPointArrToRst(rst, points, matrix, dx = 0, dy = 0) {
             var i, len;
             len = points.length;
             for (i = 0; i < len; i += 2) {
                 GraphicsBounds._addPointToRst(rst, points[i] + dx, points[i + 1] + dy, matrix);
             }
         }
         static _addPointToRst(rst, x, y, matrix) {
             var _tempPoint = Point.TEMP;
             _tempPoint.setTo(x ? x : 0, y ? y : 0);
             matrix.transformPoint(_tempPoint);
             rst.push(_tempPoint.x, _tempPoint.y);
         }
         /**
          * 获得drawPie命令可能的产生的点。注意 这里只假设用在包围盒计算上。
          * @param	x
          * @param	y
          * @param	radius
          * @param	startAngle
          * @param	endAngle
          * @return
          */
         _getPiePoints(x, y, radius, startAngle, endAngle) {
             var rst = GraphicsBounds._tempPoints;
             GraphicsBounds._tempPoints.length = 0;
             var k = Math.PI / 180;
             var d1 = endAngle - startAngle;
             if (d1 >= 360 || d1 <= -360) {
                 // 如果满了一圈了
                 rst.push(x - radius, y - radius);
                 rst.push(x + radius, y - radius);
                 rst.push(x + radius, y + radius);
                 rst.push(x - radius, y + radius);
                 return rst;
             }
             // 
             rst.push(x, y); // 中心
             var delta = d1 % 360;
             if (delta < 0)
                 delta += 360;
             // 一定增加，且在360以内的end
             var end1 = startAngle + delta;
             // 转成弧度
             var st = startAngle * k;
             var ed = end1 * k;
             // 起点
             rst.push(x + radius * Math.cos(st), y + radius * Math.sin(st));
             // 终点
             rst.push(x + radius * Math.cos(ed), y + radius * Math.sin(ed));
             // 圆形的四个边界点
             // 按照90度对齐，看看会经历几个90度
             var s1 = Math.ceil(startAngle / 90) * 90; //开始的。start的下一个90度
             var s2 = Math.floor(end1 / 90) * 90; //结束。end的上一个90度
             for (var cs = s1; cs <= s2; cs += 90) {
                 var csr = cs * k;
                 rst.push(x + radius * Math.cos(csr), y + radius * Math.sin(csr));
             }
             return rst;
             /*
             var segnum:int = 32;
             var step:Number = delta / segnum;
             var i:Number;
             var angle:Number = startAngle;
             for (i = 0; i <= segnum; i++) {
                 rst.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
                 angle += step;
             }
             */
         }
         _getPathPoints(paths) {
             var i, len;
             var rst = GraphicsBounds._tempPoints;
             rst.length = 0;
             len = paths.length;
             var tCMD;
             for (i = 0; i < len; i++) {
                 tCMD = paths[i];
                 if (tCMD.length > 1) {
                     rst.push(tCMD[1], tCMD[2]);
                     if (tCMD.length > 3) {
                         rst.push(tCMD[3], tCMD[4]);
                     }
                 }
             }
             return rst;
         }
     }
     /**@private */
     GraphicsBounds._tempMatrix = new Matrix();
     /**@private */
     GraphicsBounds._initMatrix = new Matrix();
     /**@private */
     GraphicsBounds._tempPoints = [];
     /**@private */
     GraphicsBounds._tempMatrixArrays = [];
     /**@private */
     GraphicsBounds._tempCmds = [];

     /**
          * @private
          */
     class SpriteConst {
     }
     /** @private */
     SpriteConst.ALPHA = 0x01;
     /** @private */
     SpriteConst.TRANSFORM = 0x02;
     /** @private */
     SpriteConst.BLEND = 0x04;
     /** @private */
     SpriteConst.CANVAS = 0x08;
     /** @private */
     SpriteConst.FILTERS = 0x10;
     /** @private */
     SpriteConst.MASK = 0x20;
     /** @private */
     SpriteConst.CLIP = 0x40;
     /** @private */
     SpriteConst.STYLE = 0x80;
     /** @private */
     SpriteConst.TEXTURE = 0x100;
     /** @private */
     SpriteConst.GRAPHICS = 0x200;
     /** @private */
     SpriteConst.LAYAGL3D = 0x400;
     /** @private */
     SpriteConst.CUSTOM = 0x800;
     /** @private */
     SpriteConst.ONECHILD = 0x1000;
     /** @private */
     SpriteConst.CHILDS = 0x2000;
     /** @private */
     SpriteConst.REPAINT_NONE = 0;
     /** @private */
     SpriteConst.REPAINT_NODE = 0x01;
     /** @private */
     SpriteConst.REPAINT_CACHE = 0x02;
     /** @private */
     SpriteConst.REPAINT_ALL = 0x03;

     /**
      * 裁剪命令
      */
     class ClipRectCmd {
         /**@private */
         static create(x, y, width, height) {
             var cmd = Pool.getItemByClass("ClipRectCmd", ClipRectCmd);
             cmd.x = x;
             cmd.y = y;
             cmd.width = width;
             cmd.height = height;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("ClipRectCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.clipRect(this.x + gx, this.y + gy, this.width, this.height);
         }
         /**@private */
         get cmdID() {
             return ClipRectCmd.ID;
         }
     }
     ClipRectCmd.ID = "ClipRect";

     /**
      * 绘制带九宫格信息的图片
      * @private
      */
     class Draw9GridTexture {
         constructor() {
         }
         /**@private */
         static create(texture, x, y, width, height, sizeGrid) {
             var cmd = Pool.getItemByClass("Draw9GridTexture", Draw9GridTexture);
             cmd.texture = texture;
             texture._addReference();
             cmd.x = x;
             cmd.y = y;
             cmd.width = width;
             cmd.height = height;
             cmd.sizeGrid = sizeGrid;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.texture._removeReference();
             Pool.recover("Draw9GridTexture", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.drawTextureWithSizeGrid(this.texture, this.x, this.y, this.width, this.height, this.sizeGrid, gx, gy);
         }
         /**@private */
         get cmdID() {
             return Draw9GridTexture.ID;
         }
     }
     Draw9GridTexture.ID = "Draw9GridTexture";

     /**
      * 根据坐标集合绘制多个贴图
      */
     class DrawTexturesCmd {
         /**@private */
         static create(texture, pos) {
             var cmd = Pool.getItemByClass("DrawTexturesCmd", DrawTexturesCmd);
             cmd.texture = texture;
             texture._addReference();
             cmd.pos = pos;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.texture._removeReference();
             this.texture = null;
             this.pos = null;
             Pool.recover("DrawTexturesCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.drawTextures(this.texture, this.pos, gx, gy);
         }
         /**@private */
         get cmdID() {
             return DrawTexturesCmd.ID;
         }
     }
     DrawTexturesCmd.ID = "DrawTextures";

     /**
      * 绘制三角形命令
      */
     class DrawTrianglesCmd {
         /**@private */
         static create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
             var cmd = Pool.getItemByClass("DrawTrianglesCmd", DrawTrianglesCmd);
             cmd.texture = texture;
             cmd.x = x;
             cmd.y = y;
             cmd.vertices = vertices;
             cmd.uvs = uvs;
             cmd.indices = indices;
             cmd.matrix = matrix;
             cmd.alpha = alpha;
             if (color) {
                 cmd.color = new ColorFilter();
                 var c = ColorUtils.create(color).arrColor;
                 cmd.color.color(c[0] * 255, c[1] * 255, c[2] * 255, c[3] * 255); //TODO 这个好像设置的是加色，这样并不合理
             }
             cmd.blendMode = blendMode;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.texture = null;
             this.vertices = null;
             this.uvs = null;
             this.indices = null;
             this.matrix = null;
             Pool.recover("DrawTrianglesCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.drawTriangles(this.texture, this.x + gx, this.y + gy, this.vertices, this.uvs, this.indices, this.matrix, this.alpha, this.color, this.blendMode);
         }
         /**@private */
         get cmdID() {
             return DrawTrianglesCmd.ID;
         }
     }
     DrawTrianglesCmd.ID = "DrawTriangles";

     /**
      * 绘制文本边框
      */
     class FillBorderTextCmd {
         /**@private */
         static create(text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
             var cmd = Pool.getItemByClass("FillBorderTextCmd", FillBorderTextCmd);
             cmd.text = text;
             cmd.x = x;
             cmd.y = y;
             cmd.font = font;
             cmd.fillColor = fillColor;
             cmd.borderColor = borderColor;
             cmd.lineWidth = lineWidth;
             cmd.textAlign = textAlign;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("FillBorderTextCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.fillBorderText(this.text, this.x + gx, this.y + gy, this.font, this.fillColor, this.borderColor, this.lineWidth, this.textAlign);
         }
         /**@private */
         get cmdID() {
             return FillBorderTextCmd.ID;
         }
     }
     FillBorderTextCmd.ID = "FillBorderText";

     /**
      * 绘制边框
      * @private
      */
     class FillBorderWordsCmd {
         /**@private */
         static create(words, x, y, font, fillColor, borderColor, lineWidth) {
             var cmd = Pool.getItemByClass("FillBorderWordsCmd", FillBorderWordsCmd);
             cmd.words = words;
             cmd.x = x;
             cmd.y = y;
             cmd.font = font;
             cmd.fillColor = fillColor;
             cmd.borderColor = borderColor;
             cmd.lineWidth = lineWidth;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.words = null;
             Pool.recover("FillBorderWordsCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.fillBorderWords(this.words, this.x + gx, this.y + gy, this.font, this.fillColor, this.borderColor, this.lineWidth);
         }
         /**@private */
         get cmdID() {
             return FillBorderWordsCmd.ID;
         }
     }
     FillBorderWordsCmd.ID = "FillBorderWords";

     /**
      * 绘制文字
      */
     class FillTextCmd {
         constructor() {
             /**@private */
             this._textIsWorldText = false;
             this._fontColor = 0xffffffff;
             this._strokeColor = 0;
             this._fontObj = FillTextCmd._defFontObj;
             this._nTexAlign = 0;
         }
         /**@private */
         static create(text, x, y, font, color, textAlign) {
             var cmd = Pool.getItemByClass("FillTextCmd", FillTextCmd);
             cmd.text = text;
             cmd._textIsWorldText = text instanceof WordText;
             cmd.x = x;
             cmd.y = y;
             cmd.font = font;
             cmd.color = color;
             cmd.textAlign = textAlign;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("FillTextCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             if (ILaya.stage.isGlobalRepaint()) {
                 this._textIsWorldText && this._text.cleanCache();
             }
             if (this._textIsWorldText) {
                 context._fast_filltext(this._text, this.x + gx, this.y + gy, this._fontObj, this._color, null, 0, this._nTexAlign, 0);
             }
             else {
                 context.drawText(this._text, this.x + gx, this.y + gy, this._font, this._color, this._textAlign);
             }
         }
         /**@private */
         get cmdID() {
             return FillTextCmd.ID;
         }
         /**
          * 在画布上输出的文本。
          */
         get text() {
             return this._text;
         }
         set text(value) {
             //TODO 问题。 怎么通知native
             this._text = value;
             this._textIsWorldText = value instanceof WordText;
             this._textIsWorldText && this._text.cleanCache();
         }
         /**
          * 定义字号和字体，比如"20px Arial"。
          */
         get font() {
             return this._font;
         }
         set font(value) {
             this._font = value;
             this._fontObj = FontInfo.Parse(value);
             this._textIsWorldText && this._text.cleanCache();
         }
         /**
          * 定义文本颜色，比如"#ff0000"。
          */
         get color() {
             return this._color;
         }
         set color(value) {
             this._color = value;
             this._fontColor = ColorUtils.create(value).numColor;
             this._textIsWorldText && this._text.cleanCache();
         }
         /**
          * 文本对齐方式，可选值："left"，"center"，"right"。
          */
         get textAlign() {
             return this._textAlign;
         }
         set textAlign(value) {
             this._textAlign = value;
             switch (value) {
                 case 'center':
                     this._nTexAlign = ILaya.Context.ENUM_TEXTALIGN_CENTER;
                     break;
                 case 'right':
                     this._nTexAlign = ILaya.Context.ENUM_TEXTALIGN_RIGHT;
                     break;
                 default:
                     this._nTexAlign = ILaya.Context.ENUM_TEXTALIGN_DEFAULT;
             }
             this._textIsWorldText && this._text.cleanCache();
         }
     }
     FillTextCmd.ID = "FillText";
     FillTextCmd._defFontObj = new FontInfo(null);

     /**
      * 填充文字命令
      * @private
      */
     class FillWordsCmd {
         /**@private */
         static create(words, x, y, font, color) {
             var cmd = Pool.getItemByClass("FillWordsCmd", FillWordsCmd);
             cmd.words = words;
             cmd.x = x;
             cmd.y = y;
             cmd.font = font;
             cmd.color = color;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             this.words = null;
             Pool.recover("FillWordsCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.fillWords(this.words, this.x + gx, this.y + gy, this.font, this.color);
         }
         /**@private */
         get cmdID() {
             return FillWordsCmd.ID;
         }
     }
     FillWordsCmd.ID = "FillWords";

     /**
      * 存储命令，和restore配套使用
      */
     class SaveCmd {
         /**@private */
         static create() {
             var cmd = Pool.getItemByClass("SaveCmd", SaveCmd);
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("SaveCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.save();
         }
         /**@private */
         get cmdID() {
             return SaveCmd.ID;
         }
     }
     SaveCmd.ID = "Save";

     /**
      * 绘制描边文字
      */
     class StrokeTextCmd {
         /**@private */
         static create(text, x, y, font, color, lineWidth, textAlign) {
             var cmd = Pool.getItemByClass("StrokeTextCmd", StrokeTextCmd);
             cmd.text = text;
             cmd.x = x;
             cmd.y = y;
             cmd.font = font;
             cmd.color = color;
             cmd.lineWidth = lineWidth;
             cmd.textAlign = textAlign;
             return cmd;
         }
         /**
          * 回收到对象池
          */
         recover() {
             Pool.recover("StrokeTextCmd", this);
         }
         /**@private */
         run(context, gx, gy) {
             context.strokeWord(this.text, this.x + gx, this.y + gy, this.font, this.color, this.lineWidth, this.textAlign);
         }
         /**@private */
         get cmdID() {
             return StrokeTextCmd.ID;
         }
     }
     StrokeTextCmd.ID = "StrokeText";

     /**
          * @private
          * 对象缓存统一管理类
          */
     class CacheManger {
         constructor() {
         }
         /**
          * 注册cache管理函数
          * @param disposeFunction 释放函数 fun(force:Boolean)
          * @param getCacheListFunction 获取cache列表函数fun():Array
          *
          */
         static regCacheByFunction(disposeFunction, getCacheListFunction) {
             CacheManger.unRegCacheByFunction(disposeFunction, getCacheListFunction);
             var cache;
             cache = { tryDispose: disposeFunction, getCacheList: getCacheListFunction };
             CacheManger._cacheList.push(cache);
         }
         /**
          * 移除cache管理函数
          * @param disposeFunction 释放函数 fun(force:Boolean)
          * @param getCacheListFunction 获取cache列表函数fun():Array
          *
          */
         static unRegCacheByFunction(disposeFunction, getCacheListFunction) {
             var i, len;
             len = CacheManger._cacheList.length;
             for (i = 0; i < len; i++) {
                 if (CacheManger._cacheList[i].tryDispose == disposeFunction && CacheManger._cacheList[i].getCacheList == getCacheListFunction) {
                     CacheManger._cacheList.splice(i, 1);
                     return;
                 }
             }
         }
         /**
          * 强制清理所有管理器
          *
          */
         //TODO:coverage
         static forceDispose() {
             var i, len = CacheManger._cacheList.length;
             for (i = 0; i < len; i++) {
                 CacheManger._cacheList[i].tryDispose(true);
             }
         }
         /**
          * 开始检测循环
          * @param waitTime 检测间隔时间
          *
          */
         static beginCheck(waitTime = 15000) {
             ILaya.systemTimer.loop(waitTime, null, CacheManger._checkLoop);
         }
         /**
          * 停止检测循环
          *
          */
         //TODO:coverage
         static stopCheck() {
             ILaya.systemTimer.clear(null, CacheManger._checkLoop);
         }
         /**
          * @private
          * 检测函数
          */
         static _checkLoop() {
             var cacheList = CacheManger._cacheList;
             if (cacheList.length < 1)
                 return;
             var tTime = ILaya.Browser.now();
             var count;
             var len;
             len = count = cacheList.length;
             while (count > 0) {
                 CacheManger._index++;
                 CacheManger._index = CacheManger._index % len;
                 cacheList[CacheManger._index].tryDispose(false);
                 if (ILaya.Browser.now() - tTime > CacheManger.loopTimeLimit)
                     break;
                 count--;
             }
         }
     }
     //TODO:
     /**
      * 单次清理检测允许执行的时间，单位ms。
      */
     CacheManger.loopTimeLimit = 2;
     /**
      * @private
      */
     CacheManger._cacheList = [];
     /**
      * @private
      * 当前检测的索引
      */
     CacheManger._index = 0;

     /**
      * @private
      * TODO:
      */
     class VectorGraphManager {
         constructor() {
             this.useDic = {};
             this.shapeDic = {};
             this.shapeLineDic = {};
             this._id = 0;
             this._checkKey = false;
             this._freeIdArray = [];
             CacheManger.regCacheByFunction(this.startDispose.bind(this), this.getCacheList.bind(this));
         }
         static getInstance() {
             return VectorGraphManager.instance = VectorGraphManager.instance || new VectorGraphManager();
         }
         /**
          * 得到个空闲的ID
          * @return
          */
         getId() {
             //if (_freeIdArray.length > 0) {
             //return _freeIdArray.pop();
             //}
             return this._id++;
         }
         /**
          * 添加一个图形到列表中
          * @param	id
          * @param	shape
          */
         addShape(id, shape) {
             this.shapeDic[id] = shape;
             if (!this.useDic[id]) {
                 this.useDic[id] = true;
             }
         }
         /**
          * 添加一个线图形到列表中
          * @param	id
          * @param	Line
          */
         addLine(id, Line) {
             this.shapeLineDic[id] = Line;
             if (!this.shapeLineDic[id]) {
                 this.shapeLineDic[id] = true;
             }
         }
         /**
          * 检测一个对象是否在使用中
          * @param	id
          */
         getShape(id) {
             if (this._checkKey) {
                 if (this.useDic[id] != null) {
                     this.useDic[id] = true;
                 }
             }
         }
         /**
          * 删除一个图形对象
          * @param	id
          */
         deleteShape(id) {
             if (this.shapeDic[id]) {
                 this.shapeDic[id] = null;
                 delete this.shapeDic[id];
             }
             if (this.shapeLineDic[id]) {
                 this.shapeLineDic[id] = null;
                 delete this.shapeLineDic[id];
             }
             if (this.useDic[id] != null) {
                 delete this.useDic[id];
             }
             //_freeIdArray.push(id);
         }
         /**
          * 得到缓存列表
          * @return
          */
         getCacheList() {
             var str;
             var list = [];
             for (str in this.shapeDic) {
                 list.push(this.shapeDic[str]);
             }
             for (str in this.shapeLineDic) {
                 list.push(this.shapeLineDic[str]);
             }
             return list;
         }
         /**
          * 开始清理状态，准备销毁
          */
         startDispose(key) {
             var str;
             for (str in this.useDic) {
                 this.useDic[str] = false;
             }
             this._checkKey = true;
         }
         /**
          * 确认销毁
          */
         endDispose() {
             if (this._checkKey) {
                 var str;
                 for (str in this.useDic) {
                     if (!this.useDic[str]) {
                         this.deleteShape(str);
                     }
                 }
                 this._checkKey = false;
             }
         }
     }

     /**
      * <code>Graphics</code> 类用于创建绘图显示对象。Graphics可以同时绘制多个位图或者矢量图，还可以结合save，restore，transform，scale，rotate，translate，alpha等指令对绘图效果进行变化。
      * Graphics以命令流方式存储，可以通过cmds属性访问所有命令流。Graphics是比Sprite更轻量级的对象，合理使用能提高应用性能(比如把大量的节点绘图改为一个节点的Graphics命令集合，能减少大量节点创建消耗)。
      * @see laya.display.Sprite#graphics
      */
     class Graphics {
         constructor() {
             /**@private */
             this._sp = null;
             /**@private */
             this._one = null;
             /**@private */
             this._render = this._renderEmpty;
             /**@private */
             this._cmds = null;
             /**@private */
             this._vectorgraphArray = null;
             /**@private */
             this._graphicBounds = null;
             /**@private */
             this.autoDestroy = false;
             this._createData();
         }
         /**@private */
         _createData() {
         }
         /**@private */
         _clearData() {
         }
         /**@private */
         _destroyData() {
         }
         /**
          * <p>销毁此对象。</p>
          */
         destroy() {
             this.clear(true);
             if (this._graphicBounds)
                 this._graphicBounds.destroy();
             this._graphicBounds = null;
             this._vectorgraphArray = null;
             if (this._sp) {
                 this._sp._renderType = 0;
                 this._sp._setRenderType(0);
                 this._sp = null;
             }
             this._destroyData();
         }
         /**
          * <p>清空绘制命令。</p>
          * @param recoverCmds 是否回收绘图指令数组，设置为true，则对指令数组进行回收以节省内存开销，建议设置为true进行回收，但如果手动引用了数组，不建议回收
          */
         clear(recoverCmds = true) {
             //TODO:内存回收all
             if (recoverCmds) {
                 var tCmd = this._one;
                 if (this._cmds) {
                     var i, len = this._cmds.length;
                     for (i = 0; i < len; i++) {
                         tCmd = this._cmds[i];
                         tCmd.recover();
                     }
                     this._cmds.length = 0;
                 }
                 else if (tCmd) {
                     tCmd.recover();
                 }
             }
             else {
                 this._cmds = null;
             }
             this._one = null;
             this._render = this._renderEmpty;
             this._clearData();
             //_sp && (_sp._renderType &= ~SpriteConst.IMAGE);
             if (this._sp) {
                 this._sp._renderType &= ~SpriteConst.GRAPHICS;
                 this._sp._setRenderType(this._sp._renderType);
             }
             this._repaint();
             if (this._vectorgraphArray) {
                 for (i = 0, len = this._vectorgraphArray.length; i < len; i++) {
                     VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
                 }
                 this._vectorgraphArray.length = 0;
             }
         }
         /**@private */
         _clearBoundsCache() {
             if (this._graphicBounds)
                 this._graphicBounds.reset();
         }
         /**@private */
         _initGraphicBounds() {
             if (!this._graphicBounds) {
                 this._graphicBounds = GraphicsBounds.create();
                 this._graphicBounds._graphics = this;
             }
         }
         /**
          * @private
          * 重绘此对象。
          */
         _repaint() {
             this._clearBoundsCache();
             this._sp && this._sp.repaint();
         }
         /**@private */
         //TODO:coverage
         _isOnlyOne() {
             return !this._cmds || this._cmds.length === 0;
         }
         /**
          * @private
          * 命令流。存储了所有绘制命令。
          */
         get cmds() {
             //TODO:单命令不对
             return this._cmds;
         }
         set cmds(value) {
             if (this._sp) {
                 this._sp._renderType |= SpriteConst.GRAPHICS;
                 this._sp._setRenderType(this._sp._renderType);
             }
             this._cmds = value;
             this._render = this._renderAll;
             this._repaint();
         }
         /**
          * 获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
          * @param realSize	（可选）使用图片的真实大小，默认为false
          * @return 位置与宽高组成的 一个 Rectangle 对象。
          */
         getBounds(realSize = false) {
             this._initGraphicBounds();
             return this._graphicBounds.getBounds(realSize);
         }
         /**
          * @private
          * @param realSize	（可选）使用图片的真实大小，默认为false
          * 获取端点列表。
          */
         getBoundPoints(realSize = false) {
             this._initGraphicBounds();
             return this._graphicBounds.getBoundPoints(realSize);
         }
         /**
          * 绘制单独图片
          * @param texture		纹理。
          * @param x 		（可选）X轴偏移量。
          * @param y 		（可选）Y轴偏移量。
          * @param width		（可选）宽度。
          * @param height	（可选）高度。
          */
         drawImage(texture, x = 0, y = 0, width = 0, height = 0) {
             if (!texture)
                 return null;
             if (!width)
                 width = texture.sourceWidth;
             if (!height)
                 height = texture.sourceHeight;
             if (texture.getIsReady()) {
                 var wRate = width / texture.sourceWidth;
                 var hRate = height / texture.sourceHeight;
                 width = texture.width * wRate;
                 height = texture.height * hRate;
                 if (width <= 0 || height <= 0)
                     return null;
                 x += texture.offsetX * wRate;
                 y += texture.offsetY * hRate;
             }
             if (this._sp) {
                 this._sp._renderType |= SpriteConst.GRAPHICS;
                 this._sp._setRenderType(this._sp._renderType);
             }
             var args = DrawImageCmd.create.call(this, texture, x, y, width, height);
             if (this._one == null) {
                 this._one = args;
                 this._render = this._renderOneImg;
                 //if(_sp)_sp._renderType |= SpriteConst.IMAGE;
             }
             else {
                 this._saveToCmd(null, args);
             }
             //if (!tex.loaded) {
             //tex.once(Event.LOADED, this, _textureLoaded, [tex, args]);
             //}
             this._repaint();
             return args;
         }
         /**
          * 绘制纹理，相比drawImage功能更强大，性能会差一些
          * @param texture		纹理。
          * @param x 		（可选）X轴偏移量。
          * @param y 		（可选）Y轴偏移量。
          * @param width		（可选）宽度。
          * @param height	（可选）高度。
          * @param matrix	（可选）矩阵信息。
          * @param alpha		（可选）透明度。
          * @param color		（可选）颜色滤镜。
          * @param blendMode （可选）混合模式。
          */
         drawTexture(texture, x = 0, y = 0, width = 0, height = 0, matrix = null, alpha = 1, color = null, blendMode = null) {
             if (!texture || alpha < 0.01)
                 return null;
             if (!texture.getIsReady())
                 return null;
             if (!width)
                 width = texture.sourceWidth;
             if (!height)
                 height = texture.sourceHeight;
             if (texture.getIsReady()) {
                 var wRate = width / texture.sourceWidth;
                 var hRate = height / texture.sourceHeight;
                 width = texture.width * wRate;
                 height = texture.height * hRate;
                 if (width <= 0 || height <= 0)
                     return null;
                 x += texture.offsetX * wRate;
                 y += texture.offsetY * hRate;
             }
             if (this._sp) {
                 this._sp._renderType |= SpriteConst.GRAPHICS;
                 this._sp._setRenderType(this._sp._renderType);
             }
             // canvas 模式不支持
             var args = DrawTextureCmd.create.call(this, texture, x, y, width, height, matrix, alpha, color, blendMode);
             this._repaint();
             return this._saveToCmd(null, args);
         }
         /**
          * 批量绘制同样纹理。
          * @param texture 纹理。
          * @param pos 绘制次数和坐标。
          */
         drawTextures(texture, pos) {
             if (!texture)
                 return null;
             return this._saveToCmd(Render._context.drawTextures, DrawTexturesCmd.create.call(this, texture, pos));
         }
         /**
          * 绘制一组三角形
          * @param texture	纹理。
          * @param x			X轴偏移量。
          * @param y			Y轴偏移量。
          * @param vertices  顶点数组。
          * @param indices	顶点索引。
          * @param uvData	UV数据。
          * @param matrix	缩放矩阵。
          * @param alpha		alpha
          * @param color		颜色变换
          * @param blendMode	blend模式
          */
         drawTriangles(texture, x, y, vertices, uvs, indices, matrix = null, alpha = 1, color = null, blendMode = null) {
             return this._saveToCmd(Render._context.drawTriangles, DrawTrianglesCmd.create.call(this, texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode));
         }
         /**
          * 用texture填充。
          * @param texture		纹理。
          * @param x			X轴偏移量。
          * @param y			Y轴偏移量。
          * @param width		（可选）宽度。
          * @param height	（可选）高度。
          * @param type		（可选）填充类型 repeat|repeat-x|repeat-y|no-repeat
          * @param offset	（可选）贴图纹理偏移
          *
          */
         fillTexture(texture, x, y, width = 0, height = 0, type = "repeat", offset = null) {
             if (texture && texture.getIsReady())
                 return this._saveToCmd(Render._context._fillTexture, FillTextureCmd.create.call(this, texture, x, y, width, height, type, offset || Point.EMPTY, {}));
             else
                 return null;
         }
         /**
          * @private
          * 保存到命令流。
          */
         _saveToCmd(fun, args) {
             if (this._sp) {
                 this._sp._renderType |= SpriteConst.GRAPHICS;
                 this._sp._setRenderType(this._sp._renderType);
             }
             if (this._one == null) {
                 this._one = args;
                 this._render = this._renderOne;
             }
             else {
                 //_sp && (_sp._renderType &= ~SpriteConst.IMAGE);
                 this._render = this._renderAll;
                 (this._cmds || (this._cmds = [])).length === 0 && this._cmds.push(this._one);
                 this._cmds.push(args);
             }
             this._repaint();
             return args;
         }
         /**
          * 设置剪裁区域，超出剪裁区域的坐标不显示。
          * @param x X 轴偏移量。
          * @param y Y 轴偏移量。
          * @param width 宽度。
          * @param height 高度。
          */
         clipRect(x, y, width, height) {
             return this._saveToCmd(Render._context.clipRect, ClipRectCmd.create.call(this, x, y, width, height));
         }
         /**
          * 在画布上绘制文本。
          * @param text 在画布上输出的文本。
          * @param x 开始绘制文本的 x 坐标位置（相对于画布）。
          * @param y 开始绘制文本的 y 坐标位置（相对于画布）。
          * @param font 定义字号和字体，比如"20px Arial"。
          * @param color 定义文本颜色，比如"#ff0000"。
          * @param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
          */
         fillText(text, x, y, font, color, textAlign) {
             return this._saveToCmd(Render._context.fillText, FillTextCmd.create.call(this, text, x, y, font || ILaya.Text.defaultFontStr(), color, textAlign));
         }
         /**
          * 在画布上绘制“被填充且镶边的”文本。
          * @param text			在画布上输出的文本。
          * @param x				开始绘制文本的 x 坐标位置（相对于画布）。
          * @param y				开始绘制文本的 y 坐标位置（相对于画布）。
          * @param font			定义字体和字号，比如"20px Arial"。
          * @param fillColor		定义文本颜色，比如"#ff0000"。
          * @param borderColor	定义镶边文本颜色。
          * @param lineWidth		镶边线条宽度。
          * @param textAlign		文本对齐方式，可选值："left"，"center"，"right"。
          */
         fillBorderText(text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
             return this._saveToCmd(Render._context.fillBorderText, FillBorderTextCmd.create.call(this, text, x, y, font || ILaya.Text.defaultFontStr(), fillColor, borderColor, lineWidth, textAlign));
         }
         /*** @private */
         fillWords(words, x, y, font, color) {
             return this._saveToCmd(Render._context.fillWords, FillWordsCmd.create.call(this, words, x, y, font || ILaya.Text.defaultFontStr(), color));
         }
         /*** @private */
         fillBorderWords(words, x, y, font, fillColor, borderColor, lineWidth) {
             return this._saveToCmd(Render._context.fillBorderWords, FillBorderWordsCmd.create.call(this, words, x, y, font || ILaya.Text.defaultFontStr(), fillColor, borderColor, lineWidth));
         }
         /**
          * 在画布上绘制文本（没有填色）。文本的默认颜色是黑色。
          * @param text		在画布上输出的文本。
          * @param x			开始绘制文本的 x 坐标位置（相对于画布）。
          * @param y			开始绘制文本的 y 坐标位置（相对于画布）。
          * @param font		定义字体和字号，比如"20px Arial"。
          * @param color		定义文本颜色，比如"#ff0000"。
          * @param lineWidth	线条宽度。
          * @param textAlign	文本对齐方式，可选值："left"，"center"，"right"。
          */
         strokeText(text, x, y, font, color, lineWidth, textAlign) {
             return this._saveToCmd(Render._context.fillBorderText, StrokeTextCmd.create.call(this, text, x, y, font || ILaya.Text.defaultFontStr(), null, color, lineWidth, textAlign));
         }
         /**
          * 设置透明度。
          * @param value 透明度。
          */
         alpha(alpha) {
             return this._saveToCmd(Render._context.alpha, AlphaCmd.create.call(this, alpha));
         }
         /**
          * 替换绘图的当前转换矩阵。
          * @param mat 矩阵。
          * @param pivotX	（可选）水平方向轴心点坐标。
          * @param pivotY	（可选）垂直方向轴心点坐标。
          */
         transform(matrix, pivotX = 0, pivotY = 0) {
             return this._saveToCmd(Render._context._transform, TransformCmd.create.call(this, matrix, pivotX, pivotY));
         }
         /**
          * 旋转当前绘图。(推荐使用transform，性能更高)
          * @param angle		旋转角度，以弧度计。
          * @param pivotX	（可选）水平方向轴心点坐标。
          * @param pivotY	（可选）垂直方向轴心点坐标。
          */
         rotate(angle, pivotX = 0, pivotY = 0) {
             return this._saveToCmd(Render._context._rotate, RotateCmd.create.call(this, angle, pivotX, pivotY));
         }
         /**
          * 缩放当前绘图至更大或更小。(推荐使用transform，性能更高)
          * @param scaleX	水平方向缩放值。
          * @param scaleY	垂直方向缩放值。
          * @param pivotX	（可选）水平方向轴心点坐标。
          * @param pivotY	（可选）垂直方向轴心点坐标。
          */
         scale(scaleX, scaleY, pivotX = 0, pivotY = 0) {
             return this._saveToCmd(Render._context._scale, ScaleCmd.create.call(this, scaleX, scaleY, pivotX, pivotY));
         }
         /**
          * 重新映射画布上的 (0,0) 位置。
          * @param x 添加到水平坐标（x）上的值。
          * @param y 添加到垂直坐标（y）上的值。
          */
         translate(tx, ty) {
             return this._saveToCmd(Render._context.translate, TranslateCmd.create.call(this, tx, ty));
         }
         /**
          * 保存当前环境的状态。
          */
         save() {
             return this._saveToCmd(Render._context._save, SaveCmd.create.call(this));
         }
         /**
          * 返回之前保存过的路径状态和属性。
          */
         restore() {
             return this._saveToCmd(Render._context.restore, RestoreCmd.create.call(this));
         }
         /**
          * @private
          * 替换文本内容。
          * @param text 文本内容。
          * @return 替换成功则值为true，否则值为flase。
          */
         replaceText(text) {
             this._repaint();
             //todo 该函数现在加速器应该不对
             var cmds = this._cmds;
             if (!cmds) {
                 if (this._one && this._isTextCmd(this._one)) {
                     this._one.text = text;
                     return true;
                 }
             }
             else {
                 for (var i = cmds.length - 1; i > -1; i--) {
                     if (this._isTextCmd(cmds[i])) {
                         cmds[i].text = text;
                         return true;
                     }
                 }
             }
             return false;
         }
         /**@private */
         _isTextCmd(cmd) {
             var cmdID = cmd.cmdID;
             return cmdID == FillTextCmd.ID || cmdID == StrokeTextCmd.ID || cmdID == FillBorderTextCmd.ID;
         }
         /**
          * @private
          * 替换文本颜色。
          * @param color 颜色。
          */
         replaceTextColor(color) {
             this._repaint();
             var cmds = this._cmds;
             if (!cmds) {
                 if (this._one && this._isTextCmd(this._one)) {
                     this._setTextCmdColor(this._one, color);
                 }
             }
             else {
                 for (var i = cmds.length - 1; i > -1; i--) {
                     if (this._isTextCmd(cmds[i])) {
                         this._setTextCmdColor(cmds[i], color);
                     }
                 }
             }
         }
         /**@private */
         _setTextCmdColor(cmdO, color) {
             var cmdID = cmdO.cmdID;
             switch (cmdID) {
                 case FillTextCmd.ID:
                 case StrokeTextCmd.ID:
                     cmdO.color = color;
                     break;
                 case FillBorderTextCmd.ID:
                 case FillBorderWordsCmd.ID:
                 case FillBorderTextCmd.ID:
                     cmdO.fillColor = color;
                     break;
             }
         }
         /**
          * 加载并显示一个图片。
          * @param url		图片地址。
          * @param x			（可选）显示图片的x位置。
          * @param y			（可选）显示图片的y位置。
          * @param width		（可选）显示图片的宽度，设置为0表示使用图片默认宽度。
          * @param height	（可选）显示图片的高度，设置为0表示使用图片默认高度。
          * @param complete	（可选）加载完成回调。
          */
         loadImage(url, x = 0, y = 0, width = 0, height = 0, complete = null) {
             var tex = ILaya.Loader.getRes(url);
             if (!tex) {
                 tex = new Texture();
                 tex.load(url);
                 ILaya.Loader.cacheRes(url, tex);
                 tex.once(Event.READY, this, this.drawImage, [tex, x, y, width, height]);
             }
             else {
                 if (!tex.getIsReady()) {
                     tex.once(Event.READY, this, this.drawImage, [tex, x, y, width, height]);
                 }
                 else
                     this.drawImage(tex, x, y, width, height);
             }
             if (complete != null) {
                 tex.getIsReady() ? complete.call(this._sp) : tex.on(Event.READY, this._sp, complete);
             }
         }
         /**
          * @private
          */
         _renderEmpty(sprite, context, x, y) {
         }
         /**
          * @private
          */
         _renderAll(sprite, context, x, y) {
             var cmds = this._cmds;
             for (var i = 0, n = cmds.length; i < n; i++) {
                 cmds[i].run(context, x, y);
             }
         }
         /**
          * @private
          */
         _renderOne(sprite, context, x, y) {
             context.sprite = sprite;
             this._one.run(context, x, y);
         }
         /**
          * @private
          */
         _renderOneImg(sprite, context, x, y) {
             context.sprite = sprite;
             this._one.run(context, x, y);
         }
         /**
          * 绘制一条线。
          * @param fromX		X轴开始位置。
          * @param fromY		Y轴开始位置。
          * @param toX		X轴结束位置。
          * @param toY		Y轴结束位置。
          * @param lineColor	颜色。
          * @param lineWidth	（可选）线条宽度。
          */
         drawLine(fromX, fromY, toX, toY, lineColor, lineWidth = 1) {
             var offset = (lineWidth < 1 || lineWidth % 2 === 0) ? 0 : 0.5;
             return this._saveToCmd(Render._context._drawLine, DrawLineCmd.create.call(this, fromX + offset, fromY + offset, toX + offset, toY + offset, lineColor, lineWidth, 0));
         }
         /**
          * 绘制一系列线段。
          * @param x			开始绘制的X轴位置。
          * @param y			开始绘制的Y轴位置。
          * @param points	线段的点集合。格式:[x1,y1,x2,y2,x3,y3...]。
          * @param lineColor	线段颜色，或者填充绘图的渐变对象。
          * @param lineWidth	（可选）线段宽度。
          */
         drawLines(x, y, points, lineColor, lineWidth = 1) {
             if (!points || points.length < 4)
                 return null;
             var offset = (lineWidth < 1 || lineWidth % 2 === 0) ? 0 : 0.5;
             //TODO 线段需要缓存
             return this._saveToCmd(Render._context._drawLines, DrawLinesCmd.create.call(this, x + offset, y + offset, points, lineColor, lineWidth, 0));
         }
         /**
          * 绘制一系列曲线。
          * @param x			开始绘制的 X 轴位置。
          * @param y			开始绘制的 Y 轴位置。
          * @param points	线段的点集合，格式[controlX, controlY, anchorX, anchorY...]。
          * @param lineColor	线段颜色，或者填充绘图的渐变对象。
          * @param lineWidth	（可选）线段宽度。
          */
         drawCurves(x, y, points, lineColor, lineWidth = 1) {
             return this._saveToCmd(Render._context.drawCurves, DrawCurvesCmd.create.call(this, x, y, points, lineColor, lineWidth));
         }
         /**
          * 绘制矩形。
          * @param x			开始绘制的 X 轴位置。
          * @param y			开始绘制的 Y 轴位置。
          * @param width		矩形宽度。
          * @param height	矩形高度。
          * @param fillColor	填充颜色，或者填充绘图的渐变对象。
          * @param lineColor	（可选）边框颜色，或者填充绘图的渐变对象。
          * @param lineWidth	（可选）边框宽度。
          */
         drawRect(x, y, width, height, fillColor, lineColor = null, lineWidth = 1) {
             var offset = (lineWidth >= 1 && lineColor) ? lineWidth / 2 : 0;
             var lineOffset = lineColor ? lineWidth : 0;
             return this._saveToCmd(Render._context.drawRect, DrawRectCmd.create.call(this, x + offset, y + offset, width - lineOffset, height - lineOffset, fillColor, lineColor, lineWidth));
         }
         /**
          * 绘制圆形。
          * @param x			圆点X 轴位置。
          * @param y			圆点Y 轴位置。
          * @param radius	半径。
          * @param fillColor	填充颜色，或者填充绘图的渐变对象。
          * @param lineColor	（可选）边框颜色，或者填充绘图的渐变对象。
          * @param lineWidth	（可选）边框宽度。
          */
         drawCircle(x, y, radius, fillColor, lineColor = null, lineWidth = 1) {
             var offset = (lineWidth >= 1 && lineColor) ? lineWidth / 2 : 0;
             return this._saveToCmd(Render._context._drawCircle, DrawCircleCmd.create.call(this, x, y, radius - offset, fillColor, lineColor, lineWidth, 0));
         }
         /**
          * 绘制扇形。
          * @param x				开始绘制的 X 轴位置。
          * @param y				开始绘制的 Y 轴位置。
          * @param radius		扇形半径。
          * @param startAngle	开始角度。
          * @param endAngle		结束角度。
          * @param fillColor		填充颜色，或者填充绘图的渐变对象。
          * @param lineColor		（可选）边框颜色，或者填充绘图的渐变对象。
          * @param lineWidth		（可选）边框宽度。
          */
         drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor = null, lineWidth = 1) {
             var offset = (lineWidth >= 1 && lineColor) ? lineWidth / 2 : 0;
             var lineOffset = lineColor ? lineWidth : 0;
             return this._saveToCmd(Render._context._drawPie, DrawPieCmd.create.call(this, x + offset, y + offset, radius - lineOffset, Utils.toRadian(startAngle), Utils.toRadian(endAngle), fillColor, lineColor, lineWidth, 0));
         }
         /**
          * 绘制多边形。
          * @param x			开始绘制的 X 轴位置。
          * @param y			开始绘制的 Y 轴位置。
          * @param points	多边形的点集合。
          * @param fillColor	填充颜色，或者填充绘图的渐变对象。
          * @param lineColor	（可选）边框颜色，或者填充绘图的渐变对象。
          * @param lineWidth	（可选）边框宽度。
          */
         drawPoly(x, y, points, fillColor, lineColor = null, lineWidth = 1) {
             var tIsConvexPolygon = false;
             //这里加入多加形是否是凸边形
             if (points.length > 6) {
                 tIsConvexPolygon = false;
             }
             else {
                 tIsConvexPolygon = true;
             }
             var offset = (lineWidth >= 1 && lineColor) ? (lineWidth % 2 === 0 ? 0 : 0.5) : 0;
             //TODO 非凸多边形需要缓存
             return this._saveToCmd(Render._context._drawPoly, DrawPolyCmd.create.call(this, x + offset, y + offset, points, fillColor, lineColor, lineWidth, tIsConvexPolygon, 0));
         }
         /**
          * 绘制路径。
          * @param x		开始绘制的 X 轴位置。
          * @param y		开始绘制的 Y 轴位置。
          * @param paths	路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]。
          * @param brush	（可选）刷子定义，支持以下设置{fillStyle:"#FF0000"}。
          * @param pen	（可选）画笔定义，支持以下设置{strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}。
          */
         drawPath(x, y, paths, brush = null, pen = null) {
             return this._saveToCmd(Render._context._drawPath, DrawPathCmd.create.call(this, x, y, paths, brush, pen));
         }
         /**
          * @private
          * 绘制带九宫格的图片
          * @param	texture
          * @param	x
          * @param	y
          * @param	width
          * @param	height
          * @param	sizeGrid
          */
         draw9Grid(texture, x = 0, y = 0, width = 0, height = 0, sizeGrid = null) {
             this._saveToCmd(null, Draw9GridTexture.create(texture, x, y, width, height, sizeGrid));
         }
     }

     /**
          * @private
          * 静态常量集合
          */
     class Const {
     }
     Const.NOT_ACTIVE = 0x01;
     Const.ACTIVE_INHIERARCHY = 0x02;
     Const.AWAKED = 0x04;
     Const.NOT_READY = 0x08;
     Const.DISPLAY = 0x10;
     Const.HAS_ZORDER = 0x20;
     Const.HAS_MOUSE = 0x40;
     Const.DISPLAYED_INSTAGE = 0x80;
     Const.DRAWCALL_OPTIMIZE = 0x100;

     /**
      * 添加到父对象后调度。
      * @eventType Event.ADDED
      */
     /*[Event(name = "added", type = "laya.events.Event")]*/
     /**
      * 被父对象移除后调度。
      * @eventType Event.REMOVED
      */
     /*[Event(name = "removed", type = "laya.events.Event")]*/
     /**
      * 加入节点树时调度。
      * @eventType Event.DISPLAY
      */
     /*[Event(name = "display", type = "laya.events.Event")]*/
     /**
      * 从节点树移除时调度。
      * @eventType Event.UNDISPLAY
      */
     /*[Event(name = "undisplay", type = "laya.events.Event")]*/
     /**
      *  <code>Node</code> 类是可放在显示列表中的所有对象的基类。该显示列表管理 Laya 运行时中显示的所有对象。使用 Node 类排列显示列表中的显示对象。Node 对象可以有子显示对象。
      */
     class Node extends EventDispatcher {
         constructor() {
             super();
             /**@private */
             this._bits = 0;
             /**@private 子对象集合，请不要直接修改此对象。*/
             this._children = Node.ARRAY_EMPTY;
             /**@private 仅仅用来处理输入事件的,并不是真正意义上的子对象 */
             this._extUIChild = Node.ARRAY_EMPTY;
             /**@private 父节点对象*/
             this._parent = null;
             /**节点名称。*/
             this.name = "";
             /**[只读]是否已经销毁。对象销毁后不能再使用。*/
             this.destroyed = false;
             this.createGLBuffer();
         }
         /**@private */
         createGLBuffer() {
         }
         /**@private */
         _setBit(type, value) {
             if (type === Const.DISPLAY) {
                 var preValue = this._getBit(type);
                 if (preValue != value)
                     this._updateDisplayedInstage();
             }
             if (value)
                 this._bits |= type;
             else
                 this._bits &= ~type;
         }
         /**@private */
         _getBit(type) {
             return (this._bits & type) != 0;
         }
         /**@private */
         _setUpNoticeChain() {
             if (this._getBit(Const.DISPLAY))
                 this._setBitUp(Const.DISPLAY);
         }
         /**@private */
         _setBitUp(type) {
             var ele = this;
             ele._setBit(type, true);
             ele = ele._parent;
             while (ele) {
                 if (ele._getBit(type))
                     return;
                 ele._setBit(type, true);
                 ele = ele._parent;
             }
         }
         /**
          * <p>增加事件侦听器，以使侦听器能够接收事件通知。</p>
          * <p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
          * @param	type		事件的类型。
          * @param	caller		事件侦听函数的执行域。
          * @param	listener	事件侦听函数。
          * @param	args		（可选）事件侦听函数的回调参数。
          * @return 此 EventDispatcher 对象。
          */
         /*override*/ on(type, caller, listener, args = null) {
             if (type === Event.DISPLAY || type === Event.UNDISPLAY) {
                 if (!this._getBit(Const.DISPLAY))
                     this._setBitUp(Const.DISPLAY);
             }
             return this._createListener(type, caller, listener, args, false);
         }
         /**
          * <p>增加事件侦听器，以使侦听器能够接收事件通知，此侦听事件响应一次后则自动移除侦听。</p>
          * <p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
          * @param	type		事件的类型。
          * @param	caller		事件侦听函数的执行域。
          * @param	listener	事件侦听函数。
          * @param	args		（可选）事件侦听函数的回调参数。
          * @return 此 EventDispatcher 对象。
          */
         /*override*/ once(type, caller, listener, args = null) {
             if (type === Event.DISPLAY || type === Event.UNDISPLAY) {
                 if (!this._getBit(Const.DISPLAY))
                     this._setBitUp(Const.DISPLAY);
             }
             return this._createListener(type, caller, listener, args, true);
         }
         /**
          * <p>销毁此对象。destroy对象默认会把自己从父节点移除，并且清理自身引用关系，等待js自动垃圾回收机制回收。destroy后不能再使用。</p>
          * <p>destroy时会移除自身的事情监听，自身的timer监听，移除子对象及从父节点移除自己。</p>
          * @param destroyChild	（可选）是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
          */
         destroy(destroyChild = true) {
             this.destroyed = true;
             this._destroyAllComponent();
             this._parent && this._parent.removeChild(this);
             //销毁子节点
             if (this._children) {
                 if (destroyChild)
                     this.destroyChildren();
                 else
                     this.removeChildren();
             }
             this.onDestroy();
             this._children = null;
             //移除所有事件监听
             this.offAll();
             //移除所有timer
             //this.timer.clearAll(this);			
         }
         /**
          * 销毁时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onDestroy() {
             //trace("onDestroy node", this.name);
         }
         /**
          * 销毁所有子对象，不销毁自己本身。
          */
         destroyChildren() {
             //销毁子节点
             if (this._children) {
                 //为了保持销毁顺序，所以需要正序销毁
                 for (var i = 0, n = this._children.length; i < n; i++) {
                     this._children[0].destroy(true);
                 }
             }
         }
         /**
          * 添加子节点。
          * @param	node 节点对象
          * @return	返回添加的节点
          */
         addChild(node) {
             if (!node || this.destroyed || node === this)
                 return node;
             if (node._zOrder)
                 this._setBit(Const.HAS_ZORDER, true);
             if (node._parent === this) {
                 var index = this.getChildIndex(node);
                 if (index !== this._children.length - 1) {
                     this._children.splice(index, 1);
                     this._children.push(node);
                     this._childChanged();
                 }
             }
             else {
                 node._parent && node._parent.removeChild(node);
                 this._children === Node.ARRAY_EMPTY && (this._children = []);
                 this._children.push(node);
                 node._setParent(this);
                 this._childChanged();
             }
             return node;
         }
         addInputChild(node) {
             if (this._extUIChild == Node.ARRAY_EMPTY) {
                 this._extUIChild = [node];
             }
             else {
                 if (this._extUIChild.indexOf(node) >= 0) {
                     return null;
                 }
                 this._extUIChild.push(node);
             }
             return null;
         }
         removeInputChild(node) {
             var idx = this._extUIChild.indexOf(node);
             if (idx >= 0) {
                 this._extUIChild.splice(idx, 1);
             }
         }
         /**
          * 批量增加子节点
          * @param	...args 无数子节点。
          */
         addChildren(...args) {
             var i = 0, n = args.length;
             while (i < n) {
                 this.addChild(args[i++]);
             }
         }
         /**
          * 添加子节点到指定的索引位置。
          * @param	node 节点对象。
          * @param	index 索引位置。
          * @return	返回添加的节点。
          */
         addChildAt(node, index) {
             if (!node || this.destroyed || node === this)
                 return node;
             if (node._zOrder)
                 this._setBit(Const.HAS_ZORDER, true);
             if (index >= 0 && index <= this._children.length) {
                 if (node._parent === this) {
                     var oldIndex = this.getChildIndex(node);
                     this._children.splice(oldIndex, 1);
                     this._children.splice(index, 0, node);
                     this._childChanged();
                 }
                 else {
                     node._parent && node._parent.removeChild(node);
                     this._children === Node.ARRAY_EMPTY && (this._children = []);
                     this._children.splice(index, 0, node);
                     node._setParent(this);
                 }
                 return node;
             }
             else {
                 throw new Error("appendChildAt:The index is out of bounds");
             }
         }
         /**
          * 根据子节点对象，获取子节点的索引位置。
          * @param	node 子节点。
          * @return	子节点所在的索引位置。
          */
         getChildIndex(node) {
             return this._children.indexOf(node);
         }
         /**
          * 根据子节点的名字，获取子节点对象。
          * @param	name 子节点的名字。
          * @return	节点对象。
          */
         getChildByName(name) {
             var nodes = this._children;
             if (nodes) {
                 for (var i = 0, n = nodes.length; i < n; i++) {
                     var node = nodes[i];
                     if (node.name === name)
                         return node;
                 }
             }
             return null;
         }
         /**
          * 根据子节点的索引位置，获取子节点对象。
          * @param	index 索引位置
          * @return	子节点
          */
         getChildAt(index) {
             return this._children[index] || null;
         }
         /**
          * 设置子节点的索引位置。
          * @param	node 子节点。
          * @param	index 新的索引。
          * @return	返回子节点本身。
          */
         setChildIndex(node, index) {
             var childs = this._children;
             if (index < 0 || index >= childs.length) {
                 throw new Error("setChildIndex:The index is out of bounds.");
             }
             var oldIndex = this.getChildIndex(node);
             if (oldIndex < 0)
                 throw new Error("setChildIndex:node is must child of this object.");
             childs.splice(oldIndex, 1);
             childs.splice(index, 0, node);
             this._childChanged();
             return node;
         }
         /**
          * 子节点发生改变。
          * @private
          * @param	child 子节点。
          */
         _childChanged(child = null) {
         }
         /**
          * 删除子节点。
          * @param	node 子节点
          * @return	被删除的节点
          */
         removeChild(node) {
             if (!this._children)
                 return node;
             var index = this._children.indexOf(node);
             return this.removeChildAt(index);
         }
         /**
          * 从父容器删除自己，如已经被删除不会抛出异常。
          * @return 当前节点（ Node ）对象。
          */
         removeSelf() {
             this._parent && this._parent.removeChild(this);
             return this;
         }
         /**
          * 根据子节点名字删除对应的子节点对象，如果找不到不会抛出异常。
          * @param	name 对象名字。
          * @return 查找到的节点（ Node ）对象。
          */
         removeChildByName(name) {
             var node = this.getChildByName(name);
             node && this.removeChild(node);
             return node;
         }
         /**
          * 根据子节点索引位置，删除对应的子节点对象。
          * @param	index 节点索引位置。
          * @return	被删除的节点。
          */
         removeChildAt(index) {
             var node = this.getChildAt(index);
             if (node) {
                 this._children.splice(index, 1);
                 node._setParent(null);
             }
             return node;
         }
         /**
          * 删除指定索引区间的所有子对象。
          * @param	beginIndex 开始索引。
          * @param	endIndex 结束索引。
          * @return 当前节点对象。
          */
         removeChildren(beginIndex = 0, endIndex = 0x7fffffff) {
             if (this._children && this._children.length > 0) {
                 var childs = this._children;
                 if (beginIndex === 0 && endIndex >= childs.length - 1) {
                     var arr = childs;
                     this._children = Node.ARRAY_EMPTY;
                 }
                 else {
                     arr = childs.splice(beginIndex, endIndex - beginIndex);
                 }
                 for (var i = 0, n = arr.length; i < n; i++) {
                     arr[i]._setParent(null);
                 }
             }
             return this;
         }
         /**
          * 替换子节点。
          * @internal 将传入的新节点对象替换到已有子节点索引位置处。
          * @param	newNode 新节点。
          * @param	oldNode 老节点。
          * @return	返回新节点。
          */
         replaceChild(newNode, oldNode) {
             var index = this._children.indexOf(oldNode);
             if (index > -1) {
                 this._children.splice(index, 1, newNode);
                 oldNode._setParent(null);
                 newNode._setParent(this);
                 return newNode;
             }
             return null;
         }
         /**
          * 子对象数量。
          */
         get numChildren() {
             return this._children.length;
         }
         /**父节点。*/
         get parent() {
             return this._parent;
         }
         /**@private */
         _setParent(value) {
             if (this._parent !== value) {
                 if (value) {
                     this._parent = value;
                     //如果父对象可见，则设置子对象可见
                     this._onAdded();
                     this.event(Event.ADDED);
                     if (this._getBit(Const.DISPLAY)) {
                         this._setUpNoticeChain();
                         value.displayedInStage && this._displayChild(this, true);
                     }
                     value._childChanged(this);
                 }
                 else {
                     //设置子对象不可见
                     this._onRemoved();
                     this.event(Event.REMOVED);
                     this._parent._childChanged();
                     if (this._getBit(Const.DISPLAY))
                         this._displayChild(this, false);
                     this._parent = value;
                 }
             }
         }
         /**表示是否在显示列表中显示。*/
         get displayedInStage() {
             if (this._getBit(Const.DISPLAY))
                 return this._getBit(Const.DISPLAYED_INSTAGE);
             this._setBitUp(Const.DISPLAY);
             return this._getBit(Const.DISPLAYED_INSTAGE);
         }
         /**@private */
         _updateDisplayedInstage() {
             var ele;
             ele = this;
             var stage = ILaya.stage;
             var displayedInStage = false;
             while (ele) {
                 if (ele._getBit(Const.DISPLAY)) {
                     displayedInStage = ele._getBit(Const.DISPLAYED_INSTAGE);
                     break;
                 }
                 if (ele === stage || ele._getBit(Const.DISPLAYED_INSTAGE)) {
                     displayedInStage = true;
                     break;
                 }
                 ele = ele._parent;
             }
             this._setBit(Const.DISPLAYED_INSTAGE, displayedInStage);
         }
         /**@private */
         _setDisplay(value) {
             if (this._getBit(Const.DISPLAYED_INSTAGE) !== value) {
                 this._setBit(Const.DISPLAYED_INSTAGE, value);
                 if (value)
                     this.event(Event.DISPLAY);
                 else
                     this.event(Event.UNDISPLAY);
             }
         }
         /**
          * 设置指定节点对象是否可见(是否在渲染列表中)。
          * @private
          * @param	node 节点。
          * @param	display 是否可见。
          */
         _displayChild(node, display) {
             var childs = node._children;
             if (childs) {
                 for (var i = 0, n = childs.length; i < n; i++) {
                     var child = childs[i];
                     if (!child._getBit(Const.DISPLAY))
                         continue;
                     if (child._children.length > 0) {
                         this._displayChild(child, display);
                     }
                     else {
                         child._setDisplay(display);
                     }
                 }
             }
             node._setDisplay(display);
         }
         /**
          * 当前容器是否包含指定的 <code>Node</code> 节点对象 。
          * @param	node  指定的 <code>Node</code> 节点对象 。
          * @return	一个布尔值表示是否包含指定的 <code>Node</code> 节点对象 。
          */
         contains(node) {
             if (node === this)
                 return true;
             while (node) {
                 if (node._parent === this)
                     return true;
                 node = node._parent;
             }
             return false;
         }
         /**
          * 定时重复执行某函数。功能同Laya.timer.timerLoop()。
          * @param	delay		间隔时间(单位毫秒)。
          * @param	caller		执行域(this)。
          * @param	method		结束时的回调方法。
          * @param	args		（可选）回调参数。
          * @param	coverBefore	（可选）是否覆盖之前的延迟执行，默认为true。
          * @param	jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
          */
         timerLoop(delay, caller, method, args = null, coverBefore = true, jumpFrame = false) {
             var timer = this.scene ? this.scene.timer : ILaya.timer;
             timer.loop(delay, caller, method, args, coverBefore, jumpFrame);
         }
         /**
          * 定时执行某函数一次。功能同Laya.timer.timerOnce()。
          * @param	delay		延迟时间(单位毫秒)。
          * @param	caller		执行域(this)。
          * @param	method		结束时的回调方法。
          * @param	args		（可选）回调参数。
          * @param	coverBefore	（可选）是否覆盖之前的延迟执行，默认为true。
          */
         timerOnce(delay, caller, method, args = null, coverBefore = true) {
             var timer = this.scene ? this.scene.timer : ILaya.timer;
             timer._create(false, false, delay, caller, method, args, coverBefore);
         }
         /**
          * 定时重复执行某函数(基于帧率)。功能同Laya.timer.frameLoop()。
          * @param	delay		间隔几帧(单位为帧)。
          * @param	caller		执行域(this)。
          * @param	method		结束时的回调方法。
          * @param	args		（可选）回调参数。
          * @param	coverBefore	（可选）是否覆盖之前的延迟执行，默认为true。
          */
         frameLoop(delay, caller, method, args = null, coverBefore = true) {
             var timer = this.scene ? this.scene.timer : ILaya.timer;
             timer._create(true, true, delay, caller, method, args, coverBefore);
         }
         /**
          * 定时执行一次某函数(基于帧率)。功能同Laya.timer.frameOnce()。
          * @param	delay		延迟几帧(单位为帧)。
          * @param	caller		执行域(this)
          * @param	method		结束时的回调方法
          * @param	args		（可选）回调参数
          * @param	coverBefore	（可选）是否覆盖之前的延迟执行，默认为true
          */
         frameOnce(delay, caller, method, args = null, coverBefore = true) {
             var timer = this.scene ? this.scene.timer : ILaya.timer;
             timer._create(true, false, delay, caller, method, args, coverBefore);
         }
         /**
          * 清理定时器。功能同Laya.timer.clearTimer()。
          * @param	caller 执行域(this)。
          * @param	method 结束时的回调方法。
          */
         clearTimer(caller, method) {
             var timer = this.scene ? this.scene.timer : ILaya.timer;
             timer.clear(caller, method);
         }
         /**
          * <p>延迟运行指定的函数。</p>
          * <p>在控件被显示在屏幕之前调用，一般用于延迟计算数据。</p>
          * @param method 要执行的函数的名称。例如，functionName。
          * @param args 传递给 <code>method</code> 函数的可选参数列表。
          *
          * @see #runCallLater()
          */
         callLater(method, args = null) {
             var timer = this.scene ? this.scene.timer : ILaya.timer;
             timer.callLater(this, method, args);
         }
         /**
          * <p>如果有需要延迟调用的函数（通过 <code>callLater</code> 函数设置），则立即执行延迟调用函数。</p>
          * @param method 要执行的函数名称。例如，functionName。
          * @see #callLater()
          */
         runCallLater(method) {
             var timer = this.scene ? this.scene.timer : ILaya.timer;
             timer.runCallLater(this, method);
         }
         /**
          * 获得所属场景。
          * @return	场景。
          */
         get scene() {
             return this._scene;
         }
         /**
          * 获取自身是否激活。
          *   @return	自身是否激活。
          */
         get active() {
             return !this._getBit(Const.NOT_READY) && !this._getBit(Const.NOT_ACTIVE);
         }
         /**
          * 设置是否激活。
          * @param	value 是否激活。
          */
         set active(value) {
             value = !!value;
             if (!this._getBit(Const.NOT_ACTIVE) !== value) {
                 if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                     if (value)
                         throw "Node: can't set the main inActive node active in hierarchy,if the operate is in main inActive node or it's children script's onDisable Event.";
                     else
                         throw "Node: can't set the main active node inActive in hierarchy,if the operate is in main active node or it's children script's onEnable Event.";
                 }
                 else {
                     this._setBit(Const.NOT_ACTIVE, !value);
                     if (this._parent) {
                         if (this._parent.activeInHierarchy) {
                             if (value)
                                 this._processActive();
                             else
                                 this._processInActive();
                         }
                     }
                 }
             }
         }
         /**
          * 获取在场景中是否激活。
          *   @return	在场景中是否激活。
          */
         get activeInHierarchy() {
             return this._getBit(Const.ACTIVE_INHIERARCHY);
         }
         /**
          * @private
          */
         _onActive() {
             Stat.spriteCount++;
         }
         /**
          * @private
          */
         _onInActive() {
             Stat.spriteCount--;
         }
         /**
          * @private
          */
         _onActiveInScene() {
             //override it.
         }
         /**
          * @private
          */
         _onInActiveInScene() {
             //override it.
         }
         /**
          * @private
          */
         _parse(data, spriteMap) {
             //override it.
         }
         /**
          * @private
          */
         _setBelongScene(scene) {
             if (!this._scene) {
                 this._scene = scene;
                 this._onActiveInScene();
                 for (var i = 0, n = this._children.length; i < n; i++)
                     this._children[i]._setBelongScene(scene);
             }
         }
         /**
          * @private
          */
         _setUnBelongScene() {
             if (this._scene !== this) { //移除节点本身是scene不继续派发
                 this._onInActiveInScene();
                 this._scene = null;
                 for (var i = 0, n = this._children.length; i < n; i++)
                     this._children[i]._setUnBelongScene();
             }
         }
         /**
          * 组件被激活后执行，此时所有节点和组件均已创建完毕，次方法只执行一次
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onAwake() {
             //this.name  && trace("onAwake node ", this.name);
         }
         /**
          * 组件被启用后执行，比如节点被添加到舞台后
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onEnable() {
             //this.name  && trace("onEnable node ", this.name);
         }
         /**
          * @private
          */
         _processActive() {
             (this._activeChangeScripts) || (this._activeChangeScripts = []);
             this._activeHierarchy(this._activeChangeScripts); //处理属性,保证属性的正确性和即时性
             this._activeScripts(); //延时处理组件
         }
         /**
          * @private
          */
         _activeHierarchy(activeChangeScripts) {
             this._setBit(Const.ACTIVE_INHIERARCHY, true);
             if (this._components) {
                 for (var i = 0, n = this._components.length; i < n; i++) {
                     var comp = this._components[i];
                     comp._setActive(true);
                     (comp._isScript() && comp._enabled) && (activeChangeScripts.push(comp));
                 }
             }
             this._onActive();
             for (i = 0, n = this._children.length; i < n; i++) {
                 var child = this._children[i];
                 (!child._getBit(Const.NOT_ACTIVE)) && (child._activeHierarchy(activeChangeScripts));
             }
             if (!this._getBit(Const.AWAKED)) {
                 this._setBit(Const.AWAKED, true);
                 this.onAwake();
             }
             this.onEnable();
         }
         /**
          * @private
          */
         _activeScripts() {
             for (var i = 0, n = this._activeChangeScripts.length; i < n; i++)
                 this._activeChangeScripts[i].onEnable();
             this._activeChangeScripts.length = 0;
         }
         /**
          * @private
          */
         _processInActive() {
             (this._activeChangeScripts) || (this._activeChangeScripts = []);
             this._inActiveHierarchy(this._activeChangeScripts); //处理属性,保证属性的正确性和即时性
             this._inActiveScripts(); //延时处理组件
         }
         /**
          * @private
          */
         _inActiveHierarchy(activeChangeScripts) {
             this._onInActive();
             if (this._components) {
                 for (var i = 0, n = this._components.length; i < n; i++) {
                     var comp = this._components[i];
                     comp._setActive(false);
                     (comp._isScript() && comp._enabled) && (activeChangeScripts.push(comp));
                 }
             }
             this._setBit(Const.ACTIVE_INHIERARCHY, false);
             for (i = 0, n = this._children.length; i < n; i++) {
                 var child = this._children[i];
                 (child && !child._getBit(Const.NOT_ACTIVE)) && (child._inActiveHierarchy(activeChangeScripts));
             }
             this.onDisable();
         }
         /**
          * @private
          */
         _inActiveScripts() {
             for (var i = 0, n = this._activeChangeScripts.length; i < n; i++)
                 this._activeChangeScripts[i].onDisable();
             this._activeChangeScripts.length = 0;
         }
         /**
          * 组件被禁用时执行，比如从节点从舞台移除后
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onDisable() {
             //trace("onDisable node", this.name);
         }
         /**
          * @private
          */
         _onAdded() {
             if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                 throw "Node: can't set the main inActive node active in hierarchy,if the operate is in main inActive node or it's children script's onDisable Event.";
             }
             else {
                 var parentScene = this._parent.scene;
                 parentScene && this._setBelongScene(parentScene);
                 (this._parent.activeInHierarchy && this.active) && this._processActive();
             }
         }
         /**
          * @private
          */
         _onRemoved() {
             if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                 throw "Node: can't set the main active node inActive in hierarchy,if the operate is in main active node or it's children script's onEnable Event.";
             }
             else {
                 (this._parent.activeInHierarchy && this.active) && this._processInActive();
                 this._parent.scene && this._setUnBelongScene();
             }
         }
         /**
          * @private
          */
         _addComponentInstance(comp) {
             this._components = this._components || [];
             this._components.push(comp);
             comp.owner = this;
             comp._onAdded();
             if (this.activeInHierarchy) {
                 comp._setActive(true);
                 (comp._isScript() && comp._enabled) && (comp.onEnable());
             }
         }
         /**
          * @private
          */
         _destroyComponent(comp) {
             if (this._components) {
                 for (var i = 0, n = this._components.length; i < n; i++) {
                     var item = this._components[i];
                     if (item === comp) {
                         item._destroy();
                         this._components.splice(i, 1);
                         break;
                     }
                 }
             }
         }
         /**
          * @private
          */
         _destroyAllComponent() {
             if (this._components) {
                 for (var i = 0, n = this._components.length; i < n; i++) {
                     var item = this._components[i];
                     item._destroy();
                 }
                 this._components.length = 0;
             }
         }
         /**
          * @private 克隆。
          * @param	destObject 克隆源。
          */
         _cloneTo(destObject, srcRoot, dstRoot) {
             var destNode = destObject;
             if (this._components) {
                 for (var i = 0, n = this._components.length; i < n; i++) {
                     var destComponent = destNode.addComponent(this._components[i].constructor);
                     this._components[i]._cloneTo(destComponent);
                 }
             }
         }
         /**
          * 添加组件实例。
          * @param	comp 组件实例。
          * @return	组件。
          */
         addComponentIntance(comp) {
             if (comp.owner)
                 throw "Node:the component has belong to other node.";
             if (comp.isSingleton && this.getComponent(comp.constructor))
                 throw "Node:the component is singleton,can't add the second one.";
             this._addComponentInstance(comp);
             return comp;
         }
         /**
          * 添加组件。
          * @param	type 组件类型。
          * @return	组件。
          */
         addComponent(type) {
             var comp = Pool.createByClass(type);
             comp._destroyed = false;
             if (comp.isSingleton && this.getComponent(type))
                 throw "无法实例" + type + "组件" + "，" + type + "组件已存在！";
             this._addComponentInstance(comp);
             return comp;
         }
         /**
          * 获得组件实例，如果没有则返回为null
          * @param	clas 组建类型
          * @return	返回组件
          */
         getComponent(clas) {
             if (this._components) {
                 for (var i = 0, n = this._components.length; i < n; i++) {
                     var comp = this._components[i];
                     if (comp instanceof clas)
                         return comp;
                 }
             }
             return null;
         }
         /**
          * 获得组件实例，如果没有则返回为null
          * @param	clas 组建类型
          * @return	返回组件数组
          */
         getComponents(clas) {
             var arr;
             if (this._components) {
                 for (var i = 0, n = this._components.length; i < n; i++) {
                     var comp = this._components[i];
                     if (comp instanceof clas) {
                         arr = arr || [];
                         arr.push(comp);
                     }
                 }
             }
             return arr;
         }
         /**
          * @private
          * 获取timer
          */
         get timer() {
             return this.scene ? this.scene.timer : ILaya.timer;
         }
     }
     /**@private */
     Node.ARRAY_EMPTY = [];

     /**
      * @private
      * Graphic bounds数据类
      */
     class BoundsStyle {
         /**
          * 重置
          */
         reset() {
             if (this.bounds)
                 this.bounds.recover();
             if (this.userBounds)
                 this.userBounds.recover();
             this.bounds = null;
             this.userBounds = null;
             this.temBM = null;
             return this;
         }
         /**
          * 回收
          */
         recover() {
             Pool.recover("BoundsStyle", this.reset());
         }
         /**
          * 创建
          */
         static create() {
             return Pool.getItemByClass("BoundsStyle", BoundsStyle);
         }
     }

     /**
      * <code>HTMLCanvas</code> 是 Html Canvas 的代理类，封装了 Canvas 的属性和方法。
      */
     class HTMLCanvas extends Bitmap {
         /**
          * @inheritDoc
          */
         get source() {
             return this._source;
         }
         /*override*/ _getSource() {
             return this._source;
         }
         /**
          * 根据指定的类型，创建一个 <code>HTMLCanvas</code> 实例。
          */
         constructor(createCanvas = false) {
             super();
             if (createCanvas) //webgl模式下不建立。除非强制指，例如绘制文字部分
                 this._source = document.createElement("canvas");
             else {
                 this._source = this;
             }
             this.lock = true;
         }
         /**
          * 清空画布内容。
          */
         clear() {
             this._ctx && this._ctx.clear && this._ctx.clear();
             if (this._texture) {
                 this._texture.destroy();
                 this._texture = null;
             }
         }
         /**
          * 销毁。
          */
         /*override*/ destroy() {
             super.destroy();
             this._setCPUMemory(0);
             this._ctx && this._ctx.destroy && this._ctx.destroy();
             this._ctx = null;
         }
         /**
          * 释放。
          */
         release() {
         }
         /**
          * Canvas 渲染上下文。
          */
         get context() {
             if (this._ctx)
                 return this._ctx;
             if (this._source == this) { //是webgl并且不是真的画布。如果是真的画布，可能真的想要2d context
                 this._ctx = new ILaya.Context();
             }
             else {
                 this._ctx = this._source.getContext(ILaya.Render.isConchApp ? 'layagl' : '2d');
             }
             this._ctx._canvas = this;
             //if(!Browser.onLimixiu) _ctx.size = function(w:Number, h:Number):void {};	这个是干什么的，会导致ctx的size不好使
             return this._ctx;
         }
         /**
          * @private
          * 设置 Canvas 渲染上下文。是webgl用来替换_ctx用的
          * @param	context Canvas 渲染上下文。
          */
         _setContext(context) {
             this._ctx = context;
         }
         /**
          * 获取 Canvas 渲染上下文。
          * @param	contextID 上下文ID.
          * @param	other
          * @return  Canvas 渲染上下文 Context 对象。
          */
         getContext(contextID, other = null) {
             return this.context;
         }
         /**
          * 获取内存大小。
          * @return 内存大小。
          */
         //TODO:coverage
         getMemSize() {
             return 0; //TODO:待调整
         }
         /**
          * 设置宽高。
          * @param	w 宽度。
          * @param	h 高度。
          */
         size(w, h) {
             if (this._width != w || this._height != h || (this._source && (this._source.width != w || this._source.height != h))) {
                 this._width = w;
                 this._height = h;
                 this._setCPUMemory(w * h * 4);
                 this._ctx && this._ctx.size && this._ctx.size(w, h);
                 if (this._source && this._source instanceof HTMLCanvasElement) {
                     this._source.height = h, this._source.width = w;
                 }
                 if (this._texture) {
                     this._texture.destroy();
                     this._texture = null;
                 }
             }
         }
         /**
          * 获取texture实例
          */
         getTexture() {
             if (!this._texture) {
                 var bitmap = new Texture2D();
                 bitmap.loadImageSource(this.source);
                 this._texture = new Texture(bitmap);
             }
             return this._texture;
         }
         /**
          * 把图片转换为base64信息
          * @param	type "image/png"
          * @param	encoderOptions	质量参数，取值范围为0-1
          */
         toBase64(type, encoderOptions) {
             if (this._source) {
                 if (ILaya.Render.isConchApp) {
                     var win = window;
                     if (win.conchConfig.threadMode == 2) {
                         throw "native 2 thread mode use toBase64Async";
                     }
                     var width = this._ctx._targets.sourceWidth;
                     var height = this._ctx._targets.sourceHeight;
                     var data = this._ctx._targets.getData(0, 0, width, height);
                     return win.conchToBase64FlipY ? win.conchToBase64FlipY(type, encoderOptions, data.buffer, width, height) : win.conchToBase64(type, encoderOptions, data.buffer, width, height);
                 }
                 else {
                     return this._source.toDataURL(type, encoderOptions);
                 }
             }
             return null;
         }
         //native多线程
         toBase64Async(type, encoderOptions, callBack) {
             var width = this._ctx._targets.sourceWidth;
             var height = this._ctx._targets.sourceHeight;
             this._ctx._targets.getDataAsync(0, 0, width, height, function (data) {
                 let win = window;
                 var base64 = win.conchToBase64FlipY ? win.conchToBase64FlipY(type, encoderOptions, data.buffer, width, height) : win.conchToBase64(type, encoderOptions, data.buffer, width, height);
                 callBack(base64);
             });
         }
     }

     /**
      * @private
      * 存储cache相关
      */
     class CacheStyle {
         constructor() {
             this.reset();
         }
         /**
          * 是否需要Bitmap缓存
          * @return
          */
         needBitmapCache() {
             return this.cacheForFilters || !!this.mask;
         }
         /**
          * 是否需要开启canvas渲染
          */
         needEnableCanvasRender() {
             return this.userSetCache != "none" || this.cacheForFilters || !!this.mask;
         }
         /**
          * 释放cache的资源
          */
         releaseContext() {
             if (this.canvas && this.canvas.size) {
                 Pool.recover("CacheCanvas", this.canvas);
                 this.canvas.size(0, 0);
                 // 微信在iphone8和mate20上个bug，size存在但是不起作用，可能是canvas对象不是我们的。
                 // 为了避免canvas不消失，再强制设置宽高为0 TODO 没有测试
                 try {
                     this.canvas.width = 0;
                     this.canvas.height = 0;
                 }
                 catch (e) {
                 }
             }
             this.canvas = null;
         }
         createContext() {
             if (!this.canvas) {
                 this.canvas = Pool.getItem("CacheCanvas") || new HTMLCanvas(false);
                 var tx = this.canvas.context;
                 if (!tx) {
                     tx = this.canvas.getContext('2d'); //如果是webGL的话，这个会返回WebGLContext2D
                 }
             }
         }
         /**
          * 释放滤镜资源
          */
         releaseFilterCache() {
             var fc = this.filterCache;
             if (fc) {
                 fc.destroy();
                 fc.recycle();
                 this.filterCache = null;
             }
         }
         /**
          * 回收
          */
         recover() {
             if (this === CacheStyle.EMPTY)
                 return;
             Pool.recover("SpriteCache", this.reset());
         }
         /**
          * 重置
          */
         reset() {
             this.releaseContext();
             this.releaseFilterCache();
             this.cacheAs = "none";
             this.enableCanvasRender = false;
             this.userSetCache = "none";
             this.cacheForFilters = false;
             this.staticCache = false;
             this.reCache = true;
             this.mask = null;
             this.maskParent = null;
             this.filterCache = null;
             this.filters = null;
             this.hasGlowFilter = false;
             if (this.cacheRect)
                 this.cacheRect.recover();
             this.cacheRect = null;
             return this;
         }
         /**
          * 创建一个SpriteCache
          */
         static create() {
             return Pool.getItemByClass("SpriteCache", CacheStyle);
         }
         _calculateCacheRect(sprite, tCacheType, x, y) {
             var _cacheStyle = sprite._cacheStyle;
             if (!_cacheStyle.cacheRect)
                 _cacheStyle.cacheRect = Rectangle.create();
             var tRec;
             //计算显示对象的绘图区域
             if (tCacheType === "bitmap") {
                 tRec = sprite.getSelfBounds();
                 tRec.width = tRec.width + CacheStyle.CANVAS_EXTEND_EDGE * 2;
                 tRec.height = tRec.height + CacheStyle.CANVAS_EXTEND_EDGE * 2;
                 tRec.x = tRec.x - sprite.pivotX;
                 tRec.y = tRec.y - sprite.pivotY;
                 tRec.x = tRec.x - CacheStyle.CANVAS_EXTEND_EDGE;
                 tRec.y = tRec.y - CacheStyle.CANVAS_EXTEND_EDGE;
                 tRec.x = Math.floor(tRec.x + x) - x;
                 tRec.y = Math.floor(tRec.y + y) - y;
                 tRec.width = Math.floor(tRec.width);
                 tRec.height = Math.floor(tRec.height);
                 _cacheStyle.cacheRect.copyFrom(tRec);
             }
             else {
                 _cacheStyle.cacheRect.setTo(-sprite._style.pivotX, -sprite._style.pivotY, 1, 1);
             }
             tRec = _cacheStyle.cacheRect;
             //处理显示对象的scrollRect偏移
             if (sprite._style.scrollRect) {
                 var scrollRect = sprite._style.scrollRect;
                 tRec.x -= scrollRect.x;
                 tRec.y -= scrollRect.y;
             }
             CacheStyle._scaleInfo.setTo(1, 1);
             return CacheStyle._scaleInfo;
         }
     }
     CacheStyle.EMPTY = new CacheStyle();
     CacheStyle._scaleInfo = new Point();
     CacheStyle.CANVAS_EXTEND_EDGE = 16;

     /**
      * @private
      * 元素样式
      */
     class SpriteStyle {
         constructor() {
             this.reset();
         }
         /**
          * 重置，方便下次复用
          */
         reset() {
             this.scaleX = this.scaleY = 1;
             this.skewX = this.skewY = 0;
             this.pivotX = this.pivotY = this.rotation = 0;
             this.alpha = 1;
             if (this.scrollRect)
                 this.scrollRect.recover();
             this.scrollRect = null;
             if (this.viewport)
                 this.viewport.recover();
             this.viewport = null;
             this.hitArea = null;
             this.dragging = null;
             this.blendMode = null;
             return this;
         }
         /**
          * 回收
          */
         recover() {
             if (this === SpriteStyle.EMPTY)
                 return;
             Pool.recover("SpriteStyle", this.reset());
         }
         /**
          * 从对象池中创建
          */
         static create() {
             return Pool.getItemByClass("SpriteStyle", SpriteStyle);
         }
     }
     SpriteStyle.EMPTY = new SpriteStyle();

     /**
      * @private
      * 快速节点命令执行器
      * 多个指令组合才有意义，单个指令没必要在下面加
      */
     class LayaGLQuickRunner {
         static __init__() {
             /*
                glQuickMap["drawNode;"] = drawNode;
                glQuickMap["drawNodes;"] = drawNodes;
                glQuickMap["drawLayaGL;"] = drawLayaGL;
                glQuickMap["drawLayaGL;drawNodes;"] = drawLayaGL_drawNodes;
                glQuickMap["save;alpha;drawNode;restore;"] = save_alpha_drawNode_restore;
                glQuickMap["save;alpha;drawLayaGL;restore;"] = save_alpha_drawLayaGL_restore;
              */
             //glQuickMap["save;alpha;drawTextureWithGr;restore;"] = save_alpha_drawTextureWithGr_restore;
             //glQuickMap["save;transform;drawTextureWithGr;restore;"] = save_alpha_transform_drawTextureWithGr_restore;
             //glQuickMap["save;alpha;transform;drawTextureWithGr;restore;"] = save_alpha_transform_drawTextureWithGr_restore;
             //glQuickMap["drawTextureWithGr;"] = drawTextureWithGr;
             //glQuickMap["save;transform;drawNodes;restore;"] = save_transform_drawNodes_restore;
             //glQuickMap["save;transform;drawLayaGL;restore;"] = save_alpha_transform_drawLayaGL_restore;
             //glQuickMap["save;alpha;transform;drawLayaGL;restore;"] = save_alpha_transform_drawLayaGL_restore;
             //glQuickMap["save;alpha;transform;drawLayaGL;restore;"] = save_alpha_transform_drawLayaGL_restore;
             //map[SpriteConst.TEXTURE] = _drawTexture;
             LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_transform_drawLayaGL;
             //map[ SpriteConst.GRAPHICS] = _drawLayaGL;
             LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_drawLayaGL;
             LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.transform_drawLayaGL;
             LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.CHILDS] = LayaGLQuickRunner.transform_drawNodes;
             LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_transform_drawTexture;
             LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_drawTexture;
             LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.transform_drawTexture;
             LayaGLQuickRunner.map[SpriteConst.GRAPHICS | SpriteConst.CHILDS] = LayaGLQuickRunner.drawLayaGL_drawNodes;
         }
         static transform_drawTexture(sprite, context, x, y) {
             var style = sprite._style;
             var tex = sprite.texture;
             /*
             var ctx:WebGLContext2D = context as WebGLContext2D;
             var ctxm:Matrix = ctx._curMat;
             ctxm.copyTo(curMat);
             //context.saveTransform(curMat);
             ctx.transformByMatrixNoSave(sprite.getTransform(), x, y);
             ctx.drawTexture(tex, -style.pivotX, -style.pivotY, sprite._width || tex.width, sprite._height || tex.height);
             curMat.copyTo(ctxm);
             //ctx.restoreTransform(curMat);
             */
             context.saveTransform(LayaGLQuickRunner.curMat);
             context.transformByMatrix(sprite.transform, x, y);
             context.drawTexture(tex, -sprite.pivotX, -sprite.pivotY, sprite._width || tex.width, sprite._height || tex.height);
             context.restoreTransform(LayaGLQuickRunner.curMat);
             /*
             context.saveTransform(curMat);
             var w:int = sprite._width || tex.width;
             var h:int = sprite._height || tex.height;
             var mat:Matrix = sprite.transform;// (sprite as Object)._tfChanged?(sprite as Object)._adjustTransform():(sprite as Object)._transform;
             mat.tx += x; mat.ty += y;
             //(context as WebGLContext2D).drawTextureWithTransform(tex, -style.pivotX, -style.pivotY, w, h,mat,x,y,1,null,null);
             
             var ctx:WebGLContext2D = context;
             var curMat:Matrix = ctx._curMat;
             var tmpMat:Matrix = ctx._tmpMatrix;
             var transform = mat;
             //克隆transform,因为要应用tx，ty，这里不能修改原始的transform
             tmpMat.a = transform.a; tmpMat.b = transform.b; tmpMat.c = transform.c; tmpMat.d = transform.d; tmpMat.tx = transform.tx + x; tmpMat.ty = transform.ty + y;
             tmpMat._bTransform = transform._bTransform;
             if (transform && curMat._bTransform) {
                 Matrix.mul(tmpMat, curMat, tmpMat);
                 transform = tmpMat;
                 transform._bTransform = true;
             }else {
                 //如果curmat没有旋转。
                 transform = tmpMat;
             }
             ctx._drawTextureM(tex, x, y, w,h, mat, 1,null);
             
             //var st = __JS__("performance.now()");
             //Laya.stage.perfdt += (__JS__("performance.now()")-st);
             context.restoreTransform(curMat);
             */
         }
         //static public function _drawTexture(sprite:Sprite, context:Context, x:Number, y:Number):void {
         //var tex:Texture = sprite.texture;
         //context.drawTexture(tex, x-sprite.pivotX, y-sprite.pivotY, sprite._width || tex.width, sprite._height || tex.height);
         //}
         static alpha_drawTexture(sprite, context, x, y) {
             var style = sprite._style;
             var alpha;
             var tex = sprite.texture;
             if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                 var temp = context.globalAlpha;
                 context.globalAlpha *= alpha;
                 context.drawTexture(tex, x - style.pivotX + tex.offsetX, y - style.pivotY + tex.offsetY, sprite._width || tex.width, sprite._height || tex.height);
                 context.globalAlpha = temp;
             }
         }
         static alpha_transform_drawTexture(sprite, context, x, y) {
             var style = sprite._style;
             var alpha;
             var tex = sprite.texture;
             if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                 var temp = context.globalAlpha;
                 context.globalAlpha *= alpha;
                 context.saveTransform(LayaGLQuickRunner.curMat);
                 context.transformByMatrix(sprite.transform, x, y);
                 context.drawTexture(tex, -style.pivotX + tex.offsetX, -style.pivotY + tex.offsetY, sprite._width || tex.width, sprite._height || tex.height);
                 context.restoreTransform(LayaGLQuickRunner.curMat);
                 context.globalAlpha = temp;
             }
         }
         static alpha_transform_drawLayaGL(sprite, context, x, y) {
             var style = sprite._style;
             var alpha;
             if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                 var temp = context.globalAlpha;
                 context.globalAlpha *= alpha;
                 context.saveTransform(LayaGLQuickRunner.curMat);
                 context.transformByMatrix(sprite.transform, x, y);
                 sprite._graphics && sprite._graphics._render(sprite, context, -style.pivotX, -style.pivotY);
                 context.restoreTransform(LayaGLQuickRunner.curMat);
                 context.globalAlpha = temp;
             }
         }
         static alpha_drawLayaGL(sprite, context, x, y) {
             var style = sprite._style;
             var alpha;
             if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                 var temp = context.globalAlpha;
                 context.globalAlpha *= alpha;
                 sprite._graphics && sprite._graphics._render(sprite, context, x - style.pivotX, y - style.pivotY);
                 context.globalAlpha = temp;
             }
         }
         //static public function _drawLayaGL(sprite:Sprite, context:Context, x:Number, y:Number):void {
         //sprite._graphics._render(sprite, context, x, y);
         //}		
         static transform_drawLayaGL(sprite, context, x, y) {
             var style = sprite._style;
             //var transform:Matrix = sprite.transform;
             //临时
             //if (transform) {
             context.saveTransform(LayaGLQuickRunner.curMat);
             context.transformByMatrix(sprite.transform, x, y);
             sprite._graphics && sprite._graphics._render(sprite, context, -style.pivotX, -style.pivotY);
             context.restoreTransform(LayaGLQuickRunner.curMat);
             //}else {
             //sprite._graphics && sprite._graphics._render(sprite, context, -style.pivotX, -style.pivotY);
             //}			
         }
         static transform_drawNodes(sprite, context, x, y) {
             //var transform:Matrix = sprite.transform;
             var textLastRender = sprite._getBit(Const.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
             var style = sprite._style;
             context.saveTransform(LayaGLQuickRunner.curMat);
             context.transformByMatrix(sprite.transform, x, y);
             //x = x-style.pivotX;
             //y = y - style.pivotY;
             x = -style.pivotX;
             y = -style.pivotY;
             var childs = sprite._children, n = childs.length, ele;
             if (style.viewport) {
                 var rect = style.viewport;
                 var left = rect.x;
                 var top = rect.y;
                 var right = rect.right;
                 var bottom = rect.bottom;
                 var _x, _y;
                 for (i = 0; i < n; ++i) {
                     if ((ele = childs[i])._visible && ((_x = ele._x) < right && (_x + ele.width) > left && (_y = ele._y) < bottom && (_y + ele.height) > top)) {
                         ele.render(context, x, y);
                     }
                 }
             }
             else {
                 for (var i = 0; i < n; ++i)
                     (ele = childs[i])._visible && ele.render(context, x, y);
             }
             context.restoreTransform(LayaGLQuickRunner.curMat);
             textLastRender && context.drawCallOptimize(false);
         }
         static drawLayaGL_drawNodes(sprite, context, x, y) {
             var textLastRender = sprite._getBit(Const.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
             var style = sprite._style;
             x = x - style.pivotX;
             y = y - style.pivotY;
             sprite._graphics && sprite._graphics._render(sprite, context, x, y);
             var childs = sprite._children, n = childs.length, ele;
             if (style.viewport) {
                 var rect = style.viewport;
                 var left = rect.x;
                 var top = rect.y;
                 var right = rect.right;
                 var bottom = rect.bottom;
                 var _x, _y;
                 for (i = 0; i < n; ++i) {
                     if ((ele = childs[i])._visible && ((_x = ele._x) < right && (_x + ele.width) > left && (_y = ele._y) < bottom && (_y + ele.height) > top)) {
                         ele.render(context, x, y);
                     }
                 }
             }
             else {
                 for (var i = 0; i < n; ++i)
                     (ele = childs[i])._visible && ele.render(context, x, y);
             }
             textLastRender && context.drawCallOptimize(false);
         }
     }
     /*[FILEINDEX:10000]*/
     LayaGLQuickRunner.map = {};
     LayaGLQuickRunner.curMat = new Matrix();

     /**
      * @private
      * 精灵渲染器
      */
     class RenderSprite {
         constructor(type, next) {
             if (LayaGLQuickRunner.map[type]) {
                 this._fun = LayaGLQuickRunner.map[type];
                 this._next = RenderSprite.NORENDER;
                 return;
             }
             this._next = next || RenderSprite.NORENDER;
             switch (type) {
                 case 0:
                     this._fun = this._no;
                     return;
                 //case SpriteConst.IMAGE: 
                 //_fun = this._image;
                 //return;
                 case SpriteConst.ALPHA:
                     this._fun = this._alpha;
                     return;
                 case SpriteConst.TRANSFORM:
                     this._fun = this._transform;
                     return;
                 case SpriteConst.BLEND:
                     this._fun = this._blend;
                     return;
                 case SpriteConst.CANVAS:
                     this._fun = this._canvas;
                     return;
                 case SpriteConst.MASK:
                     this._fun = this._mask;
                     return;
                 case SpriteConst.CLIP:
                     this._fun = this._clip;
                     return;
                 case SpriteConst.STYLE:
                     this._fun = this._style;
                     return;
                 case SpriteConst.GRAPHICS:
                     this._fun = this._graphics;
                     return;
                 case SpriteConst.CHILDS:
                     this._fun = this._children;
                     return;
                 case SpriteConst.CUSTOM:
                     this._fun = this._custom;
                     return;
                 case SpriteConst.TEXTURE:
                     this._fun = this._texture;
                     return;
                 //case SpriteConst.IMAGE | SpriteConst.GRAPHICS: 
                 //_fun = this._image2;
                 //return;
                 //case SpriteConst.IMAGE | SpriteConst.TRANSFORM | SpriteConst.GRAPHICS: 
                 //_fun = this._image2;
                 //return;
                 case SpriteConst.FILTERS:
                     this._fun = Filter._filter;
                     return;
                 case RenderSprite.INIT:
                     this._fun = RenderSprite._initRenderFun;
                     return;
             }
             this.onCreate(type);
         }
         static __init__() {
             LayaGLQuickRunner.__init__();
             var i, len;
             var initRender;
             initRender = new RenderSprite(RenderSprite.INIT, null);
             len = RenderSprite.renders.length = SpriteConst.CHILDS * 2;
             for (i = 0; i < len; i++)
                 RenderSprite.renders[i] = initRender;
             RenderSprite.renders[0] = new RenderSprite(0, null);
             //_initSame([SpriteConst.IMAGE, SpriteConst.GRAPHICS, SpriteConst.TRANSFORM, SpriteConst.ALPHA], RunDriver.createRenderSprite(SpriteConst.IMAGE, null));
             //
             //renders[SpriteConst.IMAGE | SpriteConst.GRAPHICS] = RunDriver.createRenderSprite(SpriteConst.IMAGE | SpriteConst.GRAPHICS, null);
             //
             //renders[SpriteConst.IMAGE | SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = RunDriver.createRenderSprite(SpriteConst.IMAGE | SpriteConst.TRANSFORM | SpriteConst.GRAPHICS, null);
         }
         static _initRenderFun(sprite, context, x, y) {
             var type = sprite._renderType;
             var r = RenderSprite.renders[type] = RenderSprite._getTypeRender(type);
             r._fun(sprite, context, x, y);
         }
         static _getTypeRender(type) {
             if (LayaGLQuickRunner.map[type])
                 return new RenderSprite(type, null);
             var rst = null;
             var tType = SpriteConst.CHILDS;
             while (tType > 0) {
                 if (tType & type)
                     rst = new RenderSprite(tType, rst);
                 tType = tType >> 1;
             }
             return rst;
         }
         onCreate(type) {
         }
         _style(sprite, context, x, y) {
             //现在只有Text会走这里，Html已经不走这里了
             var style = sprite._style;
             if (style.render != null)
                 style.render(sprite, context, x, y);
             var next = this._next;
             next._fun.call(next, sprite, context, x, y);
         }
         _no(sprite, context, x, y) {
         }
         //TODO:coverage
         _custom(sprite, context, x, y) {
             sprite.customRender(context, x, y);
             this._next._fun.call(this._next, sprite, context, x - sprite.pivotX, y - sprite.pivotY);
         }
         _clip(sprite, context, x, y) {
             var next = this._next;
             if (next == RenderSprite.NORENDER)
                 return;
             var r = sprite._style.scrollRect;
             context.save();
             context.clipRect(x, y, r.width, r.height);
             next._fun.call(next, sprite, context, x - r.x, y - r.y);
             context.restore();
         }
         /*
         public function _mask(sprite:Sprite, context:Context, x:Number, y:Number):void {
             var next:RenderSprite = this._next;
             next._fun.call(next, sprite, context, x, y);
             var mask:Sprite = sprite.mask;
             if (mask) {
                 context.globalCompositeOperation = "destination-in";
                 if (mask.numChildren > 0 || !mask.graphics._isOnlyOne()) {
                     mask.cacheAs = "bitmap";
                 }
                 mask.render(context, x - sprite._style.pivotX, y - sprite._style.pivotY);
             }
             context.globalCompositeOperation = "source-over";
         }
         */
         _texture(sprite, context, x, y) {
             var tex = sprite.texture;
             if (tex._getSource())
                 context.drawTexture(tex, x - sprite.pivotX + tex.offsetX, y - sprite.pivotY + tex.offsetY, sprite._width || tex.width, sprite._height || tex.height);
             var next = this._next;
             if (next != RenderSprite.NORENDER)
                 next._fun.call(next, sprite, context, x, y);
         }
         _graphics(sprite, context, x, y) {
             var style = sprite._style;
             var g = sprite._graphics;
             g && g._render(sprite, context, x - style.pivotX, y - style.pivotY);
             var next = this._next;
             if (next != RenderSprite.NORENDER)
                 next._fun.call(next, sprite, context, x, y);
         }
         //TODO:coverage
         _image(sprite, context, x, y) {
             var style = sprite._style;
             context.drawTexture2(x, y, style.pivotX, style.pivotY, sprite.transform, sprite._graphics._one);
         }
         //TODO:coverage
         _image2(sprite, context, x, y) {
             var style = sprite._style;
             context.drawTexture2(x, y, style.pivotX, style.pivotY, sprite.transform, sprite._graphics._one);
         }
         //TODO:coverage
         _alpha(sprite, context, x, y) {
             var style = sprite._style;
             var alpha;
             if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                 var temp = context.globalAlpha;
                 context.globalAlpha *= alpha;
                 var next = this._next;
                 next._fun.call(next, sprite, context, x, y);
                 context.globalAlpha = temp;
             }
         }
         _transform(sprite, context, x, y) {
             var transform = sprite.transform, _next = this._next;
             var style = sprite._style;
             if (transform && _next != RenderSprite.NORENDER) {
                 context.save();
                 context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x, transform.ty + y);
                 _next._fun.call(_next, sprite, context, 0, 0);
                 context.restore();
             }
             else {
                 if (_next != RenderSprite.NORENDER)
                     _next._fun.call(_next, sprite, context, x, y);
             }
         }
         _children(sprite, context, x, y) {
             var style = sprite._style;
             var childs = sprite._children, n = childs.length, ele;
             x = x - sprite.pivotX;
             y = y - sprite.pivotY;
             var textLastRender = sprite._getBit(Const.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
             if (style.viewport) {
                 var rect = style.viewport;
                 var left = rect.x;
                 var top = rect.y;
                 var right = rect.right;
                 var bottom = rect.bottom;
                 var _x, _y;
                 for (i = 0; i < n; ++i) {
                     if ((ele = childs[i])._visible && ((_x = ele._x) < right && (_x + ele.width) > left && (_y = ele._y) < bottom && (_y + ele.height) > top)) {
                         ele.render(context, x, y);
                     }
                 }
             }
             else {
                 for (var i = 0; i < n; ++i)
                     (ele = childs[i])._visible && ele.render(context, x, y);
             }
             textLastRender && context.drawCallOptimize(false);
         }
         _canvas(sprite, context, x, y) {
             var _cacheStyle = sprite._cacheStyle;
             var _next = this._next;
             if (!_cacheStyle.enableCanvasRender) {
                 _next._fun.call(_next, sprite, context, x, y);
                 return;
             }
             _cacheStyle.cacheAs === 'bitmap' ? (Stat.canvasBitmap++) : (Stat.canvasNormal++);
             //检查保存的文字是否失效了
             var cacheNeedRebuild = false;
             var textNeedRestore = false;
             if (_cacheStyle.canvas) {
                 // 检查文字是否被释放了，以及clip是否改变了，需要重新cache了
                 var canv = _cacheStyle.canvas;
                 var ctx = canv.context;
                 var charRIs = canv.touches;
                 if (charRIs) {
                     for (var ci = 0; ci < charRIs.length; ci++) {
                         if (charRIs[ci].deleted) {
                             textNeedRestore = true;
                             break;
                         }
                     }
                 }
                 cacheNeedRebuild = canv.isCacheValid && !canv.isCacheValid();
             }
             if (sprite._needRepaint() || (!_cacheStyle.canvas) || textNeedRestore || cacheNeedRebuild || window.Laya.stage.isGlobalRepaint()) {
                 if (_cacheStyle.cacheAs === 'normal') {
                     if (context._targets) { // 如果有target说明父节点已经是一个cacheas bitmap了，就不再走cacheas normal的流程了
                         _next._fun.call(_next, sprite, context, x, y);
                         return; //不再继续
                     }
                     else {
                         this._canvas_webgl_normal_repaint(sprite, context);
                     }
                 }
                 else {
                     this._canvas_repaint(sprite, context, x, y);
                 }
             }
             var tRec = _cacheStyle.cacheRect;
             //Stage._dbgSprite.graphics.drawRect(x, y, 30,30, null, 'red');
             context.drawCanvas(_cacheStyle.canvas, x + tRec.x, y + tRec.y, tRec.width, tRec.height);
         }
         _canvas_repaint(sprite, context, x, y) {
             var _cacheStyle = sprite._cacheStyle;
             var _next = this._next;
             var tx;
             var canvas = _cacheStyle.canvas;
             var left;
             var top;
             var tRec;
             var tCacheType = _cacheStyle.cacheAs;
             var w, h;
             var scaleX, scaleY;
             var scaleInfo;
             scaleInfo = _cacheStyle._calculateCacheRect(sprite, tCacheType, x, y);
             scaleX = scaleInfo.x;
             scaleY = scaleInfo.y;
             //显示对象实际的绘图区域
             tRec = _cacheStyle.cacheRect;
             //计算cache画布的大小
             w = tRec.width * scaleX;
             h = tRec.height * scaleY;
             left = tRec.x;
             top = tRec.y;
             if (tCacheType === 'bitmap' && (w > 2048 || h > 2048)) {
                 console.warn("cache bitmap size larger than 2048,cache ignored");
                 _cacheStyle.releaseContext();
                 _next._fun.call(_next, sprite, context, x, y);
                 return;
             }
             if (!canvas) {
                 _cacheStyle.createContext();
                 canvas = _cacheStyle.canvas;
             }
             tx = canvas.context;
             //WebGL用
             tx.sprite = sprite;
             (canvas.width != w || canvas.height != h) && canvas.size(w, h); //asbitmap需要合理的大小，所以size放到前面
             if (tCacheType === 'bitmap')
                 tx.asBitmap = true;
             else if (tCacheType === 'normal')
                 tx.asBitmap = false;
             //清理画布。之前记录的submit会被全部清掉
             tx.clear();
             //TODO:测试webgl下是否有缓存模糊
             if (scaleX != 1 || scaleY != 1) {
                 var ctx = tx;
                 ctx.save();
                 ctx.scale(scaleX, scaleY);
                 _next._fun.call(_next, sprite, tx, -left, -top);
                 ctx.restore();
                 sprite._applyFilters();
             }
             else {
                 ctx = tx;
                 _next._fun.call(_next, sprite, tx, -left, -top);
                 sprite._applyFilters();
             }
             if (_cacheStyle.staticCache)
                 _cacheStyle.reCache = false;
             Stat.canvasReCache++;
         }
         _canvas_webgl_normal_repaint(sprite, context) {
             var _cacheStyle = sprite._cacheStyle;
             var _next = this._next;
             var canvas = _cacheStyle.canvas;
             var tCacheType = _cacheStyle.cacheAs;
             var scaleInfo = _cacheStyle._calculateCacheRect(sprite, tCacheType, 0, 0);
             if (!canvas) {
                 canvas = _cacheStyle.canvas = new WebGLCacheAsNormalCanvas(context, sprite);
             }
             var tx = canvas.context;
             canvas['startRec']();
             _next._fun.call(_next, sprite, tx, sprite.pivotX, sprite.pivotY); // 由于后面的渲染会减去pivot，而cacheas normal并不希望这样，只希望创建一个原始的图像。所以在这里补偿。
             sprite._applyFilters();
             Stat.canvasReCache++;
             canvas['endRec']();
             //context.drawCanvas(canvas, x , y , 1, 1); // 这种情况下宽高没用
         }
         _blend(sprite, context, x, y) {
             var style = sprite._style;
             var next = this._next;
             if (style.blendMode) {
                 context.save();
                 context.globalCompositeOperation = style.blendMode;
                 next._fun.call(next, sprite, context, x, y);
                 context.restore();
             }
             else {
                 next._fun.call(next, sprite, context, x, y);
             }
         }
         /**
          * mask的渲染。 sprite有mask属性的情况下，来渲染这个sprite
          * @param	sprite
          * @param	context
          * @param	x
          * @param	y
          */
         _mask(sprite, context, x, y) {
             var next = this._next;
             var mask = sprite.mask;
             var ctx = context;
             if (mask) {
                 ctx.save();
                 var preBlendMode = ctx.globalCompositeOperation;
                 var tRect = new Rectangle();
                 //裁剪范围是根据mask来定的
                 tRect.copyFrom(mask.getBounds());
                 tRect.width = Math.round(tRect.width);
                 tRect.height = Math.round(tRect.height);
                 tRect.x = Math.round(tRect.x);
                 tRect.y = Math.round(tRect.y);
                 if (tRect.width > 0 && tRect.height > 0) {
                     var w = tRect.width;
                     var h = tRect.height;
                     var tmpRT = WebGLRTMgr.getRT(w, h);
                     ctx.breakNextMerge();
                     //先把mask画到tmpTarget上
                     ctx.pushRT();
                     ctx.addRenderObject(SubmitCMD.create([ctx, tmpRT, w, h], RenderSprite.tmpTarget, this));
                     mask.render(ctx, -tRect.x, -tRect.y);
                     ctx.breakNextMerge();
                     ctx.popRT();
                     //设置裁剪为mask的大小。要考虑pivot。有pivot的话，可能要从负的开始
                     ctx.save();
                     ctx.clipRect(x + tRect.x - sprite.getStyle().pivotX, y + tRect.y - sprite.getStyle().pivotY, w, h);
                     //画出本节点的内容
                     next._fun.call(next, sprite, ctx, x, y);
                     ctx.restore();
                     //设置混合模式
                     preBlendMode = ctx.globalCompositeOperation;
                     ctx.addRenderObject(SubmitCMD.create(["mask"], RenderSprite.setBlendMode, this));
                     var shaderValue = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
                     var uv = Texture.INV_UV;
                     //这个地方代码不要删除，为了解决在iphone6-plus上的诡异问题
                     //renderTarget + StencilBuffer + renderTargetSize < 32 就会变得超级卡
                     //所以增加的限制。王亚伟
                     //  180725 本段限制代码已经删除，如果出了问题再找王亚伟
                     ctx.drawTarget(tmpRT, x + tRect.x - sprite.getStyle().pivotX, y + tRect.y - sprite.getStyle().pivotY, w, h, Matrix.TEMP.identity(), shaderValue, uv, 6);
                     ctx.addRenderObject(SubmitCMD.create([tmpRT], RenderSprite.recycleTarget, this));
                     //恢复混合模式
                     ctx.addRenderObject(SubmitCMD.create([preBlendMode], RenderSprite.setBlendMode, this));
                 }
                 ctx.restore();
             }
             else {
                 next._fun.call(next, sprite, context, x, y);
             }
         }
         static tmpTarget(ctx, rt, w, h) {
             rt.start();
             rt.clear(0, 0, 0, 0);
         }
         static recycleTarget(rt) {
             WebGLRTMgr.releaseRT(rt);
         }
         static setBlendMode(blendMode) {
             var gl = WebGLContext.mainContext;
             BlendMode.targetFns[BlendMode.TOINT[blendMode]](gl);
         }
     }
     /** @private */
     //public static const IMAGE:int = 0x01;
     /** @private */
     //public static const ALPHA:int = 0x02;
     /** @private */
     //public static const TRANSFORM:int = 0x04;
     /** @private */
     //public static const BLEND:int = 0x08;
     /** @private */
     //public static const CANVAS:int = 0x10;
     /** @private */
     //public static const FILTERS:int = 0x20;
     /** @private */
     //public static const MASK:int = 0x40;
     /** @private */
     //public static const CLIP:int = 0x80;
     /** @private */
     //public static const STYLE:int = 0x100;
     /** @private */
     //public static const GRAPHICS:int = 0x200;
     /** @private */
     //public static const CUSTOM:int = 0x400;
     /** @private */
     //public static const CHILDS:int = 0x800;
     /** @private */
     RenderSprite.INIT = 0x11111;
     /** @private */
     RenderSprite.renders = [];
     /** @private */
     RenderSprite.NORENDER = new RenderSprite(0, null);
     RenderSprite.tempUV = new Array(8);

     /**在显示对象上按下后调度。
      * @eventType Event.MOUSE_DOWN
      * */
     /*[Event(name = "mousedown", type = "laya.events.Event")]*/
     /**在显示对象抬起后调度。
      * @eventType Event.MOUSE_UP
      * */
     /*[Event(name = "mouseup", type = "laya.events.Event")]*/
     /**鼠标在对象身上进行移动后调度
      * @eventType Event.MOUSE_MOVE
      * */
     /*[Event(name = "mousemove", type = "laya.events.Event")]*/
     /**鼠标经过对象后调度。
      * @eventType Event.MOUSE_OVER
      * */
     /*[Event(name = "mouseover", type = "laya.events.Event")]*/
     /**鼠标离开对象后调度。
      * @eventType Event.MOUSE_OUT
      * */
     /*[Event(name = "mouseout", type = "laya.events.Event")]*/
     /**鼠标点击对象后调度。
      * @eventType Event.CLICK
      * */
     /*[Event(name = "click", type = "laya.events.Event")]*/
     /**开始拖动后调度。
      * @eventType Event.DRAG_START
      * */
     /*[Event(name = "dragstart", type = "laya.events.Event")]*/
     /**拖动中调度。
      * @eventType Event.DRAG_MOVE
      * */
     /*[Event(name = "dragmove", type = "laya.events.Event")]*/
     /**拖动结束后调度。
      * @eventType Event.DRAG_END
      * */
     /*[Event(name = "dragend", type = "laya.events.Event")]*/
     /**
      * <p> <code>Sprite</code> 是基本的显示图形的显示列表节点。 <code>Sprite</code> 默认没有宽高，默认不接受鼠标事件。通过 <code>graphics</code> 可以绘制图片或者矢量图，支持旋转，缩放，位移等操作。<code>Sprite</code>同时也是容器类，可用来添加多个子节点。</p>
      * <p>注意： <code>Sprite</code> 默认没有宽高，可以通过<code>getBounds</code>函数获取；也可手动设置宽高；还可以设置<code>autoSize=true</code>，然后再获取宽高。<code>Sprite</code>的宽高一般用于进行碰撞检测和排版，并不影响显示图像大小，如果需要更改显示图像大小，请使用 <code>scaleX</code> ， <code>scaleY</code> ， <code>scale</code>。</p>
      * <p> <code>Sprite</code> 默认不接受鼠标事件，即<code>mouseEnabled=false</code>，但是只要对其监听任意鼠标事件，会自动打开自己以及所有父对象的<code>mouseEnabled=true</code>。所以一般也无需手动设置<code>mouseEnabled</code>。</p>
      * <p>LayaAir引擎API设计精简巧妙。核心显示类只有一个<code>Sprite</code>。<code>Sprite</code>针对不同的情况做了渲染优化，所以保证一个类实现丰富功能的同时，又达到高性能。</p>
      *
      * @example <caption>创建了一个 <code>Sprite</code> 实例。</caption>
      * package
      * {
      * 	import laya.display.Sprite;
      * 	import laya.events.Event;
      *
      * 	public class Sprite_Example
      * 	{
      * 		private var sprite:Sprite;
      * 		private var shape:Sprite
      * 		public function Sprite_Example()
      * 		{
      * 			Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
      * 			Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
      * 			onInit();
      * 		}
      * 		private function onInit():void
      * 		{
      * 			sprite = new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
      * 			sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
      * 			sprite.x = 200;//设置 sprite 对象相对于父容器的水平方向坐标值。
      * 			sprite.y = 200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
      * 			sprite.pivotX = 0;//设置 sprite 对象的水平方法轴心点坐标。
      * 			sprite.pivotY = 0;//设置 sprite 对象的垂直方法轴心点坐标。
      * 			Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
      * 			sprite.on(Event.CLICK, this, onClickSprite);//给 sprite 对象添加点击事件侦听。

      * 			shape = new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
      * 			shape.graphics.drawRect(0, 0, 100, 100, "#ccff00", "#ff0000", 2);//绘制一个有边框的填充矩形。
      * 			shape.x = 400;//设置 shape 对象相对于父容器的水平方向坐标值。
      * 			shape.y = 200;//设置 shape 对象相对于父容器的垂直方向坐标值。
      * 			shape.width = 100;//设置 shape 对象的宽度。
      * 			shape.height = 100;//设置 shape 对象的高度。
      * 			shape.pivotX = 50;//设置 shape 对象的水平方法轴心点坐标。
      * 			shape.pivotY = 50;//设置 shape 对象的垂直方法轴心点坐标。
      * 			Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
      * 			shape.on(Event.CLICK, this, onClickShape);//给 shape 对象添加点击事件侦听。
      * 		}
      * 		private function onClickSprite():void
      * 		{
      * 			trace("点击 sprite 对象。");
      * 			sprite.rotation += 5;//旋转 sprite 对象。
      * 		}
      * 		private function onClickShape():void
      * 		{
      * 			trace("点击 shape 对象。");
      * 			shape.rotation += 5;//旋转 shape 对象。
      * 		}
      * 	}
      * }
      *
      * @example
      * var sprite;
      * var shape;
      * Sprite_Example();
      * function Sprite_Example()
      * {
      *     Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
      *     Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
      *     onInit();
      * }
      * function onInit()
      * {
      *     sprite = new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
      *     sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
      *     sprite.x = 200;//设置 sprite 对象相对于父容器的水平方向坐标值。
      *     sprite.y = 200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
      *     sprite.pivotX = 0;//设置 sprite 对象的水平方法轴心点坐标。
      *     sprite.pivotY = 0;//设置 sprite 对象的垂直方法轴心点坐标。
      *     Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
      *     sprite.on(Event.CLICK, this, onClickSprite);//给 sprite 对象添加点击事件侦听。

      *     shape = new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
      *     shape.graphics.drawRect(0, 0, 100, 100, "#ccff00", "#ff0000", 2);//绘制一个有边框的填充矩形。
      *     shape.x = 400;//设置 shape 对象相对于父容器的水平方向坐标值。
      *     shape.y = 200;//设置 shape 对象相对于父容器的垂直方向坐标值。
      *     shape.width = 100;//设置 shape 对象的宽度。
      *     shape.height = 100;//设置 shape 对象的高度。
      *     shape.pivotX = 50;//设置 shape 对象的水平方法轴心点坐标。
      *     shape.pivotY = 50;//设置 shape 对象的垂直方法轴心点坐标。
      *     Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
      *     shape.on(laya.events.Event.CLICK, this, onClickShape);//给 shape 对象添加点击事件侦听。
      * }
      * function onClickSprite()
      * {
      *     console.log("点击 sprite 对象。");
      *     sprite.rotation += 5;//旋转 sprite 对象。
      * }
      * function onClickShape()
      * {
      *     console.log("点击 shape 对象。");
      *     shape.rotation += 5;//旋转 shape 对象。
      * }
      *
      * @example
      * import Sprite = laya.display.Sprite;
      * class Sprite_Example {
      *     private sprite: Sprite;
      *     private shape: Sprite
      *     public Sprite_Example() {
      *         Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
      *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
      *         this.onInit();
      *     }
      *     private onInit(): void {
      *         this.sprite = new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
      *         this.sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
      *         this.sprite.x = 200;//设置 sprite 对象相对于父容器的水平方向坐标值。
      *         this.sprite.y = 200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
      *         this.sprite.pivotX = 0;//设置 sprite 对象的水平方法轴心点坐标。
      *         this.sprite.pivotY = 0;//设置 sprite 对象的垂直方法轴心点坐标。
      *         Laya.stage.addChild(this.sprite);//将此 sprite 对象添加到显示列表。
      *         this.sprite.on(laya.events.Event.CLICK, this, this.onClickSprite);//给 sprite 对象添加点击事件侦听。

      *         this.shape = new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
      *         this.shape.graphics.drawRect(0, 0, 100, 100, "#ccff00", "#ff0000", 2);//绘制一个有边框的填充矩形。
      *         this.shape.x = 400;//设置 shape 对象相对于父容器的水平方向坐标值。
      *         this.shape.y = 200;//设置 shape 对象相对于父容器的垂直方向坐标值。
      *         this.shape.width = 100;//设置 shape 对象的宽度。
      *         this.shape.height = 100;//设置 shape 对象的高度。
      *         this.shape.pivotX = 50;//设置 shape 对象的水平方法轴心点坐标。
      *         this.shape.pivotY = 50;//设置 shape 对象的垂直方法轴心点坐标。
      *         Laya.stage.addChild(this.shape);//将此 shape 对象添加到显示列表。
      *         this.shape.on(laya.events.Event.CLICK, this, this.onClickShape);//给 shape 对象添加点击事件侦听。
      *     }
      *     private onClickSprite(): void {
      *         console.log("点击 sprite 对象。");
      *         this.sprite.rotation += 5;//旋转 sprite 对象。
      *     }
      *     private onClickShape(): void {
      *         console.log("点击 shape 对象。");
      *         this.shape.rotation += 5;//旋转 shape 对象。
      *     }
      * }
      */
     class Sprite extends Node {
         constructor() {
             super();
             /**@private */
             this._x = 0;
             /**@private */
             this._y = 0;
             /**@private */
             this._width = 0;
             /**@private */
             this._height = 0;
             /**@private */
             this._visible = true;
             /**@private 鼠标状态，0:auto,1:mouseEnabled=false,2:mouseEnabled=true。*/
             this._mouseState = 0;
             /**@private z排序，数值越大越靠前。*/
             this._zOrder = 0;
             /**@private */
             this._renderType = 0;
             /**@private */
             this._transform = null;
             /**@private */
             this._tfChanged = false;
             /**@private */
             this._repaint = SpriteConst.REPAINT_NONE;
             /**@private */
             this._texture = null;
             //以下变量为系统调用，请不要直接使用
             /**@private */
             this._style = SpriteStyle.EMPTY;
             /**@private */
             this._cacheStyle = CacheStyle.EMPTY;
             /**@private */
             this._boundStyle = null;
             /**@private */
             this._graphics = null;
             /**
              * <p>鼠标事件与此对象的碰撞检测是否可穿透。碰撞检测发生在鼠标事件的捕获阶段，此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象。</p>
              * <p>穿透表示鼠标事件发生的位置处于本对象绘图区域内时，才算命中，而与对象宽高和值为Rectangle对象的hitArea属性无关。如果sprite.hitArea值是HitArea对象，表示显式声明了此对象的鼠标事件响应区域，而忽略对象的宽高、mouseThrough属性。</p>
              * <p>影响对象鼠标事件响应区域的属性为：width、height、hitArea，优先级顺序为：hitArea(type:HitArea)>hitArea(type:Rectangle)>width/height。</p>
              * @default false	不可穿透，此对象的鼠标响应区域由width、height、hitArea属性决定。</p>
              */
             this.mouseThrough = false;
             /**
              * <p>指定是否自动计算宽高数据。默认值为 false 。</p>
              * <p>Sprite宽高默认为0，并且不会随着绘制内容的变化而变化，如果想根据绘制内容获取宽高，可以设置本属性为true，或者通过getBounds方法获取。设置为true，对性能有一定影响。</p>
              */
             this.autoSize = false;
             /**
              * <p>指定鼠标事件检测是优先检测自身，还是优先检测其子对象。鼠标事件检测发生在鼠标事件的捕获阶段，此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象。</p>
              * <p>如果为false，优先检测子对象，当有子对象被命中时，中断检测，获得命中目标。如果未命中任何子对象，最后再检测此对象；如果为true，则优先检测本对象，如果本对象没有被命中，直接中断检测，表示没有命中目标；如果本对象被命中，则进一步递归检测其子对象，以确认最终的命中目标。</p>
              * <p>合理使用本属性，能减少鼠标事件检测的节点，提高性能。可以设置为true的情况：开发者并不关心此节点的子节点的鼠标事件检测结果，也就是以此节点作为其子节点的鼠标事件检测依据。</p>
              * <p>Stage对象和UI的View组件默认为true。</p>
              * @default false	优先检测此对象的子对象，当递归检测完所有子对象后，仍然没有找到目标对象，最后再检测此对象。
              */
             this.hitTestPrior = false;
         }
         /**@inheritDoc */
         /*override*/ destroy(destroyChild = true) {
             super.destroy(destroyChild);
             this._style && this._style.recover();
             this._cacheStyle && this._cacheStyle.recover();
             this._boundStyle && this._boundStyle.recover();
             this._style = null;
             this._cacheStyle = null;
             this._boundStyle = null;
             this._transform = null;
             if (this._graphics && this._graphics.autoDestroy) {
                 this._graphics.destroy();
             }
             this._graphics = null;
             this.texture = null;
         }
         /**根据zOrder进行重新排序。*/
         updateZOrder() {
             Utils.updateOrder(this._children) && this.repaint();
         }
         /**
          * @private
          */
         _getBoundsStyle() {
             if (!this._boundStyle)
                 this._boundStyle = BoundsStyle.create();
             return this._boundStyle;
         }
         /**@private */
         _setCustomRender() {
         }
         /**
          * 设置是否开启自定义渲染，只有开启自定义渲染，才能使用customRender函数渲染。
          */
         set customRenderEnable(b) {
             if (b) {
                 this._renderType |= SpriteConst.CUSTOM;
                 this._setRenderType(this._renderType);
                 this._setCustomRender();
             }
         }
         /**
          * <p>指定显示对象是否缓存为静态图像，cacheAs时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。</p>
          * <p>建议把不经常变化的“复杂内容”缓存为静态图像，能极大提高渲染性能。cacheAs有"none"，"normal"和"bitmap"三个值可选。
          * <li>默认为"none"，不做任何缓存。</li>
          * <li>当值为"normal"时，canvas模式下进行画布缓存，webgl模式下进行命令缓存。</li>
          * <li>当值为"bitmap"时，canvas模式下进行依然是画布缓存，webgl模式下使用renderTarget缓存。</li></p>
          * <p>webgl下renderTarget缓存模式缺点：会额外创建renderTarget对象，增加内存开销，缓存面积有最大2048限制，不断重绘时会增加CPU开销。优点：大幅减少drawcall，渲染性能最高。
          * webgl下命令缓存模式缺点：只会减少节点遍历及命令组织，不会减少drawcall数，性能中等。优点：没有额外内存开销，无需renderTarget支持。</p>
          */
         get cacheAs() {
             return this._cacheStyle.cacheAs;
         }
         /**@private */
         _setCacheAs(value) {
             //_dataf32[SpriteConst.POSCACHE] = value == "bitmap"?2:(value == "normal"?1:0);
         }
         set cacheAs(value) {
             if (value === this._cacheStyle.userSetCache)
                 return;
             if (this.mask && value === 'normal')
                 return;
             this._setCacheAs(value);
             this._getCacheStyle().userSetCache = value;
             this._checkCanvasEnable();
             this.repaint();
         }
         /**
          * 更新_cnavas相关的状态
          */
         _checkCanvasEnable() {
             var tEnable = this._cacheStyle.needEnableCanvasRender();
             this._getCacheStyle().enableCanvasRender = tEnable;
             if (tEnable) {
                 if (this._cacheStyle.needBitmapCache()) {
                     this._cacheStyle.cacheAs = "bitmap";
                 }
                 else {
                     this._cacheStyle.cacheAs = this._cacheStyle.userSetCache;
                 }
                 this._cacheStyle.reCache = true;
                 this._renderType |= SpriteConst.CANVAS;
             }
             else {
                 this._cacheStyle.cacheAs = "none";
                 this._cacheStyle.releaseContext();
                 this._renderType &= ~SpriteConst.CANVAS;
             }
             this._setCacheAs(this._cacheStyle.cacheAs);
             this._setRenderType(this._renderType);
         }
         /**设置cacheAs为非空时此值才有效，staticCache=true时，子对象变化时不会自动更新缓存，只能通过调用reCache方法手动刷新。*/
         get staticCache() {
             return this._cacheStyle.staticCache;
         }
         set staticCache(value) {
             this._getCacheStyle().staticCache = value;
             if (!value)
                 this.reCache();
         }
         /**在设置cacheAs的情况下，调用此方法会重新刷新缓存。*/
         reCache() {
             this._cacheStyle.reCache = true;
             this._repaint |= SpriteConst.REPAINT_CACHE;
         }
         getRepaint() {
             return this._repaint;
         }
         /**@private */
         _setX(value) {
             this._x = value;
         }
         /**@private */
         _setY(value) {
             this._y = value;
         }
         /**@private */
         _setWidth(texture, value) {
         }
         /**@private */
         _setHeight(texture, value) {
         }
         /**表示显示对象相对于父容器的水平方向坐标值。*/
         get x() {
             return this._x;
         }
         set x(value) {
             if (this.destroyed)
                 return;
             if (this._x !== value) {
                 this._setX(value);
                 //_setTranformChange();
                 this.parentRepaint(SpriteConst.REPAINT_CACHE);
                 var p = this._cacheStyle.maskParent;
                 if (p) {
                     p.repaint(SpriteConst.REPAINT_CACHE);
                 }
             }
         }
         /**表示显示对象相对于父容器的垂直方向坐标值。*/
         get y() {
             return this._y;
         }
         set y(value) {
             if (this.destroyed)
                 return;
             if (this._y !== value) {
                 this._setY(value);
                 //_setTranformChange();
                 this.parentRepaint(SpriteConst.REPAINT_CACHE);
                 var p = this._cacheStyle.maskParent;
                 if (p) {
                     p.repaint(SpriteConst.REPAINT_CACHE);
                 }
             }
         }
         /**
          * <p>显示对象的宽度，单位为像素，默认为0。</p>
          * <p>此宽度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
          * <p>可以通过getbounds获取显示对象图像的实际宽度。</p>
          */
         get width() {
             return this.get_width();
         }
         set width(value) {
             this.set_width(value);
         }
         // for ts
         set_width(value) {
             if (this._width !== value) {
                 this._width = value;
                 this._setWidth(this.texture, value);
                 this._setTranformChange();
                 //repaint();
             }
         }
         get_width() {
             if (!this.autoSize)
                 return this._width || (this.texture ? this.texture.width : 0);
             if (this.texture)
                 return this.texture.width;
             if (!this._graphics && this._children.length === 0)
                 return 0;
             return this.getSelfBounds().width;
         }
         /**
          * <p>显示对象的高度，单位为像素，默认为0。</p>
          * <p>此高度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
          * <p>可以通过getbounds获取显示对象图像的实际高度。</p>
          */
         get height() {
             return this.get_height();
         }
         set height(value) {
             this.set_height(value);
         }
         // for ts
         set_height(value) {
             if (this._height !== value) {
                 this._height = value;
                 this._setHeight(this.texture, value);
                 this._setTranformChange();
                 //repaint();
             }
         }
         get_height() {
             if (!this.autoSize)
                 return this._height || (this.texture ? this.texture.height : 0);
             if (this.texture)
                 return this.texture.height;
             if (!this._graphics && this._children.length === 0)
                 return 0;
             return this.getSelfBounds().height;
         }
         /**
          * <p>对象的显示宽度（以像素为单位）。</p>
          */
         get displayWidth() {
             return this.width * this.scaleX;
         }
         /**
          * <p>对象的显示高度（以像素为单位）。</p>
          */
         get displayHeight() {
             return this.height * this.scaleY;
         }
         /**
          * 设置对象bounds大小，如果有设置，则不再通过getBounds计算，合理使用能提高性能。
          * @param	bound bounds矩形区域
          */
         setSelfBounds(bound) {
             this._getBoundsStyle().userBounds = bound;
         }
         /**
          * <p>获取本对象在父容器坐标系的矩形显示区域。</p>
          * <p><b>注意：</b>计算量较大，尽量少用。</p>
          * @return 矩形区域。
          */
         getBounds() {
             return this._getBoundsStyle().bounds = Rectangle._getWrapRec(this._boundPointsToParent());
         }
         /**
          * 获取本对象在自己坐标系的矩形显示区域。
          * <p><b>注意：</b>计算量较大，尽量少用。</p>
          * @return 矩形区域。
          */
         getSelfBounds() {
             if (this._boundStyle && this._boundStyle.userBounds)
                 return this._boundStyle.userBounds;
             if (!this._graphics && this._children.length === 0 && !this._texture)
                 return Rectangle.TEMP.setTo(0, 0, 0, 0);
             //if (_renderType === (SpriteConst.IMAGE | SpriteConst.GRAPHICS)) {
             //_getBoundsStyle();
             //if (!_boundStyle.bounds) _boundStyle.bounds = Rectangle.create();
             //var tDrawCmd:Array = _graphics._one;
             //return _boundStyle.bounds.setTo(tDrawCmd[1], tDrawCmd[2], tDrawCmd[3], tDrawCmd[4]);
             //}
             return this._getBoundsStyle().bounds = Rectangle._getWrapRec(this._getBoundPointsM(false));
         }
         /**
          * @private
          * 获取本对象在父容器坐标系的显示区域多边形顶点列表。
          * 当显示对象链中有旋转时，返回多边形顶点列表，无旋转时返回矩形的四个顶点。
          * @param ifRotate	（可选）之前的对象链中是否有旋转。
          * @return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
          */
         _boundPointsToParent(ifRotate = false) {
             var pX = 0, pY = 0;
             if (this._style) {
                 pX = this.pivotX;
                 pY = this.pivotY;
                 ifRotate = ifRotate || (this._style.rotation !== 0);
                 if (this._style.scrollRect) {
                     pX += this._style.scrollRect.x;
                     pY += this._style.scrollRect.y;
                 }
             }
             var pList = this._getBoundPointsM(ifRotate);
             if (!pList || pList.length < 1)
                 return pList;
             if (pList.length != 8) {
                 pList = ifRotate ? GrahamScan.scanPList(pList) : Rectangle._getWrapRec(pList, Rectangle.TEMP)._getBoundPoints();
             }
             if (!this.transform) {
                 Utils.transPointList(pList, this._x - pX, this._y - pY);
                 return pList;
             }
             var tPoint = Point.TEMP;
             var i, len = pList.length;
             for (i = 0; i < len; i += 2) {
                 tPoint.x = pList[i];
                 tPoint.y = pList[i + 1];
                 this.toParentPoint(tPoint);
                 pList[i] = tPoint.x;
                 pList[i + 1] = tPoint.y;
             }
             return pList;
         }
         /**
          * 返回此实例中的绘图对象（ <code>Graphics</code> ）的显示区域，不包括子对象。
          * @param realSize	（可选）使用图片的真实大小，默认为false
          * @return 一个 Rectangle 对象，表示获取到的显示区域。
          */
         getGraphicBounds(realSize = false) {
             if (!this._graphics)
                 return Rectangle.TEMP.setTo(0, 0, 0, 0);
             return this._graphics.getBounds(realSize);
         }
         /**
          * @private
          * 获取自己坐标系的显示区域多边形顶点列表
          * @param ifRotate	（可选）当前的显示对象链是否由旋转
          * @return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
          */
         _getBoundPointsM(ifRotate = false) {
             if (this._boundStyle && this._boundStyle.userBounds)
                 return this._boundStyle.userBounds._getBoundPoints();
             if (!this._boundStyle)
                 this._getBoundsStyle();
             if (!this._boundStyle.temBM)
                 this._boundStyle.temBM = [];
             if (this._style.scrollRect) {
                 var rst = Utils.clearArray(this._boundStyle.temBM);
                 var rec = Rectangle.TEMP;
                 rec.copyFrom(this._style.scrollRect);
                 Utils.concatArray(rst, rec._getBoundPoints());
                 return rst;
             }
             var pList;
             if (this._graphics) {
                 pList = this._graphics.getBoundPoints();
             }
             else {
                 pList = Utils.clearArray(this._boundStyle.temBM);
                 if (this._texture) {
                     rec = Rectangle.TEMP;
                     rec.setTo(0, 0, this.width || this._texture.width, this.height || this._texture.height);
                     Utils.concatArray(pList, rec._getBoundPoints());
                 }
             }
             //处理子对象区域
             var child;
             var cList;
             var __childs;
             __childs = this._children;
             for (var i = 0, n = __childs.length; i < n; i++) {
                 //child = getChildAt(i) as Sprite; 
                 child = __childs[i];
                 if (child instanceof Sprite && child._visible === true) {
                     cList = child._boundPointsToParent(ifRotate);
                     if (cList)
                         pList = pList ? Utils.concatArray(pList, cList) : cList;
                 }
             }
             return pList;
         }
         /**
          * @private
          * 获取cache数据。
          * @return  cache数据 CacheStyle 。
          */
         _getCacheStyle() {
             this._cacheStyle === CacheStyle.EMPTY && (this._cacheStyle = CacheStyle.create());
             return this._cacheStyle;
         }
         /**
          * @private
          * 获取样式。
          * @return  样式 Style 。
          */
         getStyle() {
             this._style === SpriteStyle.EMPTY && (this._style = SpriteStyle.create());
             return this._style;
         }
         /**
          * @private
          * 设置样式。
          * @param	value 样式。
          */
         setStyle(value) {
             this._style = value;
         }
         /**X轴缩放值，默认值为1。设置为负数，可以实现水平反转效果，比如scaleX=-1。*/
         get scaleX() {
             return this._style.scaleX;
         }
         set scaleX(value) {
             this.set_scaleX(value);
         }
         /**@private */
         _setScaleX(value) {
             this._style.scaleX = value;
         }
         /**Y轴缩放值，默认值为1。设置为负数，可以实现垂直反转效果，比如scaleX=-1。*/
         get scaleY() {
             return this._style.scaleY;
         }
         set scaleY(value) {
             this.set_scaleY(value);
         }
         /**@private */
         _setScaleY(value) {
             this._style.scaleY = value;
         }
         set_scaleX(value) {
             var style = this.getStyle();
             if (style.scaleX !== value) {
                 this._setScaleX(value);
                 this._setTranformChange();
             }
         }
         get_scaleX() {
             return this._style.scaleX;
         }
         set_scaleY(value) {
             var style = this.getStyle();
             if (style.scaleY !== value) {
                 this._setScaleY(value);
                 this._setTranformChange();
             }
         }
         get_scaleY() {
             return this._style.scaleY;
         }
         /**旋转角度，默认值为0。以角度为单位。*/
         get rotation() {
             return this._style.rotation;
         }
         set rotation(value) {
             var style = this.getStyle();
             if (style.rotation !== value) {
                 this._setRotation(value);
                 this._setTranformChange();
             }
         }
         /**@private */
         _setRotation(value) {
             this._style.rotation = value;
         }
         /**水平倾斜角度，默认值为0。以角度为单位。*/
         get skewX() {
             return this._style.skewX;
         }
         set skewX(value) {
             var style = this.getStyle();
             if (style.skewX !== value) {
                 this._setSkewX(value);
                 this._setTranformChange();
             }
         }
         /**@private */
         _setSkewX(value) {
             this._style.skewX = value;
         }
         /**垂直倾斜角度，默认值为0。以角度为单位。*/
         get skewY() {
             return this._style.skewY;
         }
         set skewY(value) {
             var style = this.getStyle();
             if (style.skewY !== value) {
                 this._setSkewY(value);
                 this._setTranformChange();
             }
         }
         /**@private */
         _setSkewY(value) {
             this._style.skewY = value;
         }
         /**@private */
         _createTransform() {
             return Matrix.create();
         }
         /**@private */
         _adjustTransform() {
             this._tfChanged = false;
             var style = this._style;
             var sx = style.scaleX, sy = style.scaleY;
             var sskx = style.skewX;
             var ssky = style.skewY;
             var rot = style.rotation;
             var m = this._transform || (this._transform = this._createTransform());
             if (rot || sx !== 1 || sy !== 1 || sskx !== 0 || ssky !== 0) {
                 m._bTransform = true;
                 var skx = (rot - sskx) * 0.0174532922222222; //laya.CONST.PI180;
                 var sky = (rot + ssky) * 0.0174532922222222;
                 var cx = Math.cos(sky);
                 var ssx = Math.sin(sky);
                 var cy = Math.sin(skx);
                 var ssy = Math.cos(skx);
                 m.a = sx * cx;
                 m.b = sx * ssx;
                 m.c = -sy * cy;
                 m.d = sy * ssy;
                 m.tx = m.ty = 0;
             }
             else {
                 m.identity();
                 this._renderType &= ~SpriteConst.TRANSFORM;
                 this._setRenderType(this._renderType);
             }
             return m;
         }
         /**@private */
         _setTransform(value) {
         }
         /**
          * <p>对象的矩阵信息。通过设置矩阵可以实现节点旋转，缩放，位移效果。</p>
          * <p>矩阵更多信息请参考 <code>Matrix</code></p>
          */
         get transform() {
             return this._tfChanged ? this._adjustTransform() : this._transform;
         }
         set transform(value) {
             this.set_transform(value);
         }
         get_transform() {
             return this._tfChanged ? this._adjustTransform() : this._transform;
         }
         set_transform(value) {
             this._tfChanged = false;
             var m = this._transform || (this._transform = this._createTransform());
             value.copyTo(m);
             this._setTransform(m);
             //设置transform时重置x,y
             if (value) {
                 this._x = m.tx;
                 this._y = m.ty;
                 m.tx = m.ty = 0;
             }
             if (value)
                 this._renderType |= SpriteConst.TRANSFORM;
             else {
                 this._renderType &= ~SpriteConst.TRANSFORM;
             }
             this._setRenderType(this._renderType);
             this.parentRepaint();
         }
         /**@private */
         _setPivotX(value) {
             var style = this.getStyle();
             style.pivotX = value;
         }
         /**@private */
         _getPivotX() {
             return this._style.pivotX;
         }
         /**@private */
         _setPivotY(value) {
             var style = this.getStyle();
             style.pivotY = value;
         }
         /**@private */
         _getPivotY() {
             return this._style.pivotY;
         }
         /**X轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
         get pivotX() {
             return this._getPivotX();
         }
         set pivotX(value) {
             this._setPivotX(value);
             this.repaint();
         }
         /**Y轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
         get pivotY() {
             return this._getPivotY();
         }
         set pivotY(value) {
             this._setPivotY(value);
             this.repaint();
         }
         /**@private */
         _setAlpha(value) {
             if (this._style.alpha !== value) {
                 var style = this.getStyle();
                 style.alpha = value;
                 if (value !== 1)
                     this._renderType |= SpriteConst.ALPHA;
                 else
                     this._renderType &= ~SpriteConst.ALPHA;
                 this._setRenderType(this._renderType);
                 this.parentRepaint();
             }
         }
         /**@private */
         _getAlpha() {
             return this._style.alpha;
         }
         /**透明度，值为0-1，默认值为1，表示不透明。更改alpha值会影响drawcall。*/
         get alpha() {
             return this._getAlpha();
         }
         set alpha(value) {
             value = value < 0 ? 0 : (value > 1 ? 1 : value);
             this._setAlpha(value);
         }
         /**表示是否可见，默认为true。如果设置不可见，节点将不被渲染。*/
         get visible() {
             return this.get_visible();
         }
         set visible(value) {
             this.set_visible(value);
         }
         get_visible() {
             return this._visible;
         }
         set_visible(value) {
             if (this._visible !== value) {
                 this._visible = value;
                 this.parentRepaint(SpriteConst.REPAINT_ALL);
             }
         }
         /**@private */
         _setBlendMode(value) {
         }
         /**指定要使用的混合模式。目前只支持"lighter"。*/
         get blendMode() {
             return this._style.blendMode;
         }
         set blendMode(value) {
             this._setBlendMode(value);
             this.getStyle().blendMode = value;
             if (value && value != "source-over")
                 this._renderType |= SpriteConst.BLEND;
             else
                 this._renderType &= ~SpriteConst.BLEND;
             this._setRenderType(this._renderType);
             this.parentRepaint();
         }
         /**绘图对象。封装了绘制位图和矢量图的接口，Sprite所有的绘图操作都通过Graphics来实现的。*/
         get graphics() {
             if (!this._graphics) {
                 this.graphics = new Graphics();
                 this._graphics.autoDestroy = true;
             }
             return this._graphics;
         }
         /**@private */
         _setGraphics(value) {
         }
         /**@private */
         _setGraphicsCallBack() {
         }
         set graphics(value) {
             if (this._graphics)
                 this._graphics._sp = null;
             this._graphics = value;
             if (value) {
                 this._setGraphics(value);
                 this._renderType |= SpriteConst.GRAPHICS;
                 value._sp = this;
             }
             else {
                 this._renderType &= ~SpriteConst.GRAPHICS;
             }
             this._setRenderType(this._renderType);
             this.repaint();
         }
         /**
          * <p>显示对象的滚动矩形范围，具有裁剪效果(如果只想限制子对象渲染区域，请使用viewport)</p>
          * <p> srollRect和viewport的区别：<br/>
          * 1.srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
          * 2.设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
          */
         get scrollRect() {
             return this._style.scrollRect;
         }
         /**@private */
         _setScrollRect(value) {
         }
         set scrollRect(value) {
             this.getStyle().scrollRect = value;
             this._setScrollRect(value);
             //viewport = value;
             this.repaint();
             if (value) {
                 this._renderType |= SpriteConst.CLIP;
             }
             else {
                 this._renderType &= ~SpriteConst.CLIP;
             }
             this._setRenderType(this._renderType);
         }
         /**
          * <p>设置坐标位置。相当于分别设置x和y属性。</p>
          * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pos(...).scale(...);</p>
          * @param	x			X轴坐标。
          * @param	y			Y轴坐标。
          * @param 	speedMode	（可选）是否极速模式，正常是调用this.x=value进行赋值，极速模式直接调用内部函数处理，如果未重写x,y属性，建议设置为急速模式性能更高。
          * @return	返回对象本身。
          */
         pos(x, y, speedMode = false) {
             if (this._x !== x || this._y !== y) {
                 if (this.destroyed)
                     return this;
                 if (speedMode) {
                     this._setX(x);
                     this._setY(y);
                     this.parentRepaint(SpriteConst.REPAINT_CACHE);
                     var p = this._cacheStyle.maskParent;
                     if (p) {
                         p.repaint(SpriteConst.REPAINT_CACHE);
                     }
                 }
                 else {
                     this.x = x;
                     this.y = y;
                 }
             }
             return this;
         }
         /**
          * <p>设置轴心点。相当于分别设置pivotX和pivotY属性。</p>
          * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pivot(...).pos(50, 100);</p>
          * @param	x X轴心点。
          * @param	y Y轴心点。
          * @return	返回对象本身。
          */
         pivot(x, y) {
             this.pivotX = x;
             this.pivotY = y;
             return this;
         }
         /**
          * <p>设置宽高。相当于分别设置width和height属性。</p>
          * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.size(...).pos(50, 100);</p>
          * @param	width 宽度值。
          * @param	hegiht 高度值。
          * @return	返回对象本身。
          */
         size(width, height) {
             this.width = width;
             this.height = height;
             return this;
         }
         /**
          * <p>设置缩放。相当于分别设置scaleX和scaleY属性。</p>
          * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.scale(...).pos(50, 100);</p>
          * @param	scaleX		X轴缩放比例。
          * @param	scaleY		Y轴缩放比例。
          * @param 	speedMode	（可选）是否极速模式，正常是调用this.scaleX=value进行赋值，极速模式直接调用内部函数处理，如果未重写scaleX,scaleY属性，建议设置为急速模式性能更高。
          * @return	返回对象本身。
          */
         scale(scaleX, scaleY, speedMode = false) {
             var style = this.getStyle();
             if (style.scaleX != scaleX || style.scaleY != scaleY) {
                 if (this.destroyed)
                     return this;
                 if (speedMode) {
                     this._setScaleX(scaleX);
                     this._setScaleY(scaleY);
                     this._setTranformChange();
                 }
                 else {
                     this.scaleX = scaleX;
                     this.scaleY = scaleY;
                 }
             }
             return this;
         }
         /**
          * <p>设置倾斜角度。相当于分别设置skewX和skewY属性。</p>
          * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.skew(...).pos(50, 100);</p>
          * @param	skewX 水平倾斜角度。
          * @param	skewY 垂直倾斜角度。
          * @return	返回对象本身
          */
         skew(skewX, skewY) {
             this.skewX = skewX;
             this.skewY = skewY;
             return this;
         }
         /**
          * 更新、呈现显示对象。由系统调用。
          * @param	context 渲染的上下文引用。
          * @param	x X轴坐标。
          * @param	y Y轴坐标。
          */
         render(ctx, x, y) {
             RenderSprite.renders[this._renderType]._fun(this, ctx, x + this._x, y + this._y);
             /*
             var rt:int = _renderType;
             var style:SpriteStyle = _style;
             var oldAlpha:Number = ctx.globalAlpha;
             var save:Boolean = false;
             if (rt & SpriteConst.TRANSFORM ) {
                 ctx.save();
                 save = true;
                 ctx.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x+_x, transform.ty + y+_y);
             }
             
             if ( rt & SpriteConst.ALPHA) {
                 var alpha:Number = style.alpha;
                 if (alpha > 0.01 || _needRepaint()) {
                     //var temp:Number = context.globalAlpha;
                     ctx.globalAlpha *= alpha;
                     //context.globalAlpha = temp;
                 }
             }
             
             if ( rt & SpriteConst.TEXTURE ) {
                 var tex:Texture = texture;
                 ctx.drawTexture(tex, x-pivotX+_x, y-pivotY+_y, tex.width, tex.height);
             }
             
             if ( rt & SpriteConst.GRAPHICS) {
                 _graphics && _graphics._render(this, ctx, x-pivotX+_x, y-pivotY+_y);
             }
             
             if (_children.length) {
                 _children.forEach(function(c:Sprite) {
                     c._visible && c.render(ctx, x - pivotX+_x, y - pivotY+_y);
                 } );
             }
             ctx.globalAlpha = oldAlpha;//TODO 可能慢
             if (save) {
                 ctx.restore();
             }
             */
             this._repaint = 0;
         }
         /**
          * <p>绘制 当前<code>Sprite</code> 到 <code>Canvas</code> 上，并返回一个HtmlCanvas。</p>
          * <p>绘制的结果可以当作图片源，再次绘制到其他Sprite里面，示例：</p>
          *
          * var htmlCanvas:HTMLCanvas = sprite.drawToCanvas(100, 100, 0, 0);//把精灵绘制到canvas上面
          * var sp:Sprite = new Sprite();//创建精灵
          * sp.graphics.drawTexture(htmlCanvas.getTexture());//把截图绘制到精灵上
          * Laya.stage.addChild(sp);//把精灵显示到舞台
          *
          * <p>也可以获取原始图片数据，分享到网上，从而实现截图效果，示例：</p>
          *
          * var htmlCanvas:HTMLCanvas = sprite.drawToCanvas(100, 100, 0, 0);//把精灵绘制到canvas上面
          * htmlCanvas.toBase64("image/png",0.9);//打印图片base64信息，可以发给服务器或者保存为图片
          *
          * @param	canvasWidth 画布宽度。
          * @param	canvasHeight 画布高度。
          * @param	x 绘制的 X 轴偏移量。
          * @param	y 绘制的 Y 轴偏移量。
          * @return  HTMLCanvas 对象。
          */
         drawToCanvas(canvasWidth, canvasHeight, offsetX, offsetY) {
             //console.log('drawToCanvas is deprecated, please use drawToTexture');
             return Sprite.drawToCanvas(this, this._renderType, canvasWidth, canvasHeight, offsetX, offsetY);
         }
         /**
          * 绘制到一个Texture对象
          * @param canvasWidth
          * @param canvasHeight
          * @param offsetX
          * @param offsetY
          */
         drawToTexture(canvasWidth, canvasHeight, offsetX, offsetY) {
             return Sprite.drawToTexture(this, this._renderType, canvasWidth, canvasHeight, offsetX, offsetY);
         }
         /**
          * <p>自定义更新、呈现显示对象。一般用来扩展渲染模式，请合理使用，可能会导致在加速器上无法渲染。</p>
          * <p><b>注意</b>不要在此函数内增加或删除树节点，否则会对树节点遍历造成影响。</p>
          * @param	context  渲染的上下文引用。
          * @param	x X轴坐标。
          * @param	y Y轴坐标。
          */
         customRender(context, x, y) {
             //_renderType |= SpriteConst.CUSTOM;
             //_setRenderType(_renderType);
             this._repaint = SpriteConst.REPAINT_ALL;
         }
         /**
          * @private
          * 应用滤镜。
          */
         _applyFilters() {
             // canvas 模式不支持
         }
         /**滤镜集合。可以设置多个滤镜组合。*/
         get filters() {
             return this._cacheStyle.filters;
         }
         /**@private */
         _setColorFilter(value) { }
         set filters(value) {
             value && value.length === 0 && (value = null);
             if (this._cacheStyle.filters == value)
                 return;
             this._getCacheStyle().filters = value ? value.slice() : null;
             if (value && value.length) {
                 //temp TODO 
                 this._setColorFilter(value[0]);
                 this._renderType |= SpriteConst.FILTERS;
             }
             else {
                 this._setColorFilter(null);
                 this._renderType &= ~SpriteConst.FILTERS;
             }
             this._setRenderType(this._renderType);
             if (value && value.length > 0) {
                 if (!this._getBit(Const.DISPLAY))
                     this._setBitUp(Const.DISPLAY);
                 if (!(value.length == 1 && (value[0] instanceof ColorFilter))) {
                     this._getCacheStyle().cacheForFilters = true;
                     this._checkCanvasEnable();
                 }
             }
             else {
                 if (this._cacheStyle.cacheForFilters) {
                     this._cacheStyle.cacheForFilters = false;
                     this._checkCanvasEnable();
                 }
             }
             this._getCacheStyle().hasGlowFilter = this._isHaveGlowFilter();
             this.repaint();
         }
         /**
          * @private
          * 查看当前原件中是否包含发光滤镜。
          * @return 一个 Boolean 值，表示当前原件中是否包含发光滤镜。
          */
         _isHaveGlowFilter() {
             var i, len;
             if (this.filters) {
                 for (i = 0; i < this.filters.length; i++) {
                     if (this.filters[i].type == Filter.GLOW) {
                         return true;
                     }
                 }
             }
             for (i = 0, len = this._children.length; i < len; i++) {
                 if (this._children[i]._isHaveGlowFilter()) {
                     return true;
                 }
             }
             return false;
         }
         /**
          * 把本地坐标转换为相对stage的全局坐标。
          * @param point				本地坐标点。
          * @param createNewPoint	（可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
          * @param globalNode		global节点，默认为Laya.stage
          * @return 转换后的坐标的点。
          */
         localToGlobal(point, createNewPoint = false, globalNode = null) {
             //if (!_displayedInStage || !point) return point;
             if (createNewPoint === true) {
                 point = new Point(point.x, point.y);
             }
             var ele = this;
             globalNode = globalNode || ILaya.stage;
             while (ele && !ele.destroyed) {
                 if (ele == globalNode)
                     break;
                 point = ele.toParentPoint(point);
                 ele = ele.parent;
             }
             return point;
         }
         /**
          * 把stage的全局坐标转换为本地坐标。
          * @param point				全局坐标点。
          * @param createNewPoint	（可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
          * @param globalNode		global节点，默认为Laya.stage
          * @return 转换后的坐标的点。
          */
         globalToLocal(point, createNewPoint = false, globalNode = null) {
             //if (!_displayedInStage || !point) return point;
             if (createNewPoint) {
                 point = new Point(point.x, point.y);
             }
             var ele = this;
             var list = [];
             globalNode = globalNode || ILaya.stage;
             while (ele && !ele.destroyed) {
                 if (ele == globalNode)
                     break;
                 list.push(ele);
                 ele = ele.parent;
             }
             var i = list.length - 1;
             while (i >= 0) {
                 ele = list[i];
                 point = ele.fromParentPoint(point);
                 i--;
             }
             return point;
         }
         /**
          * 将本地坐标系坐标转转换到父容器坐标系。
          * @param point 本地坐标点。
          * @return  转换后的点。
          */
         toParentPoint(point) {
             if (!point)
                 return point;
             point.x -= this.pivotX;
             point.y -= this.pivotY;
             if (this.transform) {
                 this._transform.transformPoint(point);
             }
             point.x += this._x;
             point.y += this._y;
             var scroll = this._style.scrollRect;
             if (scroll) {
                 point.x -= scroll.x;
                 point.y -= scroll.y;
             }
             return point;
         }
         /**
          * 将父容器坐标系坐标转换到本地坐标系。
          * @param point 父容器坐标点。
          * @return  转换后的点。
          */
         fromParentPoint(point) {
             if (!point)
                 return point;
             point.x -= this._x;
             point.y -= this._y;
             var scroll = this._style.scrollRect;
             if (scroll) {
                 point.x += scroll.x;
                 point.y += scroll.y;
             }
             if (this.transform) {
                 //_transform.setTranslate(0,0);
                 this._transform.invertTransformPoint(point);
             }
             point.x += this.pivotX;
             point.y += this.pivotY;
             return point;
         }
         /**
          * 将Stage坐标系坐标转换到本地坐标系。
          * @param point 父容器坐标点。
          * @return  转换后的点。
          */
         fromStagePoint(point) {
             // TODO 没做
             return point;
         }
         /**
          * <p>增加事件侦听器，以使侦听器能够接收事件通知。</p>
          * <p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
          * @param type		事件的类型。
          * @param caller	事件侦听函数的执行域。
          * @param listener	事件侦听函数。
          * @param args		（可选）事件侦听函数的回调参数。
          * @return 此 EventDispatcher 对象。
          */
         /*override*/ on(type, caller, listener, args = null) {
             //如果是鼠标事件，则设置自己和父对象为可接受鼠标交互事件
             if (this._mouseState !== 1 && this.isMouseEvent(type)) {
                 this.mouseEnabled = true;
                 this._setBit(Const.HAS_MOUSE, true);
                 if (this._parent) {
                     this._onDisplay();
                 }
                 return this._createListener(type, caller, listener, args, false);
             }
             return super.on(type, caller, listener, args);
         }
         /**
          * <p>增加事件侦听器，以使侦听器能够接收事件通知，此侦听事件响应一次后则自动移除侦听。</p>
          * <p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
          * @param type		事件的类型。
          * @param caller	事件侦听函数的执行域。
          * @param listener	事件侦听函数。
          * @param args		（可选）事件侦听函数的回调参数。
          * @return 此 EventDispatcher 对象。
          */
         /*override*/ once(type, caller, listener, args = null) {
             //如果是鼠标事件，则设置自己和父对象为可接受鼠标交互事件
             if (this._mouseState !== 1 && this.isMouseEvent(type)) {
                 this.mouseEnabled = true;
                 this._setBit(Const.HAS_MOUSE, true);
                 if (this._parent) {
                     this._onDisplay();
                 }
                 return this._createListener(type, caller, listener, args, true);
             }
             return super.once(type, caller, listener, args);
         }
         /** @private */
         _onDisplay(v) {
             if (this._mouseState !== 1) {
                 var ele = this;
                 ele = ele.parent;
                 while (ele && ele._mouseState !== 1) {
                     if (ele._getBit(Const.HAS_MOUSE))
                         break;
                     ele.mouseEnabled = true;
                     ele._setBit(Const.HAS_MOUSE, true);
                     ele = ele.parent;
                 }
             }
         }
         /**@private */
         /*override*/ _setParent(value) {
             super._setParent(value);
             if (value && this._getBit(Const.HAS_MOUSE)) {
                 this._onDisplay();
             }
         }
         /**
          * <p>加载并显示一个图片。相当于加载图片后，设置texture属性</p>
          * <p>注意：2.0改动：多次调用，只会显示一个图片（1.0会显示多个图片）,x,y,width,height参数取消。</p>
          * @param url		图片地址。
          * @param complete	（可选）加载完成回调。
          * @return	返回精灵对象本身。
          */
         loadImage(url, complete = null) {
             if (!url) {
                 this.texture = null;
                 loaded.call(this);
             }
             else {
                 var tex = ILaya.Loader.getRes(url);
                 if (!tex) {
                     tex = new Texture();
                     tex.load(url);
                     ILaya.Loader.cacheRes(url, tex);
                 }
                 this.texture = tex;
                 if (!tex.getIsReady())
                     tex.once(Event.READY, this, loaded);
                 else
                     loaded.call(this);
             }
             function loaded() {
                 this.repaint(SpriteConst.REPAINT_ALL);
                 complete && complete.run();
             }
             return this;
         }
         /**
          * 根据图片地址创建一个新的 <code>Sprite</code> 对象用于加载并显示此图片。
          * @param	url 图片地址。
          * @return	返回新的 <code>Sprite</code> 对象。
          */
         static fromImage(url) {
             return new Sprite().loadImage(url);
         }
         /**cacheAs后，设置自己和父对象缓存失效。*/
         repaint(type = SpriteConst.REPAINT_CACHE) {
             if (!(this._repaint & type)) {
                 this._repaint |= type;
                 this.parentRepaint(type);
             }
             if (this._cacheStyle && this._cacheStyle.maskParent) {
                 this._cacheStyle.maskParent.repaint(type);
             }
         }
         /**
          * @private
          * 获取是否重新缓存。
          * @return 如果重新缓存值为 true，否则值为 false。
          */
         _needRepaint() {
             return (this._repaint & SpriteConst.REPAINT_CACHE) && this._cacheStyle.enableCanvasRender && this._cacheStyle.reCache;
         }
         /**@private	*/
         /*override*/ _childChanged(child = null) {
             if (this._children.length)
                 this._renderType |= SpriteConst.CHILDS;
             else
                 this._renderType &= ~SpriteConst.CHILDS;
             this._setRenderType(this._renderType);
             if (child && this._getBit(Const.HAS_ZORDER))
                 ILaya.systemTimer.callLater(this, this.updateZOrder);
             this.repaint(SpriteConst.REPAINT_ALL);
         }
         /**cacheAs时，设置所有父对象缓存失效。 */
         parentRepaint(type = SpriteConst.REPAINT_CACHE) {
             var p = this._parent;
             if (p && !(p._repaint & type)) {
                 p._repaint |= type;
                 p.parentRepaint(type);
             }
         }
         /**对舞台 <code>stage</code> 的引用。*/
         get stage() {
             return ILaya.stage;
         }
         /**
          * <p>可以设置一个Rectangle区域作为点击区域，或者设置一个<code>HitArea</code>实例作为点击区域，HitArea内可以设置可点击和不可点击区域。</p>
          * <p>如果不设置hitArea，则根据宽高形成的区域进行碰撞。</p>
          */
         get hitArea() {
             return this._style.hitArea;
         }
         set hitArea(value) {
             this.getStyle().hitArea = value;
         }
         /**@private */
         _setMask(value) {
         }
         /**
          * <p>遮罩，可以设置一个对象(支持位图和矢量图)，根据对象形状进行遮罩显示。</p>
          * <p>【注意】遮罩对象坐标系是相对遮罩对象本身的，和Flash机制不同</p>
          */
         get mask() {
             return this._cacheStyle.mask;
         }
         set mask(value) {
             if (value && this.mask && this.mask._cacheStyle.maskParent)
                 return;
             this._getCacheStyle().mask = value;
             this._setMask(value);
             this._checkCanvasEnable();
             if (value) {
                 value._getCacheStyle().maskParent = this;
             }
             else {
                 if (this.mask) {
                     this.mask._getCacheStyle().maskParent = null;
                 }
             }
             this._renderType |= SpriteConst.MASK;
             this._setRenderType(this._renderType);
             this.parentRepaint(SpriteConst.REPAINT_ALL);
         }
         /**
          * 是否接受鼠标事件。
          * 默认为false，如果监听鼠标事件，则会自动设置本对象及父节点的属性 mouseEnable 的值都为 true（如果父节点手动设置为false，则不会更改）。
          * */
         get mouseEnabled() {
             return this._mouseState > 1;
         }
         set mouseEnabled(value) {
             this._mouseState = value ? 2 : 1;
         }
         /**
          * 开始拖动此对象。
          * @param area				（可选）拖动区域，此区域为当前对象注册点活动区域（不包括对象宽高），可选。
          * @param hasInertia		（可选）鼠标松开后，是否还惯性滑动，默认为false，可选。
          * @param elasticDistance	（可选）橡皮筋效果的距离值，0为无橡皮筋效果，默认为0，可选。
          * @param elasticBackTime	（可选）橡皮筋回弹时间，单位为毫秒，默认为300毫秒，可选。
          * @param data				（可选）拖动事件携带的数据，可选。
          * @param disableMouseEvent	（可选）禁用其他对象的鼠标检测，默认为false，设置为true能提高性能。
          * @param ratio				（可选）惯性阻尼系数，影响惯性力度和时长。
          */
         startDrag(area = null, hasInertia = false, elasticDistance = 0, elasticBackTime = 300, data = null, disableMouseEvent = false, ratio = 0.92) {
             this._style.dragging || (this.getStyle().dragging = new ILaya.Dragging());
             this._style.dragging.start(this, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio);
         }
         /**停止拖动此对象。*/
         stopDrag() {
             this._style.dragging && this._style.dragging.stop();
         }
         /**@private */
         /*override*/ _setDisplay(value) {
             if (!value) {
                 if (this._cacheStyle) {
                     this._cacheStyle.releaseContext();
                     this._cacheStyle.releaseFilterCache();
                     if (this._cacheStyle.hasGlowFilter) {
                         this._cacheStyle.hasGlowFilter = false;
                     }
                 }
             }
             super._setDisplay(value);
         }
         /**
          * 检测某个点是否在此对象内。
          * @param	x 全局x坐标。
          * @param	y 全局y坐标。
          * @return  表示是否在对象内。
          */
         hitTestPoint(x, y) {
             var point = this.globalToLocal(Point.TEMP.setTo(x, y));
             x = point.x;
             y = point.y;
             var rect = this._style.hitArea ? this._style.hitArea : (this._width > 0 && this._height > 0) ? Rectangle.TEMP.setTo(0, 0, this._width, this._height) : this.getSelfBounds();
             return rect.contains(x, y);
         }
         /**获得相对于本对象上的鼠标坐标信息。*/
         getMousePoint() {
             return this.globalToLocal(Point.TEMP.setTo(ILaya.stage.mouseX, ILaya.stage.mouseY));
         }
         /**
          * 获得相对于stage的全局X轴缩放值（会叠加父亲节点的缩放值）。
          */
         get globalScaleX() {
             var scale = 1;
             var ele = this;
             while (ele) {
                 if (ele === ILaya.stage)
                     break;
                 scale *= ele.scaleX;
                 ele = ele.parent;
             }
             return scale;
         }
         /**
          * 获得相对于stage的全局旋转值（会叠加父亲节点的旋转值）。
          */
         get globalRotation() {
             var angle = 0;
             var ele = this;
             while (ele) {
                 if (ele === ILaya.stage)
                     break;
                 angle += ele.rotation;
                 ele = ele.parent;
             }
             return angle;
         }
         /**
          * 获得相对于stage的全局Y轴缩放值（会叠加父亲节点的缩放值）。
          */
         get globalScaleY() {
             var scale = 1;
             var ele = this;
             while (ele) {
                 if (ele === ILaya.stage)
                     break;
                 scale *= ele.scaleY;
                 ele = ele.parent;
             }
             return scale;
         }
         /**
          * 返回鼠标在此对象坐标系上的 X 轴坐标信息。
          */
         get mouseX() {
             return this.getMousePoint().x;
         }
         /**
          * 返回鼠标在此对象坐标系上的 Y 轴坐标信息。
          */
         get mouseY() {
             return this.getMousePoint().y;
         }
         /**z排序，更改此值，则会按照值的大小对同一容器的所有对象重新排序。值越大，越靠上。默认为0，则根据添加顺序排序。*/
         get zOrder() {
             return this._zOrder;
         }
         set zOrder(value) {
             if (this._zOrder != value) {
                 this._zOrder = value;
                 if (this._parent) {
                     value && this._parent._setBit(Const.HAS_ZORDER, true);
                     ILaya.systemTimer.callLater(this._parent, this.updateZOrder);
                 }
             }
         }
         /**
          * 设置一个Texture实例，并显示此图片（如果之前有其他绘制，则会被清除掉）。
          * 等同于graphics.clear();graphics.drawImage()，但性能更高
          * 还可以赋值一个图片地址，则会自动加载图片，然后显示
          */
         get texture() {
             return this._texture;
         }
         /**@private */
         _setTexture(value) {
         }
         set texture(value) {
             if (typeof (value) == 'string') {
                 this.loadImage(value);
             }
             else if (this._texture != value) {
                 this._texture && this._texture._removeReference();
                 this._texture = value;
                 value && value._addReference();
                 this._setTexture(value);
                 this._setWidth(this._texture, this.width);
                 this._setHeight(this._texture, this.height);
                 if (value)
                     this._renderType |= SpriteConst.TEXTURE;
                 else
                     this._renderType &= ~SpriteConst.TEXTURE;
                 this._setRenderType(this._renderType);
                 this.repaint();
             }
         }
         /**
          * <p>视口大小，视口外的子对象，将不被渲染(如果想实现裁剪效果，请使用srollRect)，合理使用能提高渲染性能。比如由一个个小图片拼成的地图块，viewport外面的小图片将不渲染</p>
          * <p>srollRect和viewport的区别：<br/>
          * 1. srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
          * 2. 设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
          * @default null
          */
         get viewport() {
             return this._style.viewport;
         }
         set viewport(value) {
             if (typeof (value) == 'string') {
                 var recArr;
                 recArr = value.split(",");
                 if (recArr.length > 3) {
                     value = new Rectangle(parseFloat(recArr[0]), parseFloat(recArr[1]), parseFloat(recArr[2]), parseFloat(recArr[3]));
                 }
             }
             this.getStyle().viewport = value;
         }
         /**@private */
         _setRenderType(type) {
         }
         /**@private */
         _setTranformChange() {
             this._tfChanged = true;
             this._renderType |= SpriteConst.TRANSFORM;
             this.parentRepaint(SpriteConst.REPAINT_CACHE);
         }
         /**@private */
         _setBgStyleColor(x, y, width, height, fillColor) {
         }
         /**@private */
         _setBorderStyleColor(x, y, width, height, fillColor, borderWidth) {
         }
         /**@private */
         captureMouseEvent(exclusive) {
             ILaya.MouseManager.instance.setCapture(this, exclusive);
         }
         /**@private */
         releaseMouseEvent() {
             ILaya.MouseManager.instance.releaseCapture();
         }
         set drawCallOptimize(value) {
             this._setBit(Const.DRAWCALL_OPTIMIZE, value);
         }
         get drawCallOptimize() {
             return this._getBit(Const.DRAWCALL_OPTIMIZE);
         }
     }
     /**
      * @private
      * 绘制到画布。
      */
     Sprite.drawToCanvas = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
         offsetX -= sprite.x;
         offsetY -= sprite.y;
         offsetX |= 0;
         offsetY |= 0;
         canvasWidth |= 0;
         canvasHeight |= 0;
         var ctx = new Context();
         ctx.size(canvasWidth, canvasHeight);
         ctx.asBitmap = true;
         ctx._targets.start();
         RenderSprite.renders[_renderType]._fun(sprite, ctx, offsetX, offsetY);
         ctx.flush();
         ctx._targets.end();
         ctx._targets.restore();
         var dt = ctx._targets.getData(0, 0, canvasWidth, canvasHeight);
         ctx.destroy();
         var imgdata = new ImageData(canvasWidth, canvasHeight);
         //翻转getData的结果。
         var lineLen = canvasWidth * 4;
         var dst = imgdata.data;
         var y = canvasHeight - 1;
         var off = y * lineLen;
         var srcoff = 0;
         for (; y >= 0; y--) {
             dst.set(dt.subarray(srcoff, srcoff + lineLen), off);
             off -= lineLen;
             srcoff += lineLen;
         }
         //imgdata.data.set(dt);
         //画到2d画布上
         var canv = new HTMLCanvas(true);
         canv.size(canvasWidth, canvasHeight);
         var ctx2d = canv.getContext('2d');
         ctx2d.putImageData(imgdata, 0, 0);
         return canv;
     };
     /**
      * @private
      *
      */
     Sprite.drawToTexture = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
         offsetX -= sprite.x;
         offsetY -= sprite.y;
         offsetX |= 0;
         offsetY |= 0;
         canvasWidth |= 0;
         canvasHeight |= 0;
         var ctx = new Context();
         ctx.size(canvasWidth, canvasHeight);
         ctx.asBitmap = true;
         ctx._targets.start();
         RenderSprite.renders[_renderType]._fun(sprite, ctx, offsetX, offsetY);
         ctx.flush();
         ctx._targets.end();
         ctx._targets.restore();
         var rtex = new Texture(ctx._targets, Texture.INV_UV);
         ctx.destroy(true); // 保留 _targets
         return rtex;
     };

     /**
      * 文本的样式类
      */
     class TextStyle extends SpriteStyle {
         constructor() {
             super(...arguments);
             /**
              * 表示使用此文本格式的文本是否为斜体。
              * @default false
              */
             this.italic = false;
         }
         /*override*/ reset() {
             super.reset();
             this.italic = false;
             this.align = "left";
             this.wordWrap = false;
             this.leading = 0;
             this.padding = [0, 0, 0, 0];
             this.bgColor = null;
             this.borderColor = null;
             this.asPassword = false;
             this.stroke = 0;
             this.strokeColor = "#000000";
             this.bold = false;
             this.underline = false;
             this.underlineColor = null;
             this.currBitmapFont = null;
             return this;
         }
         /*override*/ recover() {
             if (this === TextStyle.EMPTY)
                 return;
             Pool.recover("TextStyle", this.reset());
         }
         /**
          * 从对象池中创建
          */
         static create() {
             return Pool.getItemByClass("TextStyle", TextStyle);
         }
         /**@inheritDoc	 */
         render(sprite, context, x, y) {
             (this.bgColor || this.borderColor) && context.drawRect(x, y, sprite.width, sprite.height, this.bgColor, this.borderColor, 1);
         }
     }
     /**
     * 一个已初始化的 <code>TextStyle</code> 实例。
     */
     TextStyle.EMPTY = new TextStyle();

     //import { ClassUtils } from "../utils/ClassUtils";
     /**
      * 文本内容发生改变后调度。
      * @eventType Event.CHANGE
      */
     /*[Event(name = "change", type = "laya.events.Event")]*/
     /**
      * <p> <code>Text</code> 类用于创建显示对象以显示文本。</p>
      * <p>
      * 注意：如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
      * </p>
      * @example
      * package
      * {
      * 	import laya.display.Text;
      * 	public class Text_Example
      * 	{
      * 		public function Text_Example()
      * 		{
      * 			Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
      * 			Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
      * 			onInit();
      * 		}
      * 		private function onInit():void
      * 		{
      * 			var text:Text = new Text();//创建一个 Text 类的实例对象 text 。
      * 			text.text = "这个是一个 Text 文本示例。";
      * 			text.color = "#008fff";//设置 text 的文本颜色。
      * 			text.font = "Arial";//设置 text 的文本字体。
      * 			text.bold = true;//设置 text 的文本显示为粗体。
      * 			text.fontSize = 30;//设置 text 的字体大小。
      * 			text.wordWrap = true;//设置 text 的文本自动换行。
      * 			text.x = 100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
      * 			text.y = 100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
      * 			text.width = 300;//设置 text 的宽度。
      * 			text.height = 200;//设置 text 的高度。
      * 			text.italic = true;//设置 text 的文本显示为斜体。
      * 			text.borderColor = "#fff000";//设置 text 的文本边框颜色。
      * 			Laya.stage.addChild(text);//将 text 添加到显示列表。
      * 		}
      * 	}
      * }
      * @example
      * Text_Example();
      * function Text_Example()
      * {
      *     Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
      *     Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
      *     onInit();
      * }
      * function onInit()
      * {
      *     var text = new laya.display.Text();//创建一个 Text 类的实例对象 text 。
      *     text.text = "这个是一个 Text 文本示例。";
      *     text.color = "#008fff";//设置 text 的文本颜色。
      *     text.font = "Arial";//设置 text 的文本字体。
      *     text.bold = true;//设置 text 的文本显示为粗体。
      *     text.fontSize = 30;//设置 text 的字体大小。
      *     text.wordWrap = true;//设置 text 的文本自动换行。
      *     text.x = 100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
      *     text.y = 100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
      *     text.width = 300;//设置 text 的宽度。
      *     text.height = 200;//设置 text 的高度。
      *     text.italic = true;//设置 text 的文本显示为斜体。
      *     text.borderColor = "#fff000";//设置 text 的文本边框颜色。
      *     Laya.stage.addChild(text);//将 text 添加到显示列表。
      * }
      * @example
      * class Text_Example {
      *     constructor() {
      *         Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
      *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
      *         this.onInit();
      *     }
      *     private onInit(): void {
      *         var text: laya.display.Text = new laya.display.Text();//创建一个 Text 类的实例对象 text 。
      *         text.text = "这个是一个 Text 文本示例。";
      *         text.color = "#008fff";//设置 text 的文本颜色。
      *         text.font = "Arial";//设置 text 的文本字体。
      *         text.bold = true;//设置 text 的文本显示为粗体。
      *         text.fontSize = 30;//设置 text 的字体大小。
      *         text.wordWrap = true;//设置 text 的文本自动换行。
      *         text.x = 100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
      *         text.y = 100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
      *         text.width = 300;//设置 text 的宽度。
      *         text.height = 200;//设置 text 的高度。
      *         text.italic = true;//设置 text 的文本显示为斜体。
      *         text.borderColor = "#fff000";//设置 text 的文本边框颜色。
      *         Laya.stage.addChild(text);//将 text 添加到显示列表。
      *     }
      * }
      */
     class Text extends Sprite {
         /**
          * 创建一个新的 <code>Text</code> 实例。
          */
         constructor() {
             super();
             /**@private 表示文本的宽度，以像素为单位。*/
             this._textWidth = 0;
             /**@private 表示文本的高度，以像素为单位。*/
             this._textHeight = 0;
             /**@private 存储文字行数信息。*/
             this._lines = [];
             /**@private 保存每行宽度*/
             this._lineWidths = [];
             /**@private 文本的内容位置 X 轴信息。*/
             this._startX = 0;
             /**@private 文本的内容位置X轴信息。 */
             this._startY = 0;
             /**@private */
             this._charSize = {};
             /**@private */
             this._valign = "top";
             /**@private */
             this._fontSize = Text.defaultFontSize;
             /**@private */
             this._font = Text.defaultFont;
             /**@private */
             this._color = "#000000";
             /**@private */
             this._singleCharRender = false; // 拆分渲染
             /**
              * <p>overflow 指定文本超出文本域后的行为。其值为"hidden"、"visible"和"scroll"之一。</p>
              * <p>性能从高到低依次为：hidden > visible > scroll。</p>
              */
             this.overflow = Text.VISIBLE;
             this._style = TextStyle.EMPTY;
         }
         /**@private */
         static defaultFontStr() {
             return Text.defaultFontSize + "px " + Text.defaultFont;
         }
         /**
          * @private
          * 获取样式。
          * @return  样式 Style 。
          */
         /*override*/ getStyle() {
             this._style === TextStyle.EMPTY && (this._style = TextStyle.create());
             return this._style;
         }
         _getTextStyle() {
             if (this._style === TextStyle.EMPTY) {
                 this._style = TextStyle.create();
             }
             return this._style;
         }
         /**
          * 注册位图字体。
          * @param	name		位图字体的名称。
          * @param	bitmapFont	位图字体文件。
          */
         static registerBitmapFont(name, bitmapFont) {
             Text._bitmapFonts || (Text._bitmapFonts = {});
             Text._bitmapFonts[name] = bitmapFont;
         }
         /**
          * 移除注册的位图字体文件。
          * @param	name		位图字体的名称。
          * @param	destroy		是否销毁指定的字体文件。
          */
         static unregisterBitmapFont(name, destroy = true) {
             if (Text._bitmapFonts && Text._bitmapFonts[name]) {
                 var tBitmapFont = Text._bitmapFonts[name];
                 if (destroy)
                     tBitmapFont.destroy();
                 delete Text._bitmapFonts[name];
             }
         }
         /**@inheritDoc */
         /*override*/ destroy(destroyChild = true) {
             super.destroy(destroyChild);
             this._clipPoint = null;
             this._lines = null;
             this._lineWidths = null;
             // 注意_words是一个数组（例如有换行）
             this._words && this._words.forEach(function (w) {
                 w.cleanCache();
             });
             this._words = null;
             this._charSize = null;
         }
         /**
          * @private
          * @inheritDoc
          */
         /*override*/ _getBoundPointsM(ifRotate = false) {
             var rec = Rectangle.TEMP;
             rec.setTo(0, 0, this.width, this.height);
             return rec._getBoundPoints();
         }
         /**
          * @inheritDoc
          */
         /*override*/ getGraphicBounds(realSize = false) {
             var rec = Rectangle.TEMP;
             rec.setTo(0, 0, this.width, this.height);
             return rec;
         }
         /**
          * @inheritDoc
          */
         /*override*/ get width() {
             if (this._width)
                 return this._width;
             return this.textWidth + this.padding[1] + this.padding[3];
         }
         /*override*/ set width(value) {
             if (value != this._width) {
                 super.set_width(value);
                 this.isChanged = true;
                 if (this.borderColor) {
                     this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1);
                 }
             }
         }
         /**
          * @private
          */
         _getCSSStyle() {
             return this._style;
         }
         /**
          * @inheritDoc
          */
         /*override*/ get height() {
             if (this._height)
                 return this._height;
             return this.textHeight;
         }
         /*override*/ set height(value) {
             if (value != this._height) {
                 super.set_height(value);
                 this.isChanged = true;
                 if (this.borderColor) {
                     this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1);
                 }
             }
         }
         /**
          * 表示文本的宽度，以像素为单位。
          */
         get textWidth() {
             this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);
             return this._textWidth;
         }
         /**
          * 表示文本的高度，以像素为单位。
          */
         get textHeight() {
             this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);
             return this._textHeight;
         }
         /** 当前文本的内容字符串。*/
         get text() {
             return this._text || "";
         }
         // 为了转ts。ts不支持super.get set
         get_text() {
             return this._text || "";
         }
         set_text(value) {
             if (this._text !== value) {
                 this.lang(value + "");
                 this.isChanged = true;
                 this.event(Event.CHANGE);
                 if (this.borderColor) {
                     this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1);
                 }
             }
         }
         set text(value) {
             this.set_text(value);
         }
         /**
          * <p>根据指定的文本，从语言包中取当前语言的文本内容。并对此文本中的{i}文本进行替换。</p>
          * <p>设置Text.langPacks语言包后，即可使用lang获取里面的语言</p>
          * <p>例如：
          * <li>（1）text 的值为“我的名字”，先取到这个文本对应的当前语言版本里的值“My name”，将“My name”设置为当前文本的内容。</li>
          * <li>（2）text 的值为“恭喜你赢得{0}个钻石，{1}经验。”，arg1 的值为100，arg2 的值为200。
          * 			则先取到这个文本对应的当前语言版本里的值“Congratulations on your winning {0} diamonds, {1} experience.”，
          * 			然后将文本里的{0}、{1}，依据括号里的数字从0开始替换为 arg1、arg2 的值。
          * 			将替换处理后的文本“Congratulations on your winning 100 diamonds, 200 experience.”设置为当前文本的内容。
          * </li>
          * </p>
          * @param	text 文本内容。
          * @param	...args 文本替换参数。
          */
         lang(text, arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null, arg6 = null, arg7 = null, arg8 = null, arg9 = null, arg10 = null) {
             text = Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] : text;
             if (arguments.length < 2) {
                 this._text = text;
             }
             else {
                 for (var i = 0, n = arguments.length; i < n; i++) {
                     text = text.replace("{" + i + "}", arguments[i + 1]);
                 }
                 this._text = text;
             }
         }
         /**
          * <p>文本的字体名称，以字符串形式表示。</p>
          * <p>默认值为："Arial"，可以通过Text.defaultFont设置默认字体。</p>
          * <p>如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。</p>
          * @see laya.display.Text#defaultFont
          */
         get font() {
             return this._font;
         }
         set font(value) {
             if (this._style.currBitmapFont) {
                 this._getTextStyle().currBitmapFont = null;
                 this.scale(1, 1);
             }
             if (Text._bitmapFonts && Text._bitmapFonts[value]) {
                 this._getTextStyle().currBitmapFont = Text._bitmapFonts[value];
             }
             this._font = value;
             this.isChanged = true;
         }
         /**
          * <p>指定文本的字体大小（以像素为单位）。</p>
          * <p>默认为20像素，可以通过 <code>Text.defaultFontSize</code> 设置默认大小。</p>
          */
         get fontSize() {
             return this._fontSize;
         }
         set fontSize(value) {
             if (this._fontSize != value) {
                 this._fontSize = value;
                 this.isChanged = true;
             }
         }
         /**
          * <p>指定文本是否为粗体字。</p>
          * <p>默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。</p>
          */
         get bold() {
             return this._style.bold;
         }
         set bold(value) {
             this._getTextStyle().bold = value;
             this.isChanged = true;
         }
         /**
          * <p>表示文本的颜色值。可以通过 <code>Text.defaultColor</code> 设置默认颜色。</p>
          * <p>默认值为黑色。</p>
          */
         get color() {
             return this._color;
         }
         set color(value) {
             this.set_color(value);
         }
         // for转ts。 ts不支持 super.get/set
         get_color() {
             return this._color;
         }
         set_color(value) {
             if (this._color != value) {
                 this._color = value;
                 //如果仅仅更新颜色，无需重新排版
                 if (!this._isChanged && this._graphics) {
                     this._graphics.replaceTextColor(this.color);
                 }
                 else {
                     this.isChanged = true;
                 }
             }
         }
         /**
          * <p>表示使用此文本格式的文本是否为斜体。</p>
          * <p>默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。</p>
          */
         get italic() {
             return this._style.italic;
         }
         set italic(value) {
             this._getTextStyle().italic = value;
             this.isChanged = true;
         }
         /**
          * <p>表示文本的水平显示方式。</p>
          * <p><b>取值：</b>
          * <li>"left"： 居左对齐显示。</li>
          * <li>"center"： 居中对齐显示。</li>
          * <li>"right"： 居右对齐显示。</li>
          * </p>
          */
         get align() {
             return this._style.align;
         }
         set align(value) {
             this._getTextStyle().align = value;
             this.isChanged = true;
         }
         /**
          * <p>表示文本的垂直显示方式。</p>
          * <p><b>取值：</b>
          * <li>"top"： 居顶部对齐显示。</li>
          * <li>"middle"： 居中对齐显示。</li>
          * <li>"bottom"： 居底部对齐显示。</li>
          * </p>
          */
         get valign() {
             return this._valign;
         }
         set valign(value) {
             this._valign = value;
             this.isChanged = true;
         }
         /**
          * <p>表示文本是否自动换行，默认为false。</p>
          * <p>若值为true，则自动换行；否则不自动换行。</p>
          */
         get wordWrap() {
             return this._style.wordWrap;
         }
         set wordWrap(value) {
             this._getTextStyle().wordWrap = value;
             this.isChanged = true;
         }
         /**
          * 垂直行间距（以像素为单位）。
          */
         get leading() {
             return this._style.leading;
         }
         set leading(value) {
             this._getTextStyle().leading = value;
             this.isChanged = true;
         }
         /**
          * <p>边距信息。</p>
          * <p>数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。</p>
          */
         get padding() {
             return this._style.padding;
         }
         set padding(value) {
             if (typeof (value) == 'string') {
                 var arr;
                 arr = value.split(",");
                 var i, len;
                 len = arr.length;
                 while (arr.length < 4) {
                     arr.push(0);
                 }
                 for (i = 0; i < len; i++) {
                     arr[i] = parseFloat(arr[i]) || 0;
                 }
                 value = arr;
             }
             this._getTextStyle().padding = value;
             this.isChanged = true;
         }
         /**
          * 文本背景颜色，以字符串表示。
          */
         get bgColor() {
             return this._style.bgColor;
         }
         set bgColor(value) {
             this.set_bgColor(value);
         }
         // fot ts
         set_bgColor(value) {
             this._getTextStyle().bgColor = value;
             this._renderType |= SpriteConst.STYLE;
             this._setBgStyleColor(0, 0, this.width, this.height, value);
             this._setRenderType(this._renderType);
             this.isChanged = true;
         }
         get_bgColor() {
             return this._style.bgColor;
         }
         /**
          * 文本边框背景颜色，以字符串表示。
          */
         get borderColor() {
             return this._style.borderColor;
         }
         set borderColor(value) {
             this._getTextStyle().borderColor = value;
             this._renderType |= SpriteConst.STYLE;
             this._setBorderStyleColor(0, 0, this.width, this.height, value, 1);
             this._setRenderType(this._renderType);
             this.isChanged = true;
         }
         /**
          * <p>描边宽度（以像素为单位）。</p>
          * <p>默认值0，表示不描边。</p>
          */
         get stroke() {
             return this._style.stroke;
         }
         set stroke(value) {
             this._getTextStyle().stroke = value;
             this.isChanged = true;
         }
         /**
          * <p>描边颜色，以字符串表示。</p>
          * <p>默认值为 "#000000"（黑色）;</p>
          */
         get strokeColor() {
             return this._style.strokeColor;
         }
         set strokeColor(value) {
             this._getTextStyle().strokeColor = value;
             this.isChanged = true;
         }
         /**
          * @private
          * 一个布尔值，表示文本的属性是否有改变。若为true表示有改变。
          */
         set isChanged(value) {
             if (this._isChanged !== value) {
                 this._isChanged = value;
                 value && ILaya.systemTimer.callLater(this, this.typeset);
             }
         }
         /**
          * @private
          */
         _getContextFont() {
             return (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + (ILaya.Browser.onIPhone ? (Text.fontFamilyMap[this.font] || this.font) : this.font);
         }
         /**
          * @private
          */
         _isPassWordMode() {
             var style = this._style;
             var password = style.asPassword;
             if (("prompt" in this) && this['prompt'] == this._text)
                 password = false;
             return password;
         }
         /**
          * @private
          */
         _getPassWordTxt(txt) {
             var len = txt.length;
             var word;
             word = "";
             for (var j = len; j > 0; j--) {
                 word += "●";
             }
             return word;
         }
         /**
          * @private
          * 渲染文字。
          * @param	begin 开始渲染的行索引。
          * @param	visibleLineCount 渲染的行数。
          */
         _renderText() {
             var padding = this.padding;
             var visibleLineCount = this._lines.length;
             // overflow为scroll或visible时会截行
             if (this.overflow != Text.VISIBLE) {
                 visibleLineCount = Math.min(visibleLineCount, Math.floor((this.height - padding[0] - padding[2]) / (this.leading + this._charSize.height)) + 1);
             }
             var beginLine = this.scrollY / (this._charSize.height + this.leading) | 0;
             var graphics = this.graphics;
             graphics.clear(true);
             var ctxFont = this._getContextFont();
             ILaya.Browser.context.font = ctxFont;
             //处理垂直对齐
             var startX = padding[3];
             var textAlgin = "left";
             var lines = this._lines;
             var lineHeight = this.leading + this._charSize.height;
             var tCurrBitmapFont = this._style.currBitmapFont;
             if (tCurrBitmapFont) {
                 lineHeight = this.leading + tCurrBitmapFont.getMaxHeight();
             }
             var startY = padding[0];
             //处理水平对齐
             if ((!tCurrBitmapFont) && this._width > 0 && this._textWidth <= this._width) {
                 if (this.align == "right") {
                     textAlgin = "right";
                     startX = this._width - padding[1];
                 }
                 else if (this.align == "center") {
                     textAlgin = "center";
                     startX = this._width * 0.5 + padding[3] - padding[1];
                 }
             }
             if (this._height > 0) {
                 var tempVAlign = (this._textHeight > this._height) ? "top" : this.valign;
                 if (tempVAlign === "middle")
                     startY = (this._height - visibleLineCount * lineHeight) * 0.5 + padding[0] - padding[2];
                 else if (tempVAlign === "bottom")
                     startY = this._height - visibleLineCount * lineHeight - padding[2];
             }
             var style = this._style;
             //drawBg(style);
             if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                 var bitmapScale = tCurrBitmapFont.fontSize / this.fontSize;
             }
             //渲染
             if (this._clipPoint) {
                 graphics.save();
                 if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                     var tClipWidth;
                     var tClipHeight;
                     this._width ? tClipWidth = (this._width - padding[3] - padding[1]) : tClipWidth = this._textWidth;
                     this._height ? tClipHeight = (this._height - padding[0] - padding[2]) : tClipHeight = this._textHeight;
                     tClipWidth *= bitmapScale;
                     tClipHeight *= bitmapScale;
                     graphics.clipRect(padding[3], padding[0], tClipWidth, tClipHeight);
                 }
                 else {
                     graphics.clipRect(padding[3], padding[0], this._width ? (this._width - padding[3] - padding[1]) : this._textWidth, this._height ? (this._height - padding[0] - padding[2]) : this._textHeight);
                 }
                 this.repaint();
             }
             var password = style.asPassword;
             // 输入框的prompt始终显示明文
             if (("prompt" in this) && this['prompt'] == this._text)
                 password = false;
             var x = 0, y = 0;
             var end = Math.min(this._lines.length, visibleLineCount + beginLine) || 1;
             for (var i = beginLine; i < end; i++) {
                 var word = lines[i];
                 var _word;
                 if (password) {
                     var len = word.length;
                     word = "";
                     for (var j = len; j > 0; j--) {
                         word += "●";
                     }
                 }
                 if (word == null)
                     word = "";
                 x = startX - (this._clipPoint ? this._clipPoint.x : 0);
                 y = startY + lineHeight * i - (this._clipPoint ? this._clipPoint.y : 0);
                 this.underline && this._drawUnderline(textAlgin, x, y, i);
                 if (tCurrBitmapFont) {
                     var tWidth = this.width;
                     if (tCurrBitmapFont.autoScaleSize) {
                         tWidth = this.width * bitmapScale;
                     }
                     tCurrBitmapFont._drawText(word, this, x, y, this.align, tWidth);
                 }
                 else {
                     this._words || (this._words = []);
                     if (this._words.length > (i - beginLine)) {
                         _word = this._words[i - beginLine];
                     }
                     else {
                         _word = new WordText();
                         this._words.push(_word);
                     }
                     _word.setText(word);
                     _word.splitRender = this._singleCharRender;
                     style.stroke ? graphics.fillBorderText(_word, x, y, ctxFont, this.color, style.strokeColor, style.stroke, textAlgin) : graphics.fillText(_word, x, y, ctxFont, this.color, textAlgin);
                 }
             }
             if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                 var tScale = 1 / bitmapScale;
                 this.scale(tScale, tScale);
             }
             if (this._clipPoint)
                 graphics.restore();
             this._startX = startX;
             this._startY = startY;
         }
         /**
          * @private
          * 绘制下划线
          * @param	x 本行坐标
          * @param	y 本行坐标
          * @param	lineIndex 本行索引
          */
         _drawUnderline(align, x, y, lineIndex) {
             var lineWidth = this._lineWidths[lineIndex];
             switch (align) {
                 case 'center':
                     x -= lineWidth / 2;
                     break;
                 case 'right':
                     x -= lineWidth;
                     break;
                 case 'left':
                 default:
                     break;
             }
             y += this._charSize.height;
             this._graphics.drawLine(x, y, x + lineWidth, y, this.underlineColor || this.color, 1);
         }
         /**
          * <p>排版文本。</p>
          * <p>进行宽高计算，渲染、重绘文本。</p>
          */
         typeset() {
             this._isChanged = false;
             if (!this._text) {
                 this._clipPoint = null;
                 this._textWidth = this._textHeight = 0;
                 this.graphics.clear(true);
                 return;
             }
             if (ILaya.Render.isConchApp) {
                 window.conchTextCanvas.font = this._getContextFont();
             }
             else {
                 ILaya.Browser.context.font = this._getContextFont();
             }
             this._lines.length = 0;
             this._lineWidths.length = 0;
             if (this._isPassWordMode()) //如果是password显示状态应该使用密码符号计算
              {
                 this._parseLines(this._getPassWordTxt(this._text));
             }
             else
                 this._parseLines(this._text);
             this._evalTextSize();
             //启用Viewport
             if (this._checkEnabledViewportOrNot())
                 this._clipPoint || (this._clipPoint = new Point(0, 0));
             //否则禁用Viewport
             else
                 this._clipPoint = null;
             this._renderText();
         }
         /**@private */
         _evalTextSize() {
             var nw, nh;
             nw = Math.max.apply(this, this._lineWidths);
             //计算textHeight
             if (this._style.currBitmapFont)
                 nh = this._lines.length * (this._style.currBitmapFont.getMaxHeight() + this.leading) + this.padding[0] + this.padding[2];
             else
                 nh = this._lines.length * (this._charSize.height + this.leading) + this.padding[0] + this.padding[2];
             if (nw != this._textWidth || nh != this._textHeight) {
                 this._textWidth = nw;
                 this._textHeight = nh;
                 //TODO:
                 //if (!_width || !_height)
                 //conchModel && conchModel.size(_width || _textWidth, _height || _textHeight);
             }
         }
         /**@private */
         _checkEnabledViewportOrNot() {
             return this.overflow == Text.SCROLL && ((this._width > 0 && this._textWidth > this._width) || (this._height > 0 && this._textHeight > this._height)); // 设置了宽高并且超出了
         }
         /**
          * <p>快速更改显示文本。不进行排版计算，效率较高。</p>
          * <p>如果只更改文字内容，不更改文字样式，建议使用此接口，能提高效率。</p>
          * @param text 文本内容。
          */
         changeText(text) {
             if (this._text !== text) {
                 this.lang(text + "");
                 if (this._graphics && this._graphics.replaceText(this._text)) ;
                 else {
                     this.typeset();
                 }
             }
         }
         /**
          * @private
          * 分析文本换行。
          */
         _parseLines(text) {
             //自动换行和HIDDEN都需要计算换行位置或截断位置
             var needWordWrapOrTruncate = this.wordWrap || this.overflow == Text.HIDDEN;
             if (needWordWrapOrTruncate) {
                 var wordWrapWidth = this._getWordWrapWidth();
             }
             var bitmapFont = this._style.currBitmapFont;
             if (bitmapFont) {
                 this._charSize.width = bitmapFont.getMaxWidth();
                 this._charSize.height = bitmapFont.getMaxHeight();
             }
             else {
                 var measureResult = null;
                 if (ILaya.Render.isConchApp) {
                     measureResult = window.conchTextCanvas.measureText(Text._testWord);
                 }
                 else {
                     measureResult = ILaya.Browser.context.measureText(Text._testWord);
                 }
                 if (!measureResult)
                     measureResult = { width: 100 };
                 this._charSize.width = measureResult.width;
                 this._charSize.height = (measureResult.height || this.fontSize);
             }
             var lines = text.replace(/\r\n/g, "\n").split("\n");
             for (var i = 0, n = lines.length; i < n; i++) {
                 var line = lines[i];
                 // 开启了自动换行需要计算换行位置
                 // overflow为hidden需要计算截断位置
                 if (needWordWrapOrTruncate)
                     this._parseLine(line, wordWrapWidth);
                 else {
                     this._lineWidths.push(this._getTextWidth(line));
                     this._lines.push(line);
                 }
             }
         }
         /**
          * @private
          * 解析行文本。
          * @param	line 某行的文本。
          * @param	wordWrapWidth 文本的显示宽度。
          */
         _parseLine(line, wordWrapWidth) {
             var lines = this._lines;
             var maybeIndex = 0;
             var charsWidth;
             var wordWidth;
             var startIndex;
             charsWidth = this._getTextWidth(line);
             //优化1，如果一行小于宽度，则直接跳过遍历
             if (charsWidth <= wordWrapWidth) {
                 lines.push(line);
                 this._lineWidths.push(charsWidth);
                 return;
             }
             charsWidth = this._charSize.width;
             //优化2，预算第几个字符会超出，减少遍历及字符宽度度量
             maybeIndex = Math.floor(wordWrapWidth / charsWidth);
             (maybeIndex == 0) && (maybeIndex = 1);
             charsWidth = this._getTextWidth(line.substring(0, maybeIndex));
             wordWidth = charsWidth;
             for (var j = maybeIndex, m = line.length; j < m; j++) {
                 // 逐字符测量后加入到总宽度中，在某些情况下自动换行不准确。
                 // 目前已知在全是字符1的自动换行就会出现这种情况。
                 // 考虑性能，保留这种非方式。
                 charsWidth = this._getTextWidth(line.charAt(j));
                 wordWidth += charsWidth;
                 if (wordWidth > wordWrapWidth) {
                     if (this.wordWrap) {
                         //截断换行单词
                         var newLine = line.substring(startIndex, j);
                         if (newLine.charCodeAt(newLine.length - 1) < 255) {
                             //按照英文单词字边界截取 因此将会无视中文
                             var execResult = /(?:\w|-)+$/.exec(newLine);
                             if (execResult) {
                                 j = execResult.index + startIndex;
                                 //此行只够容纳这一个单词 强制换行
                                 if (execResult.index == 0)
                                     j += newLine.length;
                                 //此行有多个单词 按单词分行
                                 else
                                     newLine = line.substring(startIndex, j);
                             }
                         }
                         //如果自动换行，则另起一行
                         lines.push(newLine);
                         this._lineWidths.push(wordWidth - charsWidth);
                         //如果非自动换行，则只截取字符串
                         startIndex = j;
                         if (j + maybeIndex < m) {
                             j += maybeIndex;
                             charsWidth = this._getTextWidth(line.substring(startIndex, j));
                             wordWidth = charsWidth;
                             j--;
                         }
                         else {
                             //此处执行将不会在循环结束后再push一次
                             lines.push(line.substring(startIndex, m));
                             this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));
                             startIndex = -1;
                             break;
                         }
                     }
                     else if (this.overflow == Text.HIDDEN) {
                         lines.push(line.substring(0, j));
                         this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));
                         return;
                     }
                 }
             }
             if (this.wordWrap && startIndex != -1) {
                 lines.push(line.substring(startIndex, m));
                 this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));
             }
         }
         /**@private */
         _getTextWidth(text) {
             var bitmapFont = this._style.currBitmapFont;
             if (bitmapFont)
                 return bitmapFont.getTextWidth(text);
             else {
                 if (ILaya.Render.isConchApp) {
                     return window.conchTextCanvas.measureText(text).width;
                 }
                 else
                     return ILaya.Browser.context.measureText(text).width;
             }
         }
         /**
          * @private
          * 获取换行所需的宽度。
          */
         _getWordWrapWidth() {
             var p = this.padding;
             var w;
             var bitmapFont = this._style.currBitmapFont;
             if (bitmapFont && bitmapFont.autoScaleSize)
                 w = this._width * (bitmapFont.fontSize / this.fontSize);
             else
                 w = this._width;
             if (w <= 0) {
                 w = this.wordWrap ? 100 : ILaya.Browser.width;
             }
             w <= 0 && (w = 100);
             return w - p[3] - p[1];
         }
         /**
          * 返回字符在本类实例的父坐标系下的坐标。
          * @param charIndex	索引位置。
          * @param out		（可选）输出的Point引用。
          * @return Point 字符在本类实例的父坐标系下的坐标。如果out参数不为空，则将结果赋值给指定的Point对象，否则创建一个新的Point对象返回。建议使用Point.TEMP作为out参数，可以省去Point对象创建和垃圾回收的开销，尤其是在需要频繁执行的逻辑中，比如帧循环和MOUSE_MOVE事件回调函数里面。
          */
         getCharPoint(charIndex, out = null) {
             this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);
             var len = 0, lines = this._lines, startIndex = 0;
             for (var i = 0, n = lines.length; i < n; i++) {
                 len += lines[i].length;
                 if (charIndex < len) {
                     var line = i;
                     break;
                 }
                 startIndex = len;
             }
             //计算字符的宽度
             var ctxFont = (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + this.font;
             ILaya.Browser.context.font = ctxFont;
             var width = this._getTextWidth(this._text.substring(startIndex, charIndex));
             var point = out || new Point();
             return point.setTo(this._startX + width - (this._clipPoint ? this._clipPoint.x : 0), this._startY + line * (this._charSize.height + this.leading) - (this._clipPoint ? this._clipPoint.y : 0));
         }
         /**
          * <p>设置横向滚动量。</p>
          * <p>即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。</p>
          */
         set scrollX(value) {
             if (this.overflow != Text.SCROLL || (this.textWidth < this._width || !this._clipPoint))
                 return;
             value = value < this.padding[3] ? this.padding[3] : value;
             var maxScrollX = this._textWidth - this._width;
             value = value > maxScrollX ? maxScrollX : value;
             this._clipPoint.x = value;
             this._renderText();
         }
         /**
          * 获取横向滚动量。
          */
         get scrollX() {
             if (!this._clipPoint)
                 return 0;
             return this._clipPoint.x;
         }
         /**
          * 设置纵向滚动量（px)。即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
          */
         set scrollY(value) {
             if (this.overflow != Text.SCROLL || (this.textHeight < this._height || !this._clipPoint))
                 return;
             value = value < this.padding[0] ? this.padding[0] : value;
             var maxScrollY = this._textHeight - this._height;
             value = value > maxScrollY ? maxScrollY : value;
             this._clipPoint.y = value;
             this._renderText();
         }
         /**
          * 获取纵向滚动量。
          */
         get scrollY() {
             if (!this._clipPoint)
                 return 0;
             return this._clipPoint.y;
         }
         /**
          * 获取横向可滚动最大值。
          */
         get maxScrollX() {
             return (this.textWidth < this._width) ? 0 : this._textWidth - this._width;
         }
         /**
          * 获取纵向可滚动最大值。
          */
         get maxScrollY() {
             return (this.textHeight < this._height) ? 0 : this._textHeight - this._height;
         }
         /**返回文字行信息*/
         get lines() {
             if (this._isChanged)
                 this.typeset();
             return this._lines;
         }
         /**下划线的颜色，为null则使用字体颜色。*/
         get underlineColor() {
             return this._style.underlineColor;
         }
         set underlineColor(value) {
             this._getTextStyle().underlineColor = value;
             if (!this._isChanged)
                 this._renderText();
         }
         /**是否显示下划线。*/
         get underline() {
             return this._style.underline;
         }
         set underline(value) {
             this._getTextStyle().underline = value;
         }
         /** 设置是否单个字符渲染，如果Textd的内容一直改变，例如是一个增加的数字，就设置这个，防止无效占用缓存 */
         set singleCharRender(value) {
             this._singleCharRender = value;
         }
         get singleCharRender() {
             return this._singleCharRender;
         }
     }
     /**visible不进行任何裁切。*/
     Text.VISIBLE = "visible";
     /**scroll 不显示文本域外的字符像素，并且支持 scroll 接口。*/
     Text.SCROLL = "scroll";
     /**hidden 不显示超出文本域的字符。*/
     Text.HIDDEN = "hidden";
     /**默认文本大小，默认为12*/
     Text.defaultFontSize = 12;
     /**默认文本字体，默认为Arial*/
     Text.defaultFont = "Arial";
     /**WebGL下，文字会被拆分为单个字符进行渲染，一些语系不能拆开显示，比如阿拉伯文，这时可以设置isComplexText=true，禁用文字拆分。*/
     Text.isComplexText = false;
     /**在IOS下，一些字体会找不到，引擎提供了字体映射功能，比如默认会把 "黑体" 映射为 "黑体-简"，更多映射，可以自己添加*/
     Text.fontFamilyMap = { "报隶": "报隶-简", "黑体": "黑体-简", "楷体": "楷体-简", "兰亭黑": "兰亭黑-简", "隶变": "隶变-简", "凌慧体": "凌慧体-简", "翩翩体": "翩翩体-简", "苹方": "苹方-简", "手札体": "手札体-简", "宋体": "宋体-简", "娃娃体": "娃娃体-简", "魏碑": "魏碑-简", "行楷": "行楷-简", "雅痞": "雅痞-简", "圆体": "圆体-简" };
     /**@private 预测长度的文字，用来提升计算效率，不同语言找一个最大的字符即可*/
     Text._testWord = "游";
     //TODO:
     Text.CharacterCache = true;
     /**是否是从右向左的显示顺序*/
     Text.RightToLeft = false;
     ILaya.regClass(Text);

     /**
      * 用户输入一个或多个文本字符时后调度。
      * @eventType Event.INPUT
      * */
     /*[Event(name = "input", type = "laya.events.Event")]*/
     /**
      * 文本发生变化后调度。
      * @eventType Event.CHANGE
      * */
     /*[Event(name = "change", type = "laya.events.Event")]*/
     /**
      * 用户在输入框内敲回车键后，将会调度 <code>enter</code> 事件。
      * @eventType Event.ENTER
      * */
     /*[Event(name = "enter", type = "laya.events.Event")]*/
     /**
      * 显示对象获得焦点后调度。
      * @eventType Event.FOCUS
      * */
     /*[Event(name = "focus", type = "laya.events.Event")]*/
     /**
      * 显示对象失去焦点后调度。
      * @eventType Event.BLUR
      * */
     /*[Event(name = "blur", type = "laya.events.Event")]*/
     /**
      * <p><code>Input</code> 类用于创建显示对象以显示和输入文本。</p>
      * <p>Input 类封装了原生的文本输入框，由于不同浏览器的差异，会导致此对象的默认文本的位置与用户点击输入时的文本的位置有少许的偏差。</p>
      */
     class Input extends Text {
         /**创建一个新的 <code>Input</code> 类实例。*/
         constructor() {
             super();
             /**@private */
             this._multiline = false;
             /**@private */
             this._editable = true;
             /**@private */
             this._maxChars = 1E5;
             this._type = "text";
             /**输入提示符。*/
             this._prompt = '';
             /**输入提示符颜色。*/
             this._promptColor = "#A9A9A9";
             this._originColor = "#000000";
             this._content = '';
             Input.IOS_IFRAME = (ILaya.Browser.onIOS && ILaya.Browser.window.top != ILaya.Browser.window.self);
             this._width = 100;
             this._height = 20;
             this.multiline = false;
             this.overflow = Text.SCROLL;
             this.on(Event.MOUSE_DOWN, this, this._onMouseDown);
             this.on(Event.UNDISPLAY, this, this._onUnDisplay);
         }
         /**@private */
         static __init__() {
             Input._createInputElement();
             // 移动端通过画布的touchend调用focus
             if (ILaya.Browser.onMobile) {
                 var isTrue = false;
                 if (ILaya.Browser.onMiniGame || ILaya.Browser.onBDMiniGame || ILaya.Browser.onQGMiniGame || ILaya.Browser.onKGMiniGame || ILaya.Browser.onVVMiniGame) {
                     isTrue = true;
                 }
                 ILaya.Render.canvas.addEventListener(Input.IOS_IFRAME ? (isTrue ? "touchend" : "click") : "touchend", Input._popupInputMethod);
             }
         }
         // 移动平台在单击事件触发后弹出输入法
         static _popupInputMethod(e) {
             //e.preventDefault();
             if (!Input.isInputting)
                 return;
             var input = Input.inputElement;
             // 弹出输入法。
             input.focus();
         }
         static _createInputElement() {
             Input._initInput(Input.area = ILaya.Browser.createElement("textarea"));
             Input._initInput(Input.input = ILaya.Browser.createElement("input"));
             Input.inputContainer = ILaya.Browser.createElement("div");
             Input.inputContainer.style.position = "absolute";
             Input.inputContainer.style.zIndex = 1E5;
             ILaya.Browser.container.appendChild(Input.inputContainer);
             Input.inputContainer.setPos = function (x, y) {
                 Input.inputContainer.style.left = x + 'px';
                 Input.inputContainer.style.top = y + 'px';
             };
         }
         static _initInput(input) {
             var style = input.style;
             style.cssText = "position:absolute;overflow:hidden;resize:none;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;";
             style.resize = 'none';
             style.backgroundColor = 'transparent';
             style.border = 'none';
             style.outline = 'none';
             style.zIndex = 1;
             input.addEventListener('input', Input._processInputting);
             input.addEventListener('mousemove', Input._stopEvent);
             input.addEventListener('mousedown', Input._stopEvent);
             input.addEventListener('touchmove', Input._stopEvent);
             input.setFontFace = function (fontFace) { input.style.fontFamily = fontFace; };
             if (!ILaya.Render.isConchApp) {
                 input.setColor = function (color) { input.style.color = color; };
                 input.setFontSize = function (fontSize) { input.style.fontSize = fontSize + 'px'; };
             }
         }
         static _processInputting(e) {
             var input = Input.inputElement.target;
             if (!input)
                 return;
             var value = Input.inputElement.value;
             // 对输入字符进行限制
             if (input._restrictPattern) {
                 // 部分输入法兼容
                 value = value.replace(/\u2006|\x27/g, "");
                 if (input._restrictPattern.test(value)) {
                     value = value.replace(input._restrictPattern, "");
                     Input.inputElement.value = value;
                 }
             }
             input._text = value;
             input.event(Event.INPUT);
         }
         static _stopEvent(e) {
             if (e.type == 'touchmove')
                 e.preventDefault();
             e.stopPropagation && e.stopPropagation();
         }
         /**
          * 设置光标位置和选取字符。
          * @param	startIndex	光标起始位置。
          * @param	endIndex	光标结束位置。
          */
         setSelection(startIndex, endIndex) {
             this.focus = true;
             Input.inputElement.selectionStart = startIndex;
             Input.inputElement.selectionEnd = endIndex;
         }
         /**表示是否是多行输入框。*/
         get multiline() {
             return this._multiline;
         }
         set multiline(value) {
             this._multiline = value;
             this.valign = value ? "top" : "middle";
         }
         /**
          * 获取对输入框的引用实例。
          */
         get nativeInput() {
             return this._multiline ? Input.area : Input.input;
         }
         _onUnDisplay(e = null) {
             this.focus = false;
         }
         _onMouseDown(e) {
             this.focus = true;
         }
         /**
          * 在输入期间，如果 Input 实例的位置改变，调用_syncInputTransform同步输入框的位置。
          */
         _syncInputTransform() {
             var inputElement = this.nativeInput;
             var transform = Utils.getTransformRelativeToWindow(this, this.padding[3], this.padding[0]);
             var inputWid = this._width - this.padding[1] - this.padding[3];
             var inputHei = this._height - this.padding[0] - this.padding[2];
             if (ILaya.Render.isConchApp) {
                 inputElement.setScale(transform.scaleX, transform.scaleY);
                 inputElement.setSize(inputWid, inputHei);
                 inputElement.setPos(transform.x, transform.y);
             }
             else {
                 Input.inputContainer.style.transform = Input.inputContainer.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (ILaya.stage.canvasDegree) + "deg)";
                 inputElement.style.width = inputWid + 'px';
                 inputElement.style.height = inputHei + 'px';
                 Input.inputContainer.style.left = transform.x + 'px';
                 Input.inputContainer.style.top = transform.y + 'px';
             }
         }
         /**选中当前实例的所有文本。*/
         select() {
             this.nativeInput.select();
         }
         /**
          * 表示焦点是否在此实例上。
          */
         get focus() {
             return this._focus;
         }
         // 移动平台最后单击画布才会调用focus
         // 因此 调用focus接口是无法都在移动平台立刻弹出键盘的
         set focus(value) {
             var input = this.nativeInput;
             if (this._focus !== value) {
                 if (value) {
                     if (input.target) {
                         input.target._focusOut();
                     }
                     else {
                         this._setInputMethod();
                     }
                     input.target = this;
                     this._focusIn();
                 }
                 else {
                     input.target = null;
                     this._focusOut();
                     ILaya.Browser.document.body.scrollTop = 0;
                     input.blur();
                     if (ILaya.Render.isConchApp)
                         input.setPos(-10000, -10000);
                     else if (Input.inputContainer.contains(input))
                         Input.inputContainer.removeChild(input);
                 }
             }
         }
         _setInputMethod() {
             Input.input.parentElement && (Input.inputContainer.removeChild(Input.input));
             Input.area.parentElement && (Input.inputContainer.removeChild(Input.area));
             Input.inputElement = (this._multiline ? Input.area : Input.input);
             Input.inputContainer.appendChild(Input.inputElement);
             if (Text.RightToLeft) {
                 Input.inputElement.style.direction = "rtl";
             }
         }
         _focusIn() {
             Input.isInputting = true;
             var input = this.nativeInput;
             this._focus = true;
             var cssStyle = input.style;
             cssStyle.whiteSpace = (this.wordWrap ? "pre-wrap" : "nowrap");
             this._setPromptColor();
             input.readOnly = !this._editable;
             if (ILaya.Render.isConchApp) {
                 input.setType(this._type);
                 input.setForbidEdit(!this._editable);
             }
             input.maxLength = this._maxChars;
             var padding = this.padding;
             //input.type = this._type;      不知道为什么说这个是只读的。但是as项目就没问题
             input.value = this._content;
             input.placeholder = this._prompt;
             ILaya.stage.off(Event.KEY_DOWN, this, this._onKeyDown);
             ILaya.stage.on(Event.KEY_DOWN, this, this._onKeyDown);
             ILaya.stage.focus = this;
             this.event(Event.FOCUS);
             // PC端直接调用focus进入焦点。
             if (ILaya.Browser.onPC)
                 input.focus();
             // PC浏览器隐藏文字
             if (!ILaya.Browser.onMiniGame && !ILaya.Browser.onBDMiniGame && !ILaya.Browser.onQGMiniGame && !ILaya.Browser.onKGMiniGame && !ILaya.Browser.onVVMiniGame) {
                 var temp = this._text;
                 this._text = null;
             }
             this.typeset();
             // PC同步输入框外观。
             input.setColor(this._originColor);
             input.setFontSize(this.fontSize);
             input.setFontFace(ILaya.Browser.onIPhone ? (Text.fontFamilyMap[this.font] || this.font) : this.font);
             if (ILaya.Render.isConchApp) {
                 input.setMultiAble && input.setMultiAble(this._multiline);
             }
             cssStyle.lineHeight = (this.leading + this.fontSize) + "px";
             cssStyle.fontStyle = (this.italic ? "italic" : "normal");
             cssStyle.fontWeight = (this.bold ? "bold" : "normal");
             cssStyle.textAlign = this.align;
             cssStyle.padding = "0 0";
             // 输入框重定位。
             this._syncInputTransform();
             if (!ILaya.Render.isConchApp && ILaya.Browser.onPC)
                 ILaya.systemTimer.frameLoop(1, this, this._syncInputTransform);
         }
         // 设置DOM输入框提示符颜色。
         _setPromptColor() {
             // 创建style标签
             Input.promptStyleDOM = ILaya.Browser.getElementById("promptStyle");
             if (!Input.promptStyleDOM) {
                 Input.promptStyleDOM = ILaya.Browser.createElement("style");
                 Input.promptStyleDOM.setAttribute("id", "promptStyle");
                 ILaya.Browser.document.head.appendChild(Input.promptStyleDOM);
             }
             // 设置style标签
             Input.promptStyleDOM.innerText = "input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {" + "color:" + this._promptColor + "}" + "input:-moz-placeholder, textarea:-moz-placeholder {" + "color:" + this._promptColor + "}" + "input::-moz-placeholder, textarea::-moz-placeholder {" + "color:" + this._promptColor + "}" + "input:-ms-input-placeholder, textarea:-ms-input-placeholder {" + "color:" + this._promptColor + "}";
         }
         /**@private */
         _focusOut() {
             Input.isInputting = false;
             this._focus = false;
             this._text = null;
             this._content = this.nativeInput.value;
             if (!this._content) {
                 super.set_text(this._prompt);
                 super.set_color(this._promptColor);
             }
             else {
                 super.set_text(this._content);
                 super.set_color(this._originColor);
             }
             ILaya.stage.off(Event.KEY_DOWN, this, this._onKeyDown);
             ILaya.stage.focus = null;
             this.event(Event.BLUR);
             this.event(Event.CHANGE);
             if (ILaya.Render.isConchApp)
                 this.nativeInput.blur();
             // 只有PC会注册此事件。
             ILaya.Browser.onPC && ILaya.systemTimer.clear(this, this._syncInputTransform);
         }
         /**@private */
         _onKeyDown(e) {
             if (e.keyCode === 13) {
                 // 移动平台单行输入状态下点击回车收回输入法。 
                 if (ILaya.Browser.onMobile && !this._multiline)
                     this.focus = false;
                 this.event(Event.ENTER);
             }
         }
         /**@inheritDoc */
         /*override*/ set text(value) {
             super.set_color(this._originColor);
             value += '';
             if (this._focus) {
                 this.nativeInput.value = value || '';
                 this.event(Event.CHANGE);
             }
             else {
                 // 单行时不允许换行
                 if (!this._multiline)
                     value = value.replace(/\r?\n/g, '');
                 this._content = value;
                 if (value)
                     super.set_text(value);
                 else {
                     super.set_text(this._prompt);
                     super.set_color(this.promptColor);
                 }
             }
         }
         /*override*/ get text() {
             if (this._focus)
                 return this.nativeInput.value;
             else
                 return this._content || "";
         }
         /*override*/ changeText(text) {
             this._content = text;
             if (this._focus) {
                 this.nativeInput.value = text || '';
                 this.event(Event.CHANGE);
             }
             else
                 super.changeText(text);
         }
         /**@inheritDoc */
         /*override*/ set color(value) {
             if (this._focus)
                 this.nativeInput.setColor(value);
             super.set_color(this._content ? value : this._promptColor);
             this._originColor = value;
         }
         get color() {
             return super.color;
         }
         /**@inheritDoc */
         /*override*/ set bgColor(value) {
             super.set_bgColor(value);
             if (ILaya.Render.isConchApp)
                 this.nativeInput.setBgColor(value);
         }
         get bgColor() {
             return super.bgColor;
         }
         /**限制输入的字符。*/
         get restrict() {
             if (this._restrictPattern) {
                 return this._restrictPattern.source;
             }
             return "";
         }
         set restrict(pattern) {
             // H5保存RegExp
             if (pattern) {
                 pattern = "[^" + pattern + "]";
                 // 如果pattern为^\00-\FF，则我们需要的正则表达式是\00-\FF
                 if (pattern.indexOf("^^") > -1)
                     pattern = pattern.replace("^^", "");
                 this._restrictPattern = new RegExp(pattern, "g");
             }
             else
                 this._restrictPattern = null;
         }
         /**
          * 是否可编辑。
          */
         set editable(value) {
             this._editable = value;
             if (ILaya.Render.isConchApp) {
                 Input.input.setForbidEdit(!value);
             }
         }
         get editable() {
             return this._editable;
         }
         /**
          * <p>字符数量限制，默认为10000。</p>
          * <p>设置字符数量限制时，小于等于0的值将会限制字符数量为10000。</p>
          */
         get maxChars() {
             return this._maxChars;
         }
         set maxChars(value) {
             if (value <= 0)
                 value = 1E5;
             this._maxChars = value;
         }
         /**
          * 设置输入提示符。
          */
         get prompt() {
             return this._prompt;
         }
         set prompt(value) {
             if (!this._text && value)
                 super.set_color(this._promptColor);
             this.promptColor = this._promptColor;
             if (this._text)
                 super.set_text((this._text == this._prompt) ? value : this._text);
             else
                 super.set_text(value);
             this._prompt = Text.langPacks && Text.langPacks[value] ? Text.langPacks[value] : value;
         }
         /**
          * 设置输入提示符颜色。
          */
         get promptColor() {
             return this._promptColor;
         }
         set promptColor(value) {
             this._promptColor = value;
             if (!this._content)
                 super.set_color(value);
         }
         /**
          * <p>输入框类型为Input静态常量之一。</p>
          * <ul>
          * <li>TYPE_TEXT</li>
          * <li>TYPE_PASSWORD</li>
          * <li>TYPE_EMAIL</li>
          * <li>TYPE_URL</li>
          * <li>TYPE_NUMBER</li>
          * <li>TYPE_RANGE</li>
          * <li>TYPE_DATE</li>
          * <li>TYPE_MONTH</li>
          * <li>TYPE_WEEK</li>
          * <li>TYPE_TIME</li>
          * <li>TYPE_DATE_TIME</li>
          * <li>TYPE_DATE_TIME_LOCAL</li>
          * </ul>
          * <p>平台兼容性参见http://www.w3school.com.cn/html5/html_5_form_input_types.asp。</p>
          */
         get type() {
             return this._type;
         }
         set type(value) {
             if (value === "password")
                 this._getTextStyle().asPassword = true;
             else
                 this._getTextStyle().asPassword = false;
             this._type = value;
         }
     }
     /** 常规文本域。*/
     Input.TYPE_TEXT = "text";
     /** password 类型用于密码域输入。*/
     Input.TYPE_PASSWORD = "password";
     /** email 类型用于应该包含 e-mail 地址的输入域。*/
     Input.TYPE_EMAIL = "email";
     /** url 类型用于应该包含 URL 地址的输入域。*/
     Input.TYPE_URL = "url";
     /** number 类型用于应该包含数值的输入域。*/
     Input.TYPE_NUMBER = "number";
     /**
      * <p>range 类型用于应该包含一定范围内数字值的输入域。</p>
      * <p>range 类型显示为滑动条。</p>
      * <p>您还能够设定对所接受的数字的限定。</p>
      */
     Input.TYPE_RANGE = "range";
     /**  选取日、月、年。*/
     Input.TYPE_DATE = "date";
     /** month - 选取月、年。*/
     Input.TYPE_MONTH = "month";
     /** week - 选取周和年。*/
     Input.TYPE_WEEK = "week";
     /** time - 选取时间（小时和分钟）。*/
     Input.TYPE_TIME = "time";
     /** datetime - 选取时间、日、月、年（UTC 时间）。*/
     Input.TYPE_DATE_TIME = "datetime";
     /** datetime-local - 选取时间、日、月、年（本地时间）。*/
     Input.TYPE_DATE_TIME_LOCAL = "datetime-local";
     /**
      * <p>search 类型用于搜索域，比如站点搜索或 Google 搜索。</p>
      * <p>search 域显示为常规的文本域。</p>
      */
     Input.TYPE_SEARCH = "search";
     /**@private */
     Input.IOS_IFRAME = false;
     Input.inputHeight = 45;
     /**表示是否处于输入状态。*/
     Input.isInputting = false;

     /**
      * <code>Browser</code> 是浏览器代理类。封装浏览器及原生 js 提供的一些功能。
      */
     class Browser {
         /**@private */
         static __init__() {
             var Laya = ILaya.Laya;
             if (Browser._window)
                 return Browser._window;
             var win = Browser._window = window;
             var doc = Browser._document = win.document;
             var u = Browser.userAgent = win.navigator.userAgent;
             //微信小游戏
             if (u.indexOf("MiniGame") > -1 && "wx" in Browser.window) {
                 if (!Laya["MiniAdpter"]) {
                     console.error("请先添加小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-0");
                     //TODO 教程要改
                 }
                 else {
                     Laya["MiniAdpter"].enable();
                 }
             }
             //百度小游戏
             if (u.indexOf("SwanGame") > -1) {
                 if (!Laya["BMiniAdapter"]) {
                     console.error("请先添加百度小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-0");
                     //TODO 教程要改
                 }
                 else {
                     Laya["BMiniAdapter"].enable();
                 }
             }
             //小米小游戏
             if (window.getApp instanceof Function) {
                 if (!Laya["KGMiniAdapter"]) {
                     console.error("请先添加小米小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-0");
                     //TODO 教程要改
                 }
                 else {
                     Laya["KGMiniAdapter"].enable();
                 }
             }
             //OPPO小游戏
             if (u.indexOf('OPPO') > -1 && u.indexOf('MiniGame') > -1) {
                 if (!Laya["QGMiniAdapter"]) {
                     console.error("请先添加OPPO小游戏适配库");
                     //TODO 教程要改
                 }
                 else {
                     Laya["QGMiniAdapter"].enable();
                 }
             }
             //VIVO小游戏
             if (u.indexOf('VVGame') > -1) {
                 if (!Laya["VVMiniAdapter"]) {
                     console.error("请先添加VIVO小游戏适配库");
                     //TODO 教程要改
                 }
                 else {
                     Laya["VVMiniAdapter"].enable();
                 }
             }
             //新增trace的支持
             win.trace = console.log;
             //兼容requestAnimationFrame
             win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (fun) {
                 return win.setTimeout(fun, 1000 / 60);
             };
             //强制修改body样式
             var bodyStyle = doc.body.style;
             bodyStyle.margin = 0;
             bodyStyle.overflow = 'hidden';
             bodyStyle['-webkit-user-select'] = 'none';
             bodyStyle['-webkit-tap-highlight-color'] = 'rgba(200,200,200,0)';
             //强制修改meta标签，防止开发者写错
             var metas = doc.getElementsByTagName('meta');
             var i = 0, flag = false, content = 'width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no';
             while (i < metas.length) {
                 var meta = metas[i];
                 if (meta.name == 'viewport') {
                     meta.content = content;
                     flag = true;
                     break;
                 }
                 i++;
             }
             if (!flag) {
                 meta = doc.createElement('meta');
                 meta.name = 'viewport', meta.content = content;
                 doc.getElementsByTagName('head')[0].appendChild(meta);
             }
             //处理兼容性			
             Browser.onMobile = window.isConchApp ? true : u.indexOf("Mobile") > -1;
             Browser.onIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
             Browser.onIPhone = u.indexOf("iPhone") > -1;
             Browser.onMac = u.indexOf("Mac OS X") > -1;
             Browser.onIPad = u.indexOf("iPad") > -1;
             Browser.onAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;
             Browser.onWP = u.indexOf("Windows Phone") > -1;
             Browser.onQQBrowser = u.indexOf("QQBrowser") > -1;
             Browser.onMQQBrowser = u.indexOf("MQQBrowser") > -1 || (u.indexOf("Mobile") > -1 && u.indexOf("QQ") > -1);
             Browser.onIE = !!win.ActiveXObject || "ActiveXObject" in win;
             Browser.onWeiXin = u.indexOf('MicroMessenger') > -1;
             Browser.onSafari = u.indexOf("Safari") > -1;
             Browser.onPC = !Browser.onMobile;
             Browser.onMiniGame = u.indexOf('MiniGame') > -1;
             Browser.onBDMiniGame = u.indexOf('SwanGame') > -1;
             Browser.onLayaRuntime = !!Browser.window.conch;
             if (u.indexOf('OPPO') > -1 && u.indexOf('MiniGame') > -1) {
                 Browser.onQGMiniGame = true; //OPPO环境判断
                 Browser.onMiniGame = false;
             }
             Browser.onLimixiu = u.indexOf('limixiu') > -1;
             Browser.onVVMiniGame = u.indexOf('VVGame') > -1; //vivo
             //小米运行环境判断
             Browser.onKGMiniGame = u.indexOf('QuickGame') > -1; //小米环境判断
             return win;
         }
         /**
          * 创建浏览器原生节点。
          * @param	type 节点类型。
          * @return	创建的节点对象的引用。
          */
         static createElement(type) {
             Browser.__init__();
             return Browser._document.createElement(type);
         }
         /**
          * 返回 Document 对象中拥有指定 id 的第一个对象的引用。
          * @param	type 节点id。
          * @return	节点对象。
          */
         static getElementById(type) {
             Browser.__init__();
             return Browser._document.getElementById(type);
         }
         /**
          * 移除指定的浏览器原生节点对象。
          * @param	type 节点对象。
          */
         static removeElement(ele) {
             if (ele && ele.parentNode)
                 ele.parentNode.removeChild(ele);
         }
         /**
          * 获取浏览器当前时间戳，单位为毫秒。
          */
         static now() {
             return Date.now();
         }
         /**
          * 浏览器窗口可视宽度。
          * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerWidth(包含滚动条宽度) > document.body.clientWidth(不包含滚动条宽度)，如果前者为0或为空，则选择后者。
          */
         static get clientWidth() {
             Browser.__init__();
             return Browser._window.innerWidth || Browser._document.body.clientWidth;
         }
         /**
          * 浏览器窗口可视高度。
          * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerHeight(包含滚动条高度) > document.body.clientHeight(不包含滚动条高度) > document.documentElement.clientHeight(不包含滚动条高度)，如果前者为0或为空，则选择后者。
          */
         static get clientHeight() {
             Browser.__init__();
             return Browser._window.innerHeight || Browser._document.body.clientHeight || Browser._document.documentElement.clientHeight;
         }
         /** 浏览器窗口物理宽度。考虑了设备像素比。*/
         static get width() {
             Browser.__init__();
             return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio;
         }
         /** 浏览器窗口物理高度。考虑了设备像素比。*/
         static get height() {
             Browser.__init__();
             return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio;
         }
         /** 获得设备像素比。*/
         static get pixelRatio() {
             if (Browser._pixelRatio < 0) {
                 Browser.__init__();
                 if (Browser.userAgent.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)") > -1)
                     Browser._pixelRatio = 2;
                 else {
                     var ctx = Browser.context;
                     var backingStore = ctx.backingStorePixelRatio || ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
                     Browser._pixelRatio = (Browser._window.devicePixelRatio || 1) / backingStore;
                     if (Browser._pixelRatio < 1)
                         Browser._pixelRatio = 1;
                 }
             }
             return Browser._pixelRatio;
         }
         /**画布容器，用来盛放画布的容器。方便对画布进行控制*/
         static get container() {
             if (!Browser._container) {
                 Browser.__init__();
                 Browser._container = Browser.createElement("div");
                 Browser._container.id = "layaContainer";
                 Browser._document.body.appendChild(Browser._container);
             }
             return Browser._container;
         }
         static set container(value) {
             Browser._container = value;
         }
         /**浏览器原生 window 对象的引用。*/
         static get window() {
             return Browser._window || Browser.__init__();
         }
         /**浏览器原生 document 对象的引用。*/
         static get document() {
             Browser.__init__();
             return Browser._document;
         }
     }
     /** @private */
     Browser._pixelRatio = -1;
     /** @private */
     Browser.mainCanvas = null;
     /**@private */
     Browser.hanzi = new RegExp("^[\u4E00-\u9FA5]$");
     /**@private */
     Browser.fontMap = [];
     /**@private */
     Browser.measureText = function (txt, font) {
         var isChinese = Browser.hanzi.test(txt);
         if (isChinese && Browser.fontMap[font]) {
             return Browser.fontMap[font];
         }
         var ctx = Browser.context;
         ctx.font = font;
         var r = ctx.measureText(txt);
         if (isChinese)
             Browser.fontMap[font] = r;
         return r;
     };

     /**
      * @private
      * Touch事件管理类，处理多点触控下的鼠标事件
      */
     class TouchManager {
         constructor() {
             /**
              * 当前over的touch表
              */
             this.preOvers = [];
             /**
              * 当前down的touch表
              */
             this.preDowns = [];
             this.preRightDowns = [];
             /**
              * 是否启用
              */
             this.enable = true;
             /**
              * 用于派发事件用的Event对象
              */
             this._event = new Event();
             this._lastClickTime = 0;
         }
         _clearTempArrs() {
             TouchManager._oldArr.length = 0;
             TouchManager._newArr.length = 0;
             TouchManager._tEleArr.length = 0;
         }
         /**
          * 从touch表里查找对应touchID的数据
          * @param touchID touch ID
          * @param arr touch表
          * @return
          *
          */
         getTouchFromArr(touchID, arr) {
             var i, len;
             len = arr.length;
             var tTouchO;
             for (i = 0; i < len; i++) {
                 tTouchO = arr[i];
                 if (tTouchO.id == touchID) {
                     return tTouchO;
                 }
             }
             return null;
         }
         /**
          * 从touch表里移除一个元素
          * @param touchID touch ID
          * @param arr touch表
          *
          */
         removeTouchFromArr(touchID, arr) {
             //DebugTxt.dTrace("removeTouch:"+touchID);
             var i;
             for (i = arr.length - 1; i >= 0; i--) {
                 if (arr[i].id == touchID) {
                     //DebugTxt.dTrace("removeedTouch:"+touchID);
                     arr.splice(i, 1);
                 }
             }
         }
         /**
          * 创建一个touch数据
          * @param ele 当前的根节点
          * @param touchID touchID
          * @return
          *
          */
         createTouchO(ele, touchID) {
             var rst;
             rst = Pool.getItem("TouchData") || {};
             rst.id = touchID;
             rst.tar = ele;
             return rst;
         }
         /**
          * 处理touchStart
          * @param ele		根节点
          * @param touchID	touchID
          * @param isLeft	（可选）是否为左键
          */
         onMouseDown(ele, touchID, isLeft = false) {
             if (!this.enable)
                 return;
             var preO;
             var tO;
             var arrs;
             preO = this.getTouchFromArr(touchID, this.preOvers);
             arrs = this.getEles(ele, null, TouchManager._tEleArr);
             if (!preO) {
                 tO = this.createTouchO(ele, touchID);
                 this.preOvers.push(tO);
             }
             else {
                 //理论上不会发生，相同触摸事件必然不会在end之前再次出发
                 preO.tar = ele;
             }
             if (Browser.onMobile)
                 this.sendEvents(arrs, Event.MOUSE_OVER);
             var preDowns;
             preDowns = isLeft ? this.preDowns : this.preRightDowns;
             preO = this.getTouchFromArr(touchID, preDowns);
             if (!preO) {
                 tO = this.createTouchO(ele, touchID);
                 preDowns.push(tO);
             }
             else {
                 //理论上不会发生，相同触摸事件必然不会在end之前再次出发
                 preO.tar = ele;
             }
             this.sendEvents(arrs, isLeft ? Event.MOUSE_DOWN : Event.RIGHT_MOUSE_DOWN);
             this._clearTempArrs();
         }
         /**
          * 派发事件。
          * @param eles		对象列表。
          * @param type		事件类型。
          */
         sendEvents(eles, type) {
             var i, len;
             len = eles.length;
             this._event._stoped = false;
             var _target;
             _target = eles[0];
             for (i = 0; i < len; i++) {
                 var tE = eles[i];
                 if (tE.destroyed)
                     return;
                 tE.event(type, this._event.setTo(type, tE, _target));
                 if (this._event._stoped)
                     break;
             }
         }
         /**
          * 获取对象列表。
          * @param start	起始节点。
          * @param end	结束节点。
          * @param rst	返回值。如果此值不为空，则将其赋值为计算结果，从而避免创建新数组；如果此值为空，则创建新数组返回。
          * @return Array 返回节点列表。
          */
         getEles(start, end = null, rst = null) {
             if (!rst) {
                 rst = [];
             }
             else {
                 rst.length = 0;
             }
             while (start && start != end) {
                 rst.push(start);
                 start = start.parent;
             }
             return rst;
         }
         /**
          * touchMove时处理out事件和over时间。
          * @param eleNew	新的根节点。
          * @param elePre	旧的根节点。
          * @param touchID	（可选）touchID，默认为0。
          */
         checkMouseOutAndOverOfMove(eleNew, elePre, touchID = 0) {
             if (elePre == eleNew)
                 return;
             var tar;
             var arrs;
             var i, len;
             if (elePre.contains(eleNew)) {
                 arrs = this.getEles(eleNew, elePre, TouchManager._tEleArr);
                 this.sendEvents(arrs, Event.MOUSE_OVER);
             }
             else if (eleNew.contains(elePre)) {
                 arrs = this.getEles(elePre, eleNew, TouchManager._tEleArr);
                 this.sendEvents(arrs, Event.MOUSE_OUT);
             }
             else {
                 //arrs = getEles(elePre);
                 arrs = TouchManager._tEleArr;
                 arrs.length = 0;
                 var oldArr;
                 oldArr = this.getEles(elePre, null, TouchManager._oldArr);
                 var newArr;
                 newArr = this.getEles(eleNew, null, TouchManager._newArr);
                 len = oldArr.length;
                 var tIndex;
                 for (i = 0; i < len; i++) {
                     tar = oldArr[i];
                     tIndex = newArr.indexOf(tar);
                     if (tIndex >= 0) {
                         newArr.splice(tIndex, newArr.length - tIndex);
                         break;
                     }
                     else {
                         arrs.push(tar);
                     }
                 }
                 if (arrs.length > 0) {
                     this.sendEvents(arrs, Event.MOUSE_OUT);
                 }
                 if (newArr.length > 0) {
                     this.sendEvents(newArr, Event.MOUSE_OVER);
                 }
             }
         }
         /**
          * 处理TouchMove事件
          * @param ele 根节点
          * @param touchID touchID
          *
          */
         onMouseMove(ele, touchID) {
             if (!this.enable)
                 return;
             //DebugTxt.dTrace("onMouseMove:"+touchID);
             var preO;
             preO = this.getTouchFromArr(touchID, this.preOvers);
             var arrs;
             if (!preO) {
                 //理论上不会发生，因为必然先有touchstart再有touchMove
                 arrs = this.getEles(ele, null, TouchManager._tEleArr);
                 this.sendEvents(arrs, Event.MOUSE_OVER);
                 this.preOvers.push(this.createTouchO(ele, touchID));
             }
             else {
                 this.checkMouseOutAndOverOfMove(ele, preO.tar);
                 preO.tar = ele;
                 arrs = this.getEles(ele, null, TouchManager._tEleArr);
             }
             this.sendEvents(arrs, Event.MOUSE_MOVE);
             this._clearTempArrs();
         }
         getLastOvers() {
             TouchManager._tEleArr.length = 0;
             if (this.preOvers.length > 0 && this.preOvers[0].tar) {
                 return this.getEles(this.preOvers[0].tar, null, TouchManager._tEleArr);
             }
             TouchManager._tEleArr.push(ILaya.stage);
             return TouchManager._tEleArr;
         }
         stageMouseOut() {
             var lastOvers;
             lastOvers = this.getLastOvers();
             this.preOvers.length = 0;
             this.sendEvents(lastOvers, Event.MOUSE_OUT);
         }
         /**
          * 处理TouchEnd事件
          * @param ele		根节点
          * @param touchID	touchID
          * @param isLeft	是否为左键
          */
         onMouseUp(ele, touchID, isLeft = false) {
             if (!this.enable)
                 return;
             var preO;
             var arrs;
             var oldArr;
             var i, len;
             var tar;
             var sendArr;
             var onMobile = Browser.onMobile;
             //处理up
             arrs = this.getEles(ele, null, TouchManager._tEleArr);
             this.sendEvents(arrs, isLeft ? Event.MOUSE_UP : Event.RIGHT_MOUSE_UP);
             //处理click
             var preDowns;
             preDowns = isLeft ? this.preDowns : this.preRightDowns;
             preO = this.getTouchFromArr(touchID, preDowns);
             if (!preO) ;
             else {
                 var isDouble;
                 var now = Browser.now();
                 isDouble = now - this._lastClickTime < 300;
                 this._lastClickTime = now;
                 if (ele == preO.tar) {
                     sendArr = arrs;
                 }
                 else {
                     oldArr = this.getEles(preO.tar, null, TouchManager._oldArr);
                     sendArr = TouchManager._newArr;
                     sendArr.length = 0;
                     len = oldArr.length;
                     for (i = 0; i < len; i++) {
                         tar = oldArr[i];
                         if (arrs.indexOf(tar) >= 0) {
                             sendArr.push(tar);
                         }
                     }
                 }
                 if (sendArr.length > 0) {
                     this.sendEvents(sendArr, isLeft ? Event.CLICK : Event.RIGHT_CLICK);
                 }
                 if (isLeft && isDouble) {
                     this.sendEvents(sendArr, Event.DOUBLE_CLICK);
                 }
                 this.removeTouchFromArr(touchID, preDowns);
                 preO.tar = null;
                 Pool.recover("TouchData", preO);
             }
             //处理out
             preO = this.getTouchFromArr(touchID, this.preOvers);
             if (!preO) ;
             else {
                 if (onMobile) {
                     sendArr = this.getEles(preO.tar, null, sendArr);
                     if (sendArr && sendArr.length > 0) {
                         this.sendEvents(sendArr, Event.MOUSE_OUT);
                     }
                     this.removeTouchFromArr(touchID, this.preOvers);
                     preO.tar = null;
                     Pool.recover("TouchData", preO);
                 }
             }
             this._clearTempArrs();
         }
     }
     TouchManager.I = new TouchManager();
     TouchManager._oldArr = [];
     TouchManager._newArr = [];
     TouchManager._tEleArr = [];

     /**
      * <p><code>MouseManager</code> 是鼠标、触摸交互管理器。</p>
      * <p>鼠标事件流包括捕获阶段、目标阶段、冒泡阶段。<br/>
      * 捕获阶段：此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象；<br/>
      * 目标阶段：找到命中的目标对象；<br/>
      * 冒泡阶段：事件离开目标对象，按节点层级向上逐层通知，直到到达舞台的过程。</p>
      */
     class MouseManager {
         constructor() {
             /** canvas 上的鼠标X坐标。*/
             this.mouseX = 0;
             /** canvas 上的鼠标Y坐标。*/
             this.mouseY = 0;
             /** 是否禁用除 stage 以外的鼠标事件检测。*/
             this.disableMouseEvent = false;
             /** 鼠标按下的时间。单位为毫秒。*/
             this.mouseDownTime = 0;
             /** 鼠标移动精度。*/
             this.mouseMoveAccuracy = 2;
             this._event = new Event();
             /** @private 希望capture鼠标事件的对象。*/
             this._captureSp = null;
             /** @private 现在不支持直接把绝对坐标转到本地坐标，只能一级一级做下去，因此记录一下这个链*/
             this._captureChain = [];
             /** @private capture对象独占消息 */
             this._captureExlusiveMode = false;
             /** @private 在发送事件的过程中，是否发送给了_captureSp */
             this._hitCaputreSp = false;
             this._point = new Point();
             this._rect = new Rectangle();
             this._lastMoveTimer = 0;
             this._prePoint = new Point();
             this._touchIDs = {};
             this._curTouchID = NaN;
             this._id = 1;
         }
         /**
          * @private
          * 初始化。
          */
         __init__(stage, canvas) {
             this._stage = stage;
             var _this = this;
             //var canvas:* = Render.canvas;
             canvas.oncontextmenu = function (e) {
                 if (MouseManager.enabled)
                     return false;
             };
             canvas.addEventListener('mousedown', function (e) {
                 if (MouseManager.enabled) {
                     if (!Browser.onIE)
                         e.preventDefault();
                     _this.mouseDownTime = Browser.now();
                     _this.runEvent(e);
                 }
             });
             canvas.addEventListener('mouseup', function (e) {
                 if (MouseManager.enabled) {
                     e.preventDefault();
                     _this.mouseDownTime = -Browser.now();
                     _this.runEvent(e);
                 }
             }, true);
             canvas.addEventListener('mousemove', function (e) {
                 if (MouseManager.enabled) {
                     e.preventDefault();
                     var now = Browser.now();
                     if (now - _this._lastMoveTimer < 10)
                         return;
                     _this._lastMoveTimer = now;
                     _this.runEvent(e);
                 }
             }, true);
             canvas.addEventListener("mouseout", function (e) {
                 if (MouseManager.enabled)
                     _this.runEvent(e);
             });
             canvas.addEventListener("mouseover", function (e) {
                 if (MouseManager.enabled)
                     _this.runEvent(e);
             });
             canvas.addEventListener("touchstart", function (e) {
                 if (MouseManager.enabled) {
                     if (!MouseManager._isFirstTouch && !Input.isInputting)
                         e.preventDefault();
                     _this.mouseDownTime = Browser.now();
                     _this.runEvent(e);
                 }
             });
             canvas.addEventListener("touchend", function (e) {
                 if (MouseManager.enabled) {
                     if (!MouseManager._isFirstTouch && !Input.isInputting)
                         e.preventDefault();
                     MouseManager._isFirstTouch = false;
                     _this.mouseDownTime = -Browser.now();
                     _this.runEvent(e);
                 }
                 else {
                     _this._curTouchID = NaN;
                 }
             }, true);
             canvas.addEventListener("touchmove", function (e) {
                 if (MouseManager.enabled) {
                     e.preventDefault();
                     _this.runEvent(e);
                 }
             }, true);
             canvas.addEventListener("touchcancel", function (e) {
                 if (MouseManager.enabled) {
                     e.preventDefault();
                     _this.runEvent(e);
                 }
                 else {
                     _this._curTouchID = NaN;
                 }
             }, true);
             canvas.addEventListener('mousewheel', function (e) {
                 if (MouseManager.enabled)
                     _this.runEvent(e);
             });
             canvas.addEventListener('DOMMouseScroll', function (e) {
                 if (MouseManager.enabled)
                     _this.runEvent(e);
             });
         }
         initEvent(e, nativeEvent = null) {
             var _this = this;
             _this._event._stoped = false;
             _this._event.nativeEvent = nativeEvent || e;
             _this._target = null;
             this._point.setTo(e.pageX || e.clientX, e.pageY || e.clientY);
             if (this._stage._canvasTransform) {
                 this._stage._canvasTransform.invertTransformPoint(this._point);
                 _this.mouseX = this._point.x;
                 _this.mouseY = this._point.y;
             }
             _this._event.touchId = e.identifier || 0;
             this._tTouchID = _this._event.touchId;
             var evt;
             evt = TouchManager.I._event;
             evt._stoped = false;
             evt.nativeEvent = _this._event.nativeEvent;
             evt.touchId = _this._event.touchId;
         }
         checkMouseWheel(e) {
             this._event.delta = e.wheelDelta ? e.wheelDelta * 0.025 : -e.detail;
             var _lastOvers = TouchManager.I.getLastOvers();
             for (var i = 0, n = _lastOvers.length; i < n; i++) {
                 var ele = _lastOvers[i];
                 ele.event(Event.MOUSE_WHEEL, this._event.setTo(Event.MOUSE_WHEEL, ele, this._target));
             }
             //			_stage.event(Event.MOUSE_WHEEL, _event.setTo(Event.MOUSE_WHEEL, _stage, _target));
         }
         onMouseMove(ele) {
             TouchManager.I.onMouseMove(ele, this._tTouchID);
         }
         onMouseDown(ele) {
             if (Input.isInputting && ILaya.stage.focus && ILaya.stage.focus["focus"] && !ILaya.stage.focus.contains(this._target)) {
                 // 从UI Input组件中取得Input引用
                 // _tf 是TextInput的属性
                 var pre_input = ILaya.stage.focus['_tf'] || ILaya.stage.focus;
                 var new_input = ele['_tf'] || ele;
                 // 新的焦点是Input的情况下，不需要blur；
                 // 不过如果是Input和TextArea之间的切换，还是需要重新弹出输入法；
                 if (new_input instanceof Input && new_input.multiline == pre_input.multiline)
                     pre_input['_focusOut']();
                 else
                     pre_input.focus = false;
             }
             TouchManager.I.onMouseDown(ele, this._tTouchID, this._isLeftMouse);
         }
         onMouseUp(ele) {
             TouchManager.I.onMouseUp(ele, this._tTouchID, this._isLeftMouse);
         }
         check(sp, mouseX, mouseY, callBack) {
             this._point.setTo(mouseX, mouseY);
             sp.fromParentPoint(this._point);
             mouseX = this._point.x;
             mouseY = this._point.y;
             //如果有裁剪，则先判断是否在裁剪范围内
             var scrollRect = sp._style.scrollRect;
             if (scrollRect) {
                 this._rect.setTo(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height);
                 if (!this._rect.contains(mouseX, mouseY))
                     return false;
             }
             //先判定子对象是否命中
             if (!this.disableMouseEvent) {
                 //优先判断父对象
                 //默认情况下，hitTestPrior=mouseThrough=false，也就是优先check子对象
                 //$NEXTBIG:下个重大版本将sp.mouseThrough从此逻辑中去除，从而使得sp.mouseThrough只负责目标对象的穿透
                 if (sp.hitTestPrior && !sp.mouseThrough && !this.hitTest(sp, mouseX, mouseY)) {
                     return false;
                 }
                 for (var i = sp._children.length - 1; i > -1; i--) {
                     var child = sp._children[i];
                     //只有接受交互事件的，才进行处理
                     if (!child.destroyed && child._mouseState > 1 && child._visible) {
                         if (this.check(child, mouseX, mouseY, callBack))
                             return true;
                     }
                 }
                 // 检查逻辑子对象
                 for (i = sp._extUIChild.length - 1; i >= 0; i--) {
                     var c = sp._extUIChild[i];
                     if (!c.destroyed && c._mouseState > 1 && c._visible) {
                         if (this.check(c, mouseX, mouseY, callBack))
                             return true;
                     }
                 }
             }
             //避免重复进行碰撞检测，考虑了判断条件的命中率。
             var isHit = (sp.hitTestPrior && !sp.mouseThrough && !this.disableMouseEvent) ? true : this.hitTest(sp, mouseX, mouseY);
             if (isHit) {
                 this._target = sp;
                 callBack.call(this, sp);
                 if (this._target == this._hitCaputreSp) {
                     this._hitCaputreSp = true;
                 }
             }
             else if (callBack === this.onMouseUp && sp === this._stage) {
                 //如果stage外mouseUP
                 this._target = this._stage;
                 callBack.call(this, this._target);
             }
             return isHit;
         }
         hitTest(sp, mouseX, mouseY) {
             var isHit = false;
             if (sp.scrollRect) {
                 mouseX -= sp._style.scrollRect.x;
                 mouseY -= sp._style.scrollRect.y;
             }
             var hitArea = sp._style.hitArea;
             if (hitArea && hitArea._hit) {
                 return hitArea.contains(mouseX, mouseY);
             }
             if (sp.width > 0 && sp.height > 0 || sp.mouseThrough || hitArea) {
                 //判断是否在矩形区域内
                 if (!sp.mouseThrough) {
                     //MOD by liuzihao: saved call of 'hitRect' and 'this._rect' when 'sp.hitArea' is not null.
                     isHit = (hitArea ? hitArea : this._rect.setTo(0, 0, sp.width, sp.height)).contains(mouseX, mouseY);
                 }
                 else {
                     //如果可穿透，则根据子对象实际大小进行碰撞
                     isHit = sp.getGraphicBounds().contains(mouseX, mouseY);
                 }
             }
             return isHit;
         }
         _checkAllBaseUI(mousex, mousey, callback) {
             var ret = this.handleExclusiveCapture(this.mouseX, this.mouseY, callback);
             if (ret)
                 return true;
             ret = this.check(this._stage, this.mouseX, this.mouseY, callback);
             //ret = check3DUI(mousex,mousey,callback) || ret;		//在这里调结果不对，好像不会调用click
             return this.handleCapture(this.mouseX, this.mouseY, callback) || ret;
         }
         /**
          * 处理3d界面。
          * @param	mousex
          * @param	mousey
          * @param	callback
          * @return
          */
         check3DUI(mousex, mousey, callback) {
             var uis = this._stage._3dUI;
             var i = 0;
             var ret = false;
             for (; i < uis.length; i++) {
                 var curui = uis[i];
                 this._stage._curUIBase = curui;
                 if (!curui.destroyed && curui._mouseState > 1 && curui._visible) {
                     ret = ret || this.check(curui, this.mouseX, this.mouseY, callback);
                 }
             }
             this._stage._curUIBase = this._stage;
             return ret;
         }
         handleExclusiveCapture(mousex, mousey, callback) {
             if (this._captureExlusiveMode && this._captureSp && this._captureChain.length > 0) {
                 var cursp;
                 // 坐标转到capture对象的相对坐标
                 this._point.setTo(mousex, mousey);
                 for (var i = 0; i < this._captureChain.length; i++) {
                     cursp = this._captureChain[i];
                     cursp.fromParentPoint(this._point);
                 }
                 this._target = cursp;
                 callback.call(this, cursp);
                 return true;
             }
             return false;
         }
         handleCapture(mousex, mousey, callback) {
             if (!this._hitCaputreSp && this._captureSp && this._captureChain.length > 0) {
                 var cursp;
                 // 坐标转到capture对象的相对坐标
                 this._point.setTo(mousex, mousey);
                 for (var i = 0; i < this._captureChain.length; i++) {
                     cursp = this._captureChain[i];
                     cursp.fromParentPoint(this._point);
                 }
                 this._target = cursp;
                 callback.call(this, cursp);
                 return true;
             }
             return false;
         }
         /**
          * 执行事件处理。
          */
         runEvent(evt) {
             var i, n, touch;
             if (evt.type !== 'mousemove')
                 this._prePoint.x = this._prePoint.y = -1000000;
             switch (evt.type) {
                 case 'mousedown':
                     this._touchIDs[0] = this._id++;
                     if (!MouseManager._isTouchRespond) {
                         this._isLeftMouse = evt.button === 0;
                         this.initEvent(evt);
                         this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseDown);
                     }
                     else
                         MouseManager._isTouchRespond = false;
                     break;
                 case 'mouseup':
                     this._isLeftMouse = evt.button === 0;
                     this.initEvent(evt);
                     this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseUp);
                     break;
                 case 'mousemove':
                     if ((Math.abs(this._prePoint.x - evt.clientX) + Math.abs(this._prePoint.y - evt.clientY)) >= this.mouseMoveAccuracy) {
                         this._prePoint.x = evt.clientX;
                         this._prePoint.y = evt.clientY;
                         this.initEvent(evt);
                         this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseMove);
                         //						checkMouseOut();
                     }
                     break;
                 case "touchstart":
                     MouseManager._isTouchRespond = true;
                     this._isLeftMouse = true;
                     var touches = evt.changedTouches;
                     for (i = 0, n = touches.length; i < n; i++) {
                         touch = touches[i];
                         //是否禁用多点触控
                         if (MouseManager.multiTouchEnabled || isNaN(this._curTouchID)) {
                             this._curTouchID = touch.identifier;
                             //200次点击清理一下id资源
                             if (this._id % 200 === 0)
                                 this._touchIDs = {};
                             this._touchIDs[touch.identifier] = this._id++;
                             this.initEvent(touch, evt);
                             this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseDown);
                         }
                     }
                     break;
                 case "touchend":
                 case "touchcancel":
                     MouseManager._isTouchRespond = true;
                     this._isLeftMouse = true;
                     var touchends = evt.changedTouches;
                     for (i = 0, n = touchends.length; i < n; i++) {
                         touch = touchends[i];
                         //是否禁用多点触控
                         if (MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) {
                             this._curTouchID = NaN;
                             this.initEvent(touch, evt);
                             var isChecked;
                             isChecked = this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseUp);
                             if (!isChecked) {
                                 this.onMouseUp(null);
                             }
                         }
                     }
                     break;
                 case "touchmove":
                     var touchemoves = evt.changedTouches;
                     for (i = 0, n = touchemoves.length; i < n; i++) {
                         touch = touchemoves[i];
                         //是否禁用多点触控
                         if (MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) {
                             this.initEvent(touch, evt);
                             this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseMove);
                         }
                     }
                     break;
                 case "wheel":
                 case "mousewheel":
                 case "DOMMouseScroll":
                     this.checkMouseWheel(evt);
                     break;
                 case "mouseout":
                     //_stage.event(Event.MOUSE_OUT, _event.setTo(Event.MOUSE_OUT, _stage, _stage));
                     TouchManager.I.stageMouseOut();
                     break;
                 case "mouseover":
                     this._stage.event(Event.MOUSE_OVER, this._event.setTo(Event.MOUSE_OVER, this._stage, this._stage));
                     break;
             }
         }
         /**
          *
          * @param	sp
          * @param	exlusive  是否是独占模式
          */
         setCapture(sp, exclusive = false) {
             this._captureSp = sp;
             this._captureExlusiveMode = exclusive;
             this._captureChain.length = 0;
             this._captureChain.push(sp);
             var cursp = sp;
             while (true) {
                 if (cursp == ILaya.stage)
                     break;
                 if (cursp == ILaya.stage._curUIBase)
                     break;
                 cursp = cursp.parent;
                 if (!cursp)
                     break;
                 this._captureChain.splice(0, 0, cursp);
             }
         }
         releaseCapture() {
             console.log('release capture');
             this._captureSp = null;
         }
     }
     /**
      * MouseManager 单例引用。
      */
     MouseManager.instance = new MouseManager();
     /**是否开启鼠标检测，默认为true*/
     MouseManager.enabled = true;
     /**是否开启多点触控*/
     MouseManager.multiTouchEnabled = true;
     MouseManager._isFirstTouch = true;

     /**
          * @private
          */
     class CallLater {
         constructor() {
             /**@private */
             this._pool = [];
             /**@private */
             this._map = [];
             /**@private */
             this._laters = [];
         }
         /**
          * @private
          * 帧循环处理函数。
          */
         _update() {
             var laters = this._laters;
             var len = laters.length;
             if (len > 0) {
                 for (var i = 0, n = len - 1; i <= n; i++) {
                     var handler = laters[i];
                     this._map[handler.key] = null;
                     if (handler.method !== null) {
                         handler.run();
                         handler.clear();
                     }
                     this._pool.push(handler);
                     i === n && (n = laters.length - 1);
                 }
                 laters.length = 0;
             }
         }
         /** @private */
         _getHandler(caller, method) {
             var cid = caller ? caller.$_GID || (caller.$_GID = ILaya.Utils.getGID()) : 0;
             var mid = method.$_TID || (method.$_TID = (ILaya.Timer._mid++) * 100000);
             return this._map[cid + mid];
         }
         /**
          * 延迟执行。
          * @param	caller 执行域(this)。
          * @param	method 定时器回调函数。
          * @param	args 回调参数。
          */
         callLater(caller, method, args = null) {
             if (this._getHandler(caller, method) == null) {
                 if (this._pool.length)
                     var handler = this._pool.pop();
                 else
                     handler = new LaterHandler();
                 //设置属性
                 handler.caller = caller;
                 handler.method = method;
                 handler.args = args;
                 //索引handler
                 var cid = caller ? caller.$_GID : 0;
                 var mid = method["$_TID"];
                 handler.key = cid + mid;
                 this._map[handler.key] = handler;
                 //插入队列
                 this._laters.push(handler);
             }
         }
         /**
          * 立即执行 callLater 。
          * @param	caller 执行域(this)。
          * @param	method 定时器回调函数。
          */
         runCallLater(caller, method) {
             var handler = this._getHandler(caller, method);
             if (handler && handler.method != null) {
                 this._map[handler.key] = null;
                 handler.run();
                 handler.clear();
             }
         }
     }
     CallLater.I = new CallLater();
     /** @private */
     class LaterHandler {
         clear() {
             this.caller = null;
             this.method = null;
             this.args = null;
         }
         run() {
             var caller = this.caller;
             if (caller && caller.destroyed)
                 return this.clear();
             var method = this.method;
             var args = this.args;
             if (method == null)
                 return;
             args ? method.apply(caller, args) : method.call(caller);
         }
     }

     /**
      * @private
      */
     class RunDriver {
     }
     //TODO:coverage
     RunDriver.createShaderCondition = function (conditionScript) {
         var fn = "(function() {return " + conditionScript + ";})";
         return window.Laya._runScript(fn); //生成条件判断函数
     };
     /**
      * 用于改变 WebGL宽高信息。
      */
     RunDriver.changeWebGLSize = function (w, h) {
         WebGL.onStageResize(w, h);
     };

     /**
      * stage大小经过重新调整时进行调度。
      * @eventType Event.RESIZE
      */
     /*[Event(name = "resize", type = "laya.events.Event")]*/
     /**
      * 舞台获得焦点时调度。比如浏览器或者当前标签处于后台，重新切换回来时进行调度。
      * @eventType Event.FOCUS
      */
     /*[Event(name = "focus", type = "laya.events.Event")]*/
     /**
      * 舞台失去焦点时调度。比如浏览器或者当前标签被切换到后台后调度。
      * @eventType Event.BLUR
      */
     /*[Event(name = "blur", type = "laya.events.Event")]*/
     /**
      * 舞台焦点变化时调度，使用Laya.stage.isFocused可以获取当前舞台是否获得焦点。
      * @eventType Event.FOCUS_CHANGE
      */
     /*[Event(name = "focuschange", type = "laya.events.Event")]*/
     /**
      * 舞台可见性发生变化时调度（比如浏览器或者当前标签被切换到后台后调度），使用Laya.stage.isVisibility可以获取当前是否处于显示状态。
      * @eventType Event.VISIBILITY_CHANGE
      */
     /*[Event(name = "visibilitychange", type = "laya.events.Event")]*/
     /**
      * 浏览器全屏更改时调度，比如进入全屏或者退出全屏。
      * @eventType Event.FULL_SCREEN_CHANGE
      */
     /*[Event(name = "fullscreenchange", type = "laya.events.Event")]*/
     /**
      * <p> <code>Stage</code> 是舞台类，显示列表的根节点，所有显示对象都在舞台上显示。通过 Laya.stage 单例访问。</p>
      * <p>Stage提供几种适配模式，不同的适配模式会产生不同的画布大小，画布越大，渲染压力越大，所以要选择合适的适配方案。</p>
      * <p>Stage提供不同的帧率模式，帧率越高，渲染压力越大，越费电，合理使用帧率甚至动态更改帧率有利于改进手机耗电。</p>
      */
     class Stage extends Sprite {
         /**场景类，引擎中只有一个stage实例，此实例可以通过Laya.stage访问。*/
         constructor() {
             super();
             /**@private 相对浏览器左上角的偏移，弃用，请使用_canvasTransform。*/
             this.offset = new Point();
             /**帧率类型，支持三种模式：fast-60帧(默认)，slow-30帧，mouse-30帧（鼠标活动后会自动加速到60，鼠标不动2秒后降低为30帧，以节省消耗），sleep-1帧。*/
             this._frameRate = "fast";
             /**设计宽度（初始化时设置的宽度Laya.init(width,height)）*/
             this.designWidth = 0;
             /**设计高度（初始化时设置的高度Laya.init(width,height)）*/
             this.designHeight = 0;
             /**画布是否发生翻转。*/
             this.canvasRotation = false;
             /**画布的旋转角度。*/
             this.canvasDegree = 0;
             /**
              * <p>设置是否渲染，设置为false，可以停止渲染，画面会停留到最后一次渲染上，减少cpu消耗，此设置不影响时钟。</p>
              * <p>比如非激活状态，可以设置renderingEnabled=false以节省消耗。</p>
              * */
             this.renderingEnabled = true;
             /**是否启用屏幕适配，可以适配后，在某个时候关闭屏幕适配，防止某些操作导致的屏幕意外改变*/
             this.screenAdaptationEnabled = true;
             /**@private */
             this._canvasTransform = new Matrix();
             /**@private */
             this._screenMode = "none";
             /**@private */
             this._scaleMode = "noscale";
             /**@private */
             this._alignV = "top";
             /**@private */
             this._alignH = "left";
             /**@private */
             this._bgColor = "black";
             /**@private */
             this._mouseMoveTime = 0;
             /**@private */
             this._renderCount = 0;
             /**@private */
             this._safariOffsetY = 0;
             /**@private */
             this._frameStartTime = 0;
             /**@private */
             this._previousOrientation = Browser.window.orientation;
             /**@private webgl Color*/
             this._wgColor = [0, 0, 0, 1];
             /**@private */
             this._scene3Ds = [];
             /**@private */
             this._globalRepaintSet = false; // 设置全局重画标志。这个是给IDE用的。IDE的Image无法在onload的时候通知对应的sprite重画。
             /**@private */
             this._globalRepaintGet = false; // 一个get一个set是为了把标志延迟到下一帧的开始，防止部分对象接收不到。
             /**@private */
             this._3dUI = [];
             /**@private */
             this._curUIBase = null; // 给鼠标事件capture用的。用来找到自己的根。因为3d界面的根不是stage（界面链会被3d对象打断）
             /**使用物理分辨率作为canvas大小，会改进渲染效果，但是会降低性能*/
             this.useRetinalCanvas = false;
             super.set_transform(this._createTransform());
             //重置默认值，请不要修改
             this.mouseEnabled = true;
             this.hitTestPrior = true;
             this.autoSize = false;
             this._setBit(Const.DISPLAYED_INSTAGE, true);
             this._setBit(Const.ACTIVE_INHIERARCHY, true);
             this._isFocused = true;
             this._isVisibility = true;
             //this.drawCallOptimize=true;
             this.useRetinalCanvas = Config.useRetinalCanvas;
             var window = Browser.window;
             var _me = this; //for TS 。 TS的_this是有特殊用途的
             window.addEventListener("focus", function () {
                 this._isFocused = true;
                 _me.event(Event.FOCUS);
                 _me.event(Event.FOCUS_CHANGE);
             });
             window.addEventListener("blur", function () {
                 this._isFocused = false;
                 _me.event(Event.BLUR);
                 _me.event(Event.FOCUS_CHANGE);
                 if (_me._isInputting())
                     Input["inputElement"].target.focus = false;
             });
             // 各种浏览器兼容
             var state = "visibilityState", visibilityChange = "visibilitychange";
             var document = window.document;
             if (typeof document.hidden !== "undefined") {
                 visibilityChange = "visibilitychange";
                 state = "visibilityState";
             }
             else if (typeof document.mozHidden !== "undefined") {
                 visibilityChange = "mozvisibilitychange";
                 state = "mozVisibilityState";
             }
             else if (typeof document.msHidden !== "undefined") {
                 visibilityChange = "msvisibilitychange";
                 state = "msVisibilityState";
             }
             else if (typeof document.webkitHidden !== "undefined") {
                 visibilityChange = "webkitvisibilitychange";
                 state = "webkitVisibilityState";
             }
             window.document.addEventListener(visibilityChange, visibleChangeFun);
             function visibleChangeFun() {
                 if (Browser.document[state] == "hidden") {
                     this._isVisibility = false;
                     if (_me._isInputting())
                         Input["inputElement"].target.focus = false;
                 }
                 else {
                     this._isVisibility = true;
                 }
                 this.renderingEnabled = this._isVisibility;
                 _me.event(Event.VISIBILITY_CHANGE);
             }
             window.addEventListener("resize", function () {
                 // 处理屏幕旋转。旋转后收起输入法。
                 var orientation = Browser.window.orientation;
                 if (orientation != null && orientation != this._previousOrientation && _me._isInputting()) {
                     Input["inputElement"].target.focus = false;
                 }
                 this._previousOrientation = orientation;
                 // 弹出输入法不应对画布进行resize。
                 if (_me._isInputting())
                     return;
                 // Safari横屏工具栏偏移
                 if (Browser.onSafari)
                     _me._safariOffsetY = (Browser.window.__innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight) - Browser.window.innerHeight;
                 _me._resetCanvas();
             });
             // 微信的iframe不触发orientationchange。
             window.addEventListener("orientationchange", function (e) {
                 _me._resetCanvas();
             });
             this.on(Event.MOUSE_MOVE, this, this._onmouseMove);
             if (Browser.onMobile)
                 this.on(Event.MOUSE_DOWN, this, this._onmouseMove);
         }
         /**
          * @private
          * 在移动端输入时，输入法弹出期间不进行画布尺寸重置。
          */
         _isInputting() {
             return (Browser.onMobile && Input.isInputting);
         }
         /**@inheritDoc */
         /*override*/ set width(value) {
             this.designWidth = value;
             super.set_width(value);
             ILaya.systemTimer.callLater(this, this._changeCanvasSize);
         }
         /*override*/ get width() {
             return super.get_width();
         }
         /**@inheritDoc */
         /*override*/ set height(value) {
             this.designHeight = value;
             super.set_height(value);
             ILaya.systemTimer.callLater(this, this._changeCanvasSize);
         }
         /*override*/ get height() {
             return super.get_height();
         }
         /*override*/ set transform(value) {
             super.set_transform(value);
         }
         /**@inheritDoc */
         /*override*/ get transform() {
             if (this._tfChanged)
                 this._adjustTransform();
             return (this._transform = this._transform || this._createTransform());
         }
         /**
          * 舞台是否获得焦点。
          */
         get isFocused() {
             return this._isFocused;
         }
         /**
          * 舞台是否处于可见状态(是否进入后台)。
          */
         get isVisibility() {
             return this._isVisibility;
         }
         /**@private */
         _changeCanvasSize() {
             this.setScreenSize(Browser.clientWidth * Browser.pixelRatio, Browser.clientHeight * Browser.pixelRatio);
         }
         /**@private */
         _resetCanvas() {
             if (!this.screenAdaptationEnabled)
                 return;
             //var canvas:HTMLCanvas = Render._mainCanvas;
             //var canvasStyle:* = canvas.source.style;
             //canvas.size(1, 1);
             //canvasStyle.transform = canvasStyle.webkitTransform = canvasStyle.msTransform = canvasStyle.mozTransform = canvasStyle.oTransform = "";
             //visible = false;
             //Laya.timer.once(100, this, this._changeCanvasSize);
             this._changeCanvasSize();
         }
         /**
          * 设置屏幕大小，场景会根据屏幕大小进行适配。可以动态调用此方法，来更改游戏显示的大小。
          * @param	screenWidth		屏幕宽度。
          * @param	screenHeight	屏幕高度。
          */
         setScreenSize(screenWidth, screenHeight) {
             //计算是否旋转
             var rotation = false;
             if (this._screenMode !== Stage.SCREEN_NONE) {
                 var screenType = screenWidth / screenHeight < 1 ? Stage.SCREEN_VERTICAL : Stage.SCREEN_HORIZONTAL;
                 rotation = screenType !== this._screenMode;
                 if (rotation) {
                     //宽高互换
                     var temp = screenHeight;
                     screenHeight = screenWidth;
                     screenWidth = temp;
                 }
             }
             this.canvasRotation = rotation;
             var canvas = Render._mainCanvas;
             var canvasStyle = canvas.source.style;
             var mat = this._canvasTransform.identity();
             var scaleMode = this._scaleMode;
             var scaleX = screenWidth / this.designWidth;
             var scaleY = screenHeight / this.designHeight;
             var canvasWidth = this.useRetinalCanvas ? screenWidth : this.designWidth;
             var canvasHeight = this.useRetinalCanvas ? screenHeight : this.designHeight;
             var realWidth = screenWidth;
             var realHeight = screenHeight;
             var pixelRatio = Browser.pixelRatio;
             this._width = this.designWidth;
             this._height = this.designHeight;
             //处理缩放模式
             switch (scaleMode) {
                 case Stage.SCALE_NOSCALE:
                     scaleX = scaleY = 1;
                     realWidth = this.designWidth;
                     realHeight = this.designHeight;
                     break;
                 case Stage.SCALE_SHOWALL:
                     scaleX = scaleY = Math.min(scaleX, scaleY);
                     canvasWidth = realWidth = Math.round(this.designWidth * scaleX);
                     canvasHeight = realHeight = Math.round(this.designHeight * scaleY);
                     break;
                 case Stage.SCALE_NOBORDER:
                     scaleX = scaleY = Math.max(scaleX, scaleY);
                     realWidth = Math.round(this.designWidth * scaleX);
                     realHeight = Math.round(this.designHeight * scaleY);
                     break;
                 case Stage.SCALE_FULL:
                     scaleX = scaleY = 1;
                     this._width = canvasWidth = screenWidth;
                     this._height = canvasHeight = screenHeight;
                     break;
                 case Stage.SCALE_FIXED_WIDTH:
                     scaleY = scaleX;
                     this._height = canvasHeight = Math.round(screenHeight / scaleX);
                     break;
                 case Stage.SCALE_FIXED_HEIGHT:
                     scaleX = scaleY;
                     this._width = canvasWidth = Math.round(screenWidth / scaleY);
                     break;
                 case Stage.SCALE_FIXED_AUTO:
                     if ((screenWidth / screenHeight) < (this.designWidth / this.designHeight)) {
                         scaleY = scaleX;
                         this._height = canvasHeight = Math.round(screenHeight / scaleX);
                     }
                     else {
                         scaleX = scaleY;
                         this._width = canvasWidth = Math.round(screenWidth / scaleY);
                     }
                     break;
             }
             if (this.useRetinalCanvas) {
                 canvasWidth = screenWidth;
                 canvasHeight = screenHeight;
             }
             //根据不同尺寸缩放stage画面
             scaleX *= this.scaleX;
             scaleY *= this.scaleY;
             if (scaleX === 1 && scaleY === 1) {
                 this.transform.identity();
             }
             else {
                 this.transform.a = this._formatData(scaleX / (realWidth / canvasWidth));
                 this.transform.d = this._formatData(scaleY / (realHeight / canvasHeight));
             }
             //处理canvas大小			
             canvas.size(canvasWidth, canvasHeight);
             RunDriver.changeWebGLSize(canvasWidth, canvasHeight);
             mat.scale(realWidth / canvasWidth / pixelRatio, realHeight / canvasHeight / pixelRatio);
             //处理水平对齐
             if (this._alignH === Stage.ALIGN_LEFT)
                 this.offset.x = 0;
             else if (this._alignH === Stage.ALIGN_RIGHT)
                 this.offset.x = screenWidth - realWidth;
             else
                 this.offset.x = (screenWidth - realWidth) * 0.5 / pixelRatio;
             //处理垂直对齐
             if (this._alignV === Stage.ALIGN_TOP)
                 this.offset.y = 0;
             else if (this._alignV === Stage.ALIGN_BOTTOM)
                 this.offset.y = screenHeight - realHeight;
             else
                 this.offset.y = (screenHeight - realHeight) * 0.5 / pixelRatio;
             //处理用户自行设置的画布偏移
             this.offset.x = Math.round(this.offset.x);
             this.offset.y = Math.round(this.offset.y);
             mat.translate(this.offset.x, this.offset.y);
             if (this._safariOffsetY)
                 mat.translate(0, this._safariOffsetY);
             //处理横竖屏
             this.canvasDegree = 0;
             if (rotation) {
                 if (this._screenMode === Stage.SCREEN_HORIZONTAL) {
                     mat.rotate(Math.PI / 2);
                     mat.translate(screenHeight / pixelRatio, 0);
                     this.canvasDegree = 90;
                 }
                 else {
                     mat.rotate(-Math.PI / 2);
                     mat.translate(0, screenWidth / pixelRatio);
                     this.canvasDegree = -90;
                 }
             }
             mat.a = this._formatData(mat.a);
             mat.d = this._formatData(mat.d);
             mat.tx = this._formatData(mat.tx);
             mat.ty = this._formatData(mat.ty);
             super.set_transform(this.transform);
             canvasStyle.transformOrigin = canvasStyle.webkitTransformOrigin = canvasStyle.msTransformOrigin = canvasStyle.mozTransformOrigin = canvasStyle.oTransformOrigin = "0px 0px 0px";
             canvasStyle.transform = canvasStyle.webkitTransform = canvasStyle.msTransform = canvasStyle.mozTransform = canvasStyle.oTransform = "matrix(" + mat.toString() + ")";
             //修正用户自行设置的偏移
             if (this._safariOffsetY)
                 mat.translate(0, -this._safariOffsetY);
             mat.translate(parseInt(canvasStyle.left) || 0, parseInt(canvasStyle.top) || 0);
             this.visible = true;
             this._repaint |= SpriteConst.REPAINT_CACHE;
             this.event(Event.RESIZE);
         }
         /**@private */
         _formatData(value) {
             if (Math.abs(value) < 0.000001)
                 return 0;
             if (Math.abs(1 - value) < 0.001)
                 return value > 0 ? 1 : -1;
             return value;
         }
         /**
          * <p>缩放模式。默认值为 "noscale"。</p>
          * <p><ul>取值范围：
          * <li>"noscale" ：不缩放；</li>
          * <li>"exactfit" ：全屏不等比缩放；</li>
          * <li>"showall" ：最小比例缩放；</li>
          * <li>"noborder" ：最大比例缩放；</li>
          * <li>"full" ：不缩放，stage的宽高等于屏幕宽高；</li>
          * <li>"fixedwidth" ：宽度不变，高度根据屏幕比缩放；</li>
          * <li>"fixedheight" ：高度不变，宽度根据屏幕比缩放；</li>
          * <li>"fixedauto" ：根据宽高比，自动选择使用fixedwidth或fixedheight；</li>
          * </ul></p>
          */
         get scaleMode() {
             return this._scaleMode;
         }
         set scaleMode(value) {
             this._scaleMode = value;
             ILaya.systemTimer.callLater(this, this._changeCanvasSize);
         }
         /**
          * <p>水平对齐方式。默认值为"left"。</p>
          * <p><ul>取值范围：
          * <li>"left" ：居左对齐；</li>
          * <li>"center" ：居中对齐；</li>
          * <li>"right" ：居右对齐；</li>
          * </ul></p>
          */
         get alignH() {
             return this._alignH;
         }
         set alignH(value) {
             this._alignH = value;
             ILaya.systemTimer.callLater(this, this._changeCanvasSize);
         }
         /**
          * <p>垂直对齐方式。默认值为"top"。</p>
          * <p><ul>取值范围：
          * <li>"top" ：居顶部对齐；</li>
          * <li>"middle" ：居中对齐；</li>
          * <li>"bottom" ：居底部对齐；</li>
          * </ul></p>
          */
         get alignV() {
             return this._alignV;
         }
         set alignV(value) {
             this._alignV = value;
             ILaya.systemTimer.callLater(this, this._changeCanvasSize);
         }
         /**舞台的背景颜色，默认为黑色，null为透明。*/
         get bgColor() {
             return this._bgColor;
         }
         set bgColor(value) {
             this._bgColor = value;
             if (value)
                 this._wgColor = ColorUtils.create(value).arrColor;
             else
                 this._wgColor = null;
             if (Browser.onLimixiu) {
                 this._wgColor = ColorUtils.create(value).arrColor;
             }
             else if (value) {
                 Render.canvas.style.background = value;
             }
             else {
                 Render.canvas.style.background = "none";
             }
         }
         /**鼠标在 Stage 上的 X 轴坐标。*/
         /*override*/ get mouseX() {
             return Math.round(MouseManager.instance.mouseX / this.clientScaleX);
         }
         /**鼠标在 Stage 上的 Y 轴坐标。*/
         /*override*/ get mouseY() {
             return Math.round(MouseManager.instance.mouseY / this.clientScaleY);
         }
         /**@inheritDoc */
         /*override*/ getMousePoint() {
             return Point.TEMP.setTo(this.mouseX, this.mouseY);
         }
         /**当前视窗由缩放模式导致的 X 轴缩放系数。*/
         get clientScaleX() {
             return this._transform ? this._transform.getScaleX() : 1;
         }
         /**当前视窗由缩放模式导致的 Y 轴缩放系数。*/
         get clientScaleY() {
             return this._transform ? this._transform.getScaleY() : 1;
         }
         /**
          * <p>场景布局类型。</p>
          * <p><ul>取值范围：
          * <li>"none" ：不更改屏幕</li>
          * <li>"horizontal" ：自动横屏</li>
          * <li>"vertical" ：自动竖屏</li>
          * </ul></p>
          */
         get screenMode() {
             return this._screenMode;
         }
         set screenMode(value) {
             this._screenMode = value;
         }
         /**@inheritDoc */
         /*override*/ repaint(type = SpriteConst.REPAINT_CACHE) {
             this._repaint |= type;
         }
         /**@inheritDoc */
         /*override*/ parentRepaint(type = SpriteConst.REPAINT_CACHE) {
         }
         /**@private */
         _loop() {
             this._globalRepaintGet = this._globalRepaintSet;
             this._globalRepaintSet = false;
             this.render(Render._context, 0, 0);
             return true;
         }
         /**@private */
         getFrameTm() {
             return this._frameStartTime;
         }
         /**@private */
         _onmouseMove(e) {
             this._mouseMoveTime = Browser.now();
         }
         /**
          * <p>获得距当前帧开始后，过了多少时间，单位为毫秒。</p>
          * <p>可以用来判断函数内时间消耗，通过合理控制每帧函数处理消耗时长，避免一帧做事情太多，对复杂计算分帧处理，能有效降低帧率波动。</p>
          */
         getTimeFromFrameStart() {
             return Browser.now() - this._frameStartTime;
         }
         /**@inheritDoc */
         /*override*/ set visible(value) {
             if (this.visible !== value) {
                 super.set_visible(value);
                 var style = Render._mainCanvas.source.style;
                 style.visibility = value ? "visible" : "hidden";
             }
         }
         get visible() {
             return super.visible;
         }
         /**@inheritDoc */
         /*override*/ render(context, x, y) {
             if (window.conch) {
                 this.renderToNative(context, x, y);
                 return;
             }
             //临时
             Stage._dbgSprite.graphics.clear();
             if (this._frameRate === Stage.FRAME_SLEEP) {
                 var now = Browser.now();
                 if (now - this._frameStartTime >= 1000)
                     this._frameStartTime = now;
                 else
                     return;
             }
             else {
                 if (!this._visible) {
                     this._renderCount++;
                     if (this._renderCount % 5 === 0) {
                         CallLater.I._update();
                         Stat.loopCount++;
                         RenderInfo.loopCount = Stat.loopCount;
                         this._updateTimers();
                     }
                     return;
                 }
                 this._frameStartTime = Browser.now();
                 RenderInfo.loopStTm = this._frameStartTime;
             }
             this._renderCount++;
             var frameMode = this._frameRate === Stage.FRAME_MOUSE ? (((this._frameStartTime - this._mouseMoveTime) < 2000) ? Stage.FRAME_FAST : Stage.FRAME_SLOW) : this._frameRate;
             var isFastMode = (frameMode !== Stage.FRAME_SLOW);
             var isDoubleLoop = (this._renderCount % 2 === 0);
             Stat.renderSlow = !isFastMode;
             if (isFastMode || isDoubleLoop) {
                 CallLater.I._update();
                 Stat.loopCount++;
                 RenderInfo.loopCount = Stat.loopCount;
                 if (this.renderingEnabled) {
                     for (var i = 0, n = this._scene3Ds.length; i < n; i++) //更新3D场景,必须提出来,否则在脚本中移除节点会导致BUG
                         this._scene3Ds[i]._update();
                     context.clear();
                     super.render(context, x, y);
                     Stat._StatRender.renderNotCanvas(context, x, y);
                 }
             }
             Stage._dbgSprite.render(context, 0, 0);
             if (isFastMode || !isDoubleLoop) {
                 if (this.renderingEnabled) {
                     Stage.clear(this._bgColor);
                     context.flush();
                     VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
                 }
                 this._updateTimers();
             }
         }
         renderToNative(context, x, y) {
             this._renderCount++;
             if (!this._visible) {
                 if (this._renderCount % 5 === 0) {
                     CallLater.I._update();
                     Stat.loopCount++;
                     RenderInfo.loopCount = Stat.loopCount;
                     this._updateTimers();
                 }
                 return;
             }
             //update
             CallLater.I._update();
             Stat.loopCount++;
             RenderInfo.loopCount = Stat.loopCount;
             //render
             if (this.renderingEnabled) {
                 for (var i = 0, n = this._scene3Ds.length; i < n; i++) //更新3D场景,必须提出来,否则在脚本中移除节点会导致BUG
                     this._scene3Ds[i]._update();
                 context.clear();
                 super.render(context, x, y);
                 Stat._StatRender.renderNotCanvas(context, x, y);
             }
             //commit submit
             if (this.renderingEnabled) {
                 Stage.clear(this._bgColor);
                 context.flush();
                 VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
             }
             this._updateTimers();
         }
         _updateTimers() {
             ILaya.systemTimer._update();
             ILaya.startTimer._update();
             ILaya.physicsTimer._update();
             ILaya.updateTimer._update();
             ILaya.lateTimer._update();
             ILaya.timer._update();
         }
         /**
          * <p>是否开启全屏，用户点击后进入全屏。</p>
          * <p>兼容性提示：部分浏览器不允许点击进入全屏，比如Iphone等。</p>
          */
         set fullScreenEnabled(value) {
             var document = Browser.document;
             var canvas = Render.canvas;
             if (value) {
                 canvas.addEventListener('mousedown', this._requestFullscreen);
                 canvas.addEventListener('touchstart', this._requestFullscreen);
                 document.addEventListener("fullscreenchange", this._fullScreenChanged);
                 document.addEventListener("mozfullscreenchange", this._fullScreenChanged);
                 document.addEventListener("webkitfullscreenchange", this._fullScreenChanged);
                 document.addEventListener("msfullscreenchange", this._fullScreenChanged);
             }
             else {
                 canvas.removeEventListener('mousedown', this._requestFullscreen);
                 canvas.removeEventListener('touchstart', this._requestFullscreen);
                 document.removeEventListener("fullscreenchange", this._fullScreenChanged);
                 document.removeEventListener("mozfullscreenchange", this._fullScreenChanged);
                 document.removeEventListener("webkitfullscreenchange", this._fullScreenChanged);
                 document.removeEventListener("msfullscreenchange", this._fullScreenChanged);
             }
         }
         get frameRate() {
             if (!ILaya.Render.isConchApp) {
                 return this._frameRate;
             }
             else {
                 return this._frameRateNative;
             }
         }
         set frameRate(value) {
             if (!ILaya.Render.isConchApp) {
                 this._frameRate = value;
             }
             else {
                 var c = window.conch;
                 switch (value) {
                     case Stage.FRAME_FAST:
                         c.config.setLimitFPS(60);
                         break;
                     case Stage.FRAME_MOUSE:
                         c.config.setMouseFrame(2000);
                         break;
                     case Stage.FRAME_SLOW:
                         c.config.setSlowFrame(true);
                         break;
                     case Stage.FRAME_SLEEP:
                         c.config.setLimitFPS(1);
                         break;
                 }
                 this._frameRateNative = value;
             }
         }
         /**@private */
         _requestFullscreen() {
             var element = Browser.document.documentElement;
             if (element.requestFullscreen) {
                 element.requestFullscreen();
             }
             else if (element.mozRequestFullScreen) {
                 element.mozRequestFullScreen();
             }
             else if (element.webkitRequestFullscreen) {
                 element.webkitRequestFullscreen();
             }
             else if (element.msRequestFullscreen) {
                 element.msRequestFullscreen();
             }
         }
         /**@private */
         _fullScreenChanged() {
             ILaya.stage.event(Event.FULL_SCREEN_CHANGE);
         }
         /**退出全屏模式*/
         exitFullscreen() {
             var document = Browser.document;
             if (document.exitFullscreen) {
                 document.exitFullscreen();
             }
             else if (document.mozCancelFullScreen) {
                 document.mozCancelFullScreen();
             }
             else if (document.webkitExitFullscreen) {
                 document.webkitExitFullscreen();
             }
         }
         /**@private */
         isGlobalRepaint() {
             return this._globalRepaintGet;
         }
         /**@private */
         setGlobalRepaint() {
             this._globalRepaintSet = true;
         }
         /**@private */
         add3DUI(uibase) {
             var uiroot = uibase.rootView;
             if (this._3dUI.indexOf(uiroot) >= 0)
                 return;
             this._3dUI.push(uiroot);
         }
         /**@private */
         remove3DUI(uibase) {
             var uiroot = uibase.rootView;
             var p = this._3dUI.indexOf(uiroot);
             if (p >= 0) {
                 this._3dUI.splice(p, 1);
                 return true;
             }
             return false;
         }
     }
     /**应用保持设计宽高不变，不缩放不变形，stage的宽高等于设计宽高。*/
     Stage.SCALE_NOSCALE = "noscale";
     /**应用根据屏幕大小铺满全屏，非等比缩放会变形，stage的宽高等于设计宽高。*/
     Stage.SCALE_EXACTFIT = "exactfit";
     /**应用显示全部内容，按照最小比率缩放，等比缩放不变形，一边可能会留空白，stage的宽高等于设计宽高。*/
     Stage.SCALE_SHOWALL = "showall";
     /**应用按照最大比率缩放显示，宽或高方向会显示一部分，等比缩放不变形，stage的宽高等于设计宽高。*/
     Stage.SCALE_NOBORDER = "noborder";
     /**应用保持设计宽高不变，不缩放不变形，stage的宽高等于屏幕宽高。*/
     Stage.SCALE_FULL = "full";
     /**应用保持设计宽度不变，高度根据屏幕比缩放，stage的宽度等于设计高度，高度根据屏幕比率大小而变化*/
     Stage.SCALE_FIXED_WIDTH = "fixedwidth";
     /**应用保持设计高度不变，宽度根据屏幕比缩放，stage的高度等于设计宽度，宽度根据屏幕比率大小而变化*/
     Stage.SCALE_FIXED_HEIGHT = "fixedheight";
     /**应用保持设计比例不变，全屏显示全部内容(类似showall，但showall非全屏，会有黑边)，根据屏幕长宽比，自动选择使用SCALE_FIXED_WIDTH或SCALE_FIXED_HEIGHT*/
     Stage.SCALE_FIXED_AUTO = "fixedauto";
     /**画布水平居左对齐。*/
     Stage.ALIGN_LEFT = "left";
     /**画布水平居右对齐。*/
     Stage.ALIGN_RIGHT = "right";
     /**画布水平居中对齐。*/
     Stage.ALIGN_CENTER = "center";
     /**画布垂直居上对齐。*/
     Stage.ALIGN_TOP = "top";
     /**画布垂直居中对齐。*/
     Stage.ALIGN_MIDDLE = "middle";
     /**画布垂直居下对齐。*/
     Stage.ALIGN_BOTTOM = "bottom";
     /**不更改屏幕。*/
     Stage.SCREEN_NONE = "none";
     /**自动横屏。*/
     Stage.SCREEN_HORIZONTAL = "horizontal";
     /**自动竖屏。*/
     Stage.SCREEN_VERTICAL = "vertical";
     /**全速模式，以60的帧率运行。*/
     Stage.FRAME_FAST = "fast";
     /**慢速模式，以30的帧率运行。*/
     Stage.FRAME_SLOW = "slow";
     /**自动模式，以30的帧率运行，但鼠标活动后会自动加速到60，鼠标不动2秒后降低为30帧，以节省消耗。*/
     Stage.FRAME_MOUSE = "mouse";
     /**休眠模式，以1的帧率运行*/
     Stage.FRAME_SLEEP = "sleep";
     /**@private */
     Stage._dbgSprite = new Sprite();
     /** @private */
     Stage.clear = function (value) {
         //修改需要同步到上面的native实现中
         Context.set2DRenderConfig(); //渲染2D前要还原2D状态,否则可能受3D影响
         RenderState2D.worldScissorTest && WebGLContext.mainContext.disable(WebGLContext.SCISSOR_TEST);
         var ctx = Render.context;
         //兼容浏览器
         var c = (ctx._submits._length == 0 || Config.preserveDrawingBuffer) ? ColorUtils.create(value).arrColor : window.Laya.stage._wgColor;
         if (c)
             ctx.clearBG(c[0], c[1], c[2], c[3]);
         else
             ctx.clearBG(0, 0, 0, 0);
         RenderState2D.clear();
     };

     /**
      * <p><code>KeyBoardManager</code> 是键盘事件管理类。该类从浏览器中接收键盘事件，并派发该事件。</p>
      * <p>派发事件时若 Stage.focus 为空则只从 Stage 上派发该事件，否则将从 Stage.focus 对象开始一直冒泡派发该事件。所以在 Laya.stage 上监听键盘事件一定能够收到，如果在其他地方监听，则必须处在Stage.focus的冒泡链上才能收到该事件。</p>
      * <p>用户可以通过代码 Laya.stage.focus=someNode 的方式来设置focus对象。</p>
      * <p>用户可统一的根据事件对象中 e.keyCode 来判断按键类型，该属性兼容了不同浏览器的实现。</p>
      */
     class KeyBoardManager {
         /**@private */
         static __init__() {
             KeyBoardManager._addEvent("keydown");
             KeyBoardManager._addEvent("keypress");
             KeyBoardManager._addEvent("keyup");
         }
         static _addEvent(type) {
             ILaya.Browser.document.addEventListener(type, function (e) {
                 KeyBoardManager._dispatch(e, type);
             }, true);
         }
         static _dispatch(e, type) {
             if (!KeyBoardManager.enabled)
                 return;
             KeyBoardManager._event._stoped = false;
             KeyBoardManager._event.nativeEvent = e;
             KeyBoardManager._event.keyCode = e.keyCode || e.which || e.charCode;
             //判断同时按下的键
             if (type === "keydown")
                 KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = true;
             else if (type === "keyup")
                 KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = null;
             var target = (ILaya.stage.focus && (ILaya.stage.focus.event != null) && ILaya.stage.focus.displayedInStage) ? ILaya.stage.focus : ILaya.stage;
             var ct = target;
             while (ct) {
                 ct.event(type, KeyBoardManager._event.setTo(type, ct, target));
                 ct = ct.parent;
             }
         }
         /**
          * 返回指定键是否被按下。
          * @param	key 键值。
          * @return 是否被按下。
          */
         static hasKeyDown(key) {
             return KeyBoardManager._pressKeys[key];
         }
     }
     KeyBoardManager._pressKeys = {};
     /**是否开启键盘事件，默认为true*/
     KeyBoardManager.enabled = true;
     /**@private */
     KeyBoardManager._event = new Event();

     /**
      * @private
      * 普通命令执行器
      */
     class LayaGLRunner {
         /**
          * @private
          * 批量上传ShaderUniforms。
          */
         static uploadShaderUniforms(layaGL, commandEncoder, shaderData, uploadUnTexture) {
             var data = shaderData._data;
             var shaderUniform = commandEncoder.getArrayData();
             var shaderCall = 0;
             for (var i = 0, n = shaderUniform.length; i < n; i++) {
                 var one = shaderUniform[i];
                 if (uploadUnTexture || one.textureID !== -1) { //如uniform为纹理切换Shader时需要重新上传
                     var value = data[one.dataOffset];
                     if (value != null)
                         shaderCall += one.fun.call(one.caller, one, value);
                 }
             }
             return shaderCall;
         }
         /**
          * @private
          * 上传ShaderUniform。
          */
         static uploadCustomUniform(layaGL, custom, index, data) {
             var shaderCall = 0;
             var one = custom[index];
             if (one && data != null)
                 shaderCall += one.fun.call(one.caller, one, data);
             return shaderCall;
         }
         /**
          * @private
          * 批量上传ShaderUniforms。
          */
         static uploadShaderUniformsForNative(layaGL, commandEncoder, shaderData) {
             var nType = LayaGL.UPLOAD_SHADER_UNIFORM_TYPE_ID;
             if (shaderData._runtimeCopyValues.length > 0) {
                 nType = LayaGL.UPLOAD_SHADER_UNIFORM_TYPE_DATA;
             }
             var data = shaderData._data;
             return layaGL.uploadShaderUniforms(commandEncoder, data, nType);
         }
     }

     /**
      * <p> <code>SoundChannel</code> 用来控制程序中的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。</p>
      * <p> <code>SoundChannel</code> 类包含控制声音的播放、暂停、停止、音量的方法，以及获取声音的播放状态、总时间、当前播放时间、总循环次数、播放地址等信息的方法。</p>
      */
     class SoundChannel extends EventDispatcher {
         constructor() {
             super(...arguments);
             /**
              * 表示声音是否已暂停。
              */
             this.isStopped = false;
         }
         /**
          * 音量范围从 0（静音）至 1（最大音量）。
          */
         set volume(v) {
         }
         get volume() {
             return 1;
         }
         /**
          * 获取当前播放时间，单位是秒。
          */
         get position() {
             return 0;
         }
         /**
          * 获取总时间，单位是秒。
          */
         get duration() {
             return 0;
         }
         /**
          * 播放声音。
          */
         play() {
         }
         /**
          * 停止播放。
          */
         stop() {
             if (this.completeHandler)
                 this.completeHandler.run();
         }
         /**
          * 暂停播放。
          */
         pause() {
         }
         /**
          * 继续播放。
          */
         resume() {
         }
         /**
          * private
          */
         __runComplete(handler) {
             if (handler) {
                 handler.run();
             }
         }
     }

     /**
      * @private
      * audio标签播放声音的音轨控制
      */
     class AudioSoundChannel extends SoundChannel {
         constructor(audio) {
             super();
             /**
              * 播放用的audio标签
              */
             this._audio = null;
             this._onEnd = this.__onEnd.bind(this);
             this._resumePlay = this.__resumePlay.bind(this);
             audio.addEventListener("ended", this._onEnd);
             this._audio = audio;
         }
         __onEnd(evt) {
             if (this.loops == 1) {
                 if (this.completeHandler) {
                     ILaya.systemTimer.once(10, this, this.__runComplete, [this.completeHandler], false);
                     this.completeHandler = null;
                 }
                 this.stop();
                 this.event(Event.COMPLETE);
                 return;
             }
             if (this.loops > 0) {
                 this.loops--;
             }
             this.startTime = 0;
             this.play();
         }
         __resumePlay() {
             if (this._audio)
                 this._audio.removeEventListener("canplay", this._resumePlay);
             if (this.isStopped)
                 return;
             try {
                 this._audio.currentTime = this.startTime;
                 Browser.container.appendChild(this._audio);
                 this._audio.play();
             }
             catch (e) {
                 //this.audio.play();
                 this.event(Event.ERROR);
             }
         }
         /**
          * 播放
          */
         /*override*/ play() {
             this.isStopped = false;
             try {
                 this._audio.playbackRate = ILaya.SoundManager.playbackRate;
                 this._audio.currentTime = this.startTime;
             }
             catch (e) {
                 this._audio.addEventListener("canplay", this._resumePlay);
                 return;
             }
             ILaya.SoundManager.addChannel(this);
             Browser.container.appendChild(this._audio);
             if ("play" in this._audio)
                 this._audio.play();
         }
         /**
          * 当前播放到的位置
          * @return
          *
          */
         /*override*/ get position() {
             if (!this._audio)
                 return 0;
             return this._audio.currentTime;
         }
         /**
          * 获取总时间。
          */
         /*override*/ get duration() {
             if (!this._audio)
                 return 0;
             return this._audio.duration;
         }
         /**
          * 停止播放
          *
          */
         /*override*/ stop() {
             //trace("stop and remove event");
             super.stop();
             this.isStopped = true;
             ILaya.SoundManager.removeChannel(this);
             this.completeHandler = null;
             if (!this._audio)
                 return;
             if ("pause" in this._audio)
                 //理论上应该全部使用stop，但是不知为什么，使用pause，为了安全我只修改在加速器模式下再调用一次stop
                 if (ILaya.Render.isConchApp) {
                     this._audio.stop();
                 }
             this._audio.pause();
             this._audio.removeEventListener("ended", this._onEnd);
             this._audio.removeEventListener("canplay", this._resumePlay);
             //ie下使用对象池可能会导致后面的声音播放不出来
             if (!ILaya.Browser.onIE) {
                 if (this._audio != ILaya.AudioSound._musicAudio) {
                     ILaya.Pool.recover("audio:" + this.url, this._audio);
                 }
             }
             Browser.removeElement(this._audio);
             this._audio = null;
         }
         /*override*/ pause() {
             this.isStopped = true;
             ILaya.SoundManager.removeChannel(this);
             if ("pause" in this._audio)
                 this._audio.pause();
         }
         /*override*/ resume() {
             if (!this._audio)
                 return;
             this.isStopped = false;
             ILaya.SoundManager.addChannel(this);
             if ("play" in this._audio)
                 this._audio.play();
         }
         /**
          * 设置音量
          * @param v
          *
          */
         /*override*/ set volume(v) {
             if (!this._audio)
                 return;
             this._audio.volume = v;
         }
         /**
          * 获取音量
          * @return
          *
          */
         /*override*/ get volume() {
             if (!this._audio)
                 return 1;
             return this._audio.volume;
         }
     }

     /**
      * @private
      * 使用Audio标签播放声音
      */
     class AudioSound extends EventDispatcher {
         constructor() {
             super(...arguments);
             /**
              * 是否已加载完成
              */
             this.loaded = false;
         }
         /**
          * 释放声音
          *
          */
         dispose() {
             var ad = AudioSound._audioCache[this.url];
             Pool.clearBySign("audio:" + this.url);
             if (ad) {
                 if (!Render.isConchApp) {
                     ad.src = "";
                 }
                 delete AudioSound._audioCache[this.url];
             }
         }
         /**@private */
         static _initMusicAudio() {
             if (AudioSound._musicAudio)
                 return;
             if (!AudioSound._musicAudio)
                 AudioSound._musicAudio = Browser.createElement("audio");
             if (!Render.isConchApp) {
                 Browser.document.addEventListener("mousedown", AudioSound._makeMusicOK);
             }
         }
         /**@private */
         static _makeMusicOK() {
             Browser.document.removeEventListener("mousedown", AudioSound._makeMusicOK);
             if (!AudioSound._musicAudio.src) {
                 AudioSound._musicAudio.src = "";
                 AudioSound._musicAudio.load();
             }
             else {
                 AudioSound._musicAudio.play();
             }
         }
         /**
          * 加载声音
          * @param url
          *
          */
         load(url) {
             url = URL.formatURL(url);
             this.url = url;
             var ad;
             if (url == ILaya.SoundManager._bgMusic) {
                 AudioSound._initMusicAudio();
                 ad = AudioSound._musicAudio;
                 if (ad.src != url) {
                     AudioSound._audioCache[ad.src] = null;
                     ad = null;
                 }
             }
             else {
                 ad = AudioSound._audioCache[url];
             }
             if (ad && ad.readyState >= 2) {
                 this.event(Event.COMPLETE);
                 return;
             }
             if (!ad) {
                 if (url == ILaya.SoundManager._bgMusic) {
                     AudioSound._initMusicAudio();
                     ad = AudioSound._musicAudio;
                 }
                 else {
                     ad = Browser.createElement("audio");
                 }
                 AudioSound._audioCache[url] = ad;
                 ad.src = url;
             }
             ad.addEventListener("canplaythrough", onLoaded);
             ad.addEventListener("error", onErr);
             var me = this;
             function onLoaded() {
                 offs();
                 me.loaded = true;
                 me.event(Event.COMPLETE);
             }
             function onErr() {
                 ad.load = null;
                 offs();
                 me.event(Event.ERROR);
             }
             function offs() {
                 ad.removeEventListener("canplaythrough", onLoaded);
                 ad.removeEventListener("error", onErr);
             }
             this.audio = ad;
             if (ad.load) {
                 ad.load();
             }
             else {
                 onErr();
             }
         }
         /**
          * 播放声音
          * @param startTime 起始时间
          * @param loops 循环次数
          * @return
          *
          */
         play(startTime = 0, loops = 0) {
             //trace("playAudioSound");
             if (!this.url)
                 return null;
             var ad;
             if (this.url == ILaya.SoundManager._bgMusic) {
                 ad = AudioSound._musicAudio;
             }
             else {
                 ad = AudioSound._audioCache[this.url];
             }
             if (!ad)
                 return null;
             var tAd;
             tAd = Pool.getItem("audio:" + this.url);
             if (Render.isConchApp) {
                 if (!tAd) {
                     tAd = Browser.createElement("audio");
                     tAd.src = this.url;
                 }
             }
             else {
                 if (this.url == ILaya.SoundManager._bgMusic) {
                     AudioSound._initMusicAudio();
                     tAd = AudioSound._musicAudio;
                     tAd.src = this.url;
                 }
                 else {
                     tAd = tAd ? tAd : ad.cloneNode(true);
                 }
             }
             var channel = new AudioSoundChannel(tAd);
             channel.url = this.url;
             channel.loops = loops;
             channel.startTime = startTime;
             channel.play();
             ILaya.SoundManager.addChannel(channel);
             return channel;
         }
         /**
          * 获取总时间。
          */
         get duration() {
             var ad;
             ad = AudioSound._audioCache[this.url];
             if (!ad)
                 return 0;
             return ad.duration;
         }
     }
     /**@private */
     AudioSound._audioCache = {};

     //import { WebAudioSound } from "./WebAudioSound";
     /**
      * @private
      * web audio api方式播放声音的音轨控制
      */
     class WebAudioSoundChannel extends SoundChannel {
         constructor() {
             super();
             /**
              * 播放用的数据
              */
             this.bufferSource = null;
             /**
              * 当前时间
              */
             this._currentTime = 0;
             /**
              * 当前音量
              */
             this._volume = 1;
             /**
              * 播放开始时的时间戳
              */
             this._startTime = 0;
             this._pauseTime = 0;
             /**
              * 播放设备
              */
             this.context = ILaya.WebAudioSound.ctx;
             this._onPlayEnd = Utils.bind(this.__onPlayEnd, this);
             if (this.context["createGain"]) {
                 this.gain = this.context["createGain"]();
             }
             else {
                 this.gain = this.context["createGainNode"]();
             }
         }
         /**
          * 播放声音
          */
         /*override*/ play() {
             ILaya.SoundManager.addChannel(this);
             this.isStopped = false;
             this._clearBufferSource();
             if (!this.audioBuffer)
                 return;
             var context = this.context;
             var gain = this.gain;
             var bufferSource = context.createBufferSource();
             this.bufferSource = bufferSource;
             bufferSource.buffer = this.audioBuffer;
             bufferSource.connect(gain);
             if (gain)
                 gain.disconnect();
             gain.connect(context.destination);
             bufferSource.onended = this._onPlayEnd;
             if (this.startTime >= this.duration)
                 this.startTime = 0;
             this._startTime = Browser.now();
             if (this.gain.gain.setTargetAtTime) {
                 this.gain.gain.setTargetAtTime(this._volume, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay);
             }
             else
                 this.gain.gain.value = this._volume;
             if (this.loops == 0) {
                 bufferSource.loop = true;
             }
             if (bufferSource.playbackRate.setTargetAtTime) {
                 bufferSource.playbackRate.setTargetAtTime(ILaya.SoundManager.playbackRate, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay);
             }
             else
                 bufferSource.playbackRate.value = ILaya.SoundManager.playbackRate;
             bufferSource.start(0, this.startTime);
             this._currentTime = 0;
         }
         __onPlayEnd() {
             if (this.loops == 1) {
                 if (this.completeHandler) {
                     ILaya.timer.once(10, this, this.__runComplete, [this.completeHandler], false);
                     this.completeHandler = null;
                 }
                 this.stop();
                 this.event(Event.COMPLETE);
                 return;
             }
             if (this.loops > 0) {
                 this.loops--;
             }
             this.startTime = 0;
             this.play();
         }
         /**
          * 获取当前播放位置
          */
         /*override*/ get position() {
             if (this.bufferSource) {
                 return (Browser.now() - this._startTime) / 1000 + this.startTime;
             }
             return 0;
         }
         /*override*/ get duration() {
             if (this.audioBuffer) {
                 return this.audioBuffer.duration;
             }
             return 0;
         }
         _clearBufferSource() {
             if (this.bufferSource) {
                 var sourceNode = this.bufferSource;
                 if (sourceNode.stop) {
                     sourceNode.stop(0);
                 }
                 else {
                     sourceNode.noteOff(0);
                 }
                 sourceNode.disconnect(0);
                 sourceNode.onended = null;
                 if (!WebAudioSoundChannel._tryCleanFailed)
                     this._tryClearBuffer(sourceNode);
                 this.bufferSource = null;
             }
         }
         _tryClearBuffer(sourceNode) {
             if (!Browser.onMac) {
                 try {
                     sourceNode.buffer = null;
                 }
                 catch (e) {
                     WebAudioSoundChannel._tryCleanFailed = true;
                 }
                 return;
             }
             try {
                 sourceNode.buffer = ILaya.WebAudioSound._miniBuffer;
             }
             catch (e) {
                 WebAudioSoundChannel._tryCleanFailed = true;
             }
         }
         /**
          * 停止播放
          */
         /*override*/ stop() {
             super.stop();
             this._clearBufferSource();
             this.audioBuffer = null;
             if (this.gain)
                 this.gain.disconnect();
             this.isStopped = true;
             ILaya.SoundManager.removeChannel(this);
             this.completeHandler = null;
             if (ILaya.SoundManager.autoReleaseSound)
                 ILaya.SoundManager.disposeSoundLater(this.url);
         }
         /*override*/ pause() {
             if (!this.isStopped) {
                 this._pauseTime = this.position;
             }
             this._clearBufferSource();
             if (this.gain)
                 this.gain.disconnect();
             this.isStopped = true;
             ILaya.SoundManager.removeChannel(this);
             if (ILaya.SoundManager.autoReleaseSound)
                 ILaya.SoundManager.disposeSoundLater(this.url);
         }
         /*override*/ resume() {
             this.startTime = this._pauseTime;
             this.play();
         }
         /**
          * 设置音量
          */
         /*override*/ set volume(v) {
             this._volume = v;
             if (this.isStopped) {
                 return;
             }
             if (this.gain.gain.setTargetAtTime) {
                 this.gain.gain.setTargetAtTime(v, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay);
             }
             else
                 this.gain.gain.value = v;
         }
         /**
          * 获取音量
          */
         /*override*/ get volume() {
             return this._volume;
         }
     }
     WebAudioSoundChannel._tryCleanFailed = false;
     WebAudioSoundChannel.SetTargetDelay = 0.001;

     /**
      * @private
      * web audio api方式播放声音
      */
     class WebAudioSound extends EventDispatcher {
         constructor() {
             super(...arguments);
             /**
              * 是否已加载完成
              */
             this.loaded = false;
             /**
              * @private
              */
             this._disposed = false;
         }
         /**
          * 解码声音文件
          *
          */
         static decode() {
             if (WebAudioSound.buffs.length <= 0 || WebAudioSound.isDecoding) {
                 return;
             }
             WebAudioSound.isDecoding = true;
             WebAudioSound.tInfo = WebAudioSound.buffs.shift();
             WebAudioSound.ctx.decodeAudioData(WebAudioSound.tInfo["buffer"], WebAudioSound._done, WebAudioSound._fail);
         }
         /**
          * 解码成功回调
          * @param audioBuffer
          *
          */
         static _done(audioBuffer) {
             WebAudioSound.e.event("loaded:" + WebAudioSound.tInfo.url, audioBuffer);
             WebAudioSound.isDecoding = false;
             WebAudioSound.decode();
         }
         /**
          * 解码失败回调
          * @return
          *
          */
         static _fail() {
             WebAudioSound.e.event("err:" + WebAudioSound.tInfo.url, null);
             WebAudioSound.isDecoding = false;
             WebAudioSound.decode();
         }
         /**
          * 播放声音以解锁IOS的声音
          *
          */
         static _playEmptySound() {
             if (WebAudioSound.ctx == null) {
                 return;
             }
             var source = WebAudioSound.ctx.createBufferSource();
             source.buffer = WebAudioSound._miniBuffer;
             source.connect(WebAudioSound.ctx.destination);
             source.start(0, 0, 0);
         }
         /**
          * 尝试解锁声音
          *
          */
         static _unlock() {
             if (WebAudioSound._unlocked) {
                 return;
             }
             WebAudioSound._playEmptySound();
             if (WebAudioSound.ctx.state == "running") {
                 window.document.removeEventListener("mousedown", WebAudioSound._unlock, true);
                 window.document.removeEventListener("touchend", WebAudioSound._unlock, true);
                 window.document.removeEventListener("touchstart", WebAudioSound._unlock, true);
                 WebAudioSound._unlocked = true;
             }
         }
         /*;*/
         static initWebAudio() {
             if (WebAudioSound.ctx.state != "running") {
                 WebAudioSound._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.
                 window.document.addEventListener("mousedown", WebAudioSound._unlock, true);
                 window.document.addEventListener("touchend", WebAudioSound._unlock, true);
                 window.document.addEventListener("touchstart", WebAudioSound._unlock, true);
             }
         }
         /**
          * 加载声音
          * @param url
          *
          */
         load(url) {
             var me = this;
             url = URL.formatURL(url);
             this.url = url;
             this.audioBuffer = WebAudioSound._dataCache[url];
             if (this.audioBuffer) {
                 this._loaded(this.audioBuffer);
                 return;
             }
             WebAudioSound.e.on("loaded:" + url, this, this._loaded);
             WebAudioSound.e.on("err:" + url, this, this._err);
             if (WebAudioSound.__loadingSound[url]) {
                 return;
             }
             WebAudioSound.__loadingSound[url] = true;
             var request = new XMLHttpRequest();
             request.open("GET", url, true);
             request.responseType = "arraybuffer";
             request.onload = function () {
                 if (me._disposed) {
                     me._removeLoadEvents();
                     return;
                 }
                 me.data = request.response;
                 WebAudioSound.buffs.push({ "buffer": me.data, "url": me.url });
                 WebAudioSound.decode();
             };
             request.onerror = function (e) {
                 me._err();
             };
             request.send();
         }
         _err() {
             this._removeLoadEvents();
             WebAudioSound.__loadingSound[this.url] = false;
             this.event(Event.ERROR);
         }
         _loaded(audioBuffer) {
             this._removeLoadEvents();
             if (this._disposed) {
                 return;
             }
             this.audioBuffer = audioBuffer;
             WebAudioSound._dataCache[this.url] = this.audioBuffer;
             this.loaded = true;
             this.event(Event.COMPLETE);
         }
         _removeLoadEvents() {
             WebAudioSound.e.off("loaded:" + this.url, this, this._loaded);
             WebAudioSound.e.off("err:" + this.url, this, this._err);
         }
         __playAfterLoaded() {
             if (!this.__toPlays)
                 return;
             var i, len;
             var toPlays;
             toPlays = this.__toPlays;
             len = toPlays.length;
             var tParams;
             for (i = 0; i < len; i++) {
                 tParams = toPlays[i];
                 if (tParams[2] && !tParams[2].isStopped) {
                     this.play(tParams[0], tParams[1], tParams[2]);
                 }
             }
             this.__toPlays.length = 0;
         }
         /**
          * 播放声音
          * @param startTime 起始时间
          * @param loops 循环次数
          * @return
          *
          */
         play(startTime = 0, loops = 0, channel = null) {
             channel = channel ? channel : new WebAudioSoundChannel();
             if (!this.audioBuffer) {
                 if (this.url) {
                     if (!this.__toPlays)
                         this.__toPlays = [];
                     this.__toPlays.push([startTime, loops, channel]);
                     this.once(Event.COMPLETE, this, this.__playAfterLoaded);
                     this.load(this.url);
                 }
             }
             channel.url = this.url;
             channel.loops = loops;
             channel["audioBuffer"] = this.audioBuffer;
             channel.startTime = startTime;
             channel.play();
             ILaya.SoundManager.addChannel(channel);
             return channel;
         }
         get duration() {
             if (this.audioBuffer) {
                 return this.audioBuffer.duration;
             }
             return 0;
         }
         dispose() {
             this._disposed = true;
             delete WebAudioSound._dataCache[this.url];
             delete WebAudioSound.__loadingSound[this.url];
             this.audioBuffer = null;
             this.data = null;
             this.__toPlays = [];
         }
     }
     WebAudioSound._dataCache = {};
     /**
      * 是否支持web audio api
      */
     WebAudioSound.webAudioEnabled = window["AudioContext"] || window["webkitAudioContext"] || window["mozAudioContext"];
     /**
      * 播放设备
      */
     WebAudioSound.ctx = WebAudioSound.webAudioEnabled ? new (window["AudioContext"] || window["webkitAudioContext"] || window["mozAudioContext"])() : undefined;
     /**
      * 当前要解码的声音文件列表
      */
     WebAudioSound.buffs = [];
     /**
      * 是否在解码中
      */
     WebAudioSound.isDecoding = false;
     /**
      * 用于播放解锁声音以及解决Ios9版本的内存释放
      */
     WebAudioSound._miniBuffer = WebAudioSound.ctx ? WebAudioSound.ctx.createBuffer(1, 1, 22050) : undefined;
     /**
      * 事件派发器，用于处理加载解码完成事件的广播
      */
     WebAudioSound.e = new EventDispatcher();
     /**
      * 是否已解锁声音播放
      */
     WebAudioSound._unlocked = false;
     WebAudioSound.__loadingSound = {};

     /**
      * <code>SoundManager</code> 是一个声音管理类。提供了对背景音乐、音效的播放控制方法。
      * 引擎默认有两套声音方案：WebAudio和H5Audio
      * 播放音效，优先使用WebAudio播放声音，如果WebAudio不可用，则用H5Audio播放，H5Audio在部分机器上有兼容问题（比如不能混音，播放有延迟等）。
      * 播放背景音乐，则使用H5Audio播放（使用WebAudio会增加特别大的内存，并且要等加载完毕后才能播放，有延迟）
      * 建议背景音乐用mp3类型，音效用wav或者mp3类型（如果打包为app，音效只能用wav格式）。
      * 详细教程及声音格式请参考：http://ldc2.layabox.com/doc/?nav=ch-as-1-7-0
      */
     class SoundManager {
         /**@private */
         static __init__() {
             var win = ILaya.Browser.window;
             var supportWebAudio = win["AudioContext"] || win["webkitAudioContext"] || win["mozAudioContext"] ? true : false;
             if (supportWebAudio)
                 WebAudioSound.initWebAudio();
             SoundManager._soundClass = supportWebAudio ? WebAudioSound : AudioSound;
             AudioSound._initMusicAudio();
             SoundManager._musicClass = AudioSound;
             return supportWebAudio;
         }
         /**
          * 添加播放的声音实例。
          * @param channel <code>SoundChannel</code> 对象。
          */
         static addChannel(channel) {
             if (SoundManager._channels.indexOf(channel) >= 0)
                 return;
             SoundManager._channels.push(channel);
         }
         /**
          * 移除播放的声音实例。
          * @param channel <code>SoundChannel</code> 对象。
          */
         static removeChannel(channel) {
             var i;
             for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                 if (SoundManager._channels[i] == channel) {
                     SoundManager._channels.splice(i, 1);
                 }
             }
         }
         /**@private */
         static disposeSoundLater(url) {
             SoundManager._lastSoundUsedTimeDic[url] = ILaya.Browser.now();
             if (!SoundManager._isCheckingDispose) {
                 SoundManager._isCheckingDispose = true;
                 ILaya.timer.loop(5000, null, SoundManager._checkDisposeSound);
             }
         }
         /**@private */
         static _checkDisposeSound() {
             var key;
             var tTime = ILaya.Browser.now();
             var hasCheck = false;
             for (key in SoundManager._lastSoundUsedTimeDic) {
                 if (tTime - SoundManager._lastSoundUsedTimeDic[key] > 30000) {
                     delete SoundManager._lastSoundUsedTimeDic[key];
                     SoundManager.disposeSoundIfNotUsed(key);
                 }
                 else {
                     hasCheck = true;
                 }
             }
             if (!hasCheck) {
                 SoundManager._isCheckingDispose = false;
                 ILaya.timer.clear(null, SoundManager._checkDisposeSound);
             }
         }
         /**@private */
         static disposeSoundIfNotUsed(url) {
             var i;
             for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                 if (SoundManager._channels[i].url == url) {
                     return;
                 }
             }
             SoundManager.destroySound(url);
         }
         /**
          * 失去焦点后是否自动停止背景音乐。
          * @param v Boolean 失去焦点后是否自动停止背景音乐。
          *
          */
         static set autoStopMusic(v) {
             ILaya.stage.off(Event.BLUR, null, SoundManager._stageOnBlur);
             ILaya.stage.off(Event.FOCUS, null, SoundManager._stageOnFocus);
             ILaya.stage.off(Event.VISIBILITY_CHANGE, null, SoundManager._visibilityChange);
             SoundManager._autoStopMusic = v;
             if (v) {
                 ILaya.stage.on(Event.BLUR, null, SoundManager._stageOnBlur);
                 ILaya.stage.on(Event.FOCUS, null, SoundManager._stageOnFocus);
                 ILaya.stage.on(Event.VISIBILITY_CHANGE, null, SoundManager._visibilityChange);
             }
         }
         /**
          * 失去焦点后是否自动停止背景音乐。
          */
         static get autoStopMusic() {
             return SoundManager._autoStopMusic;
         }
         static _visibilityChange() {
             if (ILaya.stage.isVisibility) {
                 SoundManager._stageOnFocus();
             }
             else {
                 SoundManager._stageOnBlur();
             }
         }
         static _stageOnBlur() {
             SoundManager._isActive = false;
             if (SoundManager._musicChannel) {
                 if (!SoundManager._musicChannel.isStopped) {
                     SoundManager._blurPaused = true;
                     SoundManager._musicChannel.pause();
                 }
             }
             SoundManager.stopAllSound();
             ILaya.stage.once(Event.MOUSE_DOWN, null, SoundManager._stageOnFocus);
         }
         static _recoverWebAudio() {
             if (WebAudioSound.ctx && WebAudioSound.ctx.state != "running" && WebAudioSound.ctx.resume)
                 WebAudioSound.ctx.resume();
         }
         static _stageOnFocus() {
             SoundManager._isActive = true;
             SoundManager._recoverWebAudio();
             ILaya.stage.off(Event.MOUSE_DOWN, null, SoundManager._stageOnFocus);
             if (SoundManager._blurPaused) {
                 if (SoundManager._musicChannel && SoundManager._musicChannel.isStopped) {
                     SoundManager._blurPaused = false;
                     SoundManager._musicChannel.resume();
                 }
             }
         }
         /**
          * 背景音乐和所有音效是否静音。
          */
         static set muted(value) {
             if (value == SoundManager._muted)
                 return;
             if (value) {
                 SoundManager.stopAllSound();
             }
             SoundManager.musicMuted = value;
             SoundManager._muted = value;
         }
         static get muted() {
             return SoundManager._muted;
         }
         /**
          * 所有音效（不包括背景音乐）是否静音。
          */
         static set soundMuted(value) {
             SoundManager._soundMuted = value;
         }
         static get soundMuted() {
             return SoundManager._soundMuted;
         }
         /**
          * 背景音乐（不包括音效）是否静音。
          */
         static set musicMuted(value) {
             if (value == SoundManager._musicMuted)
                 return;
             if (value) {
                 if (SoundManager._bgMusic) {
                     if (SoundManager._musicChannel && !SoundManager._musicChannel.isStopped) {
                         if (ILaya.Render.isConchApp) {
                             if (SoundManager._musicChannel._audio)
                                 SoundManager._musicChannel._audio.muted = true;
                         }
                         else {
                             SoundManager._musicChannel.pause();
                         }
                     }
                     else {
                         SoundManager._musicChannel = null;
                     }
                 }
                 else {
                     SoundManager._musicChannel = null;
                 }
                 SoundManager._musicMuted = value;
             }
             else {
                 SoundManager._musicMuted = value;
                 if (SoundManager._bgMusic) {
                     if (SoundManager._musicChannel) {
                         if (ILaya.Render.isConchApp) {
                             if (SoundManager._musicChannel._audio)
                                 SoundManager._musicChannel._audio.muted = false;
                         }
                         else {
                             SoundManager._musicChannel.resume();
                         }
                     }
                 }
             }
         }
         static get musicMuted() {
             return SoundManager._musicMuted;
         }
         static get useAudioMusic() {
             return SoundManager._useAudioMusic;
         }
         static set useAudioMusic(value) {
             SoundManager._useAudioMusic = value;
             if (value) {
                 SoundManager._musicClass = AudioSound;
             }
             else {
                 SoundManager._musicClass = null;
             }
         }
         /**
          * 播放音效。音效可以同时播放多个。
          * @param url			声音文件地址。
          * @param loops			循环次数,0表示无限循环。
          * @param complete		声音播放完成回调  Handler对象。
          * @param soundClass	使用哪个声音类进行播放，null表示自动选择。
          * @param startTime		声音播放起始时间。
          * @return SoundChannel对象，通过此对象可以对声音进行控制，以及获取声音信息。
          */
         static playSound(url, loops = 1, complete = null, soundClass = null, startTime = 0) {
             if (!SoundManager._isActive || !url)
                 return null;
             if (SoundManager._muted)
                 return null;
             SoundManager._recoverWebAudio();
             url = URL.formatURL(url);
             if (url == SoundManager._bgMusic) {
                 if (SoundManager._musicMuted)
                     return null;
             }
             else {
                 if (ILaya.Render.isConchApp) {
                     var ext = Utils.getFileExtension(url);
                     if (ext != "wav" && ext != "ogg") {
                         alert("The sound only supports wav or ogg format,for optimal performance reason,please refer to the official website document.");
                         return null;
                     }
                 }
                 if (SoundManager._soundMuted)
                     return null;
             }
             var tSound;
             if (!ILaya.Browser.onMiniGame) {
                 tSound = ILaya.loader.getRes(url);
             }
             if (!soundClass)
                 soundClass = SoundManager._soundClass;
             if (!tSound) {
                 tSound = new soundClass();
                 tSound.load(url);
                 if (!ILaya.Browser.onMiniGame) {
                     ILaya.Loader.cacheRes(url, tSound);
                 }
             }
             var channel;
             channel = tSound.play(startTime, loops);
             if (!channel)
                 return null;
             channel.url = url;
             channel.volume = (url == SoundManager._bgMusic) ? SoundManager.musicVolume : SoundManager.soundVolume;
             channel.completeHandler = complete;
             return channel;
         }
         /**
          * 释放声音资源。
          * @param url	声音播放地址。
          */
         static destroySound(url) {
             var tSound = ILaya.loader.getRes(url);
             if (tSound) {
                 ILaya.Loader.clearRes(url);
                 tSound.dispose();
             }
         }
         /**
          * 播放背景音乐。背景音乐同时只能播放一个，如果在播放背景音乐时再次调用本方法，会先停止之前的背景音乐，再播发当前的背景音乐。
          * @param url		声音文件地址。
          * @param loops		循环次数,0表示无限循环。
          * @param complete	声音播放完成回调。
          * @param startTime	声音播放起始时间。
          * @return SoundChannel对象，通过此对象可以对声音进行控制，以及获取声音信息。
          */
         static playMusic(url, loops = 0, complete = null, startTime = 0) {
             url = URL.formatURL(url);
             SoundManager._bgMusic = url;
             if (SoundManager._musicChannel)
                 SoundManager._musicChannel.stop();
             return SoundManager._musicChannel = SoundManager.playSound(url, loops, complete, SoundManager._musicClass, startTime);
         }
         /**
          * 停止声音播放。此方法能够停止任意声音的播放（包括背景音乐和音效），只需传入对应的声音播放地址。
          * @param url  声音文件地址。
          */
         static stopSound(url) {
             url = URL.formatURL(url);
             var i;
             var channel;
             for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                 channel = SoundManager._channels[i];
                 if (channel.url == url) {
                     channel.stop();
                 }
             }
         }
         /**
          * 停止播放所有声音（包括背景音乐和音效）。
          */
         static stopAll() {
             SoundManager._bgMusic = null;
             var i;
             var channel;
             for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                 channel = SoundManager._channels[i];
                 channel.stop();
             }
         }
         /**
          * 停止播放所有音效（不包括背景音乐）。
          */
         static stopAllSound() {
             var i;
             var channel;
             for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                 channel = SoundManager._channels[i];
                 if (channel.url != SoundManager._bgMusic) {
                     channel.stop();
                 }
             }
         }
         /**
          * 停止播放背景音乐（不包括音效）。
          * @param url  声音文件地址。
          */
         static stopMusic() {
             if (SoundManager._musicChannel)
                 SoundManager._musicChannel.stop();
             SoundManager._bgMusic = null;
         }
         /**
          * 设置声音音量。根据参数不同，可以分别设置指定声音（背景音乐或音效）音量或者所有音效（不包括背景音乐）音量。
          * @param volume	音量。初始值为1。音量范围从 0（静音）至 1（最大音量）。
          * @param url		(default = null)声音播放地址。默认为null。为空表示设置所有音效（不包括背景音乐）的音量，不为空表示设置指定声音（背景音乐或音效）的音量。
          */
         static setSoundVolume(volume, url = null) {
             if (url) {
                 url = URL.formatURL(url);
                 SoundManager._setVolume(url, volume);
             }
             else {
                 SoundManager.soundVolume = volume;
                 var i;
                 var channel;
                 for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                     channel = SoundManager._channels[i];
                     if (channel.url != SoundManager._bgMusic) {
                         channel.volume = volume;
                     }
                 }
             }
         }
         /**
          * 设置背景音乐音量。音量范围从 0（静音）至 1（最大音量）。
          * @param volume	音量。初始值为1。音量范围从 0（静音）至 1（最大音量）。
          */
         static setMusicVolume(volume) {
             SoundManager.musicVolume = volume;
             SoundManager._setVolume(SoundManager._bgMusic, volume);
         }
         /**
          * 设置指定声音的音量。
          * @param url		声音文件url
          * @param volume	音量。初始值为1。
          */
         static _setVolume(url, volume) {
             url = URL.formatURL(url);
             var i;
             var channel;
             for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                 channel = SoundManager._channels[i];
                 if (channel.url == url) {
                     channel.volume = volume;
                 }
             }
         }
     }
     /**
      * 背景音乐音量。
      * @default 1
      */
     SoundManager.musicVolume = 1;
     /**
      * 音效音量。
      * @default 1
      */
     SoundManager.soundVolume = 1;
     /**
      * 声音播放速率。
      * @default 1
      */
     SoundManager.playbackRate = 1;
     /**
      * 背景音乐使用Audio标签播放。
      * @default true
      */
     SoundManager._useAudioMusic = true;
     /**@private 是否静音，默认为false。*/
     SoundManager._muted = false;
     /**@private 是否音效静音，默认为false。*/
     SoundManager._soundMuted = false;
     /**@private 是否背景音乐静音，默认为false。*/
     SoundManager._musicMuted = false;
     /**@private 当前背景音乐url。*/
     SoundManager._bgMusic = null;
     /**@private 当前背景音乐声道。*/
     SoundManager._musicChannel = null;
     /**@private 当前播放的Channel列表。*/
     SoundManager._channels = [];
     /**@private */
     SoundManager._blurPaused = false;
     /**@private */
     SoundManager._isActive = true;
     /**@private */
     SoundManager._lastSoundUsedTimeDic = {};
     /**@private */
     SoundManager._isCheckingDispose = false;
     /**
      * 音效播放后自动删除。
      * @default true
      */
     SoundManager.autoReleaseSound = true;

     /**
      * 请求进度改变时调度。
      * @eventType Event.PROGRESS
      * */
     /*[Event(name = "progress", type = "laya.events.Event")]*/
     /**
      * 请求结束后调度。
      * @eventType Event.COMPLETE
      * */
     /*[Event(name = "complete", type = "laya.events.Event")]*/
     /**
      * 请求出错时调度。
      * @eventType Event.ERROR
      * */
     /*[Event(name = "error", type = "laya.events.Event")]*/
     /**
      * <p> <code>HttpRequest</code> 通过封装 HTML <code>XMLHttpRequest</code> 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。 <code>HttpRequest</code> 只提供以异步的形式返回 Web 服务器的响应，并且能够以文本或者二进制的形式返回内容。</p>
      * <p><b>注意：</b>建议每次请求都使用新的 <code>HttpRequest</code> 对象，因为每次调用该对象的send方法时，都会清空之前设置的数据，并重置 HTTP 请求的状态，这会导致之前还未返回响应的请求被重置，从而得不到之前请求的响应结果。</p>
      */
     class HttpRequest extends EventDispatcher {
         constructor() {
             super(...arguments);
             /**@private */
             this._http = new XMLHttpRequest();
         }
         /**
          * 发送 HTTP 请求。
          * @param	url				请求的地址。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。
          * @param	data			(default = null)发送的数据。
          * @param	method			(default = "get")用于请求的 HTTP 方法。值包括 "get"、"post"、"head"。
          * @param	responseType	(default = "text")Web 服务器的响应类型，可设置为 "text"、"json"、"xml"、"arraybuffer"。
          * @param	headers			(default = null) HTTP 请求的头部信息。参数形如key-value数组：key是头部的名称，不应该包括空白、冒号或换行；value是头部的值，不应该包括换行。比如["Content-Type", "application/json"]。
          */
         send(url, data = null, method = "get", responseType = "text", headers = null) {
             this._responseType = responseType;
             this._data = null;
             this._url = url;
             var _this = this;
             var http = this._http;
             //临时，因为微信不支持以下文件格式
             url = URL.getAdptedFilePath(url);
             http.open(method, url, true);
             if (headers) {
                 for (var i = 0; i < headers.length; i++) {
                     http.setRequestHeader(headers[i++], headers[i]);
                 }
             }
             else if (!(window.conch)) {
                 if (!data || typeof (data) == 'string')
                     http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                 else
                     http.setRequestHeader("Content-Type", "application/json");
             }
             http.responseType = responseType !== "arraybuffer" ? "text" : "arraybuffer";
             http.onerror = function (e) {
                 _this._onError(e);
             };
             http.onabort = function (e) {
                 _this._onAbort(e);
             };
             http.onprogress = function (e) {
                 _this._onProgress(e);
             };
             http.onload = function (e) {
                 _this._onLoad(e);
             };
             http.send(data);
         }
         /**
          * @private
          * 请求进度的侦听处理函数。
          * @param	e 事件对象。
          */
         _onProgress(e) {
             if (e && e.lengthComputable)
                 this.event(Event.PROGRESS, e.loaded / e.total);
         }
         /**
          * @private
          * 请求中断的侦听处理函数。
          * @param	e 事件对象。
          */
         _onAbort(e) {
             this.error("Request was aborted by user");
         }
         /**
          * @private
          * 请求出错侦的听处理函数。
          * @param	e 事件对象。
          */
         _onError(e) {
             this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText);
         }
         /**
          * @private
          * 请求消息返回的侦听处理函数。
          * @param	e 事件对象。
          */
         _onLoad(e) {
             var http = this._http;
             var status = http.status !== undefined ? http.status : 200;
             if (status === 200 || status === 204 || status === 0) {
                 this.complete();
             }
             else {
                 this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL);
             }
         }
         /**
          * @private
          * 请求错误的处理函数。
          * @param	message 错误信息。
          */
         error(message) {
             this.clear();
             console.warn(this.url, message);
             this.event(Event.ERROR, message);
         }
         /**
          * @private
          * 请求成功完成的处理函数。
          */
         complete() {
             this.clear();
             var flag = true;
             try {
                 if (this._responseType === "json") {
                     this._data = JSON.parse(this._http.responseText);
                 }
                 else if (this._responseType === "xml") {
                     this._data = Utils.parseXMLFromString(this._http.responseText);
                 }
                 else {
                     this._data = this._http.response || this._http.responseText;
                 }
             }
             catch (e) {
                 flag = false;
                 this.error(e.message);
             }
             flag && this.event(Event.COMPLETE, this._data instanceof Array ? [this._data] : this._data);
         }
         /**
          * @private
          * 清除当前请求。
          */
         clear() {
             var http = this._http;
             http.onerror = http.onabort = http.onprogress = http.onload = null;
         }
         /** 请求的地址。*/
         get url() {
             return this._url;
         }
         /** 返回的数据。*/
         get data() {
             return this._data;
         }
         /**
          * 本对象所封装的原生 XMLHttpRequest 引用。
          */
         get http() {
             return this._http;
         }
     }

     /**
      * <code>BitmapFont</code> 是位图字体类，用于定义位图字体信息。
      * 字体制作及使用方法，请参考文章
      * @see http://ldc2.layabox.com/doc/?nav=ch-js-1-2-5
      */
     class BitmapFont {
         constructor() {
             this._fontCharDic = {};
             this._fontWidthMap = {};
             this._maxWidth = 0;
             this._spaceWidth = 10;
             /**当前位图字体字号，使用时，如果字号和设置不同，并且autoScaleSize=true，则按照设置字号比率进行缩放显示。*/
             this.fontSize = 12;
             /**表示是否根据实际使用的字体大小缩放位图字体大小。*/
             this.autoScaleSize = false;
             /**字符间距（以像素为单位）。*/
             this.letterSpacing = 0;
         }
         /**
          * 通过指定位图字体文件路径，加载位图字体文件，加载完成后会自动解析。
          * @param	path		位图字体文件的路径。
          * @param	complete	加载并解析完成的回调。
          */
         loadFont(path, complete) {
             this._path = path;
             this._complete = complete;
             if (!path || path.indexOf(".fnt") === -1) {
                 console.error('Bitmap font configuration information must be a ".fnt" file');
                 return;
             }
             ILaya.loader.load([{ url: path, type: ILaya.Loader.XML }, { url: path.replace(".fnt", ".png"), type: ILaya.Loader.IMAGE }], Handler.create(this, this._onLoaded));
         }
         /**
          * @private
          */
         _onLoaded() {
             this.parseFont(ILaya.Loader.getRes(this._path), ILaya.Loader.getRes(this._path.replace(".fnt", ".png")));
             this._complete && this._complete.run();
         }
         /**
          * 解析字体文件。
          * @param	xml			字体文件XML。
          * @param	texture		字体的纹理。
          */
         parseFont(xml, texture) {
             if (xml == null || texture == null)
                 return;
             this._texture = texture;
             var tScale = 1;
             var tInfo = xml.getElementsByTagName("info");
             if (!tInfo[0].getAttributeNode) {
                 return this.parseFont2(xml, texture);
             }
             this.fontSize = parseInt(tInfo[0].getAttributeNode("size").nodeValue);
             var tPadding = tInfo[0].getAttributeNode("padding").nodeValue;
             var tPaddingArray = tPadding.split(",");
             this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
             var chars = xml.getElementsByTagName("char");
             var i = 0;
             for (i = 0; i < chars.length; i++) {
                 var tAttribute = chars[i];
                 var tId = parseInt(tAttribute.getAttributeNode("id").nodeValue);
                 var xOffset = parseInt(tAttribute.getAttributeNode("xoffset").nodeValue) / tScale;
                 var yOffset = parseInt(tAttribute.getAttributeNode("yoffset").nodeValue) / tScale;
                 var xAdvance = parseInt(tAttribute.getAttributeNode("xadvance").nodeValue) / tScale;
                 var region = new Rectangle();
                 region.x = parseInt(tAttribute.getAttributeNode("x").nodeValue);
                 region.y = parseInt(tAttribute.getAttributeNode("y").nodeValue);
                 region.width = parseInt(tAttribute.getAttributeNode("width").nodeValue);
                 region.height = parseInt(tAttribute.getAttributeNode("height").nodeValue);
                 var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                 this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
                 this._fontCharDic[tId] = tTexture;
                 this._fontWidthMap[tId] = xAdvance;
             }
         }
         /**
          * 解析字体文件。
          * @param	xml			字体文件XML。
          * @param	texture		字体的纹理。
          */
         parseFont2(xml, texture) {
             if (xml == null || texture == null)
                 return;
             this._texture = texture;
             var tScale = 1;
             var tInfo = xml.getElementsByTagName("info");
             this.fontSize = parseInt(tInfo[0].attributes["size"].nodeValue);
             var tPadding = tInfo[0].attributes["padding"].nodeValue;
             var tPaddingArray = tPadding.split(",");
             this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
             var chars = xml.getElementsByTagName("char");
             var i = 0;
             for (i = 0; i < chars.length; i++) {
                 var tAttribute = chars[i].attributes;
                 var tId = parseInt(tAttribute["id"].nodeValue);
                 var xOffset = parseInt(tAttribute["xoffset"].nodeValue) / tScale;
                 var yOffset = parseInt(tAttribute["yoffset"].nodeValue) / tScale;
                 var xAdvance = parseInt(tAttribute["xadvance"].nodeValue) / tScale;
                 var region = new Rectangle();
                 region.x = parseInt(tAttribute["x"].nodeValue);
                 region.y = parseInt(tAttribute["y"].nodeValue);
                 region.width = parseInt(tAttribute["width"].nodeValue);
                 region.height = parseInt(tAttribute["height"].nodeValue);
                 var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                 this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
                 this._fontCharDic[tId] = tTexture;
                 this._fontWidthMap[tId] = xAdvance;
             }
         }
         /**
          * 获取指定字符的字体纹理对象。
          * @param	char 字符。
          * @return 指定的字体纹理对象。
          */
         getCharTexture(char) {
             return this._fontCharDic[char.charCodeAt(0)];
         }
         /**
          * 销毁位图字体，调用Text.unregisterBitmapFont 时，默认会销毁。
          */
         destroy() {
             if (this._texture) {
                 for (var p in this._fontCharDic) {
                     var tTexture = this._fontCharDic[p];
                     if (tTexture)
                         tTexture.destroy();
                 }
                 this._texture.destroy();
                 this._fontCharDic = null;
                 this._fontWidthMap = null;
                 this._texture = null;
                 this._complete = null;
                 this._padding = null;
             }
         }
         /**
          * 设置空格的宽（如果字体库有空格，这里就可以不用设置了）。
          * @param	spaceWidth 宽度，单位为像素。
          */
         setSpaceWidth(spaceWidth) {
             this._spaceWidth = spaceWidth;
         }
         /**
          * 获取指定字符的宽度。
          * @param	char 字符。
          * @return  宽度。
          */
         getCharWidth(char) {
             var code = char.charCodeAt(0);
             if (this._fontWidthMap[code])
                 return this._fontWidthMap[code] + this.letterSpacing;
             if (char === " ")
                 return this._spaceWidth + this.letterSpacing;
             return 0;
         }
         /**
          * 获取指定文本内容的宽度。
          * @param	text 文本内容。
          * @return  宽度。
          */
         getTextWidth(text) {
             var tWidth = 0;
             for (var i = 0, n = text.length; i < n; i++) {
                 tWidth += this.getCharWidth(text.charAt(i));
             }
             return tWidth;
         }
         /**
          * 获取最大字符宽度。
          */
         getMaxWidth() {
             return this._maxWidth;
         }
         /**
          * 获取最大字符高度。
          */
         getMaxHeight() {
             return this.fontSize;
         }
         /**
          * @private
          * 将指定的文本绘制到指定的显示对象上。
          */
         _drawText(text, sprite, drawX, drawY, align, width) {
             var tWidth = this.getTextWidth(text);
             var tTexture;
             var dx = 0;
             align === "center" && (dx = (width - tWidth) / 2);
             align === "right" && (dx = (width - tWidth));
             var tx = 0;
             for (var i = 0, n = text.length; i < n; i++) {
                 tTexture = this.getCharTexture(text.charAt(i));
                 if (tTexture) {
                     sprite.graphics.drawImage(tTexture, drawX + tx + dx, drawY);
                     tx += this.getCharWidth(text.charAt(i));
                 }
             }
         }
     }

     /**
      * 模板，预制件
      */
     class Prefab {
         /**
          * 通过预制创建实例
          */
         create() {
             if (this.json)
                 return ILaya.SceneUtils.createByData(null, this.json);
             return null;
         }
     }

     /**
      * <p> <code>Byte</code> 类提供用于优化读取、写入以及处理二进制数据的方法和属性。</p>
      * <p> <code>Byte</code> 类适用于需要在字节层访问数据的高级开发人员。</p>
      */
     class Byte {
         /**
          * 创建一个 <code>Byte</code> 类的实例。
          * @param	data	用于指定初始化的元素数目，或者用于初始化的TypedArray对象、ArrayBuffer对象。如果为 null ，则预分配一定的内存空间，当可用空间不足时，优先使用这部分内存，如果还不够，则重新分配所需内存。
          */
         constructor(data = null) {
             /**@private 是否为小端数据。*/
             this._xd_ = true;
             /**@private */
             this._allocated_ = 8;
             /**@private */
             this._pos_ = 0;
             /**@private */
             this._length = 0;
             if (data) {
                 this._u8d_ = new Uint8Array(data);
                 this._d_ = new DataView(this._u8d_.buffer);
                 this._length = this._d_.byteLength;
             }
             else {
                 this._resizeBuffer(this._allocated_);
             }
         }
         /**
          * <p>获取当前主机的字节序。</p>
          * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>
          * <p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。<br/>
          * <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
          * @return 当前系统的字节序。
          */
         static getSystemEndian() {
             if (!Byte._sysEndian) {
                 var buffer = new ArrayBuffer(2);
                 new DataView(buffer).setInt16(0, 256, true);
                 Byte._sysEndian = (new Int16Array(buffer))[0] === 256 ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
             }
             return Byte._sysEndian;
         }
         /**
          * 获取此对象的 ArrayBuffer 数据，数据只包含有效数据部分。
          */
         get buffer() {
             var rstBuffer = this._d_.buffer;
             if (rstBuffer.byteLength === this._length)
                 return rstBuffer;
             return rstBuffer.slice(0, this._length);
         }
         /**
          * <p> <code>Byte</code> 实例的字节序。取值为：<code>BIG_ENDIAN</code> 或 <code>BIG_ENDIAN</code> 。</p>
          * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
          * <p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。<br/>
          *  <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
          */
         get endian() {
             return this._xd_ ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
         }
         set endian(value) {
             this._xd_ = (value === Byte.LITTLE_ENDIAN);
         }
         /**
          * <p> <code>Byte</code> 对象的长度（以字节为单位）。</p>
          * <p>如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧；如果将长度设置为小于当前长度的值，将会截断该字节数组。</p>
          * <p>如果要设置的长度大于当前已分配的内存空间的字节长度，则重新分配内存空间，大小为以下两者较大者：要设置的长度、当前已分配的长度的2倍，并将原有数据拷贝到新的内存空间中；如果要设置的长度小于当前已分配的内存空间的字节长度，也会重新分配内存空间，大小为要设置的长度，并将原有数据从头截断为要设置的长度存入新的内存空间中。</p>
          */
         set length(value) {
             if (this._allocated_ < value)
                 this._resizeBuffer(this._allocated_ = Math.floor(Math.max(value, this._allocated_ * 2)));
             else if (this._allocated_ > value)
                 this._resizeBuffer(this._allocated_ = value);
             this._length = value;
         }
         get length() {
             return this._length;
         }
         /**@private */
         _resizeBuffer(len) {
             try {
                 var newByteView = new Uint8Array(len);
                 if (this._u8d_ != null) {
                     if (this._u8d_.length <= len)
                         newByteView.set(this._u8d_);
                     else
                         newByteView.set(this._u8d_.subarray(0, len));
                 }
                 this._u8d_ = newByteView;
                 this._d_ = new DataView(newByteView.buffer);
             }
             catch (err) {
                 throw "Invalid typed array length:" + len;
             }
         }
         /**
          * @private
          * <p>常用于解析固定格式的字节流。</p>
          * <p>先从字节流的当前字节偏移位置处读取一个 <code>Uint16</code> 值，然后以此值为长度，读取此长度的字符串。</p>
          * @return 读取的字符串。
          */
         getString() {
             return this.readString();
         }
         /**
          * <p>常用于解析固定格式的字节流。</p>
          * <p>先从字节流的当前字节偏移位置处读取一个 <code>Uint16</code> 值，然后以此值为长度，读取此长度的字符串。</p>
          * @return 读取的字符串。
          */
         readString() {
             return this._rUTF(this.getUint16());
         }
         /**
          * @private
          * <p>从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Float32Array</code> 对象并返回此对象。</p>
          * <p><b>注意：</b>返回的 Float32Array 对象，在 JavaScript 环境下，是原生的 HTML5 Float32Array 对象，对此对象的读取操作都是基于运行此程序的当前主机字节序，此顺序可能与实际数据的字节序不同，如果使用此对象进行读取，需要用户知晓实际数据的字节序和当前主机字节序，如果相同，可正常读取，否则需要用户对实际数据(Float32Array.buffer)包装一层 DataView ，使用 DataView 对象可按照指定的字节序进行读取。</p>
          * @param	start	开始位置。
          * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
          * @return  读取的 Float32Array 对象。
          */
         getFloat32Array(start, len) {
             return this.readFloat32Array(start, len);
         }
         /**
          * 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Float32Array</code> 对象并返回此对象。
          * @param	start	开始位置。
          * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
          * @return  读取的 Float32Array 对象。
          */
         readFloat32Array(start, len) {
             var end = start + len;
             end = (end > this._length) ? this._length : end;
             var v = new Float32Array(this._d_.buffer.slice(start, end));
             this._pos_ = end;
             return v;
         }
         /**
          * @private
          * 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Uint8Array</code> 对象并返回此对象。
          * @param	start	开始位置。
          * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
          * @return  读取的 Uint8Array 对象。
          */
         getUint8Array(start, len) {
             return this.readUint8Array(start, len);
         }
         /**
          * 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Uint8Array</code> 对象并返回此对象。
          * @param	start	开始位置。
          * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
          * @return  读取的 Uint8Array 对象。
          */
         readUint8Array(start, len) {
             var end = start + len;
             end = (end > this._length) ? this._length : end;
             var v = new Uint8Array(this._d_.buffer.slice(start, end));
             this._pos_ = end;
             return v;
         }
         /**
          * @private
          * <p>从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Int16Array</code> 对象并返回此对象。</p>
          * <p><b>注意：</b>返回的 Int16Array 对象，在 JavaScript 环境下，是原生的 HTML5 Int16Array 对象，对此对象的读取操作都是基于运行此程序的当前主机字节序，此顺序可能与实际数据的字节序不同，如果使用此对象进行读取，需要用户知晓实际数据的字节序和当前主机字节序，如果相同，可正常读取，否则需要用户对实际数据(Int16Array.buffer)包装一层 DataView ，使用 DataView 对象可按照指定的字节序进行读取。</p>
          * @param	start	开始读取的字节偏移量位置。
          * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
          * @return  读取的 Int16Array 对象。
          */
         getInt16Array(start, len) {
             return this.readInt16Array(start, len);
         }
         /**
          * 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Int16Array</code> 对象并返回此对象。
          * @param	start	开始读取的字节偏移量位置。
          * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
          * @return  读取的 Uint8Array 对象。
          */
         readInt16Array(start, len) {
             var end = start + len;
             end = (end > this._length) ? this._length : end;
             var v = new Int16Array(this._d_.buffer.slice(start, end));
             this._pos_ = end;
             return v;
         }
         /**
          * @private
          * 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
          * @return 单精度（32 位）浮点数。
          */
         getFloat32() {
             return this.readFloat32();
         }
         /**
          * 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
          * @return 单精度（32 位）浮点数。
          */
         readFloat32() {
             if (this._pos_ + 4 > this._length)
                 throw "getFloat32 error - Out of bounds";
             var v = this._d_.getFloat32(this._pos_, this._xd_);
             this._pos_ += 4;
             return v;
         }
         /**
          * @private
          * 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
          * @return 双精度（64 位）浮点数。
          */
         getFloat64() {
             return this.readFloat64();
         }
         /**
          * 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
          * @return 双精度（64 位）浮点数。
          */
         readFloat64() {
             if (this._pos_ + 8 > this._length)
                 throw "getFloat64 error - Out of bounds";
             var v = this._d_.getFloat64(this._pos_, this._xd_);
             this._pos_ += 8;
             return v;
         }
         /**
          * 在字节流的当前字节偏移量位置处写入一个 IEEE 754 单精度（32 位）浮点数。
          * @param	value	单精度（32 位）浮点数。
          */
         writeFloat32(value) {
             this._ensureWrite(this._pos_ + 4);
             this._d_.setFloat32(this._pos_, value, this._xd_);
             this._pos_ += 4;
         }
         /**
          * 在字节流的当前字节偏移量位置处写入一个 IEEE 754 双精度（64 位）浮点数。
          * @param	value	双精度（64 位）浮点数。
          */
         writeFloat64(value) {
             this._ensureWrite(this._pos_ + 8);
             this._d_.setFloat64(this._pos_, value, this._xd_);
             this._pos_ += 8;
         }
         /**
          * @private
          * 从字节流的当前字节偏移量位置处读取一个 Int32 值。
          * @return Int32 值。
          */
         getInt32() {
             return this.readInt32();
         }
         /**
          * 从字节流的当前字节偏移量位置处读取一个 Int32 值。
          * @return Int32 值。
          */
         readInt32() {
             if (this._pos_ + 4 > this._length)
                 throw "getInt32 error - Out of bounds";
             var float = this._d_.getInt32(this._pos_, this._xd_);
             this._pos_ += 4;
             return float;
         }
         /**
          * @private
          * 从字节流的当前字节偏移量位置处读取一个 Uint32 值。
          * @return Uint32 值。
          */
         getUint32() {
             return this.readUint32();
         }
         /**
          * 从字节流的当前字节偏移量位置处读取一个 Uint32 值。
          * @return Uint32 值。
          */
         readUint32() {
             if (this._pos_ + 4 > this._length)
                 throw "getUint32 error - Out of bounds";
             var v = this._d_.getUint32(this._pos_, this._xd_);
             this._pos_ += 4;
             return v;
         }
         /**
          * 在字节流的当前字节偏移量位置处写入指定的 Int32 值。
          * @param	value	需要写入的 Int32 值。
          */
         writeInt32(value) {
             this._ensureWrite(this._pos_ + 4);
             this._d_.setInt32(this._pos_, value, this._xd_);
             this._pos_ += 4;
         }
         /**
          * 在字节流的当前字节偏移量位置处写入 Uint32 值。
          * @param	value	需要写入的 Uint32 值。
          */
         writeUint32(value) {
             this._ensureWrite(this._pos_ + 4);
             this._d_.setUint32(this._pos_, value, this._xd_);
             this._pos_ += 4;
         }
         /**
          * @private
          * 从字节流的当前字节偏移量位置处读取一个 Int16 值。
          * @return Int16 值。
          */
         getInt16() {
             return this.readInt16();
         }
         /**
          * 从字节流的当前字节偏移量位置处读取一个 Int16 值。
          * @return Int16 值。
          */
         readInt16() {
             if (this._pos_ + 2 > this._length)
                 throw "getInt16 error - Out of bounds";
             var us = this._d_.getInt16(this._pos_, this._xd_);
             this._pos_ += 2;
             return us;
         }
         /**
          * @private
          * 从字节流的当前字节偏移量位置处读取一个 Uint16 值。
          * @return Uint16 值。
          */
         getUint16() {
             return this.readUint16();
         }
         /**
          * 从字节流的当前字节偏移量位置处读取一个 Uint16 值。
          * @return Uint16 值。
          */
         readUint16() {
             if (this._pos_ + 2 > this._length)
                 throw "getUint16 error - Out of bounds";
             var us = this._d_.getUint16(this._pos_, this._xd_);
             this._pos_ += 2;
             return us;
         }
         /**
          * 在字节流的当前字节偏移量位置处写入指定的 Uint16 值。
          * @param	value	需要写入的Uint16 值。
          */
         writeUint16(value) {
             this._ensureWrite(this._pos_ + 2);
             this._d_.setUint16(this._pos_, value, this._xd_);
             this._pos_ += 2;
         }
         /**
          * 在字节流的当前字节偏移量位置处写入指定的 Int16 值。
          * @param	value	需要写入的 Int16 值。
          */
         writeInt16(value) {
             this._ensureWrite(this._pos_ + 2);
             this._d_.setInt16(this._pos_, value, this._xd_);
             this._pos_ += 2;
         }
         /**
          * @private
          * 从字节流的当前字节偏移量位置处读取一个 Uint8 值。
          * @return Uint8 值。
          */
         getUint8() {
             return this.readUint8();
         }
         /**
          * 从字节流的当前字节偏移量位置处读取一个 Uint8 值。
          * @return Uint8 值。
          */
         readUint8() {
             if (this._pos_ + 1 > this._length)
                 throw "getUint8 error - Out of bounds";
             return this._u8d_[this._pos_++];
         }
         /**
          * 在字节流的当前字节偏移量位置处写入指定的 Uint8 值。
          * @param	value	需要写入的 Uint8 值。
          */
         writeUint8(value) {
             this._ensureWrite(this._pos_ + 1);
             this._d_.setUint8(this._pos_, value);
             this._pos_++;
         }
         /**
          * @private
          * 从字节流的指定字节偏移量位置处读取一个 Uint8 值。
          * @param	pos	字节读取位置。
          * @return Uint8 值。
          */
         //TODO:coverage
         _getUInt8(pos) {
             return this._readUInt8(pos);
         }
         /**
          * @private
          * 从字节流的指定字节偏移量位置处读取一个 Uint8 值。
          * @param	pos	字节读取位置。
          * @return Uint8 值。
          */
         //TODO:coverage
         _readUInt8(pos) {
             return this._d_.getUint8(pos);
         }
         /**
          * @private
          * 从字节流的指定字节偏移量位置处读取一个 Uint16 值。
          * @param	pos	字节读取位置。
          * @return Uint16 值。
          */
         //TODO:coverage
         _getUint16(pos) {
             return this._readUint16(pos);
         }
         /**
          * @private
          * 从字节流的指定字节偏移量位置处读取一个 Uint16 值。
          * @param	pos	字节读取位置。
          * @return Uint16 值。
          */
         //TODO:coverage
         _readUint16(pos) {
             return this._d_.getUint16(pos, this._xd_);
         }
         /**
          * @private
          * 使用 getFloat32() 读取6个值，用于创建并返回一个 Matrix 对象。
          * @return  Matrix 对象。
          */
         //TODO:coverage
         _getMatrix() {
             return this._readMatrix();
         }
         /**
          * @private
          * 使用 getFloat32() 读取6个值，用于创建并返回一个 Matrix 对象。
          * @return  Matrix 对象。
          */
         //TODO:coverage
         _readMatrix() {
             var rst = new Matrix(this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32());
             return rst;
         }
         /**
          * @private
          * 读取指定长度的 UTF 型字符串。
          * @param	len 需要读取的长度。
          * @return 读取的字符串。
          */
         _rUTF(len) {
             var max = this._pos_ + len, c, c2, c3, f = String.fromCharCode;
             var u = this._u8d_;
             var strs = [];
             var n = 0;
             strs.length = 1000;
             while (this._pos_ < max) {
                 c = u[this._pos_++];
                 if (c < 0x80) {
                     if (c != 0)
                         //v += f(c);\
                         strs[n++] = f(c);
                 }
                 else if (c < 0xE0) {
                     //v += f(((c & 0x3F) << 6) | (u[_pos_++] & 0x7F));
                     strs[n++] = f(((c & 0x3F) << 6) | (u[this._pos_++] & 0x7F));
                 }
                 else if (c < 0xF0) {
                     c2 = u[this._pos_++];
                     //v += f(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (u[_pos_++] & 0x7F));
                     strs[n++] = f(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (u[this._pos_++] & 0x7F));
                 }
                 else {
                     c2 = u[this._pos_++];
                     c3 = u[this._pos_++];
                     //v += f(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (u[_pos_++] & 0x7F));
                     strs[n++] = f(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (u[this._pos_++] & 0x7F));
                 }
             }
             strs.length = n;
             return strs.join('');
             //return v;
         }
         /**
          * @private
          * 读取 <code>len</code> 参数指定的长度的字符串。
          * @param	len	要读取的字符串的长度。
          * @return 指定长度的字符串。
          */
         //TODO:coverage
         getCustomString(len) {
             return this.readCustomString(len);
         }
         /**
          * @private
          * 读取 <code>len</code> 参数指定的长度的字符串。
          * @param	len	要读取的字符串的长度。
          * @return 指定长度的字符串。
          */
         //TODO:coverage
         readCustomString(len) {
             var v = "", ulen = 0, c, c2, f = String.fromCharCode;
             var u = this._u8d_;
             while (len > 0) {
                 c = u[this._pos_];
                 if (c < 0x80) {
                     v += f(c);
                     this._pos_++;
                     len--;
                 }
                 else {
                     ulen = c - 0x80;
                     this._pos_++;
                     len -= ulen;
                     while (ulen > 0) {
                         c = u[this._pos_++];
                         c2 = u[this._pos_++];
                         v += f((c2 << 8) | c);
                         ulen--;
                     }
                 }
             }
             return v;
         }
         /**
          * 移动或返回 Byte 对象的读写指针的当前位置（以字节为单位）。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
          */
         get pos() {
             return this._pos_;
         }
         set pos(value) {
             this._pos_ = value;
             //$MOD byteOffset是只读的，这里进行赋值没有意义。
             //_d_.byteOffset = value;
         }
         /**
          * 可从字节流的当前位置到末尾读取的数据的字节数。
          */
         get bytesAvailable() {
             return this._length - this._pos_;
         }
         /**
          * 清除字节数组的内容，并将 length 和 pos 属性重置为 0。调用此方法将释放 Byte 实例占用的内存。
          */
         clear() {
             this._pos_ = 0;
             this.length = 0;
         }
         /**
          * @private
          * 获取此对象的 ArrayBuffer 引用。
          * @return
          */
         __getBuffer() {
             //this._d_.buffer.byteLength = this.length;
             return this._d_.buffer;
         }
         /**
          * <p>将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的字为字符串添加前缀。</p>
          * <p>对应的读取方法为： getUTFBytes 。</p>
          * @param value 要写入的字符串。
          */
         writeUTFBytes(value) {
             // utf8-decode
             value = value + "";
             for (var i = 0, sz = value.length; i < sz; i++) {
                 var c = value.charCodeAt(i);
                 if (c <= 0x7F) {
                     this.writeByte(c);
                 }
                 else if (c <= 0x7FF) {
                     //优化为直接写入多个字节，而不必重复调用writeByte，免去额外的调用和逻辑开销。
                     this._ensureWrite(this._pos_ + 2);
                     this._u8d_.set([0xC0 | (c >> 6), 0x80 | (c & 0x3F)], this._pos_);
                     this._pos_ += 2;
                 }
                 else if (c <= 0xFFFF) {
                     this._ensureWrite(this._pos_ + 3);
                     this._u8d_.set([0xE0 | (c >> 12), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                     this._pos_ += 3;
                 }
                 else {
                     this._ensureWrite(this._pos_ + 4);
                     this._u8d_.set([0xF0 | (c >> 18), 0x80 | ((c >> 12) & 0x3F), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                     this._pos_ += 4;
                 }
             }
         }
         /**
          * <p>将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。</p>
          * <p>对应的读取方法为： getUTFString 。</p>
          * @param	value 要写入的字符串值。
          */
         writeUTFString(value) {
             var tPos = this.pos;
             this.writeUint16(1);
             this.writeUTFBytes(value);
             var dPos = this.pos - tPos - 2;
             //trace("writeLen:",dPos,"pos:",tPos);
             this._d_.setUint16(tPos, dPos, this._xd_);
         }
         /**
          * @private
          * 读取 UTF-8 字符串。
          * @return 读取的字符串。
          */
         readUTFString() {
             //var tPos:int = pos;
             //var len:int = getUint16();
             ////trace("readLen:"+len,"pos,",tPos);
             return this.readUTFBytes(this.getUint16());
         }
         /**
          * <p>从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是一个无符号的短整型（以此字节表示要读取的长度）。</p>
          * <p>对应的写入方法为： writeUTFString 。</p>
          * @return 读取的字符串。
          */
         getUTFString() {
             return this.readUTFString();
         }
         /**
          * @private
          * 读字符串，必须是 writeUTFBytes 方法写入的字符串。
          * @param len	要读的buffer长度，默认将读取缓冲区全部数据。
          * @return 读取的字符串。
          */
         readUTFBytes(len = -1) {
             if (len === 0)
                 return "";
             var lastBytes = this.bytesAvailable;
             if (len > lastBytes)
                 throw "readUTFBytes error - Out of bounds";
             len = len > 0 ? len : lastBytes;
             return this._rUTF(len);
         }
         /**
          * <p>从字节流中读取一个由 length 参数指定的长度的 UTF-8 字节序列，并返回一个字符串。</p>
          * <p>一般读取的是由 writeUTFBytes 方法写入的字符串。</p>
          * @param len	要读的buffer长度，默认将读取缓冲区全部数据。
          * @return 读取的字符串。
          */
         getUTFBytes(len = -1) {
             return this.readUTFBytes(len);
         }
         /**
          * <p>在字节流中写入一个字节。</p>
          * <p>使用参数的低 8 位。忽略高 24 位。</p>
          * @param	value
          */
         writeByte(value) {
             this._ensureWrite(this._pos_ + 1);
             this._d_.setInt8(this._pos_, value);
             this._pos_ += 1;
         }
         /**
          * <p>从字节流中读取带符号的字节。</p>
          * <p>返回值的范围是从 -128 到 127。</p>
          * @return 介于 -128 和 127 之间的整数。
          */
         readByte() {
             if (this._pos_ + 1 > this._length)
                 throw "readByte error - Out of bounds";
             return this._d_.getInt8(this._pos_++);
         }
         /**
          * @private
          * 从字节流中读取带符号的字节。
          */
         getByte() {
             return this.readByte();
         }
         /**
          * @private
          * <p>保证该字节流的可用长度不小于 <code>lengthToEnsure</code> 参数指定的值。</p>
          * @param	lengthToEnsure	指定的长度。
          */
         _ensureWrite(lengthToEnsure) {
             if (this._length < lengthToEnsure)
                 this._length = lengthToEnsure;
             if (this._allocated_ < lengthToEnsure)
                 this.length = lengthToEnsure;
         }
         /**
          * <p>将指定 arraybuffer 对象中的以 offset 为起始偏移量， length 为长度的字节序列写入字节流。</p>
          * <p>如果省略 length 参数，则使用默认长度 0，该方法将从 offset 开始写入整个缓冲区；如果还省略了 offset 参数，则写入整个缓冲区。</p>
          * <p>如果 offset 或 length 小于0，本函数将抛出异常。</p>
          * @param	arraybuffer	需要写入的 Arraybuffer 对象。
          * @param	offset		Arraybuffer 对象的索引的偏移量（以字节为单位）
          * @param	length		从 Arraybuffer 对象写入到 Byte 对象的长度（以字节为单位）
          */
         writeArrayBuffer(arraybuffer, offset = 0, length = 0) {
             if (offset < 0 || length < 0)
                 throw "writeArrayBuffer error - Out of bounds";
             if (length == 0)
                 length = arraybuffer.byteLength - offset;
             this._ensureWrite(this._pos_ + length);
             var uint8array = new Uint8Array(arraybuffer);
             this._u8d_.set(uint8array.subarray(offset, offset + length), this._pos_);
             this._pos_ += length;
         }
         /**
          * 读取ArrayBuffer数据
          * @param	length
          * @return
          */
         readArrayBuffer(length) {
             var rst;
             rst = this._u8d_.buffer.slice(this._pos_, this._pos_ + length);
             this._pos_ = this._pos_ + length;
             return rst;
         }
     }
     /**
      * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
      * <p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。<br/>
      * <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
      */
     Byte.BIG_ENDIAN = "bigEndian";
     /**
      * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
      * <p> <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。<br/>
      * <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。</p>
      */
     Byte.LITTLE_ENDIAN = "littleEndian";
     /**@private */
     Byte._sysEndian = null;

     /**
      * 加载进度发生改变时调度。
      * @eventType Event.PROGRESS
      * */
     /*[Event(name = "progress", type = "laya.events.Event")]*/
     /**
      * 加载完成后调度。
      * @eventType Event.COMPLETE
      * */
     /*[Event(name = "complete", type = "laya.events.Event")]*/
     /**
      * 加载出错时调度。
      * @eventType Event.ERROR
      * */
     /*[Event(name = "error", type = "laya.events.Event")]*/
     /**
      * <code>Loader</code> 类可用来加载文本、JSON、XML、二进制、图像等资源。
      */
     class Loader extends EventDispatcher {
         constructor() {
             super(...arguments);
             /**@private 自定义解析不派发complete事件，但会派发loaded事件，手动调用endLoad方法再派发complete事件*/
             this._customParse = false;
         }
         /**
          * 获取指定资源地址的数据类型。
          * @param	url 资源地址。
          * @return 数据类型。
          */
         static getTypeFromUrl(url) {
             var type = Utils.getFileExtension(url);
             if (type)
                 return Loader.typeMap[type];
             console.warn("Not recognize the resources suffix", url);
             return "text";
         }
         /**
          * 加载资源。加载错误会派发 Event.ERROR 事件，参数为错误信息。
          * @param	url			资源地址。
          * @param	type		(default = null)资源类型。可选值为：Loader.TEXT、Loader.JSON、Loader.XML、Loader.BUFFER、Loader.IMAGE、Loader.SOUND、Loader.ATLAS、Loader.FONT。如果为null，则根据文件后缀分析类型。
          * @param	cache		(default = true)是否缓存数据。
          * @param	group		(default = null)分组名称。
          * @param	ignoreCache (default = false)是否忽略缓存，强制重新加载。
          * @param	useWorkerLoader(default = false)是否使用worker加载（只针对IMAGE类型和ATLAS类型，并且浏览器支持的情况下生效）
          */
         load(url, type = null, cache = true, group = null, ignoreCache = false, useWorkerLoader = ILaya.WorkerLoader.enable) {
             if (!url) {
                 this.onLoaded(null);
                 return;
             }
             Loader.setGroup(url, "666");
             this._url = url;
             if (url.indexOf("data:image") === 0)
                 type = Loader.IMAGE;
             else
                 url = URL.formatURL(url);
             this._type = type || (type = Loader.getTypeFromUrl(this._url));
             this._cache = cache;
             this._useWorkerLoader = useWorkerLoader;
             this._data = null;
             if (useWorkerLoader)
                 ILaya.WorkerLoader.enableWorkerLoader();
             if (!ignoreCache && Loader.loadedMap[url]) {
                 this._data = Loader.loadedMap[url];
                 this.event(Event.PROGRESS, 1);
                 this.event(Event.COMPLETE, this._data);
                 return;
             }
             if (group)
                 Loader.setGroup(url, group);
             //如果自定义了解析器，则自己解析，自定义解析不派发complete事件，但会派发loaded事件，手动调用endLoad方法再派发complete事件
             if (Loader.parserMap[type] != null) {
                 this._customParse = true;
                 if (Loader.parserMap[type] instanceof Handler)
                     Loader.parserMap[type].runWith(this);
                 else
                     Loader.parserMap[type].call(null, this);
                 return;
             }
             switch (type) {
                 case Loader.IMAGE:
                 case "htmlimage": //内部类型
                 case "nativeimage": //内部类型
                     this._loadImage(url);
                     break;
                 case Loader.SOUND:
                     this._loadSound(url);
                     break;
                 case Loader.TTF:
                     this._loadTTF(url);
                     break;
                 case Loader.ATLAS:
                 case Loader.PREFAB:
                 case Loader.PLF:
                     this._loadHttpRequestWhat(url, Loader.JSON);
                     break;
                 case Loader.FONT:
                     this._loadHttpRequestWhat(url, Loader.XML);
                     break;
                 case Loader.PLFB:
                     this._loadHttpRequestWhat(url, Loader.BUFFER);
                     break;
                 default:
                     this._loadHttpRequestWhat(url, type);
             }
         }
         /**
          * @private
          * onload、onprocess、onerror必须写在本类
          */
         _loadHttpRequest(url, contentType, onLoadCaller, onLoad, onProcessCaller, onProcess, onErrorCaller, onError) {
             if (Browser.onVVMiniGame) {
                 this._http = new HttpRequest(); //临时修复vivo复用xmlhttprequest的bug
             }
             else {
                 if (!this._http)
                     this._http = new HttpRequest();
             }
             this._http.on(Event.PROGRESS, onProcessCaller, onProcess);
             this._http.on(Event.COMPLETE, onLoadCaller, onLoad);
             this._http.on(Event.ERROR, onErrorCaller, onError);
             this._http.send(url, null, "get", contentType);
         }
         /**
          * @private
          */
         _loadHtmlImage(url, onLoadCaller, onLoad, onErrorCaller, onError) {
             var image;
             function clear() {
                 var img = image;
                 img.onload = null;
                 img.onerror = null;
                 delete Loader._imgCache[url];
             }
             var onerror = function () {
                 clear();
                 onError.call(onErrorCaller);
             };
             var onload = function () {
                 clear();
                 onLoad.call(onLoadCaller, image);
             };
             image = new Browser.window.Image();
             image.crossOrigin = "";
             image.onload = onload;
             image.onerror = onerror;
             image.src = url;
             Loader._imgCache[url] = image; //增加引用，防止垃圾回收
         }
         /**
          * @private
          */
         _loadHttpRequestWhat(url, contentType) {
             if (Loader.preLoadedMap[url])
                 this.onLoaded(Loader.preLoadedMap[url]);
             else
                 this._loadHttpRequest(url, contentType, this, this.onLoaded, this, this.onProgress, this, this.onError);
         }
         /**
          * @private
          * 加载TTF资源。
          * @param	url 资源地址。
          */
         _loadTTF(url) {
             url = URL.formatURL(url);
             var ttfLoader = new ILaya.TTFLoader();
             ttfLoader.complete = Handler.create(this, this.onLoaded);
             ttfLoader.load(url);
         }
         /**
          * @private
          */
         _loadImage(url) {
             var _this = this;
             url = URL.formatURL(url);
             var onLoaded;
             var onError = function () {
                 _this.event(Event.ERROR, "Load image failed");
             };
             if (this._type === "nativeimage") {
                 onLoaded = function (image) {
                     _this.onLoaded(image);
                 };
                 this._loadHtmlImage(url, this, onLoaded, this, onError);
             }
             else {
                 var ext = Utils.getFileExtension(url);
                 if (ext === "ktx" || ext === "pvr") {
                     onLoaded = function (imageData) {
                         var format;
                         switch (ext) {
                             case "ktx":
                                 format = /*BaseTexture.FORMAT_ETC1RGB*/ 5;
                                 break;
                             case "pvr":
                                 format = /*BaseTexture.FORMAT_PVRTCRGBA_4BPPV*/ 12;
                                 break;
                         }
                         var tex = new Texture2D(0, 0, format, false, false);
                         tex.wrapModeU = BaseTexture.WARPMODE_CLAMP;
                         tex.wrapModeV = BaseTexture.WARPMODE_CLAMP;
                         tex.setCompressData(imageData);
                         tex._setCreateURL(url);
                         _this.onLoaded(tex);
                     };
                     this._loadHttpRequest(url, Loader.BUFFER, this, onLoaded, null, null, this, onError);
                 }
                 else {
                     onLoaded = function (image) {
                         var tex = new Texture2D(image.width, image.height, 1, false, false);
                         tex.wrapModeU = BaseTexture.WARPMODE_CLAMP;
                         tex.wrapModeV = BaseTexture.WARPMODE_CLAMP;
                         tex.loadImageSource(image, true);
                         tex._setCreateURL(url);
                         _this.onLoaded(tex);
                     };
                     this._loadHtmlImage(url, this, onLoaded, this, onError);
                 }
             }
         }
         /**
          * @private
          * 加载声音资源。
          * @param	url 资源地址。
          */
         _loadSound(url) {
             var sound = (new SoundManager._soundClass());
             var _this = this;
             sound.on(Event.COMPLETE, this, soundOnload);
             sound.on(Event.ERROR, this, soundOnErr);
             sound.load(url);
             function soundOnload() {
                 clear();
                 _this.onLoaded(sound);
             }
             function soundOnErr() {
                 clear();
                 sound.dispose();
                 _this.event(Event.ERROR, "Load sound failed");
             }
             function clear() {
                 sound.offAll();
             }
         }
         /**@private */
         onProgress(value) {
             if (this._type === Loader.ATLAS)
                 this.event(Event.PROGRESS, value * 0.3);
             else
                 this.event(Event.PROGRESS, value);
         }
         /**@private */
         onError(message) {
             this.event(Event.ERROR, message);
         }
         /**
          * 资源加载完成的处理函数。
          * @param	data 数据。
          */
         onLoaded(data = null) {
             var type = this._type;
             if (type == Loader.PLFB) {
                 this.parsePLFBData(data);
                 this.complete(data);
             }
             else if (type == Loader.PLF) {
                 this.parsePLFData(data);
                 this.complete(data);
             }
             else if (type === Loader.IMAGE) {
                 var tex = new Texture(data);
                 tex.url = this._url;
                 this.complete(tex);
             }
             else if (type === Loader.SOUND || type === "htmlimage" || type === "nativeimage") {
                 this.complete(data);
             }
             else if (type === Loader.ATLAS) {
                 //处理图集
                 if (!(data instanceof Texture2D)) {
                     if (!this._data) {
                         this._data = data;
                         //构造加载图片信息
                         if (data.meta && data.meta.image) {
                             //带图片信息的类型
                             var toloadPics = data.meta.image.split(",");
                             var split = this._url.indexOf("/") >= 0 ? "/" : "\\";
                             var idx = this._url.lastIndexOf(split);
                             var folderPath = idx >= 0 ? this._url.substr(0, idx + 1) : "";
                             var changeType;
                             if (Browser.onAndroid && data.meta.compressTextureAndroid) {
                                 changeType = ".ktx";
                             }
                             if (Browser.onIOS && data.meta.compressTextureIOS) {
                                 changeType = ".pvr";
                             }
                             //idx = _url.indexOf("?");
                             //var ver:String;
                             //ver = idx >= 0 ? _url.substr(idx) : "";
                             for (var i = 0, len = toloadPics.length; i < len; i++) {
                                 if (changeType) {
                                     toloadPics[i] = folderPath + toloadPics[i].replace(".png", changeType);
                                 }
                                 else {
                                     toloadPics[i] = folderPath + toloadPics[i];
                                 }
                             }
                         }
                         else {
                             //不带图片信息
                             toloadPics = [this._url.replace(".json", ".png")];
                         }
                         //保证图集的正序加载
                         toloadPics.reverse();
                         data.toLoads = toloadPics;
                         data.pics = [];
                     }
                     this.event(Event.PROGRESS, 0.3 + 1 / toloadPics.length * 0.6);
                     return this._loadImage(toloadPics.pop());
                 }
                 else {
                     this._data.pics.push(data);
                     if (this._data.toLoads.length > 0) {
                         this.event(Event.PROGRESS, 0.3 + 1 / this._data.toLoads.length * 0.6);
                         //有图片未加载
                         return this._loadImage(this._data.toLoads.pop());
                     }
                     var frames = this._data.frames;
                     var cleanUrl = this._url.split("?")[0];
                     var directory = (this._data.meta && this._data.meta.prefix) ? this._data.meta.prefix : cleanUrl.substring(0, cleanUrl.lastIndexOf(".")) + "/";
                     var pics = this._data.pics;
                     var atlasURL = URL.formatURL(this._url);
                     var map = Loader.atlasMap[atlasURL] || (Loader.atlasMap[atlasURL] = []);
                     map.dir = directory;
                     var scaleRate = 1;
                     if (this._data.meta && this._data.meta.scale && this._data.meta.scale != 1) {
                         scaleRate = parseFloat(this._data.meta.scale);
                         for (var name in frames) {
                             var obj = frames[name]; //取对应的图
                             var tPic = pics[obj.frame.idx ? obj.frame.idx : 0]; //是否释放
                             var url = URL.formatURL(directory + name);
                             tPic.scaleRate = scaleRate;
                             var tTexture;
                             tTexture = Texture._create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h, Loader.getRes(url));
                             Loader.cacheRes(url, tTexture);
                             tTexture.url = url;
                             map.push(url);
                         }
                     }
                     else {
                         for (name in frames) {
                             obj = frames[name]; //取对应的图
                             tPic = pics[obj.frame.idx ? obj.frame.idx : 0]; //是否释放
                             url = URL.formatURL(directory + name);
                             tTexture = Texture._create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h, Loader.getRes(url));
                             Loader.cacheRes(url, tTexture);
                             tTexture.url = url;
                             map.push(url);
                         }
                     }
                     delete this._data.pics;
                     this.complete(this._data);
                 }
             }
             else if (type === Loader.FONT) {
                 //处理位图字体
                 if (!data._source) {
                     this._data = data;
                     this.event(Event.PROGRESS, 0.5);
                     return this._loadImage(this._url.replace(".fnt", ".png"));
                 }
                 else {
                     var bFont = new BitmapFont();
                     bFont.parseFont(this._data, new Texture(data));
                     var tArr = this._url.split(".fnt")[0].split("/");
                     var fontName = tArr[tArr.length - 1];
                     Text.registerBitmapFont(fontName, bFont);
                     this._data = bFont;
                     this.complete(this._data);
                 }
             }
             else if (type === Loader.PREFAB) {
                 var prefab = new Prefab();
                 prefab.json = data;
                 this.complete(prefab);
             }
             else {
                 this.complete(data);
             }
         }
         parsePLFData(plfData) {
             var type;
             var filePath;
             var fileDic;
             for (type in plfData) {
                 fileDic = plfData[type];
                 switch (type) {
                     case "json":
                     case "text":
                         for (filePath in fileDic) {
                             Loader.preLoadedMap[URL.formatURL(filePath)] = fileDic[filePath];
                         }
                         break;
                     default:
                         for (filePath in fileDic) {
                             Loader.preLoadedMap[URL.formatURL(filePath)] = fileDic[filePath];
                         }
                 }
             }
         }
         parsePLFBData(plfData) {
             var byte;
             byte = new Byte(plfData);
             var i, len;
             len = byte.getInt32();
             for (i = 0; i < len; i++) {
                 this.parseOnePLFBFile(byte);
             }
         }
         parseOnePLFBFile(byte) {
             var fileLen;
             var fileName;
             var fileData;
             fileName = byte.getUTFString();
             fileLen = byte.getInt32();
             fileData = byte.readArrayBuffer(fileLen);
             Loader.preLoadedMap[URL.formatURL(fileName)] = fileData;
         }
         /**
          * 加载完成。
          * @param	data 加载的数据。
          */
         complete(data) {
             this._data = data;
             if (this._customParse) {
                 this.event(Event.LOADED, data instanceof Array ? [data] : data);
             }
             else {
                 Loader._loaders.push(this);
                 if (!Loader._isWorking)
                     Loader.checkNext();
             }
         }
         /**@private */
         static checkNext() {
             Loader._isWorking = true;
             var startTimer = Browser.now();
             var thisTimer = startTimer;
             while (Loader._startIndex < Loader._loaders.length) {
                 thisTimer = Browser.now();
                 Loader._loaders[Loader._startIndex].endLoad();
                 Loader._startIndex++;
                 if (Browser.now() - startTimer > Loader.maxTimeOut) {
                     console.warn("loader callback cost a long time:" + (Browser.now() - startTimer) + " url=" + Loader._loaders[Loader._startIndex - 1].url);
                     ILaya.systemTimer.frameOnce(1, null, Loader.checkNext);
                     return;
                 }
             }
             Loader._loaders.length = 0;
             Loader._startIndex = 0;
             Loader._isWorking = false;
         }
         /**
          * 结束加载，处理是否缓存及派发完成事件 <code>Event.COMPLETE</code> 。
          * @param	content 加载后的数据
          */
         endLoad(content = null) {
             content && (this._data = content);
             if (this._cache)
                 Loader.cacheRes(this._url, this._data);
             this.event(Event.PROGRESS, 1);
             this.event(Event.COMPLETE, this.data instanceof Array ? [this.data] : this.data);
         }
         /**加载地址。*/
         get url() {
             return this._url;
         }
         /**加载类型。*/
         get type() {
             return this._type;
         }
         /**是否缓存。*/
         get cache() {
             return this._cache;
         }
         /**返回的数据。*/
         get data() {
             return this._data;
         }
         /**
          * 清理指定资源地址的缓存。
          * @param	url 资源地址。
          */
         static clearRes(url) {
             url = URL.formatURL(url);
             //删除图集
             var arr = Loader.getAtlas(url);
             if (arr) {
                 for (var i = 0, n = arr.length; i < n; i++) {
                     var resUrl = arr[i];
                     var tex = Loader.getRes(resUrl);
                     delete Loader.loadedMap[resUrl];
                     if (tex)
                         tex.destroy();
                 }
                 arr.length = 0;
                 delete Loader.atlasMap[url];
                 delete Loader.loadedMap[url];
             }
             else {
                 var res = Loader.loadedMap[url];
                 if (res) {
                     delete Loader.loadedMap[url];
                     if (res instanceof Texture && res.bitmap)
                         res.destroy();
                 }
             }
         }
         /**
          * 销毁Texture使用的图片资源，保留texture壳，如果下次渲染的时候，发现texture使用的图片资源不存在，则会自动恢复
          * 相比clearRes，clearTextureRes只是清理texture里面使用的图片资源，并不销毁texture，再次使用到的时候会自动恢复图片资源
          * 而clearRes会彻底销毁texture，导致不能再使用；clearTextureRes能确保立即销毁图片资源，并且不用担心销毁错误，clearRes则采用引用计数方式销毁
          * 【注意】如果图片本身在自动合集里面（默认图片小于512*512），内存是不能被销毁的，此图片被大图合集管理器管理
          * @param	url	图集地址或者texture地址，比如 Loader.clearTextureRes("res/atlas/comp.atlas"); Loader.clearTextureRes("hall/bg.jpg");
          */
         static clearTextureRes(url) {
             url = URL.formatURL(url);
             //删除图集
             var arr = Loader.getAtlas(url);
             if (arr && arr.length > 0) {
                 arr.forEach(function (t) {
                     var tex = Loader.getRes(t);
                     if (tex instanceof Texture) {
                         tex.disposeBitmap();
                     }
                 });
             }
             else {
                 var t = Loader.getRes(url);
                 if (t instanceof Texture) {
                     t.disposeBitmap();
                 }
             }
         }
         /**
          * 获取指定资源地址的资源。
          * @param	url 资源地址。
          * @return	返回资源。
          */
         static getRes(url) {
             return Loader.loadedMap[URL.formatURL(url)];
         }
         /**
          * 获取指定资源地址的图集地址列表。
          * @param	url 图集地址。
          * @return	返回地址集合。
          */
         static getAtlas(url) {
             return Loader.atlasMap[URL.formatURL(url)];
         }
         /**
          * 缓存资源。
          * @param	url 资源地址。
          * @param	data 要缓存的内容。
          */
         static cacheRes(url, data) {
             url = URL.formatURL(url);
             if (Loader.loadedMap[url] != null) {
                 console.warn("Resources already exist,is repeated loading:", url);
             }
             else {
                 Loader.loadedMap[url] = data;
             }
         }
         /**
          * 设置资源分组。
          * @param url 资源地址。
          * @param group 分组名。
          */
         static setGroup(url, group) {
             if (!Loader.groupMap[group])
                 Loader.groupMap[group] = [];
             Loader.groupMap[group].push(url);
         }
         /**
          * 根据分组清理资源。
          * @param group 分组名。
          */
         static clearResByGroup(group) {
             if (!Loader.groupMap[group])
                 return;
             var arr = Loader.groupMap[group], i, len = arr.length;
             for (i = 0; i < len; i++) {
                 Loader.clearRes(arr[i]);
             }
             arr.length = 0;
         }
     }
     /**文本类型，加载完成后返回文本。*/
     Loader.TEXT = "text";
     /**JSON 类型，加载完成后返回json数据。*/
     Loader.JSON = "json";
     /**prefab 类型，加载完成后返回Prefab实例。*/
     Loader.PREFAB = "prefab";
     /**XML 类型，加载完成后返回domXML。*/
     Loader.XML = "xml";
     /**二进制类型，加载完成后返回arraybuffer二进制数据。*/
     Loader.BUFFER = "arraybuffer";
     /**纹理类型，加载完成后返回Texture。*/
     Loader.IMAGE = "image";
     /**声音类型，加载完成后返回sound。*/
     Loader.SOUND = "sound";
     /**图集类型，加载完成后返回图集json信息(并创建图集内小图Texture)。*/
     Loader.ATLAS = "atlas";
     /**位图字体类型，加载完成后返回BitmapFont，加载后，会根据文件名自动注册为位图字体。*/
     Loader.FONT = "font";
     /** TTF字体类型，加载完成后返回null。*/
     Loader.TTF = "ttf";
     /** 预加载文件类型，加载完成后自动解析到preLoadedMap。*/
     Loader.PLF = "plf";
     /** 二进制预加载文件类型，加载完成后自动解析到preLoadedMap。*/
     Loader.PLFB = "plfb";
     /**Hierarchy资源。*/
     Loader.HIERARCHY = "HIERARCHY";
     /**Mesh资源。*/
     Loader.MESH = "MESH";
     /**Material资源。*/
     Loader.MATERIAL = "MATERIAL";
     /**Texture2D资源。*/
     Loader.TEXTURE2D = "TEXTURE2D";
     /**TextureCube资源。*/
     Loader.TEXTURECUBE = "TEXTURECUBE";
     /**AnimationClip资源。*/
     Loader.ANIMATIONCLIP = "ANIMATIONCLIP";
     /**Avatar资源。*/
     Loader.AVATAR = "AVATAR";
     /**Terrain资源。*/
     Loader.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA";
     /**Terrain资源。*/
     Loader.TERRAINRES = "TERRAIN";
     /**文件后缀和类型对应表。*/
     Loader.typeMap = { "ttf": "ttf", "png": "image", "jpg": "image", "jpeg": "image", "ktx": "image", "pvr": "image", "txt": "text", "json": "json", "prefab": "prefab", "xml": "xml", "als": "atlas", "atlas": "atlas", "mp3": "sound", "ogg": "sound", "wav": "sound", "part": "json", "fnt": "font", "plf": "plf", "plfb": "plfb", "scene": "json", "ani": "json", "sk": "arraybuffer" };
     /**资源解析函数对应表，用来扩展更多类型的资源加载解析。*/
     Loader.parserMap = {};
     /**每帧加载完成回调使用的最大超时时间，如果超时，则下帧再处理，防止帧卡顿。*/
     Loader.maxTimeOut = 100;
     /**资源分组对应表。*/
     Loader.groupMap = {};
     /**已加载的资源池。*/
     Loader.loadedMap = {};
     /**已加载的图集资源池。*/
     Loader.atlasMap = {};
     /** @private 已加载的数据文件。*/
     Loader.preLoadedMap = {};
     /**@private 引用image对象，防止垃圾回收*/
     Loader._imgCache = {};
     /**@private */
     Loader._loaders = [];
     /**@private */
     Loader._isWorking = false;
     /**@private */
     Loader._startIndex = 0;

     /**
      * @private
      */
     class AtlasInfoManager {
         static enable(infoFile, callback = null) {
             ILaya.loader.load(infoFile, Handler.create(null, AtlasInfoManager._onInfoLoaded, [callback]), null, Loader.JSON);
         }
         /**@private */
         static _onInfoLoaded(callback, data) {
             var tKey;
             var tPrefix;
             var tArr;
             var i, len;
             for (tKey in data) {
                 tArr = data[tKey];
                 tPrefix = tArr[0];
                 tArr = tArr[1];
                 len = tArr.length;
                 for (i = 0; i < len; i++) {
                     AtlasInfoManager._fileLoadDic[tPrefix + tArr[i]] = tKey;
                 }
             }
             callback && callback.run();
         }
         static getFileLoadPath(file) {
             return AtlasInfoManager._fileLoadDic[file] || file;
         }
     }
     AtlasInfoManager._fileLoadDic = {};

     /**
      * 所有资源加载完成时调度。
      * @eventType Event.COMPLETE
      * */
     /*[Event(name = "complete", type = "laya.events.Event")]*/
     /**
      * 任何资源加载出错时调度。
      * @eventType Event.ERROR
      * */
     /*[Event(name = "error", type = "laya.events.Event")]*/
     /**
      * <p> <code>LoaderManager</code> 类用于用于批量加载资源。此类是单例，不要手动实例化此类，请通过Laya.loader访问。</p>
      * <p>全部队列加载完成，会派发 Event.COMPLETE 事件；如果队列中任意一个加载失败，会派发 Event.ERROR 事件，事件回调参数值为加载出错的资源地址。</p>
      * <p> <code>LoaderManager</code> 类提供了以下几种功能：<br/>
      * 多线程：默认5个加载线程，可以通过maxLoader属性修改线程数量；<br/>
      * 多优先级：有0-4共5个优先级，优先级高的优先加载。0最高，4最低；<br/>
      * 重复过滤：自动过滤重复加载（不会有多个相同地址的资源同时加载）以及复用缓存资源，防止重复加载；<br/>
      * 错误重试：资源加载失败后，会重试加载（以最低优先级插入加载队列），retryNum设定加载失败后重试次数，retryDelay设定加载重试的时间间隔。</p>
      * @see laya.net.Loader
      */
     class LoaderManager extends EventDispatcher {
         /**
          * <p>创建一个新的 <code>LoaderManager</code> 实例。</p>
          * <p><b>注意：</b>请使用Laya.loader加载资源，这是一个单例，不要手动实例化此类，否则会导致不可预料的问题。</p>
          */
         constructor() {
             super();
             /** 加载出错后的重试次数，默认重试一次*/
             this.retryNum = 1;
             /** 延迟时间多久再进行错误重试，默认立即重试*/
             this.retryDelay = 0;
             /** 最大下载线程，默认为5个*/
             this.maxLoader = 5;
             /**@private */
             this._loaders = [];
             /**@private */
             this._loaderCount = 0;
             /**@private */
             this._resInfos = [];
             /**@private */
             this._infoPool = [];
             /**@private */
             this._maxPriority = 5;
             /**@private */
             this._failRes = {};
             /**@private */
             this._statInfo = { count: 1, loaded: 1 };
             for (var i = 0; i < this._maxPriority; i++)
                 this._resInfos[i] = [];
         }
         /**@private */
         getProgress() {
             return this._statInfo.loaded / this._statInfo.count;
         }
         /**@private */
         resetProgress() {
             this._statInfo.count = this._statInfo.loaded = 1;
         }
         /**
          * <p>根据clas类型创建一个未初始化资源的对象，随后进行异步加载，资源加载完成后，初始化对象的资源，并通过此对象派发 Event.LOADED 事件，事件回调参数值为此对象本身。套嵌资源的子资源会保留资源路径"?"后的部分。</p>
          * <p>如果url为数组，返回true；否则返回指定的资源类对象，可以通过侦听此对象的 Event.LOADED 事件来判断资源是否已经加载完毕。</p>
          * <p><b>注意：</b>cache参数只能对文件后缀为atlas的资源进行缓存控制，其他资源会忽略缓存，强制重新加载。</p>
          * @param	url			资源地址或者数组。如果url和clas同时指定了资源类型，优先使用url指定的资源类型。参数形如：[{url:xx,clas:xx,priority:xx,params:xx},{url:xx,clas:xx,priority:xx,params:xx}]。
          * @param	complete	加载结束回调。根据url类型不同分为2种情况：1. url为String类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，指定了一组要加载的资源，如果全部加载成功，则回调参数值为true，否则为false。
          * @param	progress	资源加载进度回调，回调参数值为当前资源加载的进度信息(0-1)。
          * @param	type	资源类型。
          * @param	constructParams		资源构造函数参数。
          * @param	propertyParams		资源属性参数。
          * @param	priority	(default = 1)加载的优先级，优先级高的优先加载。有0-4共5个优先级，0最高，4最低。
          * @param	cache		是否缓存加载的资源。
          * @return	如果url为数组，返回true；否则返回指定的资源类对象。
          */
         create(url, complete = null, progress = null, type = null, constructParams = null, propertyParams = null, priority = 1, cache = true) {
             this._create(url, true, complete, progress, type, constructParams, propertyParams, priority, cache);
         }
         /**
          * @private
          */
         _create(url, mainResou, complete = null, progress = null, type = null, constructParams = null, propertyParams = null, priority = 1, cache = true) {
             if (url instanceof Array) {
                 var allScuess = true;
                 var items = url;
                 var itemCount = items.length;
                 var loadedCount = 0;
                 if (progress) {
                     var progress2 = Handler.create(progress.caller, progress.method, progress.args, false);
                 }
                 for (var i = 0; i < itemCount; i++) {
                     var item = items[i];
                     if (typeof (item) == 'string')
                         item = items[i] = { url: item };
                     item.progress = 0;
                 }
                 for (i = 0; i < itemCount; i++) {
                     item = items[i];
                     var progressHandler = progress ? Handler.create(null, function (item, value) {
                         item.progress = value;
                         var num = 0;
                         for (var j = 0; j < itemCount; j++) {
                             var item1 = items[j];
                             num += item1.progress;
                         }
                         var v = num / itemCount;
                         progress2.runWith(v);
                     }, [item], false) : null;
                     var completeHandler = (progress || complete) ? Handler.create(null, function (item, content = null) {
                         loadedCount++;
                         item.progress = 1;
                         content || (allScuess = false); //资源加载失败
                         if (loadedCount === itemCount && complete) {
                             complete.runWith(allScuess);
                         }
                     }, [item]) : null;
                     this._createOne(item.url, mainResou, completeHandler, progressHandler, item.type || type, item.constructParams || constructParams, item.propertyParams || propertyParams, item.priority || priority, cache);
                 }
             }
             else {
                 this._createOne(url, mainResou, complete, progress, type, constructParams, propertyParams, priority, cache);
             }
         }
         /**
          * @private
          */
         _createOne(url, mainResou, complete = null, progress = null, type = null, constructParams = null, propertyParams = null, priority = 1, cache = true) {
             var item = this.getRes(url);
             if (!item) {
                 var extension = Utils.getFileExtension(url);
                 (type) || (type = LoaderManager.createMap[extension] ? LoaderManager.createMap[extension][0] : null);
                 if (!type) {
                     this.load(url, complete, progress, type, priority, cache);
                     return;
                 }
                 var parserMap = Loader.parserMap;
                 if (!parserMap[type]) { //not custom parse type
                     this.load(url, complete, progress, type, priority, cache);
                     return;
                 }
                 this._createLoad(url, Handler.create(null, function (createRes) {
                     if (createRes) {
                         if (!mainResou && createRes instanceof Resource)
                             createRes._addReference();
                         createRes._setCreateURL(url);
                     }
                     complete && complete.runWith(createRes);
                     ILaya.loader.event(url);
                 }), progress, type, constructParams, propertyParams, priority, cache, true);
             }
             else {
                 if (!mainResou && item instanceof Resource)
                     item._addReference();
                 progress && progress.runWith(1);
                 complete && complete.runWith(item);
             }
         }
         /**
          * <p>加载资源。资源加载错误时，本对象会派发 Event.ERROR 事件，事件回调参数值为加载出错的资源地址。</p>
          * <p>因为返回值为 LoaderManager 对象本身，所以可以使用如下语法：loaderManager.load(...).load(...);</p>
          * @param	url			要加载的单个资源地址或资源信息数组。比如：简单数组：["a.png","b.png"]；复杂数组[{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]。
          * @param	complete	加载结束回调。根据url类型不同分为2种情况：1. url为String类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，指定了一组要加载的资源，如果全部加载成功，则回调参数值为true，否则为false。
          * @param	progress	加载进度回调。回调参数值为当前资源的加载进度信息(0-1)。
          * @param	type		资源类型。比如：Loader.IMAGE。
          * @param	priority	(default = 1)加载的优先级，优先级高的优先加载。有0-4共5个优先级，0最高，4最低。
          * @param	cache		是否缓存加载结果。
          * @param	group		分组，方便对资源进行管理。
          * @param	ignoreCache	是否忽略缓存，强制重新加载。
          * @param	useWorkerLoader(default = false)是否使用worker加载（只针对IMAGE类型和ATLAS类型，并且浏览器支持的情况下生效）
          * @return 此 LoaderManager 对象本身。
          */
         load(url, complete = null, progress = null, type = null, priority = 1, cache = true, group = null, ignoreCache = false, useWorkerLoader = ILaya.WorkerLoader.enable) {
             if (url instanceof Array)
                 return this._loadAssets(url, complete, progress, type, priority, cache, group);
             var content = Loader.getRes(url);
             if (!ignoreCache && content != null) {
                 //增加延迟回掉，防止快速回掉导致执行顺序错误
                 ILaya.systemTimer.frameOnce(1, this, function () {
                     progress && progress.runWith(1);
                     complete && complete.runWith(content instanceof Array ? [content] : content);
                     //判断是否全部加载，如果是则抛出complete事件
                     this._loaderCount || this.event(Event.COMPLETE);
                 });
             }
             else {
                 var original;
                 original = url;
                 url = AtlasInfoManager.getFileLoadPath(url);
                 if (url != original && type !== "nativeimage") {
                     type = Loader.ATLAS;
                 }
                 else {
                     original = null;
                 }
                 var info = LoaderManager._resMap[url];
                 if (!info) {
                     info = this._infoPool.length ? this._infoPool.pop() : new ResInfo();
                     info.url = url;
                     info.type = type;
                     info.cache = cache;
                     info.group = group;
                     info.ignoreCache = ignoreCache;
                     info.useWorkerLoader = useWorkerLoader;
                     info.originalUrl = original;
                     complete && info.on(Event.COMPLETE, complete.caller, complete.method, complete.args);
                     progress && info.on(Event.PROGRESS, progress.caller, progress.method, progress.args);
                     LoaderManager._resMap[url] = info;
                     priority = priority < this._maxPriority ? priority : this._maxPriority - 1;
                     this._resInfos[priority].push(info);
                     this._statInfo.count++;
                     this.event(Event.PROGRESS, this.getProgress());
                     this._next();
                 }
                 else {
                     if (complete) {
                         if (original) {
                             complete && info._createListener(Event.COMPLETE, this, this._resInfoLoaded, [original, complete], false, false);
                         }
                         else {
                             complete && info._createListener(Event.COMPLETE, complete.caller, complete.method, complete.args, false, false);
                         }
                     }
                     progress && info._createListener(Event.PROGRESS, progress.caller, progress.method, progress.args, false, false);
                 }
             }
             return this;
         }
         _resInfoLoaded(original, complete) {
             complete.runWith(Loader.getRes(original));
         }
         /**
          * @private
          */
         _createLoad(url, complete = null, progress = null, type = null, constructParams = null, propertyParams = null, priority = 1, cache = true, ignoreCache = false) {
             if (url instanceof Array)
                 return this._loadAssets(url, complete, progress, type, priority, cache);
             var content = Loader.getRes(url);
             if (content != null) {
                 //增加延迟回掉
                 ILaya.systemTimer.frameOnce(1, this, function () {
                     progress && progress.runWith(1);
                     complete && complete.runWith(content);
                     //判断是否全部加载，如果是则抛出complete事件
                     this._loaderCount || this.event(Event.COMPLETE);
                 });
             }
             else {
                 var info = LoaderManager._resMap[url];
                 if (!info) {
                     info = this._infoPool.length ? this._infoPool.pop() : new ResInfo();
                     info.url = url;
                     info.type = type;
                     info.cache = false;
                     info.ignoreCache = ignoreCache;
                     info.originalUrl = null;
                     info.createCache = cache;
                     info.createConstructParams = constructParams;
                     info.createPropertyParams = propertyParams;
                     complete && info.on(Event.COMPLETE, complete.caller, complete.method, complete.args);
                     progress && info.on(Event.PROGRESS, progress.caller, progress.method, progress.args);
                     LoaderManager._resMap[url] = info;
                     priority = priority < this._maxPriority ? priority : this._maxPriority - 1;
                     this._resInfos[priority].push(info);
                     this._statInfo.count++;
                     this.event(Event.PROGRESS, this.getProgress());
                     this._next();
                 }
                 else {
                     complete && info._createListener(Event.COMPLETE, complete.caller, complete.method, complete.args, false, false);
                     progress && info._createListener(Event.PROGRESS, progress.caller, progress.method, progress.args, false, false);
                 }
             }
             return this;
         }
         _next() {
             if (this._loaderCount >= this.maxLoader)
                 return;
             for (var i = 0; i < this._maxPriority; i++) {
                 var infos = this._resInfos[i];
                 while (infos.length > 0) {
                     var info = infos.shift();
                     if (info)
                         return this._doLoad(info);
                 }
             }
             this._loaderCount || this.event(Event.COMPLETE);
         }
         _doLoad(resInfo) {
             this._loaderCount++;
             var loader = this._loaders.length ? this._loaders.pop() : new Loader();
             loader.on(Event.COMPLETE, null, onLoaded);
             loader.on(Event.PROGRESS, null, function (num) {
                 resInfo.event(Event.PROGRESS, num);
             });
             loader.on(Event.ERROR, null, function (msg) {
                 onLoaded(null);
             });
             var _me = this;
             function onLoaded(data = null) {
                 loader.offAll();
                 loader._data = null;
                 loader._customParse = false;
                 _me._loaders.push(loader);
                 _me._endLoad(resInfo, data instanceof Array ? [data] : data);
                 _me._loaderCount--;
                 _me._next();
             }
             loader._constructParams = resInfo.createConstructParams;
             loader._propertyParams = resInfo.createPropertyParams;
             loader._createCache = resInfo.createCache;
             loader.load(resInfo.url, resInfo.type, resInfo.cache, resInfo.group, resInfo.ignoreCache, resInfo.useWorkerLoader);
         }
         _endLoad(resInfo, content) {
             //如果加载后为空，放入队列末尾重试
             var url = resInfo.url;
             if (content == null) {
                 var errorCount = this._failRes[url] || 0;
                 if (errorCount < this.retryNum) {
                     console.warn("[warn]Retry to load:", url);
                     this._failRes[url] = errorCount + 1;
                     ILaya.systemTimer.once(this.retryDelay, this, this._addReTry, [resInfo], false);
                     return;
                 }
                 else {
                     Loader.clearRes(url); //使用create加载失败需要清除资源
                     console.warn("[error]Failed to load:", url);
                     this.event(Event.ERROR, url);
                 }
             }
             if (this._failRes[url])
                 this._failRes[url] = 0;
             delete LoaderManager._resMap[url];
             if (resInfo.originalUrl) {
                 content = Loader.getRes(resInfo.originalUrl);
             }
             resInfo.event(Event.COMPLETE, content);
             resInfo.offAll();
             this._infoPool.push(resInfo);
             this._statInfo.loaded++;
             this.event(Event.PROGRESS, this.getProgress());
         }
         _addReTry(resInfo) {
             this._resInfos[this._maxPriority - 1].push(resInfo);
             this._next();
         }
         /**
          * 清理指定资源地址缓存。
          * @param	url 资源地址。
          */
         clearRes(url) {
             Loader.clearRes(url);
         }
         /**
          * 销毁Texture使用的图片资源，保留texture壳，如果下次渲染的时候，发现texture使用的图片资源不存在，则会自动恢复
          * 相比clearRes，clearTextureRes只是清理texture里面使用的图片资源，并不销毁texture，再次使用到的时候会自动恢复图片资源
          * 而clearRes会彻底销毁texture，导致不能再使用；clearTextureRes能确保立即销毁图片资源，并且不用担心销毁错误，clearRes则采用引用计数方式销毁
          * 【注意】如果图片本身在自动合集里面（默认图片小于512*512），内存是不能被销毁的，此图片被大图合集管理器管理
          * @param	url	图集地址或者texture地址，比如 Loader.clearTextureRes("res/atlas/comp.atlas"); Loader.clearTextureRes("hall/bg.jpg");
          */
         clearTextureRes(url) {
             Loader.clearTextureRes(url);
         }
         /**
          * 获取指定资源地址的资源。
          * @param	url 资源地址。
          * @return	返回资源。
          */
         getRes(url) {
             return Loader.getRes(url);
         }
         /**
          * 缓存资源。
          * @param	url 资源地址。
          * @param	data 要缓存的内容。
          */
         cacheRes(url, data) {
             Loader.cacheRes(url, data);
         }
         /**
          * 设置资源分组。
          * @param url 资源地址。
          * @param group 分组名
          */
         setGroup(url, group) {
             Loader.setGroup(url, group);
         }
         /**
          * 根据分组清理资源。
          * @param group 分组名
          */
         clearResByGroup(group) {
             Loader.clearResByGroup(group);
         }
         /**
          * @private
          * 缓存资源。
          * @param	url 资源地址。
          * @param	data 要缓存的内容。
          */
         static cacheRes(url, data) {
             Loader.cacheRes(url, data);
         }
         /** 清理当前未完成的加载，所有未加载的内容全部停止加载。*/
         clearUnLoaded() {
             //回收Handler
             for (var i = 0; i < this._maxPriority; i++) {
                 var infos = this._resInfos[i];
                 for (var j = infos.length - 1; j > -1; j--) {
                     var info = infos[j];
                     if (info) {
                         info.offAll();
                         this._infoPool.push(info);
                     }
                 }
                 infos.length = 0;
             }
             this._loaderCount = 0;
             LoaderManager._resMap = {};
         }
         /**
          * 根据地址集合清理掉未加载的内容
          * @param	urls 资源地址集合
          */
         cancelLoadByUrls(urls) {
             if (!urls)
                 return;
             for (var i = 0, n = urls.length; i < n; i++) {
                 this.cancelLoadByUrl(urls[i]);
             }
         }
         /**
          * 根据地址清理掉未加载的内容
          * @param	url 资源地址
          */
         cancelLoadByUrl(url) {
             for (var i = 0; i < this._maxPriority; i++) {
                 var infos = this._resInfos[i];
                 for (var j = infos.length - 1; j > -1; j--) {
                     var info = infos[j];
                     if (info && info.url === url) {
                         infos[j] = null;
                         info.offAll();
                         this._infoPool.push(info);
                     }
                 }
             }
             if (LoaderManager._resMap[url])
                 delete LoaderManager._resMap[url];
         }
         /**
          * @private
          * 加载数组里面的资源。
          * @param arr 简单：["a.png","b.png"]，复杂[{url:"a.png",type:Loader.IMAGE,size:100,priority:1,useWorkerLoader:true},{url:"b.json",type:Loader.JSON,size:50,priority:1}]*/
         _loadAssets(arr, complete = null, progress = null, type = null, priority = 1, cache = true, group = null) {
             var itemCount = arr.length;
             var loadedCount = 0;
             var totalSize = 0;
             var items = [];
             var success = true;
             for (var i = 0; i < itemCount; i++) {
                 var item = arr[i];
                 if (typeof (item) == 'string')
                     item = { url: item, type: type, size: 1, priority: priority };
                 if (!item.size)
                     item.size = 1;
                 item.progress = 0;
                 totalSize += item.size;
                 items.push(item);
                 var progressHandler = progress ? Handler.create(null, loadProgress, [item], false) : null;
                 var completeHandler = (complete || progress) ? Handler.create(null, loadComplete, [item]) : null;
                 this.load(item.url, completeHandler, progressHandler, item.type, item.priority || 1, cache, item.group || group, false, item.useWorkerLoader);
             }
             function loadComplete(item, content = null) {
                 loadedCount++;
                 item.progress = 1;
                 if (!content)
                     success = false;
                 if (loadedCount === itemCount && complete) {
                     complete.runWith(success);
                 }
             }
             function loadProgress(item, value) {
                 if (progress != null) {
                     item.progress = value;
                     var num = 0;
                     for (var j = 0; j < items.length; j++) {
                         var item1 = items[j];
                         num += item1.size * item1.progress;
                     }
                     var v = num / totalSize;
                     progress.runWith(v);
                 }
             }
             return this;
         }
         /**
          * 解码Texture或者图集
          * @param	urls texture地址或者图集地址集合
          */
         //TODO:TESTs
         decodeBitmaps(urls) {
             var i, len = urls.length;
             var ctx;
             //ctx = Browser.context;
             ctx = ILaya.Render._context;
             //经测试需要画到主画布上才能只解码一次
             //当前用法下webgl模式会报错
             for (i = 0; i < len; i++) {
                 var atlas;
                 atlas = Loader.getAtlas(urls[i]);
                 if (atlas) {
                     this._decodeTexture(atlas[0], ctx);
                 }
                 else {
                     var tex;
                     tex = this.getRes(urls[i]);
                     if (tex && tex instanceof Texture) {
                         this._decodeTexture(tex, ctx);
                     }
                 }
             }
         }
         _decodeTexture(tex, ctx) {
             var bitmap = tex.bitmap;
             if (!tex || !bitmap)
                 return;
             var tImg = bitmap.source || bitmap.image;
             if (!tImg)
                 return;
             if (tImg instanceof HTMLImageElement) {
                 ctx.drawImage(tImg, 0, 0, 1, 1);
                 var info = ctx.getImageData(0, 0, 1, 1);
             }
         }
     }
     /**@private */
     LoaderManager._resMap = {};
     /**@private */
     LoaderManager.createMap = { atlas: [null, Loader.ATLAS] };
     class ResInfo extends EventDispatcher {
     }

     /**
          * <p> <code>LocalStorage</code> 类用于没有时间限制的数据存储。</p>
          */
     class LocalStorage {
         static __init__() {
             if (!LocalStorage._baseClass) {
                 LocalStorage._baseClass = Storage;
                 Storage.init();
             }
             LocalStorage.items = LocalStorage._baseClass.items;
             LocalStorage.support = LocalStorage._baseClass.support;
             return LocalStorage.support;
         }
         /**
          * 存储指定键名和键值，字符串类型。
          * @param key 键名。
          * @param value 键值。
          */
         static setItem(key, value) {
             LocalStorage._baseClass.setItem(key, value);
         }
         /**
          * 获取指定键名的值。
          * @param key 键名。
          * @return 字符串型值。
          */
         static getItem(key) {
             return LocalStorage._baseClass.getItem(key);
         }
         /**
          * 存储指定键名及其对应的 <code>Object</code> 类型值。
          * @param key 键名。
          * @param value 键值。是 <code>Object</code> 类型，此致会被转化为 JSON 字符串存储。
          */
         static setJSON(key, value) {
             LocalStorage._baseClass.setJSON(key, value);
         }
         /**
          * 获取指定键名对应的 <code>Object</code> 类型值。
          * @param key 键名。
          * @return <code>Object</code> 类型值
          */
         static getJSON(key) {
             return LocalStorage._baseClass.getJSON(key);
         }
         /**
          * 删除指定键名的信息。
          * @param key 键名。
          */
         static removeItem(key) {
             LocalStorage._baseClass.removeItem(key);
         }
         /**
          * 清除本地存储信息。
          */
         static clear() {
             LocalStorage._baseClass.clear();
         }
     }
     /**
      * 表示是否支持  <code>LocalStorage</code>。
      */
     LocalStorage.support = false;
     class Storage {
         static init() {
             try {
                 Storage.support = true;
                 Storage.items = window.localStorage;
                 Storage.setItem('laya', '1');
                 Storage.removeItem('laya');
             }
             catch (e) {
                 Storage.support = false;
             }
             if (!Storage.support)
                 console.log('LocalStorage is not supprot or browser is private mode.');
         }
         /**
          * 存储指定键名和键值，字符串类型。
          * @param key 键名。
          * @param value 键值。
          */
         static setItem(key, value) {
             try {
                 Storage.support && Storage.items.setItem(key, value);
             }
             catch (e) {
                 console.warn("set localStorage failed", e);
             }
         }
         /**
          * 获取指定键名的值。
          * @param key 键名。
          * @return 字符串型值。
          */
         static getItem(key) {
             return Storage.support ? Storage.items.getItem(key) : null;
         }
         /**
          * 存储指定键名和它的 <code>Object</code> 类型值。
          * @param key 键名。
          * @param value 键值。是 <code>Object</code> 类型，此致会被转化为 JSON 字符串存储。
          */
         static setJSON(key, value) {
             try {
                 Storage.support && Storage.items.setItem(key, JSON.stringify(value));
             }
             catch (e) {
                 console.warn("set localStorage failed", e);
             }
         }
         /**
          * 获取指定键名的 <code>Object</code> 类型值。
          * @param key 键名。
          * @return <code>Object</code> 类型值
          */
         static getJSON(key) {
             return JSON.parse(Storage.support ? Storage.items.getItem(key) : null);
         }
         /**
          * 删除指定键名的信息。
          * @param key 键名。
          */
         static removeItem(key) {
             Storage.support && Storage.items.removeItem(key);
         }
         /**
          * 清除本地存储信息。
          */
         static clear() {
             Storage.support && Storage.items.clear();
         }
     }
     /**
      * 表示是否支持  <code>LocalStorage</code>。
      */
     Storage.support = false;

     /**
      * @private
      */
     class TTFLoader {
         //TODO:coverage
         load(fontPath) {
             this._url = fontPath;
             var tArr = fontPath.split(".ttf")[0].split("/");
             this.fontName = tArr[tArr.length - 1];
             if (ILaya.Render.isConchApp) {
                 this._loadConch();
             }
             else if (window.FontFace) {
                 this._loadWithFontFace();
             }
             else {
                 this._loadWithCSS();
             }
         }
         //TODO:coverage
         _loadConch() {
             this._http = new HttpRequest();
             this._http.on(Event.ERROR, this, this._onErr);
             this._http.on(Event.COMPLETE, this, this._onHttpLoaded);
             this._http.send(this._url, null, "get", Loader.BUFFER);
         }
         //TODO:coverage
         _onHttpLoaded(data = null) {
             window["conchTextCanvas"].setFontFaceFromBuffer(this.fontName, data);
             this._clearHttp();
             this._complete();
         }
         //TODO:coverage
         _clearHttp() {
             if (this._http) {
                 this._http.off(Event.ERROR, this, this._onErr);
                 this._http.off(Event.COMPLETE, this, this._onHttpLoaded);
                 this._http = null;
             }
         }
         //TODO:coverage
         _onErr() {
             this._clearHttp();
             if (this.err) {
                 this.err.runWith("fail:" + this._url);
                 this.err = null;
             }
         }
         //TODO:coverage
         _complete() {
             ILaya.systemTimer.clear(this, this._complete);
             ILaya.systemTimer.clear(this, this._checkComplete);
             if (this._div && this._div.parentNode) {
                 this._div.parentNode.removeChild(this._div);
                 this._div = null;
             }
             if (this.complete) {
                 this.complete.runWith(this);
                 this.complete = null;
             }
         }
         //TODO:coverage
         _checkComplete() {
             if (ILaya.Browser.measureText(TTFLoader._testString, this._fontTxt).width != this._txtWidth) {
                 this._complete();
             }
         }
         //TODO:coverage
         _loadWithFontFace() {
             var fontFace = new window.FontFace(this.fontName, "url('" + this._url + "')");
             document.fonts.add(fontFace);
             var self = this;
             fontFace.loaded.then((function () {
                 self._complete();
             }));
             //_createDiv();
             fontFace.load();
         }
         //TODO:coverage
         _createDiv() {
             this._div = document.createElement("div");
             this._div.innerHTML = "laya";
             var _style = this._div.style;
             _style.fontFamily = this.fontName;
             _style.position = "absolute";
             _style.left = "-100px";
             _style.top = "-100px";
             document.body.appendChild(this._div);
         }
         //TODO:coverage
         _loadWithCSS() {
             var fontStyle = document.createElement("style");
             fontStyle.type = "text/css";
             document.body.appendChild(fontStyle);
             fontStyle.textContent = "@font-face { font-family:'" + this.fontName + "'; src:url('" + this._url + "');}";
             this._fontTxt = "40px " + this.fontName;
             this._txtWidth = ILaya.Browser.measureText(TTFLoader._testString, this._fontTxt).width;
             var self = this;
             fontStyle.onload = function () {
                 ILaya.systemTimer.once(10000, self, this._complete);
             };
             ILaya.systemTimer.loop(20, this, this._checkComplete);
             this._createDiv();
         }
     }
     TTFLoader._testString = "LayaTTFFont";

     /**
      * @private
      * 场景资源加载器
      */
     class SceneLoader extends EventDispatcher {
         constructor() {
             super();
             this._completeHandler = new Handler(this, this.onOneLoadComplete);
             this.reset();
         }
         reset() {
             this._toLoadList = [];
             this._isLoading = false;
             this.totalCount = 0;
         }
         get leftCount() {
             if (this._isLoading)
                 return this._toLoadList.length + 1;
             return this._toLoadList.length;
         }
         get loadedCount() {
             return this.totalCount - this.leftCount;
         }
         load(url, is3D = false, ifCheck = true) {
             if (url instanceof Array) {
                 var i, len;
                 len = url.length;
                 for (i = 0; i < len; i++) {
                     this._addToLoadList(url[i], is3D);
                 }
             }
             else {
                 this._addToLoadList(url, is3D);
             }
             if (ifCheck)
                 this._checkNext();
         }
         _addToLoadList(url, is3D = false) {
             if (this._toLoadList.indexOf(url) >= 0)
                 return;
             if (Loader.getRes(url))
                 return;
             if (is3D) {
                 this._toLoadList.push({ url: url });
             }
             else
                 this._toLoadList.push(url);
             this.totalCount++;
         }
         _checkNext() {
             if (!this._isLoading) {
                 if (this._toLoadList.length == 0) {
                     this.event(Event.COMPLETE);
                     return;
                 }
                 var tItem;
                 tItem = this._toLoadList.pop();
                 if (typeof (tItem) == 'string') {
                     this.loadOne(tItem);
                 }
                 else {
                     this.loadOne(tItem.url, true);
                 }
             }
         }
         loadOne(url, is3D = false) {
             this._curUrl = url;
             var type = Utils.getFileExtension(this._curUrl);
             if (is3D) {
                 ILaya.loader.create(url, this._completeHandler);
             }
             else if (SceneLoader.LoadableExtensions[type]) {
                 ILaya.loader.load(url, this._completeHandler, null, SceneLoader.LoadableExtensions[type]);
             }
             else if (url != AtlasInfoManager.getFileLoadPath(url) || SceneLoader.No3dLoadTypes[type] || !LoaderManager.createMap[type]) {
                 ILaya.loader.load(url, this._completeHandler);
             }
             else {
                 ILaya.loader.create(url, this._completeHandler);
             }
         }
         onOneLoadComplete() {
             this._isLoading = false;
             if (!Loader.getRes(this._curUrl)) {
                 console.log("Fail to load:", this._curUrl);
             }
             var type = Utils.getFileExtension(this._curUrl);
             if (SceneLoader.LoadableExtensions[type]) {
                 var dataO;
                 dataO = Loader.getRes(this._curUrl);
                 if (dataO && (dataO instanceof Prefab)) {
                     dataO = dataO.json;
                 }
                 if (dataO) {
                     if (dataO.loadList) {
                         this.load(dataO.loadList, false, false);
                     }
                     if (dataO.loadList3D) {
                         this.load(dataO.loadList3D, true, false);
                     }
                 }
             }
             if (type == "sk") {
                 this.load(this._curUrl.replace(".sk", ".png"), false, false);
             }
             this.event(Event.PROGRESS, this.getProgress());
             this._checkNext();
         }
         getProgress() {
             return this.loadedCount / this.totalCount;
         }
     }
     SceneLoader.LoadableExtensions = { "scene": Loader.JSON, "scene3d": Loader.JSON, "ani": Loader.JSON, "ui": Loader.JSON, "prefab": Loader.PREFAB };
     SceneLoader.No3dLoadTypes = { "png": true, "jpg": true, "txt": true };

     /**
      * <code>Component</code> 类用于创建组件的基类。
      */
     class Component {
         /**
          * 创建一个新的 <code>Component</code> 实例。
          */
         constructor() {
             this._id = Utils.getGID();
             this._resetComp();
         }
         /**
          * 获取唯一标识ID。
          */
         get id() {
             return this._id;
         }
         /**
          * 获取是否启用组件。
          */
         get enabled() {
             return this._enabled;
         }
         set enabled(value) {
             this._enabled = value;
             if (this.owner) {
                 if (value)
                     this.owner.activeInHierarchy && this._onEnable();
                 else
                     this.owner.activeInHierarchy && this._onDisable();
             }
         }
         /**
          * 获取是否为单实例组件。
          */
         get isSingleton() {
             return true;
         }
         /**
          * 获取是否已经销毁 。
          */
         get destroyed() {
             //[实现IListPool接口]
             return this._destroyed;
         }
         /**
          * @private
          */
         _isScript() {
             return false;
         }
         /**
          * @private
          */
         _resetComp() {
             this._indexInList = -1;
             this._enabled = true;
             this._awaked = false;
             this.owner = null;
         }
         /**
          * [实现IListPool接口]
          * @private
          */
         _getIndexInList() {
             return this._indexInList;
         }
         /**
          * [实现IListPool接口]
          * @private
          */
         _setIndexInList(index) {
             this._indexInList = index;
         }
         /**
          * 被添加到节点后调用，可根据需要重写此方法
          * @private
          */
         _onAdded() {
             //override it.
         }
         /**
          * 被激活后调用，可根据需要重写此方法
          * @private
          */
         _onAwake() {
             //override it.
         }
         /**
          * 被激活后调用，可根据需要重写此方法
          * @private
          */
         _onEnable() {
             //override it.
         }
         /**
          * 被禁用时调用，可根据需要重写此方法
          * @private
          */
         _onDisable() {
             //override it.
         }
         /**
          * 被销毁时调用，可根据需要重写此方法
          * @private
          */
         _onDestroy() {
             //override it.
         }
         /**
          * 重置组件参数到默认值，如果实现了这个函数，则组件会被重置并且自动回收到对象池，方便下次复用
          * 如果没有重置，则不进行回收复用
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onReset() {
             //override it.
         }
         /**
          * @private
          */
         _parse(data) {
             //override it.
         }
         /**
          * @private
          */
         _cloneTo(dest) {
             //override it.
         }
         /**
          * @private
          */
         _setActive(value) {
             if (value) {
                 if (!this._awaked) {
                     this._awaked = true;
                     this._onAwake();
                 }
                 this._enabled && this._onEnable();
             }
             else {
                 this._enabled && this._onDisable();
             }
         }
         /**
          * 销毁组件
          */
         destroy() {
             if (this.owner)
                 this.owner._destroyComponent(this);
         }
         /**
          * @private
          */
         _destroy() {
             if (this.owner.activeInHierarchy && this._enabled) {
                 this._setActive(false);
                 (this._isScript()) && (this.onDisable());
             }
             this._onDestroy();
             this._destroyed = true;
             if (this.onReset !== Component.prototype.onReset) {
                 this.onReset();
                 this._resetComp();
                 Pool.recoverByClass(this);
             }
             else {
                 this._resetComp();
             }
         }
     }

     /**
      * 动画播放完毕后调度。
      * @eventType Event.COMPLETE
      */
     /*[Event(name = "complete", type = "laya.events.Event")]*/
     /**
      * 播放到某标签后调度。
      * @eventType Event.LABEL
      */
     /*[Event(name = "label", type = "laya.events.Event")]*/
     /**
      * <p>动画基类，提供了基础的动画播放控制方法和帧标签事件相关功能。</p>
      * <p>可以继承此类，但不要直接实例化此类，因为有些方法需要由子类实现。</p>
      */
     class AnimationBase extends Sprite {
         /**
          * 可以继承此类，但不要直接实例化此类，因为有些方法需要由子类实现。
          */
         constructor() {
             super();
             /**播放顺序类型：AnimationBase.WRAP_POSITIVE为正序播放(默认值)，AnimationBase.WRAP_REVERSE为倒序播放，AnimationBase.WRAP_PINGPONG为pingpong播放(当按指定顺序播放完结尾后，如果继续播发，则会改变播放顺序)。*/
             this.wrapMode = 0;
             /**@private 播放间隔(单位：毫秒)。*/
             this._interval = Config.animationInterval;
             /**是否是逆序播放*/
             this._isReverse = false;
             /**@private */
             this._frameRateChanged = false;
             this._setBitUp(Const.DISPLAY);
         }
         /**
          * <p>开始播放动画。play(...)方法被设计为在创建实例后的任何时候都可以被调用，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否正在播放中，如果是，则进行播放。</p>
          * <p>配合wrapMode属性，可设置动画播放顺序类型。</p>
          * @param	start	（可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
          * @param	loop	（可选）是否循环播放。
          * @param	name	（可选）动画名称。
          */
         play(start = 0, loop = true, name = "") {
             this._isPlaying = true;
             this._actionName = name;
             this.index = (typeof (start) == 'string') ? this._getFrameByLabel(start) : start;
             this.loop = loop;
             this._isReverse = this.wrapMode === AnimationBase.WRAP_REVERSE;
             if (this.index == 0 && this._isReverse) {
                 this.index = this.count - 1;
             }
             if (this.interval > 0)
                 this.timerLoop(this.interval, this, this._frameLoop, null, true, true);
         }
         /**
          * <p>动画播放的帧间隔时间(单位：毫秒)。默认值依赖于Config.animationInterval=50，通过Config.animationInterval可以修改默认帧间隔时间。</p>
          * <p>要想为某动画设置独立的帧间隔时间，可以使用set interval，注意：如果动画正在播放，设置后会重置帧循环定时器的起始时间为当前时间，也就是说，如果频繁设置interval，会导致动画帧更新的时间间隔会比预想的要慢，甚至不更新。</p>
          */
         get interval() {
             return this._interval;
         }
         set interval(value) {
             if (this._interval != value) {
                 this._frameRateChanged = true;
                 this._interval = value;
                 if (this._isPlaying && value > 0) {
                     this.timerLoop(value, this, this._frameLoop, null, true, true);
                 }
             }
         }
         /**@private */
         _getFrameByLabel(label) {
             for (var i = 0; i < this._count; i++) {
                 var item = this._labels[i];
                 if (item && item.indexOf(label) > -1)
                     return i;
             }
             return 0;
         }
         /**@private */
         _frameLoop() {
             if (this._isReverse) {
                 this._index--;
                 if (this._index < 0) {
                     if (this.loop) {
                         if (this.wrapMode == AnimationBase.WRAP_PINGPONG) {
                             this._index = this._count > 0 ? 1 : 0;
                             this._isReverse = false;
                         }
                         else {
                             this._index = this._count - 1;
                         }
                         this.event(Event.COMPLETE);
                     }
                     else {
                         this._index = 0;
                         this.stop();
                         this.event(Event.COMPLETE);
                         return;
                     }
                 }
             }
             else {
                 this._index++;
                 if (this._index >= this._count) {
                     if (this.loop) {
                         if (this.wrapMode == AnimationBase.WRAP_PINGPONG) {
                             this._index = this._count - 2 >= 0 ? this._count - 2 : 0;
                             this._isReverse = true;
                         }
                         else {
                             this._index = 0;
                         }
                         this.event(Event.COMPLETE);
                     }
                     else {
                         this._index--;
                         this.stop();
                         this.event(Event.COMPLETE);
                         return;
                     }
                 }
             }
             this.index = this._index;
         }
         /**@private */
         _setControlNode(node) {
             if (this._controlNode) {
                 this._controlNode.off(Event.DISPLAY, this, this._resumePlay);
                 this._controlNode.off(Event.UNDISPLAY, this, this._resumePlay);
             }
             this._controlNode = node;
             if (node && node != this) {
                 node.on(Event.DISPLAY, this, this._resumePlay);
                 node.on(Event.UNDISPLAY, this, this._resumePlay);
             }
         }
         /**@private */
         /*override*/ _setDisplay(value) {
             super._setDisplay(value);
             this._resumePlay();
         }
         /**@private */
         _resumePlay() {
             if (this._isPlaying) {
                 if (this._controlNode.displayedInStage)
                     this.play(this._index, this.loop, this._actionName);
                 else
                     this.clearTimer(this, this._frameLoop);
             }
         }
         /**
          * 停止动画播放。
          */
         stop() {
             this._isPlaying = false;
             this.clearTimer(this, this._frameLoop);
         }
         /**
          * 是否正在播放中。
          */
         get isPlaying() {
             return this._isPlaying;
         }
         /**
          * 增加一个帧标签到指定索引的帧上。当动画播放到此索引的帧时会派发Event.LABEL事件，派发事件是在完成当前帧画面更新之后。
          * @param	label	帧标签名称
          * @param	index	帧索引
          */
         addLabel(label, index) {
             if (!this._labels)
                 this._labels = {};
             if (!this._labels[index])
                 this._labels[index] = [];
             this._labels[index].push(label);
         }
         /**
          * 删除指定的帧标签。
          * @param	label 帧标签名称。注意：如果为空，则删除所有帧标签！
          */
         removeLabel(label) {
             if (!label)
                 this._labels = null;
             else if (this._labels) {
                 for (var name in this._labels) {
                     this._removeLabelFromList(this._labels[name], label);
                 }
             }
         }
         /**@private */
         _removeLabelFromList(list, label) {
             if (!list)
                 return;
             for (var i = list.length - 1; i >= 0; i--) {
                 if (list[i] == label) {
                     list.splice(i, 1);
                 }
             }
         }
         /**
          * 将动画切换到指定帧并停在那里。
          * @param	position 帧索引或帧标签
          */
         gotoAndStop(position) {
             this.index = (typeof (position) == 'string') ? this._getFrameByLabel(position) : position;
             this.stop();
         }
         /**
          * 动画当前帧的索引。
          */
         get index() {
             return this._index;
         }
         set index(value) {
             this._index = value;
             this._displayToIndex(value);
             if (this._labels && this._labels[value]) {
                 var tArr = this._labels[value];
                 for (var i = 0, len = tArr.length; i < len; i++) {
                     this.event(Event.LABEL, tArr[i]);
                 }
             }
         }
         /**
          * @private
          * 显示到某帧
          * @param value 帧索引
          */
         _displayToIndex(value) {
         }
         /**
          * 当前动画中帧的总数。
          */
         get count() {
             return this._count;
         }
         /**
          * 停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
          * @return 返回对象本身
          */
         clear() {
             this.stop();
             this._labels = null;
             return this;
         }
     }
     /**动画播放顺序类型：正序播放。 */
     AnimationBase.WRAP_POSITIVE = 0;
     /**动画播放顺序类型：逆序播放。 */
     AnimationBase.WRAP_REVERSE = 1;
     /**动画播放顺序类型：pingpong播放(当按指定顺序播放完结尾后，如果继续播放，则会改变播放顺序)。 */
     AnimationBase.WRAP_PINGPONG = 2;

     /**
          * @private
          * <code>MathUtil</code> 是一个数据处理工具类。
          */
     class MathUtil {
         static subtractVector3(l, r, o) {
             o[0] = l[0] - r[0];
             o[1] = l[1] - r[1];
             o[2] = l[2] - r[2];
         }
         static lerp(left, right, amount) {
             return left * (1 - amount) + right * amount;
         }
         static scaleVector3(f, b, e) {
             e[0] = f[0] * b;
             e[1] = f[1] * b;
             e[2] = f[2] * b;
         }
         static lerpVector3(l, r, t, o) {
             var ax = l[0], ay = l[1], az = l[2];
             o[0] = ax + t * (r[0] - ax);
             o[1] = ay + t * (r[1] - ay);
             o[2] = az + t * (r[2] - az);
         }
         static lerpVector4(l, r, t, o) {
             var ax = l[0], ay = l[1], az = l[2], aw = l[3];
             o[0] = ax + t * (r[0] - ax);
             o[1] = ay + t * (r[1] - ay);
             o[2] = az + t * (r[2] - az);
             o[3] = aw + t * (r[3] - aw);
         }
         static slerpQuaternionArray(a, Offset1, b, Offset2, t, out, Offset3) {
             var ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2], aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2], bw = b[Offset2 + 3];
             var omega, cosom, sinom, scale0, scale1;
             // calc cosine 
             cosom = ax * bx + ay * by + az * bz + aw * bw;
             // adjust signs (if necessary) 
             if (cosom < 0.0) {
                 cosom = -cosom;
                 bx = -bx;
                 by = -by;
                 bz = -bz;
                 bw = -bw;
             }
             // calculate coefficients 
             if ((1.0 - cosom) > 0.000001) {
                 // standard case (slerp) 
                 omega = Math.acos(cosom);
                 sinom = Math.sin(omega);
                 scale0 = Math.sin((1.0 - t) * omega) / sinom;
                 scale1 = Math.sin(t * omega) / sinom;
             }
             else {
                 // "from" and "to" quaternions are very close  
                 //  ... so we can do a linear interpolation 
                 scale0 = 1.0 - t;
                 scale1 = t;
             }
             // calculate final values 
             out[Offset3 + 0] = scale0 * ax + scale1 * bx;
             out[Offset3 + 1] = scale0 * ay + scale1 * by;
             out[Offset3 + 2] = scale0 * az + scale1 * bz;
             out[Offset3 + 3] = scale0 * aw + scale1 * bw;
             return out;
         }
         /**
          * 获取指定的两个点组成的线段的弧度值。
          * @param	x0 点一的 X 轴坐标值。
          * @param	y0 点一的 Y 轴坐标值。
          * @param	x1 点二的 X 轴坐标值。
          * @param	y1 点二的 Y 轴坐标值。
          * @return 弧度值。
          */
         static getRotation(x0, y0, x1, y1) {
             return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180;
         }
         /**
          * 一个用来确定数组元素排序顺序的比较函数。
          * @param	a 待比较数字。
          * @param	b 待比较数字。
          * @return 如果a等于b 则值为0；如果b>a则值为1；如果b<则值为-1。
          */
         static sortBigFirst(a, b) {
             if (a == b)
                 return 0;
             return b > a ? 1 : -1;
         }
         /**
          * 一个用来确定数组元素排序顺序的比较函数。
          * @param	a 待比较数字。
          * @param	b 待比较数字。
          * @return 如果a等于b 则值为0；如果b>a则值为-1；如果b<则值为1。
          */
         static sortSmallFirst(a, b) {
             if (a == b)
                 return 0;
             return b > a ? -1 : 1;
         }
         /**
          * 将指定的元素转为数字进行比较。
          * @param	a 待比较元素。
          * @param	b 待比较元素。
          * @return b、a转化成数字的差值 (b-a)。
          */
         static sortNumBigFirst(a, b) {
             return parseFloat(b) - parseFloat(a);
         }
         /**
          * 将指定的元素转为数字进行比较。
          * @param	a 待比较元素。
          * @param	b 待比较元素。
          * @return a、b转化成数字的差值 (a-b)。
          */
         static sortNumSmallFirst(a, b) {
             return parseFloat(a) - parseFloat(b);
         }
         /**
          * 返回根据对象指定的属性进行排序的比较函数。
          * @param	key 排序要依据的元素属性名。
          * @param	bigFirst 如果值为true，则按照由大到小的顺序进行排序，否则按照由小到大的顺序进行排序。
          * @param	forceNum 如果值为true，则将排序的元素转为数字进行比较。
          * @return 排序函数。
          */
         static sortByKey(key, bigFirst = false, forceNum = true) {
             var _sortFun;
             if (bigFirst) {
                 _sortFun = forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst;
             }
             else {
                 _sortFun = forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst;
             }
             return function (a, b) {
                 return _sortFun(a[key], b[key]);
             };
         }
     }

     /**
          * <code>Ease</code> 类定义了缓动函数，以便实现 <code>Tween</code> 动画的缓动效果。
          */
     class Ease {
         /**
          * 定义无加速持续运动。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static linearNone(t, b, c, d) {
             return c * t / d + b;
         }
         /**
          * 定义无加速持续运动。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static linearIn(t, b, c, d) {
             return c * t / d + b;
         }
         /**
          * 定义无加速持续运动。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static linearInOut(t, b, c, d) {
             return c * t / d + b;
         }
         /**
          * 定义无加速持续运动。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static linearOut(t, b, c, d) {
             return c * t / d + b;
         }
         /**
          * 方法以零速率开始运动，然后在执行时加快运动速度。
          * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static bounceIn(t, b, c, d) {
             return c - Ease.bounceOut(d - t, 0, c, d) + b;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static bounceInOut(t, b, c, d) {
             if (t < d * 0.5)
                 return Ease.bounceIn(t * 2, 0, c, d) * .5 + b;
             else
                 return Ease.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static bounceOut(t, b, c, d) {
             if ((t /= d) < (1 / 2.75))
                 return c * (7.5625 * t * t) + b;
             else if (t < (2 / 2.75))
                 return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
             else if (t < (2.5 / 2.75))
                 return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
             else
                 return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
         }
         /**
          * 开始时往后运动，然后反向朝目标移动。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @param	s 指定过冲量，此处数值越大，过冲越大。
          * @return 指定时间的插补属性的值。
          */
         static backIn(t, b, c, d, s = 1.70158) {
             return c * (t /= d) * t * ((s + 1) * t - s) + b;
         }
         /**
          * 开始运动时是向后跟踪，再倒转方向并朝目标移动，稍微过冲目标，然后再次倒转方向，回来朝目标移动。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @param	s 指定过冲量，此处数值越大，过冲越大。
          * @return 指定时间的插补属性的值。
          */
         static backInOut(t, b, c, d, s = 1.70158) {
             if ((t /= d * 0.5) < 1)
                 return c * 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
             return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
         }
         /**
          * 开始运动时是朝目标移动，稍微过冲，再倒转方向回来朝着目标。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @param	s 指定过冲量，此处数值越大，过冲越大。
          * @return 指定时间的插补属性的值。
          */
         static backOut(t, b, c, d, s = 1.70158) {
             return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
         }
         /**
          * 方法以零速率开始运动，然后在执行时加快运动速度。
          * 其中的运动由按照指数方式衰减的正弦波来定义。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @param	a 指定正弦波的幅度。
          * @param	p 指定正弦波的周期。
          * @return 指定时间的插补属性的值。
          */
         static elasticIn(t, b, c, d, a = 0, p = 0) {
             var s;
             if (t == 0)
                 return b;
             if ((t /= d) == 1)
                 return b + c;
             if (!p)
                 p = d * .3;
             if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                 a = c;
                 s = p / 4;
             }
             else
                 s = p / Ease.PI2 * Math.asin(c / a);
             return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * 其中的运动由按照指数方式衰减的正弦波来定义。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @param	a 指定正弦波的幅度。
          * @param	p 指定正弦波的周期。
          * @return 指定时间的插补属性的值。
          */
         static elasticInOut(t, b, c, d, a = 0, p = 0) {
             var s;
             if (t == 0)
                 return b;
             if ((t /= d * 0.5) == 2)
                 return b + c;
             if (!p)
                 p = d * (.3 * 1.5);
             if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                 a = c;
                 s = p / 4;
             }
             else
                 s = p / Ease.PI2 * Math.asin(c / a);
             if (t < 1)
                 return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b;
             return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p) * .5 + c + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * 其中的运动由按照指数方式衰减的正弦波来定义。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @param	a 指定正弦波的幅度。
          * @param	p 指定正弦波的周期。
          * @return 指定时间的插补属性的值。
          */
         static elasticOut(t, b, c, d, a = 0, p = 0) {
             var s;
             if (t == 0)
                 return b;
             if ((t /= d) == 1)
                 return b + c;
             if (!p)
                 p = d * .3;
             if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                 a = c;
                 s = p / 4;
             }
             else
                 s = p / Ease.PI2 * Math.asin(c / a);
             return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * Ease.PI2 / p) + c + b);
         }
         /**
          * 以零速率开始运动，然后在执行时加快运动速度。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static strongIn(t, b, c, d) {
             return c * (t /= d) * t * t * t * t + b;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static strongInOut(t, b, c, d) {
             if ((t /= d * 0.5) < 1)
                 return c * 0.5 * t * t * t * t * t + b;
             return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static strongOut(t, b, c, d) {
             return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static sineInOut(t, b, c, d) {
             return -c * 0.5 * (Math.cos(Math.PI * t / d) - 1) + b;
         }
         /**
          * 以零速率开始运动，然后在执行时加快运动速度。
          * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static sineIn(t, b, c, d) {
             return -c * Math.cos(t / d * Ease.HALF_PI) + c + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static sineOut(t, b, c, d) {
             return c * Math.sin(t / d * Ease.HALF_PI) + b;
         }
         /**
          * 以零速率开始运动，然后在执行时加快运动速度。
          * Quint 缓动方程的运动加速大于 Quart 缓动方程。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static quintIn(t, b, c, d) {
             return c * (t /= d) * t * t * t * t + b;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * Quint 缓动方程的运动加速大于 Quart 缓动方程。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static quintInOut(t, b, c, d) {
             if ((t /= d * 0.5) < 1)
                 return c * 0.5 * t * t * t * t * t + b;
             return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * Quint 缓动方程的运动加速大于 Quart 缓动方程。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static quintOut(t, b, c, d) {
             return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
         }
         /**
          * 方法以零速率开始运动，然后在执行时加快运动速度。
          * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static quartIn(t, b, c, d) {
             return c * (t /= d) * t * t * t + b;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static quartInOut(t, b, c, d) {
             if ((t /= d * 0.5) < 1)
                 return c * 0.5 * t * t * t * t + b;
             return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static quartOut(t, b, c, d) {
             return -c * ((t = t / d - 1) * t * t * t - 1) + b;
         }
         /**
          * 方法以零速率开始运动，然后在执行时加快运动速度。
          * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static cubicIn(t, b, c, d) {
             return c * (t /= d) * t * t + b;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static cubicInOut(t, b, c, d) {
             if ((t /= d * 0.5) < 1)
                 return c * 0.5 * t * t * t + b;
             return c * 0.5 * ((t -= 2) * t * t + 2) + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static cubicOut(t, b, c, d) {
             return c * ((t = t / d - 1) * t * t + 1) + b;
         }
         /**
          * 方法以零速率开始运动，然后在执行时加快运动速度。
          * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static quadIn(t, b, c, d) {
             return c * (t /= d) * t + b;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static quadInOut(t, b, c, d) {
             if ((t /= d * 0.5) < 1)
                 return c * 0.5 * t * t + b;
             return -c * 0.5 * ((--t) * (t - 2) - 1) + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static quadOut(t, b, c, d) {
             return -c * (t /= d) * (t - 2) + b;
         }
         /**
          * 方法以零速率开始运动，然后在执行时加快运动速度。
          * 其中每个时间间隔是剩余距离减去一个固定比例部分。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static expoIn(t, b, c, d) {
             return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * 其中每个时间间隔是剩余距离减去一个固定比例部分。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static expoInOut(t, b, c, d) {
             if (t == 0)
                 return b;
             if (t == d)
                 return b + c;
             if ((t /= d * 0.5) < 1)
                 return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b;
             return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * 其中每个时间间隔是剩余距离减去一个固定比例部分。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static expoOut(t, b, c, d) {
             return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
         }
         /**
          * 方法以零速率开始运动，然后在执行时加快运动速度。
          * 缓动方程的运动加速会产生突然的速率变化。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static circIn(t, b, c, d) {
             return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
         }
         /**
          * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
          * 缓动方程的运动加速会产生突然的速率变化。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static circInOut(t, b, c, d) {
             if ((t /= d * 0.5) < 1)
                 return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b;
             return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
         }
         /**
          * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
          * 缓动方程的运动加速会产生突然的速率变化。
          * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
          * @param	b 指定动画属性的初始值。
          * @param	c 指定动画属性的更改总计。
          * @param	d 指定运动的持续时间。
          * @return 指定时间的插补属性的值。
          */
         static circOut(t, b, c, d) {
             return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
         }
     }
     /**@private */
     Ease.HALF_PI = Math.PI * 0.5;
     /**@private */
     Ease.PI2 = Math.PI * 2;

     /**
      * 动画播放完毕后调度。
      * @eventType Event.COMPLETE
      */
     /*[Event(name = "complete", type = "laya.events.Event")]*/
     /**
      * 播放到某标签后调度。
      * @eventType Event.LABEL
      */
     /*[Event(name = "label", type = "laya.events.Event")]*/
     /**
      * 节点关键帧动画播放类。解析播放IDE内制作的节点动画。
      */
     class FrameAnimation extends AnimationBase {
         constructor() {
             super();
             if (FrameAnimation._sortIndexFun === null) {
                 FrameAnimation._sortIndexFun = MathUtil.sortByKey("index", false, true);
             }
         }
         /**
          * @private
          * 初始化动画数据
          * @param targetDic 节点ID索引
          * @param animationData 动画数据
          */
         _setUp(targetDic, animationData) {
             this._targetDic = targetDic;
             this._animationData = animationData;
             this.interval = 1000 / animationData.frameRate;
             if (animationData.parsed) {
                 this._count = animationData.count;
                 this._labels = animationData.labels;
                 this._usedFrames = animationData.animationNewFrames;
             }
             else {
                 this._usedFrames = [];
                 this._calculateDatas();
                 animationData.parsed = true;
                 animationData.labels = this._labels;
                 animationData.count = this._count;
                 animationData.animationNewFrames = this._usedFrames;
             }
         }
         /**@inheritDoc */
         /*override*/ clear() {
             super.clear();
             this._targetDic = null;
             this._animationData = null;
             return this;
         }
         /**@inheritDoc */
         /*override*/ _displayToIndex(value) {
             if (!this._animationData)
                 return;
             if (value < 0)
                 value = 0;
             if (value > this._count)
                 value = this._count;
             var nodes = this._animationData.nodes, i, len = nodes.length;
             for (i = 0; i < len; i++) {
                 this._displayNodeToFrame(nodes[i], value);
             }
         }
         /**
          * @private
          * 将节点设置到某一帧的状态
          * @param node 节点ID
          * @param frame
          * @param targetDic 节点表
          */
         _displayNodeToFrame(node, frame, targetDic = null) {
             if (!targetDic)
                 targetDic = this._targetDic;
             var target = targetDic[node.target];
             if (!target) {
                 //trace("loseTarget:",node.target);
                 return;
             }
             var frames = node.frames, key, propFrames, value;
             var keys = node.keys, i, len = keys.length;
             for (i = 0; i < len; i++) {
                 key = keys[i];
                 propFrames = frames[key];
                 if (propFrames.length > frame) {
                     value = propFrames[frame];
                 }
                 else {
                     value = propFrames[propFrames.length - 1];
                 }
                 target[key] = value;
             }
             var funkeys = node.funkeys;
             len = funkeys.length;
             var funFrames;
             if (len == 0)
                 return;
             for (i = 0; i < len; i++) {
                 key = funkeys[i];
                 funFrames = frames[key];
                 if (funFrames[frame] !== undefined) {
                     target[key] && target[key].apply(target, funFrames[frame]);
                 }
             }
         }
         /**
          * @private
          * 计算帧数据
          */
         _calculateDatas() {
             if (!this._animationData)
                 return;
             var nodes = this._animationData.nodes, i, len = nodes.length, tNode;
             this._count = 0;
             for (i = 0; i < len; i++) {
                 tNode = nodes[i];
                 this._calculateKeyFrames(tNode);
             }
             this._count += 1;
         }
         /**
          * @private
          * 计算某个节点的帧数据
          */
         _calculateKeyFrames(node) {
             var keyFrames = node.keyframes, key, tKeyFrames, target = node.target;
             if (!node.frames)
                 node.frames = {};
             if (!node.keys)
                 node.keys = [];
             else
                 node.keys.length = 0;
             if (!node.funkeys)
                 node.funkeys = [];
             else
                 node.funkeys.length = 0;
             if (!node.initValues)
                 node.initValues = {};
             for (key in keyFrames) {
                 var isFun = key.indexOf("()") != -1;
                 tKeyFrames = keyFrames[key];
                 if (isFun)
                     key = key.substr(0, key.length - 2);
                 if (!node.frames[key]) {
                     node.frames[key] = [];
                 }
                 if (!isFun) {
                     if (this._targetDic && this._targetDic[target]) {
                         node.initValues[key] = this._targetDic[target][key];
                     }
                     tKeyFrames.sort(FrameAnimation._sortIndexFun);
                     node.keys.push(key);
                     this._calculateNodePropFrames(tKeyFrames, node.frames[key], key, target);
                 }
                 else {
                     node.funkeys.push(key);
                     var map = node.frames[key];
                     for (var i = 0; i < tKeyFrames.length; i++) {
                         var temp = tKeyFrames[i];
                         map[temp.index] = temp.value;
                         if (temp.index > this._count)
                             this._count = temp.index;
                     }
                 }
             }
         }
         /**
          * 重置节点，使节点恢复到动画之前的状态，方便其他动画控制
          */
         resetNodes() {
             if (!this._targetDic)
                 return;
             if (!this._animationData)
                 return;
             var nodes = this._animationData.nodes, i, len = nodes.length;
             var tNode;
             var initValues;
             for (i = 0; i < len; i++) {
                 tNode = nodes[i];
                 initValues = tNode.initValues;
                 if (!initValues)
                     continue;
                 var target = this._targetDic[tNode.target];
                 if (!target)
                     continue;
                 var key;
                 for (key in initValues) {
                     target[key] = initValues[key];
                 }
             }
         }
         /**
          * @private
          * 计算节点某个属性的帧数据
          */
         _calculateNodePropFrames(keyframes, frames, key, target) {
             var i, len = keyframes.length - 1;
             frames.length = keyframes[len].index + 1;
             for (i = 0; i < len; i++) {
                 this._dealKeyFrame(keyframes[i]);
                 this._calculateFrameValues(keyframes[i], keyframes[i + 1], frames);
             }
             if (len == 0) {
                 frames[0] = keyframes[0].value;
                 if (this._usedFrames)
                     this._usedFrames[keyframes[0].index] = true;
             }
             this._dealKeyFrame(keyframes[i]);
         }
         /**
          * @private
          */
         _dealKeyFrame(keyFrame) {
             if (keyFrame.label && keyFrame.label != "")
                 this.addLabel(keyFrame.label, keyFrame.index);
         }
         /**
          * @private
          * 计算两个关键帧直接的帧数据
          */
         _calculateFrameValues(startFrame, endFrame, result) {
             var i, easeFun;
             var start = startFrame.index, end = endFrame.index;
             var startValue = startFrame.value;
             var dValue = endFrame.value - startFrame.value;
             var dLen = end - start;
             var frames = this._usedFrames;
             if (end > this._count)
                 this._count = end;
             if (startFrame.tween) {
                 easeFun = Ease[startFrame.tweenMethod];
                 if (easeFun == null)
                     easeFun = Ease.linearNone;
                 for (i = start; i < end; i++) {
                     result[i] = easeFun(i - start, startValue, dValue, dLen);
                     if (frames)
                         frames[i] = true;
                 }
             }
             else {
                 for (i = start; i < end; i++) {
                     result[i] = startValue;
                 }
             }
             if (frames) {
                 frames[startFrame.index] = true;
                 frames[endFrame.index] = true;
             }
             result[endFrame.index] = endFrame.value;
         }
     }

     var supportWeakMap = !!WeakMap;
     /**
          * 封装弱引用WeakMap
          * 如果支持WeakMap，则使用WeakMap，如果不支持，则用Object代替
          * 注意：如果采用Object，为了防止内存泄漏，则采用定时清理缓存策略
          */
     class WeakObject {
         constructor() {
             this._obj = WeakObject.supportWeakMap ? new Browser.window.WeakMap() : {};
             if (!WeakObject.supportWeakMap)
                 WeakObject._maps.push(this);
         }
         /**@private */
         static __init__() {
             //WeakObject.supportWeakMap = Browser.window.WeakMap != null;
             //如果不支持，10分钟回收一次
             if (!WeakObject.supportWeakMap)
                 window.Laya.systemTimer.loop(WeakObject.delInterval, null, WeakObject.clearCache);
         }
         /**清理缓存，回收内存*/
         //TODO:coverage
         static clearCache() {
             for (var i = 0, n = WeakObject._maps.length; i < n; i++) {
                 var obj = WeakObject._maps[i];
                 obj._obj = {};
             }
         }
         /**
          * 设置缓存
          * @param	key kye对象，可被回收
          * @param	value object对象，可被回收
          */
         set(key, value) {
             if (key == null)
                 return;
             if (WeakObject.supportWeakMap) {
                 var objKey = key;
                 if (typeof (key) == 'string' || typeof (key) == 'number') {
                     objKey = WeakObject._keys[key];
                     if (!objKey)
                         objKey = WeakObject._keys[key] = { k: key };
                 }
                 this._obj.set(objKey, value);
             }
             else {
                 if (typeof (key) == 'string' || typeof (key) == 'number') {
                     this._obj[key] = value;
                 }
                 else {
                     key.$_GID || (key.$_GID = Utils.getGID());
                     this._obj[key.$_GID] = value;
                 }
             }
         }
         /**
          * 获取缓存
          * @param	key kye对象，可被回收
          */
         get(key) {
             if (key == null)
                 return null;
             if (WeakObject.supportWeakMap) {
                 var objKey = (typeof (key) == 'string' || typeof (key) == 'number') ? WeakObject._keys[key] : key;
                 if (!objKey)
                     return null;
                 return this._obj.get(objKey);
             }
             else {
                 if (typeof (key) == 'string' || typeof (key) == 'number')
                     return this._obj[key];
                 return this._obj[key.$_GID];
             }
         }
         /**
          * 删除缓存
          */
         //TODO:coverage
         del(key) {
             if (key == null)
                 return;
             if (WeakObject.supportWeakMap) {
                 var objKey = (typeof (key) == 'string' || typeof (key) == 'number') ? WeakObject._keys[key] : key;
                 if (!objKey)
                     return;
                 this._obj.delete(objKey);
             }
             else {
                 if (typeof (key) == 'string' || typeof (key) == 'number')
                     delete this._obj[key];
                 else
                     delete this._obj[this._obj.$_GID];
             }
         }
         /**
          * 是否有缓存
          */
         //TODO:coverage
         has(key) {
             if (key == null)
                 return false;
             if (WeakObject.supportWeakMap) {
                 var objKey = (typeof (key) == 'string' || typeof (key) == 'number') ? WeakObject._keys[key] : key;
                 return this._obj.has(objKey);
             }
             else {
                 if (typeof (key) == 'string' || typeof (key) == 'number')
                     return this._obj[key] != null;
                 return this._obj[this._obj.$_GID] != null;
             }
         }
     }
     /**是否支持WeakMap*/
     WeakObject.supportWeakMap = supportWeakMap;
     /**如果不支持WeakMap，则多少时间清理一次缓存，默认10分钟清理一次*/
     WeakObject.delInterval = 10 * 60 * 1000;
     /**全局WeakObject单例*/
     WeakObject.I = new WeakObject();
     /**@private */
     WeakObject._keys = {};
     /**@private */
     WeakObject._maps = [];
     //WeakObject.__init__();

     /**
      * @private 场景辅助类
      */
     class SceneUtils {
         /**
          * @private 根据字符串，返回函数表达式
          */
         //TODO:coverage
         static getBindFun(value) {
             var fun = SceneUtils._funMap.get(value);
             if (fun == null) {
                 var temp = "\"" + value + "\"";
                 temp = temp.replace(/^"\${|}"$/g, "").replace(/\${/g, "\"+").replace(/}/g, "+\"");
                 var str = "(function(data){if(data==null)return;with(data){try{\nreturn " + temp + "\n}catch(e){}}})";
                 fun = window.Laya._runScript(str);
                 SceneUtils._funMap.set(value, fun);
             }
             return fun;
         }
         /**
          * @private
          * 通过视图数据创建视图。
          * @param uiView 视图数据信息。
          */
         //TODO:coverage
         static createByData(root, uiView) {
             var tInitTool = InitTool.create();
             //递归创建节点
             root = SceneUtils.createComp(uiView, root, root, null, tInitTool);
             root._setBit(Const.NOT_READY, true);
             if ("_idMap" in root) {
                 root["_idMap"] = tInitTool._idMap;
             }
             //处理动画信息
             if (uiView.animations) {
                 var anilist = [];
                 var animations = uiView.animations;
                 var i, len = animations.length;
                 var tAni;
                 var tAniO;
                 for (i = 0; i < len; i++) {
                     tAni = new FrameAnimation();
                     tAniO = animations[i];
                     tAni._setUp(tInitTool._idMap, tAniO);
                     root[tAniO.name] = tAni;
                     tAni._setControlNode(root);
                     switch (tAniO.action) {
                         case 1:
                             tAni.play(0, false);
                             break;
                         case 2:
                             tAni.play(0, true);
                             break;
                     }
                     anilist.push(tAni);
                 }
                 root._aniList = anilist;
             }
             //设置页面穿透
             if (root._$componentType === "Scene" && root._width > 0 && uiView.props.hitTestPrior == null && !root.mouseThrough)
                 root.hitTestPrior = true;
             //设置组件
             tInitTool.beginLoad(root);
             return root;
         }
         static createInitTool() {
             return InitTool.create();
         }
         /**
          * 根据UI数据实例化组件。
          * @param uiView UI数据。
          * @param comp 组件本体，如果为空，会新创建一个。
          * @param view 组件所在的视图实例，用来注册var全局变量，如果值为空则不注册。
          * @return 一个 Component 对象。
          */
         static createComp(uiView, comp = null, view = null, dataMap = null, initTool = null) {
             if (uiView.type == "Scene3D" || uiView.type == "Sprite3D") {
                 var outBatchSprits = [];
                 var scene3D = ILaya.Laya["Utils3D"]._createSceneByJsonForMaker(uiView, outBatchSprits, initTool);
                 if (uiView.type == "Sprite3D")
                     ILaya.Laya["StaticBatchManager"].combine(scene3D, outBatchSprits);
                 else
                     ILaya.Laya["StaticBatchManager"].combine(null, outBatchSprits);
                 return scene3D;
             }
             comp = comp || SceneUtils.getCompInstance(uiView);
             if (!comp) {
                 if (uiView.props && uiView.props.runtime)
                     console.warn("runtime not found:" + uiView.props.runtime);
                 else
                     console.warn("can not create:" + uiView.type);
                 return null;
             }
             var child = uiView.child;
             if (child) {
                 var isList = comp["_$componentType"] == "List";
                 for (var i = 0, n = child.length; i < n; i++) {
                     var node = child[i];
                     if ('itemRender' in comp && (node.props.name == "render" || node.props.renderType === "render")) {
                         //如果list的itemRender
                         comp["itemRender"] = node;
                     }
                     else if (node.type == "Graphic") {
                         //绘制矢量图
                         ILaya.ClassUtils._addGraphicsToSprite(node, comp);
                     }
                     else if (ILaya.ClassUtils._isDrawType(node.type)) {
                         ILaya.ClassUtils._addGraphicToSprite(node, comp, true);
                     }
                     else {
                         if (isList) {
                             //收集数据绑定信息
                             var arr = [];
                             var tChild = SceneUtils.createComp(node, null, view, arr, initTool);
                             if (arr.length)
                                 tChild["_$bindData"] = arr;
                         }
                         else {
                             tChild = SceneUtils.createComp(node, null, view, dataMap, initTool);
                         }
                         //处理脚本
                         if (node.type == "Script") {
                             if (tChild instanceof Component) {
                                 comp._addComponentInstance(tChild);
                             }
                             else {
                                 //兼容老版本
                                 if ("owner" in tChild) {
                                     tChild["owner"] = comp;
                                 }
                                 else if ("target" in tChild) {
                                     tChild["target"] = comp;
                                 }
                             }
                         }
                         else if (node.props.renderType == "mask" || node.props.name == "mask") {
                             comp.mask = tChild;
                         }
                         else {
                             tChild instanceof Node && comp.addChild(tChild);
                         }
                     }
                 }
             }
             var props = uiView.props;
             for (var prop in props) {
                 var value = props[prop];
                 if (typeof (value) == 'string' && (value.indexOf("@node:") >= 0 || value.indexOf("@Prefab:") >= 0)) {
                     if (initTool) {
                         initTool.addNodeRef(comp, prop, value);
                     }
                 }
                 else
                     SceneUtils.setCompValue(comp, prop, value, view, dataMap);
             }
             if (comp._afterInited) {
                 //if (initTool) {
                 //initTool.addInitItem(comp);
                 //} else {
                 comp._afterInited();
                 //}
             }
             if (uiView.compId && initTool && initTool._idMap) {
                 initTool._idMap[uiView.compId] = comp;
             }
             return comp;
         }
         /**
          * @private
          * 设置组件的属性值。
          * @param comp 组件实例。
          * @param prop 属性名称。
          * @param value 属性值。
          * @param view 组件所在的视图实例，用来注册var全局变量，如果值为空则不注册。
          */
         static setCompValue(comp, prop, value, view = null, dataMap = null) {
             //处理数据绑定
             if (typeof (value) == 'string' && value.indexOf("${") > -1) {
                 SceneUtils._sheet || (SceneUtils._sheet = ILaya.ClassUtils.getClass("laya.data.Table"));
                 if (!SceneUtils._sheet) {
                     console.warn("Can not find class Sheet");
                     return;
                 }
                 //list的item处理
                 if (dataMap) {
                     dataMap.push(comp, prop, value);
                 }
                 else if (view) {
                     if (value.indexOf("].") == -1) {
                         //TODO
                         value = value.replace(".", "[0].");
                     }
                     var watcher = new DataWatcher(comp, prop, value);
                     //执行第一次数据赋值
                     watcher.exe(view);
                     var one, temp;
                     var str = value.replace(/\[.*?\]\./g, ".");
                     while ((one = SceneUtils._parseWatchData.exec(str)) != null) {
                         var key1 = one[1];
                         while ((temp = SceneUtils._parseKeyWord.exec(key1)) != null) {
                             var key2 = temp[0];
                             var arr = (view._watchMap[key2] || (view._watchMap[key2] = []));
                             arr.push(watcher);
                             //监听数据变化
                             SceneUtils._sheet.I.notifer.on(key2, view, view.changeData, [key2]);
                         }
                         //TODO
                         arr = (view._watchMap[key1] || (view._watchMap[key1] = []));
                         arr.push(watcher);
                         SceneUtils._sheet.I.notifer.on(key1, view, view.changeData, [key1]);
                     }
                     //trace(view._watchMap);
                 }
                 return;
             }
             if (prop === "var" && view) {
                 view[value] = comp;
             }
             else {
                 comp[prop] = (value === "true" ? true : (value === "false" ? false : value));
             }
         }
         /**
          * @private
          * 通过组建UI数据，获取组件实例。
          * @param json UI数据。
          * @return Component 对象。
          */
         static getCompInstance(json) {
             if (json.type == "UIView") {
                 if (json.props && json.props.pageData) {
                     return SceneUtils.createByData(null, json.props.pageData);
                 }
             }
             var runtime = (json.props && json.props.runtime) || json.type;
             var compClass = ILaya.ClassUtils.getClass(runtime);
             if (!compClass)
                 throw "Can not find class " + runtime;
             if (json.type === "Script" && compClass.prototype._doAwake) {
                 var comp = Pool.createByClass(compClass);
                 comp._destroyed = false;
                 return comp;
             }
             if (json.props && "renderType" in json.props && json.props["renderType"] == "instance") {
                 if (!compClass["instance"])
                     compClass["instance"] = new compClass();
                 return compClass["instance"];
             }
             return new compClass();
         }
     }
     /**@private */
     SceneUtils._funMap = new WeakObject();
     /**@private */
     SceneUtils._parseWatchData = /\${(.*?)}/g;
     /**@private */
     SceneUtils._parseKeyWord = /[a-zA-Z_][a-zA-Z0-9_]*(?:(?:\.[a-zA-Z_][a-zA-Z0-9_]*)+)/g;
     /**
      * @private 场景辅助类
      */
     class DataWatcher {
         //TODO:coverage
         constructor(comp, prop, value) {
             this.comp = comp;
             this.prop = prop;
             this.value = value;
         }
         exe(view) {
             var fun = SceneUtils.getBindFun(this.value);
             this.comp[this.prop] = fun.call(this, view);
         }
     }
     /**
      * @private 场景辅助类
      */
     class InitTool {
         //TODO:coverage
         reset() {
             this._nodeRefList = null;
             this._initList = null;
             this._idMap = null;
             this._loadList = null;
             this._scene = null;
         }
         //TODO:coverage
         recover() {
             this.reset();
             Pool.recover("InitTool", this);
         }
         static create() {
             var tool = Pool.getItemByClass("InitTool", InitTool);
             tool._idMap = [];
             return tool;
         }
         //TODO:coverage
         addLoadRes(url, type = null) {
             if (!this._loadList)
                 this._loadList = [];
             if (!type) {
                 this._loadList.push(url);
             }
             else {
                 this._loadList.push({ url: url, type: type });
             }
         }
         /**@private */
         //TODO:coverage
         addNodeRef(node, prop, referStr) {
             if (!this._nodeRefList)
                 this._nodeRefList = [];
             this._nodeRefList.push([node, prop, referStr]);
             if (referStr.indexOf("@Prefab:") >= 0) {
                 this.addLoadRes(referStr.replace("@Prefab:", ""), Loader.PREFAB);
             }
         }
         /**@private */
         //TODO:coverage
         setNodeRef() {
             if (!this._nodeRefList)
                 return;
             if (!this._idMap) {
                 this._nodeRefList = null;
                 return;
             }
             var i, len;
             len = this._nodeRefList.length;
             var tRefInfo;
             for (i = 0; i < len; i++) {
                 tRefInfo = this._nodeRefList[i];
                 tRefInfo[0][tRefInfo[1]] = this.getReferData(tRefInfo[2]);
             }
             this._nodeRefList = null;
         }
         /**@private */
         //TODO:coverage
         getReferData(referStr) {
             if (referStr.indexOf("@Prefab:") >= 0) {
                 var prefab;
                 prefab = Loader.getRes(referStr.replace("@Prefab:", ""));
                 return prefab;
             }
             else if (referStr.indexOf("@arr:") >= 0) {
                 referStr = referStr.replace("@arr:", "");
                 var list;
                 list = referStr.split(",");
                 var i, len;
                 var tStr;
                 len = list.length;
                 for (i = 0; i < len; i++) {
                     tStr = list[i];
                     if (tStr) {
                         list[i] = this._idMap[tStr.replace("@node:", "")];
                     }
                     else {
                         list[i] = null;
                     }
                 }
                 return list;
             }
             else {
                 return this._idMap[referStr.replace("@node:", "")];
             }
         }
         /**@private */
         //TODO:coverage
         addInitItem(item) {
             if (!this._initList)
                 this._initList = [];
             this._initList.push(item);
         }
         /**@private */
         //TODO:coverage
         doInits() {
             if (!this._initList)
                 return;
             this._initList = null;
         }
         /**@private */
         //TODO:coverage
         finish() {
             this.setNodeRef();
             this.doInits();
             this._scene._setBit(Const.NOT_READY, false);
             if (this._scene.parent && this._scene.parent.activeInHierarchy && this._scene.active)
                 this._scene._processActive();
             this._scene.event("onViewCreated");
             this.recover();
         }
         /**@private */
         //TODO:coverage
         beginLoad(scene) {
             this._scene = scene;
             if (!this._loadList || this._loadList.length < 1) {
                 this.finish();
             }
             else {
                 ILaya.loader.load(this._loadList, Handler.create(this, this.finish));
             }
         }
     }

     /**
      * 场景类，负责场景创建，加载，销毁等功能
      * 场景被从节点移除后，并不会被自动垃圾机制回收，如果想回收，请调用destroy接口，可以通过unDestroyedScenes属性查看还未被销毁的场景列表
      */
     class Scene extends Sprite {
         constructor() {
             super();
             /**场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为false*/
             this.autoDestroyAtClosed = false;
             /**场景地址*/
             this.url = null;
             /**@private */
             this._viewCreated = false;
             /**@private */
             this._$componentType = "Scene";
             this._setBit(Const.NOT_READY, true);
             Scene.unDestroyedScenes.push(this);
             this._scene = this;
             this.createChildren();
         }
         /**
          * @private 兼容老项目
          */
         createChildren() {
         }
         /**
          * @private 兼容老项目
          * 装载场景视图。用于加载模式。
          * @param path 场景地址。
          */
         loadScene(path) {
             var url = path.indexOf(".") > -1 ? path : path + ".scene";
             var view = ILaya.loader.getRes(url);
             if (view) {
                 this.createView(view);
             }
             else {
                 ILaya.loader.resetProgress();
                 var loader = new SceneLoader();
                 loader.on(Event.COMPLETE, this, this._onSceneLoaded, [url]);
                 loader.load(url);
                 //Laya.loader.load(url, Handler.create(this, createView), null, Loader.JSON);
             }
         }
         _onSceneLoaded(url) {
             this.createView(ILaya.Loader.getRes(url));
         }
         /**
          * @private 兼容老项目
          * 通过视图数据创建视图。
          * @param uiView 视图数据信息。
          */
         createView(view) {
             if (view && !this._viewCreated) {
                 this._viewCreated = true;
                 SceneUtils.createByData(this, view);
             }
         }
         /**
          * 根据IDE内的节点id，获得节点实例
          */
         getNodeByID(id) {
             if (this._idMap)
                 return this._idMap[id];
             return null;
         }
         /**
          * 打开场景。【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收
          * @param	closeOther	是否关闭其他场景，默认为true（可选）
          * @param	param		打开页面的参数，会传递给onOpened方法（可选）
          */
         open(closeOther = true, param = null) {
             if (closeOther)
                 Scene.closeAll();
             Scene.root.addChild(this);
             this.onOpened(param);
         }
         /**场景打开完成后，调用此方法（如果有弹出动画，则在动画完成后执行）*/
         onOpened(param) {
             //trace("onOpened");
         }
         /**
          * 关闭场景
          * 【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收
          * @param type 关闭的原因，会传递给onClosed函数
          */
         close(type = null) {
             this.onClosed(type);
             if (this.autoDestroyAtClosed)
                 this.destroy();
             else
                 this.removeSelf();
         }
         /**关闭完成后，调用此方法（如果有关闭动画，则在动画完成后执行）
          * @param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。
          */
         onClosed(type = null) {
             //trace("onClosed");
         }
         /**@inheritDoc */
         /*override*/ destroy(destroyChild = true) {
             this._idMap = null;
             super.destroy(destroyChild);
             var list = Scene.unDestroyedScenes;
             for (var i = list.length - 1; i > -1; i--) {
                 if (list[i] === this) {
                     list.splice(i, 1);
                     return;
                 }
             }
         }
         /**@inheritDoc */
         /*override*/ set scaleX(value) {
             if (super.get_scaleX() == value)
                 return;
             super.set_scaleX(value);
             this.event(Event.RESIZE);
         }
         get scaleX() {
             return super.scaleX;
         }
         /**@inheritDoc */
         /*override*/ set scaleY(value) {
             if (super.get_scaleY() == value)
                 return;
             super.set_scaleY(value);
             this.event(Event.RESIZE);
         }
         get scaleY() {
             return super.scaleY;
         }
         /**@inheritDoc */
         /*override*/ get width() {
             if (this._width)
                 return this._width;
             var max = 0;
             for (var i = this.numChildren - 1; i > -1; i--) {
                 var comp = this.getChildAt(i);
                 if (comp._visible) {
                     max = Math.max(comp._x + comp.width * comp.scaleX, max);
                 }
             }
             return max;
         }
         /**@inheritDoc */
         /*override*/ set width(value) {
             if (super.get_width() == value)
                 return;
             super.set_width(value);
             this.callLater(this._sizeChanged);
         }
         /**@inheritDoc */
         /*override*/ get height() {
             if (this._height)
                 return this._height;
             var max = 0;
             for (var i = this.numChildren - 1; i > -1; i--) {
                 var comp = this.getChildAt(i);
                 if (comp._visible) {
                     max = Math.max(comp._y + comp.height * comp.scaleY, max);
                 }
             }
             return max;
         }
         /**@inheritDoc */
         /*override*/ set height(value) {
             if (super.get_height() == value)
                 return;
             super.set_height(value);
             this.callLater(this._sizeChanged);
         }
         /**@private */
         _sizeChanged() {
             this.event(Event.RESIZE);
         }
         //////////////////////////////////////静态方法//////////////////////////////////////////
         /**获取场景根容器*/
         static get root() {
             if (!Scene._root) {
                 Scene._root = ILaya.stage.addChild(new Sprite());
                 Scene._root.name = "root";
                 ILaya.stage.on("resize", null, () => {
                     Scene._root.size(ILaya.stage.width, ILaya.stage.height);
                     Scene._root.event(Event.RESIZE);
                 });
                 Scene._root.size(ILaya.stage.width, ILaya.stage.height);
                 Scene._root.event(Event.RESIZE);
             }
             return Scene._root;
         }
         /**场景时钟*/
         /*override*/ get timer() {
             return this._timer || ILaya.timer;
         }
         set timer(value) {
             this._timer = value;
         }
         /**
          * 加载场景及场景使用到的资源
          * @param	url			场景地址
          * @param	complete	加载完成回调，返回场景实例（可选）
          * @param	progress	加载进度回调（可选）
          */
         static load(url, complete = null, progress = null) {
             ILaya.loader.resetProgress();
             var loader = new SceneLoader();
             loader.on(Event.PROGRESS, null, onProgress);
             loader.once(Event.COMPLETE, null, create);
             loader.load(url);
             function onProgress(value) {
                 if (Scene._loadPage)
                     Scene._loadPage.event("progress", value);
                 progress && progress.runWith(value);
             }
             function create() {
                 loader.off(Event.PROGRESS, null, onProgress);
                 var obj = ILaya.Loader.getRes(url);
                 if (!obj)
                     throw "Can not find scene:" + url;
                 if (!obj.props)
                     throw "Scene data is error:" + url;
                 var runtime = obj.props.runtime ? obj.props.runtime : obj.type;
                 var clas = ILaya.ClassUtils.getClass(runtime);
                 if (obj.props.renderType == "instance") {
                     var scene = clas.instance || (clas.instance = new clas());
                 }
                 else {
                     scene = new clas();
                 }
                 if (scene && scene instanceof Node) {
                     scene.url = url;
                     if (!scene._getBit(Const.NOT_READY)) {
                         complete && complete.runWith(scene);
                     }
                     else {
                         scene.on("onViewCreated", null, function () {
                             complete && complete.runWith(scene);
                         });
                         scene.createView(obj);
                     }
                     Scene.hideLoadingPage();
                 }
                 else {
                     throw "Can not find scene:" + runtime;
                 }
             }
         }
         /**
          * 加载并打开场景
          * @param	url			场景地址
          * @param	closeOther	是否关闭其他场景，默认为true（可选），【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收
          * @param	param		打开页面的参数，会传递给onOpened方法（可选）
          * @param	complete	打开完成回调，返回场景实例（可选）
          * @param	progress	加载进度回调（可选）
          */
         static open(url, closeOther = true, param = null, complete = null, progress = null) {
             //兼容处理
             if (param instanceof Handler) {
                 var temp = complete;
                 complete = param;
                 param = temp;
             }
             Scene.showLoadingPage();
             Scene.load(url, Handler.create(null, this._onSceneLoaded, [closeOther, complete, param]), progress);
         }
         /**@private */
         static _onSceneLoaded(closeOther, complete, param, scene) {
             scene.open(closeOther, param);
             if (complete)
                 complete.runWith(scene);
         }
         /**
          * 根据地址，关闭场景（包括对话框）
          * @param	url		场景地址
          * @param	name	如果name不为空，name必须相同才能关闭
          * @return	返回是否关闭成功，如果url找不到，则不成功
          */
         static close(url, name = "") {
             var flag = false;
             var list = Scene.unDestroyedScenes;
             for (var i = 0, n = list.length; i < n; i++) {
                 var scene = list[i];
                 if (scene && scene.parent && scene.url === url && scene.name == name) {
                     scene.close();
                     flag = true;
                 }
             }
             return flag;
         }
         /**
          * 关闭所有场景，不包括对话框，如果关闭对话框，请使用Dialog.closeAll()
          * 【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收
          */
         static closeAll() {
             var root = Scene.root;
             for (var i = 0, n = root.numChildren; i < n; i++) {
                 var scene = root.getChildAt(0);
                 if (scene instanceof Scene)
                     scene.close();
                 else
                     scene.removeSelf();
             }
         }
         /**
          * 根据地址，销毁场景（包括对话框）
          * @param	url		场景地址
          * @param	name	如果name不为空，name必须相同才能关闭
          * @return	返回是否销毁成功，如果url找不到，则不成功
          */
         static destroy(url, name = "") {
             var flag = false;
             var list = Scene.unDestroyedScenes;
             for (var i = 0, n = list.length; i < n; i++) {
                 var scene = list[i];
                 if (scene.url === url && scene.name == name) {
                     scene.destroy();
                     flag = true;
                 }
             }
             return flag;
         }
         /**
          * 销毁当前没有被使用的资源,该函数会忽略lock=true的资源。
          */
         static gc() {
             Resource.destroyUnusedResources();
         }
         /**
          * 设置loading界面，引擎会在调用open方法后，延迟打开loading界面，在页面添加到舞台之后，关闭loading界面
          * @param	loadPage 	load界面实例
          */
         static setLoadingPage(loadPage) {
             if (Scene._loadPage != loadPage) {
                 Scene._loadPage = loadPage;
             }
         }
         /**
          * 显示loading界面
          * @param	param 打开参数，如果是scene，则会传递给onOpened方法
          * @param	delay 延迟打开时间，默认500毫秒
          */
         static showLoadingPage(param = null, delay = 500) {
             if (Scene._loadPage) {
                 ILaya.systemTimer.clear(null, Scene._showLoading);
                 ILaya.systemTimer.clear(null, Scene._hideLoading);
                 ILaya.systemTimer.once(delay, null, Scene._showLoading, [param], false);
             }
         }
         static _showLoading(param) {
             ILaya.stage.addChild(Scene._loadPage);
             Scene._loadPage.onOpened(param);
         }
         static _hideLoading() {
             Scene._loadPage.close();
         }
         /**
          * 隐藏loading界面
          * @param	delay 延迟关闭时间，默认500毫秒
          */
         static hideLoadingPage(delay = 500) {
             if (Scene._loadPage) {
                 ILaya.systemTimer.clear(null, Scene._showLoading);
                 ILaya.systemTimer.clear(null, Scene._hideLoading);
                 ILaya.systemTimer.once(delay, null, Scene._hideLoading);
             }
         }
     }
     /**创建后，还未被销毁的场景列表，方便查看还未被销毁的场景列表，方便内存管理，本属性只读，请不要直接修改*/
     Scene.unDestroyedScenes = [];

     /**
      * 鼠标点击区域，可以设置绘制一系列矢量图作为点击区域和非点击区域（目前只支持圆形，矩形，多边形）
      *
      */
     class HitArea {
         /**
          * 检测对象是否包含指定的点。
          * @param	x	点的 X 轴坐标值（水平位置）。
          * @param	y	点的 Y 轴坐标值（垂直位置）。
          * @return	如果包含指定的点，则值为 true；否则为 false。
          */
         contains(x, y) {
             if (!HitArea._isHitGraphic(x, y, this.hit))
                 return false;
             return !HitArea._isHitGraphic(x, y, this.unHit);
         }
         /**
          * @private
          * 是否击中Graphic
          */
         static _isHitGraphic(x, y, graphic) {
             if (!graphic)
                 return false;
             var cmds = graphic.cmds;
             if (!cmds && graphic._one) {
                 cmds = HitArea._cmds;
                 cmds.length = 1;
                 cmds[0] = graphic._one;
             }
             if (!cmds)
                 return false;
             var i, len;
             len = cmds.length;
             var cmd;
             for (i = 0; i < len; i++) {
                 cmd = cmds[i];
                 if (!cmd)
                     continue;
                 switch (cmd.cmdID) {
                     case "Translate":
                         x -= cmd.tx;
                         y -= cmd.ty;
                 }
                 if (HitArea._isHitCmd(x, y, cmd))
                     return true;
             }
             return false;
         }
         /**
          * @private
          * 是否击中绘图指令
          */
         static _isHitCmd(x, y, cmd) {
             if (!cmd)
                 return false;
             var rst = false;
             switch (cmd.cmdID) {
                 case "DrawRect":
                     HitArea._rect.setTo(cmd.x, cmd.y, cmd.width, cmd.height);
                     rst = HitArea._rect.contains(x, y);
                     break;
                 case "DrawCircle":
                     var d;
                     x -= cmd.x;
                     y -= cmd.y;
                     d = x * x + y * y;
                     rst = d < cmd.radius * cmd.radius;
                     break;
                 case "DrawPoly":
                     x -= cmd.x;
                     y -= cmd.y;
                     rst = HitArea._ptInPolygon(x, y, cmd.points);
                     break;
             }
             return rst;
         }
         /**
          * @private
          * 坐标是否在多边形内
          */
         static _ptInPolygon(x, y, areaPoints) {
             var p = HitArea._ptPoint;
             p.setTo(x, y);
             // 交点个数
             var nCross = 0;
             var p1x, p1y, p2x, p2y;
             var len;
             len = areaPoints.length;
             for (var i = 0; i < len; i += 2) {
                 p1x = areaPoints[i];
                 p1y = areaPoints[i + 1];
                 p2x = areaPoints[(i + 2) % len];
                 p2y = areaPoints[(i + 3) % len];
                 //var p1:Point = areaPoints[i];
                 //var p2:Point = areaPoints[(i + 1) % areaPoints.length]; // 最后一个点与第一个点连线
                 if (p1y == p2y)
                     continue;
                 if (p.y < Math.min(p1y, p2y))
                     continue;
                 if (p.y >= Math.max(p1y, p2y))
                     continue;
                 // 求交点的x坐标
                 var tx = (p.y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
                 // 只统计p1p2与p向右射线的交点
                 if (tx > p.x)
                     nCross++;
             }
             // 交点为偶数，点在多边形之外
             return (nCross % 2 == 1);
         }
         /**
          * 可点击区域，可以设置绘制一系列矢量图作为点击区域（目前只支持圆形，矩形，多边形）
          */
         get hit() {
             if (!this._hit)
                 this._hit = new ILaya.Graphics();
             return this._hit;
         }
         set hit(value) {
             this._hit = value;
         }
         /**
          * 不可点击区域，可以设置绘制一系列矢量图作为非点击区域（目前只支持圆形，矩形，多边形）
          */
         get unHit() {
             if (!this._unHit)
                 this._unHit = new ILaya.Graphics();
             return this._unHit;
         }
         set unHit(value) {
             this._unHit = value;
         }
     }
     /**@private */
     HitArea._cmds = [];
     /**@private */
     HitArea._rect = new Rectangle();
     /**@private */
     HitArea._ptPoint = new Point();

     /**
      * <code>ClassUtils</code> 是一个类工具类。
      */
     class ClassUtils {
         /**
          * 注册 Class 映射，方便在class反射时获取。
          * @param	className 映射的名字或者别名。
          * @param	classDef 类的全名或者类的引用，全名比如:"laya.display.Sprite"。
          */
         static regClass(className, classDef) {
             ClassUtils._classMap[className] = classDef;
         }
         /**
          * 根据类名短名字注册类，比如传入[Sprite]，功能同regClass("Sprite",Sprite);
          * @param	classes 类数组
          */
         static regShortClassName(classes) {
             for (var i = 0; i < classes.length; i++) {
                 var classDef = classes[i];
                 var className = classDef.name;
                 ClassUtils._classMap[className] = classDef;
             }
         }
         /**
          * 返回注册的 Class 映射。
          * @param	className 映射的名字。
          */
         static getRegClass(className) {
             return ClassUtils._classMap[className];
         }
         /**
          * 根据名字返回类对象。
          * @param	className 类名(比如laya.display.Sprite)或者注册的别名(比如Sprite)。
          * @return 类对象
          */
         static getClass(className) {
             var classObject = ClassUtils._classMap[className] || className;
             var glaya = ILaya.Laya;
             if (typeof (classObject) == 'string')
                 return (ILaya.__classMap[classObject] || glaya[className]);
             return classObject;
         }
         /**
          * 根据名称创建 Class 实例。
          * @param	className 类名(比如laya.display.Sprite)或者注册的别名(比如Sprite)。
          * @return	返回类的实例。
          */
         static getInstance(className) {
             var compClass = ClassUtils.getClass(className);
             if (compClass)
                 return new compClass();
             else
                 console.warn("[error] Undefined class:", className);
             return null;
         }
         /**
          * 根据指定的 json 数据创建节点对象。
          * 比如:
          * {
          * 	"type":"Sprite",
          * 	"props":{
          * 		"x":100,
          * 		"y":50,
          * 		"name":"item1",
          * 		"scale":[2,2]
          * 	},
          * 	"customProps":{
          * 		"x":100,
          * 		"y":50,
          * 		"name":"item1",
          * 		"scale":[2,2]
          * 	},
          * 	"child":[
          * 		{
          * 			"type":"Text",
          * 			"props":{
          * 				"text":"this is a test",
          * 				"var":"label",
          * 				"rumtime":""
          * 			}
          * 		}
          * 	]
          * }
          * @param	json json字符串或者Object对象。
          * @param	node node节点，如果为空，则新创建一个。
          * @param	root 根节点，用来设置var定义。
          * @return	生成的节点。
          */
         static createByJson(json, node = null, root = null, customHandler = null, instanceHandler = null) {
             if (typeof (json) == 'string')
                 json = JSON.parse(json);
             var props = json.props;
             if (!node) {
                 node = instanceHandler ? instanceHandler.runWith(json) : ClassUtils.getInstance(props.runtime || json.type);
                 if (!node)
                     return null;
             }
             var child = json.child;
             if (child) {
                 for (var i = 0, n = child.length; i < n; i++) {
                     var data = child[i];
                     if ((data.props.name === "render" || data.props.renderType === "render") && node["_$set_itemRender"])
                         node.itemRender = data;
                     else {
                         if (data.type == "Graphic") {
                             ClassUtils._addGraphicsToSprite(data, node);
                         }
                         else if (ClassUtils._isDrawType(data.type)) {
                             ClassUtils._addGraphicToSprite(data, node, true);
                         }
                         else {
                             var tChild = ClassUtils.createByJson(data, null, root, customHandler, instanceHandler);
                             if (data.type === "Script") {
                                 if ("owner" in tChild) {
                                     tChild["owner"] = node;
                                 }
                                 else if ("target" in tChild) {
                                     tChild["target"] = node;
                                 }
                             }
                             else if (data.props.renderType == "mask") {
                                 node.mask = tChild;
                             }
                             else {
                                 node.addChild(tChild);
                             }
                         }
                     }
                 }
             }
             if (props) {
                 for (var prop in props) {
                     var value = props[prop];
                     if (prop === "var" && root) {
                         root[value] = node;
                     }
                     else if (value instanceof Array && node[prop] instanceof Function) {
                         node[prop].apply(node, value);
                     }
                     else {
                         node[prop] = value;
                     }
                 }
             }
             if (customHandler && json.customProps) {
                 customHandler.runWith([node, json]);
             }
             if (node["created"])
                 node.created();
             return node;
         }
         /**
          * @private
          * 将graphic对象添加到Sprite上
          * @param graphicO graphic对象描述
          */
         static _addGraphicsToSprite(graphicO, sprite) {
             var graphics = graphicO.child;
             if (!graphics || graphics.length < 1)
                 return;
             var g = ClassUtils._getGraphicsFromSprite(graphicO, sprite);
             var ox = 0;
             var oy = 0;
             if (graphicO.props) {
                 ox = ClassUtils._getObjVar(graphicO.props, "x", 0);
                 oy = ClassUtils._getObjVar(graphicO.props, "y", 0);
             }
             if (ox != 0 && oy != 0) {
                 g.translate(ox, oy);
             }
             var i, len;
             len = graphics.length;
             for (i = 0; i < len; i++) {
                 ClassUtils._addGraphicToGraphics(graphics[i], g);
             }
             if (ox != 0 && oy != 0) {
                 g.translate(-ox, -oy);
             }
         }
         /**
          * @private
          * 将graphic绘图指令添加到sprite上
          * @param graphicO 绘图指令描述
          */
         static _addGraphicToSprite(graphicO, sprite, isChild = false) {
             var g = isChild ? ClassUtils._getGraphicsFromSprite(graphicO, sprite) : sprite.graphics;
             ClassUtils._addGraphicToGraphics(graphicO, g);
         }
         /**
          * @private
          */
         static _getGraphicsFromSprite(dataO, sprite) {
             if (!dataO || !dataO.props)
                 return sprite.graphics;
             var propsName = dataO.props.renderType;
             if (propsName === "hit" || propsName === "unHit") {
                 var hitArea = sprite._style.hitArea || (sprite.hitArea = new HitArea());
                 if (!hitArea[propsName]) {
                     hitArea[propsName] = new Graphics();
                 }
                 var g = hitArea[propsName];
             }
             if (!g)
                 g = sprite.graphics;
             return g;
         }
         /**
          * @private
          */
         static _getTransformData(propsO) {
             var m;
             if ("pivotX" in propsO || "pivotY" in propsO) {
                 m = m || new Matrix();
                 m.translate(-ClassUtils._getObjVar(propsO, "pivotX", 0), -ClassUtils._getObjVar(propsO, "pivotY", 0));
             }
             var sx = ClassUtils._getObjVar(propsO, "scaleX", 1), sy = ClassUtils._getObjVar(propsO, "scaleY", 1);
             var rotate = ClassUtils._getObjVar(propsO, "rotation", 0);
             var skewX = ClassUtils._getObjVar(propsO, "skewX", 0);
             var skewY = ClassUtils._getObjVar(propsO, "skewY", 0);
             if (sx != 1 || sy != 1 || rotate != 0) {
                 m = m || new Matrix();
                 m.scale(sx, sy);
                 m.rotate(rotate * 0.0174532922222222);
             }
             return m;
         }
         /**
          * @private
          */
         static _addGraphicToGraphics(graphicO, graphic) {
             var propsO;
             propsO = graphicO.props;
             if (!propsO)
                 return;
             var drawConfig;
             drawConfig = ClassUtils.DrawTypeDic[graphicO.type];
             if (!drawConfig)
                 return;
             var g = graphic;
             var params = ClassUtils._getParams(propsO, drawConfig[1], drawConfig[2], drawConfig[3]);
             var m = ClassUtils._tM;
             if (m || ClassUtils._alpha != 1) {
                 g.save();
                 if (m)
                     g.transform(m);
                 if (ClassUtils._alpha != 1)
                     g.alpha(ClassUtils._alpha);
             }
             g[drawConfig[0]].apply(g, params);
             if (m || ClassUtils._alpha != 1) {
                 g.restore();
             }
         }
         /**
          * @private
          */
         static _adptLineData(params) {
             params[2] = parseFloat(params[0]) + parseFloat(params[2]);
             params[3] = parseFloat(params[1]) + parseFloat(params[3]);
             return params;
         }
         /**
          * @private
          */
         static _adptTextureData(params) {
             params[0] = ILaya.Loader.getRes(params[0]);
             return params;
         }
         /**
          * @private
          */
         static _adptLinesData(params) {
             params[2] = ClassUtils._getPointListByStr(params[2]);
             return params;
         }
         /**
          * @private
          */
         static _isDrawType(type) {
             if (type === "Image")
                 return false;
             return type in ClassUtils.DrawTypeDic;
         }
         /**
          * @private
          */
         static _getParams(obj, params, xPos = 0, adptFun = null) {
             var rst = ClassUtils._temParam;
             rst.length = params.length;
             var i, len;
             len = params.length;
             for (i = 0; i < len; i++) {
                 rst[i] = ClassUtils._getObjVar(obj, params[i][0], params[i][1]);
             }
             ClassUtils._alpha = ClassUtils._getObjVar(obj, "alpha", 1);
             var m;
             m = ClassUtils._getTransformData(obj);
             if (m) {
                 if (!xPos)
                     xPos = 0;
                 m.translate(rst[xPos], rst[xPos + 1]);
                 rst[xPos] = rst[xPos + 1] = 0;
                 ClassUtils._tM = m;
             }
             else {
                 ClassUtils._tM = null;
             }
             if (adptFun && ClassUtils[adptFun]) {
                 rst = ClassUtils[adptFun](rst);
             }
             return rst;
         }
         /**
          * @private
          */
         static _getPointListByStr(str) {
             var pointArr = str.split(",");
             var i, len;
             len = pointArr.length;
             for (i = 0; i < len; i++) {
                 pointArr[i] = parseFloat(pointArr[i]);
             }
             return pointArr;
         }
         /**
          * @private
          */
         static _getObjVar(obj, key, noValue) {
             if (key in obj) {
                 return obj[key];
             }
             return noValue;
         }
     }
     /**@private */
     ClassUtils.DrawTypeDic = { "Rect": ["drawRect", [["x", 0], ["y", 0], ["width", 0], ["height", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Circle": ["drawCircle", [["x", 0], ["y", 0], ["radius", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Pie": ["drawPie", [["x", 0], ["y", 0], ["radius", 0], ["startAngle", 0], ["endAngle", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Image": ["drawTexture", [["x", 0], ["y", 0], ["width", 0], ["height", 0]]], "Texture": ["drawTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0]], 1, "_adptTextureData"], "FillTexture": ["fillTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0], ["repeat", null]], 1, "_adptTextureData"], "FillText": ["fillText", [["text", ""], ["x", 0], ["y", 0], ["font", null], ["color", null], ["textAlign", null]], 1], "Line": ["drawLine", [["x", 0], ["y", 0], ["toX", 0], ["toY", 0], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLineData"], "Lines": ["drawLines", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Curves": ["drawCurves", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Poly": ["drawPoly", [["x", 0], ["y", 0], ["points", ""], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]], 0, "_adptLinesData"] };
     /**@private */
     ClassUtils._temParam = [];
     /**@private */
     ClassUtils._classMap = {
         'Sprite': Sprite,
         'Scene': Scene,
         'Text': Text,
         'Animation': 'Animation',
         'Skeleton': 'Skeleton',
         'Particle2D': 'Particle2D',
         'div': 'HTMLDivParser',
         'p': 'HTMLElement',
         'img': 'HTMLImageElement',
         'span': 'HTMLElement',
         'br': 'HTMLBrElement',
         'style': 'HTMLStyleElement',
         'font': 'HTMLElement',
         'a': 'HTMLElement',
         '#text': 'HTMLElement',
         'link': 'HTMLLinkElement'
     };

     /**
          * <code>Tween</code>  是一个缓动类。使用此类能够实现对目标对象属性的渐变。
          */
     class Tween {
         constructor() {
             /**@private 唯一标识，TimeLintLite用到*/
             this.gid = 0;
             /**重播次数，如果repeat=0，则表示无限循环播放*/
             this.repeat = 1;
             /**当前播放次数*/
             this._count = 0;
         }
         /**
          * 缓动对象的props属性到目标值。
          * @param	target 目标对象(即将更改属性值的对象)。
          * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
          * @param	duration 花费的时间，单位毫秒。
          * @param	ease 缓动类型，默认为匀速运动。
          * @param	complete 结束回调函数。
          * @param	delay 延迟执行时间。
          * @param	coverBefore 是否覆盖之前的缓动。
          * @param	autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。
          * @return	返回Tween对象。
          */
         static to(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false, autoRecover = true) {
             return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, true, autoRecover, true);
         }
         /**
          * 从props属性，缓动到当前状态。
          * @param	target 目标对象(即将更改属性值的对象)。
          * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
          * @param	duration 花费的时间，单位毫秒。
          * @param	ease 缓动类型，默认为匀速运动。
          * @param	complete 结束回调函数。
          * @param	delay 延迟执行时间。
          * @param	coverBefore 是否覆盖之前的缓动。
          * @param	autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。
          * @return	返回Tween对象。
          */
         static from(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false, autoRecover = true) {
             return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, false, autoRecover, true);
         }
         /**
          * 缓动对象的props属性到目标值。
          * @param	target 目标对象(即将更改属性值的对象)。
          * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
          * @param	duration 花费的时间，单位毫秒。
          * @param	ease 缓动类型，默认为匀速运动。
          * @param	complete 结束回调函数。
          * @param	delay 延迟执行时间。
          * @param	coverBefore 是否覆盖之前的缓动。
          * @return	返回Tween对象。
          */
         to(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false) {
             return this._create(target, props, duration, ease, complete, delay, coverBefore, true, false, true);
         }
         /**
          * 从props属性，缓动到当前状态。
          * @param	target 目标对象(即将更改属性值的对象)。
          * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
          * @param	duration 花费的时间，单位毫秒。
          * @param	ease 缓动类型，默认为匀速运动。
          * @param	complete 结束回调函数。
          * @param	delay 延迟执行时间。
          * @param	coverBefore 是否覆盖之前的缓动。
          * @return	返回Tween对象。
          */
         from(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false) {
             return this._create(target, props, duration, ease, complete, delay, coverBefore, false, false, true);
         }
         /** @private */
         _create(target, props, duration, ease, complete, delay, coverBefore, isTo, usePool, runNow) {
             if (!target)
                 throw new Error("Tween:target is null");
             this._target = target;
             this._duration = duration;
             this._ease = ease || props.ease || Tween.easeNone;
             this._complete = complete || props.complete;
             this._delay = delay;
             this._props = [];
             this._usedTimer = 0;
             this._startTimer = Browser.now();
             this._usedPool = usePool;
             this._delayParam = null;
             this.update = props.update;
             //判断是否覆盖			
             var gid = (target.$_GID || (target.$_GID = Utils.getGID()));
             if (!Tween.tweenMap[gid]) {
                 Tween.tweenMap[gid] = [this];
             }
             else {
                 if (coverBefore)
                     Tween.clearTween(target);
                 Tween.tweenMap[gid].push(this);
             }
             if (runNow) {
                 if (delay <= 0)
                     this.firstStart(target, props, isTo);
                 else {
                     this._delayParam = [target, props, isTo];
                     ILaya.timer.once(delay, this, this.firstStart, this._delayParam);
                 }
             }
             else {
                 this._initProps(target, props, isTo);
             }
             return this;
         }
         firstStart(target, props, isTo) {
             this._delayParam = null;
             if (target.destroyed) {
                 this.clear();
                 return;
             }
             this._initProps(target, props, isTo);
             this._beginLoop();
         }
         _initProps(target, props, isTo) {
             //初始化属性
             for (var p in props) {
                 if (typeof (target[p]) == 'number') {
                     var start = isTo ? target[p] : props[p];
                     var end = isTo ? props[p] : target[p];
                     this._props.push([p, start, end - start]);
                     if (!isTo)
                         target[p] = start;
                 }
             }
         }
         _beginLoop() {
             ILaya.timer.frameLoop(1, this, this._doEase);
         }
         /**执行缓动**/
         _doEase() {
             this._updateEase(Browser.now());
         }
         /**@private */
         _updateEase(time) {
             var target = this._target;
             if (!target)
                 return;
             //如果对象被销毁，则立即停止缓动
             if (target.destroyed)
                 return Tween.clearTween(target);
             var usedTimer = this._usedTimer = time - this._startTimer - this._delay;
             if (usedTimer < 0)
                 return;
             if (usedTimer >= this._duration)
                 return this.complete();
             var ratio = usedTimer > 0 ? this._ease(usedTimer, 0, 1, this._duration) : 0;
             var props = this._props;
             for (var i = 0, n = props.length; i < n; i++) {
                 var prop = props[i];
                 target[prop[0]] = prop[1] + (ratio * prop[2]);
             }
             if (this.update)
                 this.update.run();
         }
         /**设置当前执行比例**/
         set progress(v) {
             var uTime = v * this._duration;
             this._startTimer = Browser.now() - this._delay - uTime;
         }
         /**
          * 立即结束缓动并到终点。
          */
         complete() {
             if (!this._target)
                 return;
             //立即执行初始化
             ILaya.timer.runTimer(this, this.firstStart);
             //缓存当前属性
             var target = this._target;
             var props = this._props;
             var handler = this._complete;
             //设置终点属性
             for (var i = 0, n = props.length; i < n; i++) {
                 var prop = props[i];
                 target[prop[0]] = prop[1] + prop[2];
             }
             if (this.update)
                 this.update.run();
             this._count++;
             if (this.repeat != 0 && this._count >= this.repeat) {
                 //清理
                 this.clear();
                 //回调
                 handler && handler.run();
             }
             else {
                 this.restart();
             }
         }
         /**
          * 暂停缓动，可以通过resume或restart重新开始。
          */
         pause() {
             ILaya.timer.clear(this, this._beginLoop);
             ILaya.timer.clear(this, this._doEase);
             ILaya.timer.clear(this, this.firstStart);
             var time = Browser.now();
             var dTime;
             dTime = time - this._startTimer - this._delay;
             if (dTime < 0) {
                 this._usedTimer = dTime;
             }
         }
         /**
          * 设置开始时间。
          * @param	startTime 开始时间。
          */
         setStartTime(startTime) {
             this._startTimer = startTime;
         }
         /**
          * 清理指定目标对象上的所有缓动。
          * @param	target 目标对象。
          */
         static clearAll(target) {
             if (!target || !target.$_GID)
                 return;
             var tweens = Tween.tweenMap[target.$_GID];
             if (tweens) {
                 for (var i = 0, n = tweens.length; i < n; i++) {
                     tweens[i]._clear();
                 }
                 tweens.length = 0;
             }
         }
         /**
          * 清理某个缓动。
          * @param	tween 缓动对象。
          */
         static clear(tween) {
             tween.clear();
         }
         /**@private 同clearAll，废弃掉，尽量别用。*/
         static clearTween(target) {
             Tween.clearAll(target);
         }
         /**
          * 停止并清理当前缓动。
          */
         clear() {
             if (this._target) {
                 this._remove();
                 this._clear();
             }
         }
         /**
          * @private
          */
         _clear() {
             this.pause();
             ILaya.timer.clear(this, this.firstStart);
             this._complete = null;
             this._target = null;
             this._ease = null;
             this._props = null;
             this._delayParam = null;
             if (this._usedPool) {
                 this.update = null;
                 Pool.recover("tween", this);
             }
         }
         /** 回收到对象池。*/
         recover() {
             this._usedPool = true;
             this._clear();
         }
         _remove() {
             var tweens = Tween.tweenMap[this._target.$_GID];
             if (tweens) {
                 for (var i = 0, n = tweens.length; i < n; i++) {
                     if (tweens[i] === this) {
                         tweens.splice(i, 1);
                         break;
                     }
                 }
             }
         }
         /**
          * 重新开始暂停的缓动。
          */
         restart() {
             this.pause();
             this._usedTimer = 0;
             this._startTimer = Browser.now();
             if (this._delayParam) {
                 ILaya.timer.once(this._delay, this, this.firstStart, this._delayParam);
                 return;
             }
             var props = this._props;
             for (var i = 0, n = props.length; i < n; i++) {
                 var prop = props[i];
                 this._target[prop[0]] = prop[1];
             }
             ILaya.timer.once(this._delay, this, this._beginLoop);
         }
         /**
          * 恢复暂停的缓动。
          */
         resume() {
             if (this._usedTimer >= this._duration)
                 return;
             this._startTimer = Browser.now() - this._usedTimer - this._delay;
             if (this._delayParam) {
                 if (this._usedTimer < 0) {
                     ILaya.timer.once(-this._usedTimer, this, this.firstStart, this._delayParam);
                 }
                 else {
                     this.firstStart.apply(this, this._delayParam);
                 }
             }
             else {
                 this._beginLoop();
             }
         }
         static easeNone(t, b, c, d) {
             return c * t / d + b;
         }
     }
     /**@private */
     Tween.tweenMap = [];

     /**
      * @private
      * <code>Dragging</code> 类是触摸滑动控件。
      */
     class Dragging {
         constructor() {
             /** 缓动衰减系数。*/
             this.ratio = 0.92;
             /** 单帧最大偏移量。*/
             this.maxOffset = 60;
             this._dragging = false;
             this._clickOnly = true;
         }
         /**
          * 开始拖拽。
          * @param	target 待拖拽的 <code>Sprite</code> 对象。
          * @param	area 滑动范围。
          * @param	hasInertia 拖动是否有惯性。
          * @param	elasticDistance 橡皮筋最大值。
          * @param	elasticBackTime 橡皮筋回弹时间，单位为毫秒。
          * @param	data 事件携带数据。
          * @param	disableMouseEvent 鼠标事件是否有效。
          * @param	ratio 惯性阻尼系数
          */
         start(target, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio = 0.92) {
             this.clearTimer();
             this.target = target;
             this.area = area;
             this.hasInertia = hasInertia;
             this.elasticDistance = area ? elasticDistance : 0;
             this.elasticBackTime = elasticBackTime;
             this.data = data;
             this._disableMouseEvent = disableMouseEvent;
             this.ratio = ratio;
             this._parent = target.parent;
             this._clickOnly = true;
             this._dragging = true;
             this._elasticRateX = this._elasticRateY = 1;
             this._lastX = this._parent.mouseX;
             this._lastY = this._parent.mouseY;
             ILaya.stage.on(Event.MOUSE_UP, this, this.onStageMouseUp);
             ILaya.stage.on(Event.MOUSE_OUT, this, this.onStageMouseUp);
             //Laya.stage.on(Event.MOUSE_MOVE, this, onStageMouseMove);
             ILaya.systemTimer.frameLoop(1, this, this.loop);
         }
         /**
          * 清除计时器。
          */
         clearTimer() {
             ILaya.systemTimer.clear(this, this.loop);
             ILaya.systemTimer.clear(this, this.tweenMove);
             if (this._tween) {
                 this._tween.recover();
                 this._tween = null;
             }
         }
         /**
          * 停止拖拽。
          */
         stop() {
             if (this._dragging) {
                 MouseManager.instance.disableMouseEvent = false;
                 ILaya.stage.off(Event.MOUSE_UP, this, this.onStageMouseUp);
                 ILaya.stage.off(Event.MOUSE_OUT, this, this.onStageMouseUp);
                 this._dragging = false;
                 this.target && this.area && this.backToArea();
                 this.clear();
             }
         }
         /**
          * 拖拽的循环处理函数。
          */
         loop() {
             var point = this._parent.getMousePoint();
             var mouseX = point.x;
             var mouseY = point.y;
             var offsetX = mouseX - this._lastX;
             var offsetY = mouseY - this._lastY;
             if (this._clickOnly) {
                 if (Math.abs(offsetX * ILaya.stage._canvasTransform.getScaleX()) > 1 || Math.abs(offsetY * ILaya.stage._canvasTransform.getScaleY()) > 1) {
                     this._clickOnly = false;
                     this._offsets || (this._offsets = []);
                     this._offsets.length = 0;
                     this.target.event(Event.DRAG_START, this.data);
                     MouseManager.instance.disableMouseEvent = this._disableMouseEvent;
                     //TODO:
                     //target._set$P("$_MOUSEDOWN", false);
                 }
                 else
                     return;
             }
             else {
                 this._offsets.push(offsetX, offsetY);
             }
             if (offsetX === 0 && offsetY === 0)
                 return;
             this._lastX = mouseX;
             this._lastY = mouseY;
             this.target.x += offsetX * this._elasticRateX;
             this.target.y += offsetY * this._elasticRateY;
             this.area && this.checkArea();
             this.target.event(Event.DRAG_MOVE, this.data);
         }
         /**
          * 拖拽区域检测。
          */
         checkArea() {
             if (this.elasticDistance <= 0) {
                 this.backToArea();
             }
             else {
                 if (this.target._x < this.area.x) {
                     var offsetX = this.area.x - this.target._x;
                 }
                 else if (this.target._x > this.area.x + this.area.width) {
                     offsetX = this.target._x - this.area.x - this.area.width;
                 }
                 else {
                     offsetX = 0;
                 }
                 this._elasticRateX = Math.max(0, 1 - (offsetX / this.elasticDistance));
                 if (this.target._y < this.area.y) {
                     var offsetY = this.area.y - this.target.y;
                 }
                 else if (this.target._y > this.area.y + this.area.height) {
                     offsetY = this.target._y - this.area.y - this.area.height;
                 }
                 else {
                     offsetY = 0;
                 }
                 this._elasticRateY = Math.max(0, 1 - (offsetY / this.elasticDistance));
             }
         }
         /**
          * 移动至设定的拖拽区域。
          */
         backToArea() {
             this.target.x = Math.min(Math.max(this.target._x, this.area.x), this.area.x + this.area.width);
             this.target.y = Math.min(Math.max(this.target._y, this.area.y), this.area.y + this.area.height);
         }
         /**
          * 舞台的抬起事件侦听函数。
          * @param	e Event 对象。
          */
         onStageMouseUp(e) {
             MouseManager.instance.disableMouseEvent = false;
             ILaya.stage.off(Event.MOUSE_UP, this, this.onStageMouseUp);
             ILaya.stage.off(Event.MOUSE_OUT, this, this.onStageMouseUp);
             //Laya.stage.off(Event.MOUSE_MOVE, this, onStageMouseMove);
             ILaya.systemTimer.clear(this, this.loop);
             if (this._clickOnly || !this.target)
                 return;
             //target.mouseEnabled = true;
             if (this.hasInertia) {
                 //计算平均值
                 if (this._offsets.length < 1) {
                     this._offsets.push(this._parent.mouseX - this._lastX, this._parent.mouseY - this._lastY);
                 }
                 this._offsetX = this._offsetY = 0;
                 var len = this._offsets.length;
                 var n = Math.min(len, 6);
                 var m = this._offsets.length - n;
                 for (var i = len - 1; i > m; i--) {
                     this._offsetY += this._offsets[i--];
                     this._offsetX += this._offsets[i];
                 }
                 this._offsetX = this._offsetX / n * 2;
                 this._offsetY = this._offsetY / n * 2;
                 if (Math.abs(this._offsetX) > this.maxOffset)
                     this._offsetX = this._offsetX > 0 ? this.maxOffset : -this.maxOffset;
                 if (Math.abs(this._offsetY) > this.maxOffset)
                     this._offsetY = this._offsetY > 0 ? this.maxOffset : -this.maxOffset;
                 ILaya.systemTimer.frameLoop(1, this, this.tweenMove);
             }
             else if (this.elasticDistance > 0) {
                 this.checkElastic();
             }
             else {
                 this.clear();
             }
         }
         /**
          * 橡皮筋效果检测。
          */
         checkElastic() {
             var tx = NaN;
             var ty = NaN;
             if (this.target.x < this.area.x)
                 tx = this.area.x;
             else if (this.target._x > this.area.x + this.area.width)
                 tx = this.area.x + this.area.width;
             if (this.target.y < this.area.y)
                 ty = this.area.y;
             else if (this.target._y > this.area.y + this.area.height)
                 ty = this.area.y + this.area.height;
             if (!isNaN(tx) || !isNaN(ty)) {
                 var obj = {};
                 if (!isNaN(tx))
                     obj.x = tx;
                 if (!isNaN(ty))
                     obj.y = ty;
                 this._tween = Tween.to(this.target, obj, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.clear), 0, false, false);
             }
             else {
                 this.clear();
             }
         }
         /**
          * 移动。
          */
         tweenMove() {
             this._offsetX *= this.ratio * this._elasticRateX;
             this._offsetY *= this.ratio * this._elasticRateY;
             this.target.x += this._offsetX;
             this.target.y += this._offsetY;
             this.area && this.checkArea();
             this.target.event(Event.DRAG_MOVE, this.data);
             if ((Math.abs(this._offsetX) < 1 && Math.abs(this._offsetY) < 1) || this._elasticRateX < 0.5 || this._elasticRateY < 0.5) {
                 ILaya.systemTimer.clear(this, this.tweenMove);
                 if (this.elasticDistance > 0)
                     this.checkElastic();
                 else
                     this.clear();
             }
         }
         /**
          * 结束拖拽。
          */
         clear() {
             if (this.target) {
                 this.clearTimer();
                 var sp = this.target;
                 this.target = null;
                 this._parent = null;
                 sp.event(Event.DRAG_END, this.data);
             }
         }
     }

     /**
          * @author laya
          */
     class IStatRender {
         /**
          * 显示性能统计信息。
          * @param	x X轴显示位置。
          * @param	y Y轴显示位置。
          */
         show(x = 0, y = 0) {
         }
         /**激活性能统计*/
         enable() {
         }
         /**
          * 隐藏性能统计信息。
          */
         hide() {
         }
         /**
          * 点击性能统计显示区域的处理函数。
          */
         set_onclick(fn) {
         }
         isCanvasRender() {
             return true;
         }
         // 非canvas模式的渲染
         renderNotCanvas(ctx, x, y) { }
     }

     /**
      * 显示Stat的结果。由于stat会引入很多的循环引用，所以把显示部分拆开
      * @author laya
      */
     class StatUI extends IStatRender {
         constructor() {
             super(...arguments);
             /**@private */
             this._show = false;
             this._useCanvas = false;
             this._height = 100;
             this._view = [];
         }
         /**
          * 显示性能统计信息。
          * @param	x X轴显示位置。
          * @param	y Y轴显示位置。
          */
         show(x = 0, y = 0) {
             if (!Browser.onMiniGame && !Browser.onLimixiu && !ILaya.Render.isConchApp && !Browser.onBDMiniGame && !Browser.onKGMiniGame && !Browser.onQGMiniGame)
                 this._useCanvas = true;
             this._show = true;
             Stat._fpsData.length = 60;
             this._view[0] = { title: "FPS(Canvas)", value: "_fpsStr", color: "yellow", units: "int" };
             this._view[1] = { title: "Sprite", value: "_spriteStr", color: "white", units: "int" };
             this._view[2] = { title: "RenderBatches", value: "renderBatches", color: "white", units: "int" };
             this._view[3] = { title: "SavedRenderBatches", value: "savedRenderBatches", color: "white", units: "int" };
             this._view[4] = { title: "CPUMemory", value: "cpuMemory", color: "yellow", units: "M" };
             this._view[5] = { title: "GPUMemory", value: "gpuMemory", color: "yellow", units: "M" };
             this._view[6] = { title: "Shader", value: "shaderCall", color: "white", units: "int" };
             if (!Render.is3DMode) {
                 this._view[0].title = "FPS(WebGL)";
                 this._view[7] = { title: "Canvas", value: "_canvasStr", color: "white", units: "int" };
             }
             else {
                 this._view[0].title = "FPS(3D)";
                 this._view[7] = { title: "TriFaces", value: "trianglesFaces", color: "white", units: "int" };
                 this._view[8] = { title: "FrustumCulling", value: "frustumCulling", color: "white", units: "int" };
                 this._view[9] = { title: "OctreeNodeCulling", value: "octreeNodeCulling", color: "white", units: "int" };
             }
             if (this._useCanvas) {
                 this.createUIPre(x, y);
             }
             else
                 this.createUI(x, y);
             this.enable();
         }
         createUIPre(x, y) {
             var pixel = Browser.pixelRatio;
             this._width = pixel * 180;
             this._vx = pixel * 120;
             this._height = pixel * (this._view.length * 12 + 3 * pixel) + 4;
             StatUI._fontSize = 12 * pixel;
             for (var i = 0; i < this._view.length; i++) {
                 this._view[i].x = 4;
                 this._view[i].y = i * StatUI._fontSize + 2 * pixel;
             }
             if (!this._canvas) {
                 this._canvas = new HTMLCanvas(true);
                 this._canvas.size(this._width, this._height);
                 this._ctx = this._canvas.getContext('2d');
                 this._ctx.textBaseline = "top";
                 this._ctx.font = StatUI._fontSize + "px Arial";
                 this._canvas.source.style.cssText = "pointer-events:none;background:rgba(150,150,150,0.8);z-index:100000;position: absolute;direction:ltr;left:" + x + "px;top:" + y + "px;width:" + (this._width / pixel) + "px;height:" + (this._height / pixel) + "px;";
             }
             if (!Browser.onKGMiniGame) {
                 Browser.container.appendChild(this._canvas.source);
             }
             this._first = true;
             this.loop();
             this._first = false;
         }
         createUI(x, y) {
             var stat = this._sp;
             var pixel = Browser.pixelRatio;
             if (!stat) {
                 stat = new Sprite();
                 this._leftText = new Text();
                 this._leftText.pos(5, 5);
                 this._leftText.color = "#ffffff";
                 stat.addChild(this._leftText);
                 this._txt = new Text();
                 this._txt.pos(80 * pixel, 5);
                 this._txt.color = "#ffffff";
                 stat.addChild(this._txt);
                 this._sp = stat;
             }
             stat.pos(x, y);
             var text = "";
             for (var i = 0; i < this._view.length; i++) {
                 var one = this._view[i];
                 text += one.title + "\n";
             }
             this._leftText.text = text;
             //调整为合适大小和字体			
             var width = pixel * 138;
             var height = pixel * (this._view.length * 12 + 3 * pixel) + 4;
             this._txt.fontSize = StatUI._fontSize * pixel;
             this._leftText.fontSize = StatUI._fontSize * pixel;
             stat.size(width, height);
             stat.graphics.clear();
             stat.graphics.alpha(0.5);
             stat.graphics.drawRect(0, 0, width, height, "#999999");
             stat.graphics.alpha(2);
             this.loop();
         }
         /**激活性能统计*/
         enable() {
             ILaya.systemTimer.frameLoop(1, this, this.loop);
         }
         /**
          * 隐藏性能统计信息。
          */
         hide() {
             this._show = false;
             ILaya.systemTimer.clear(this, this.loop);
             if (this._canvas) {
                 Browser.removeElement(this._canvas.source);
             }
         }
         /**
          * 点击性能统计显示区域的处理函数。
          */
         set_onclick(fn) {
             if (this._sp) {
                 this._sp.on("click", this._sp, fn);
             }
             if (this._canvas) {
                 this._canvas.source.onclick = fn;
                 this._canvas.source.style.pointerEvents = '';
             }
         }
         /**
          * @private
          * 性能统计参数计算循环处理函数。
          */
         loop() {
             Stat._count++;
             var timer = Browser.now();
             if (timer - Stat._timer < 1000)
                 return;
             var count = Stat._count;
             //计算更精确的FPS值
             Stat.FPS = Math.round((count * 1000) / (timer - Stat._timer));
             if (this._show) {
                 //计算平均值
                 Stat.trianglesFaces = Math.round(Stat.trianglesFaces / count);
                 if (!this._useCanvas) {
                     Stat.renderBatches = Math.round(Stat.renderBatches / count) - 1;
                 }
                 else {
                     Stat.renderBatches = Math.round(Stat.renderBatches / count);
                 }
                 Stat.savedRenderBatches = Math.round(Stat.savedRenderBatches / count);
                 Stat.shaderCall = Math.round(Stat.shaderCall / count);
                 Stat.spriteRenderUseCacheCount = Math.round(Stat.spriteRenderUseCacheCount / count);
                 Stat.canvasNormal = Math.round(Stat.canvasNormal / count);
                 Stat.canvasBitmap = Math.round(Stat.canvasBitmap / count);
                 Stat.canvasReCache = Math.ceil(Stat.canvasReCache / count);
                 Stat.frustumCulling = Math.round(Stat.frustumCulling / count);
                 Stat.octreeNodeCulling = Math.round(Stat.octreeNodeCulling / count);
                 var delay = Stat.FPS > 0 ? Math.floor(1000 / Stat.FPS).toString() : " ";
                 Stat._fpsStr = Stat.FPS + (Stat.renderSlow ? " slow" : "") + " " + delay;
                 if (this._useCanvas)
                     Stat._spriteStr = (Stat.spriteCount - 1) + (Stat.spriteRenderUseCacheCount ? ("/" + Stat.spriteRenderUseCacheCount) : '');
                 else
                     Stat._spriteStr = (Stat.spriteCount - 4) + (Stat.spriteRenderUseCacheCount ? ("/" + Stat.spriteRenderUseCacheCount) : '');
                 Stat._canvasStr = Stat.canvasReCache + "/" + Stat.canvasNormal + "/" + Stat.canvasBitmap;
                 Stat.cpuMemory = Resource.cpuMemory;
                 Stat.gpuMemory = Resource.gpuMemory;
                 if (this._useCanvas) {
                     this.renderInfoPre();
                 }
                 else
                     this.renderInfo();
                 Stat.clear();
             }
             Stat._count = 0;
             Stat._timer = timer;
         }
         renderInfoPre() {
             var i = 0;
             var one;
             var value;
             if (this._canvas) {
                 var ctx = this._ctx;
                 ctx.clearRect(this._first ? 0 : this._vx, 0, this._width, this._height);
                 for (i = 0; i < this._view.length; i++) {
                     one = this._view[i];
                     //只有第一次才渲染标题文字，减少文字渲染次数
                     if (this._first) {
                         ctx.fillStyle = "white";
                         ctx.fillText(one.title, one.x, one.y);
                     }
                     ctx.fillStyle = one.color;
                     value = Stat[one.value];
                     (one.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100 + " M");
                     ctx.fillText(value + "", one.x + this._vx, one.y);
                 }
             }
         }
         renderInfo() {
             var text = "";
             for (var i = 0; i < this._view.length; i++) {
                 var one = this._view[i];
                 var value = Stat[one.value];
                 (one.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100 + " M");
                 (one.units == "K") && (value = Math.floor(value / (1024) * 100) / 100 + " K");
                 text += value + "\n";
             }
             this._txt.text = text;
         }
         isCanvasRender() {
             return this._useCanvas;
         }
         // 非canvas模式的渲染
         renderNotCanvas(ctx, x, y) {
             this._show && this._sp && this._sp.render(ctx, 0, 0);
         }
     }
     StatUI._fontSize = 12;

     /**
          * <code>Timer</code> 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。
          */
     class Timer {
         /**
          * 创建 <code>Timer</code> 类的一个实例。
          */
         constructor(autoActive = true) {
             /** 时针缩放。*/
             this.scale = 1;
             /** 当前帧开始的时间。*/
             this.currTimer = Date.now();
             /** 当前的帧数。*/
             this.currFrame = 0;
             /**@private 两帧之间的时间间隔,单位毫秒。*/
             this._delta = 0;
             /**@private */
             this._lastTimer = Date.now();
             /**@private */
             this._map = [];
             /**@private */
             this._handlers = [];
             /**@private */
             this._temp = [];
             /**@private */
             this._count = 0;
             autoActive && Timer.gSysTimer && Timer.gSysTimer.frameLoop(1, this, this._update);
         }
         /**两帧之间的时间间隔,单位毫秒。*/
         get delta() {
             return this._delta;
         }
         /**
          * @private
          * 帧循环处理函数。
          */
         _update() {
             if (this.scale <= 0) {
                 this._lastTimer = Date.now();
                 return;
             }
             var frame = this.currFrame = this.currFrame + this.scale;
             var now = Date.now();
             this._delta = (now - this._lastTimer) * this.scale;
             var timer = this.currTimer = this.currTimer + this._delta;
             this._lastTimer = now;
             //处理handler
             var handlers = this._handlers;
             this._count = 0;
             for (var i = 0, n = handlers.length; i < n; i++) {
                 var handler = handlers[i];
                 if (handler.method !== null) {
                     var t = handler.userFrame ? frame : timer;
                     if (t >= handler.exeTime) {
                         if (handler.repeat) {
                             if (!handler.jumpFrame) {
                                 handler.exeTime += handler.delay;
                                 handler.run(false);
                                 if (t > handler.exeTime) {
                                     //如果执行一次后还能再执行，做跳出处理，如果想用多次执行，需要设置jumpFrame=true
                                     handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
                                 }
                             }
                             else {
                                 while (t >= handler.exeTime) {
                                     handler.exeTime += handler.delay;
                                     handler.run(false);
                                 }
                             }
                         }
                         else {
                             handler.run(true);
                         }
                     }
                 }
                 else {
                     this._count++;
                 }
             }
             if (this._count > 30 || frame % 200 === 0)
                 this._clearHandlers();
         }
         /** @private */
         _clearHandlers() {
             var handlers = this._handlers;
             for (var i = 0, n = handlers.length; i < n; i++) {
                 var handler = handlers[i];
                 if (handler.method !== null)
                     this._temp.push(handler);
                 else
                     this._recoverHandler(handler);
             }
             this._handlers = this._temp;
             handlers.length = 0;
             this._temp = handlers;
         }
         /** @private */
         _recoverHandler(handler) {
             if (this._map[handler.key] == handler)
                 this._map[handler.key] = null;
             handler.clear();
             Timer._pool.push(handler);
         }
         /** @private */
         _create(useFrame, repeat, delay, caller, method, args, coverBefore) {
             //如果延迟为0，则立即执行
             if (!delay) {
                 method.apply(caller, args);
                 return null;
             }
             //先覆盖相同函数的计时
             if (coverBefore) {
                 var handler = this._getHandler(caller, method);
                 if (handler) {
                     handler.repeat = repeat;
                     handler.userFrame = useFrame;
                     handler.delay = delay;
                     handler.caller = caller;
                     handler.method = method;
                     handler.args = args;
                     handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);
                     return handler;
                 }
             }
             //找到一个空闲的timerHandler
             handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();
             handler.repeat = repeat;
             handler.userFrame = useFrame;
             handler.delay = delay;
             handler.caller = caller;
             handler.method = method;
             handler.args = args;
             handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);
             //索引handler
             this._indexHandler(handler);
             //插入数组
             this._handlers.push(handler);
             return handler;
         }
         /** @private */
         _indexHandler(handler) {
             var caller = handler.caller;
             var method = handler.method;
             var cid = caller ? caller.$_GID || (caller.$_GID = ILaya.Utils.getGID()) : 0;
             var mid = method.$_TID || (method.$_TID = (Timer._mid++) * 100000);
             handler.key = cid + mid;
             this._map[handler.key] = handler;
         }
         /**
          * 定时执行一次。
          * @param	delay	延迟时间(单位为毫秒)。
          * @param	caller	执行域(this)。
          * @param	method	定时器回调函数。
          * @param	args	回调参数。
          * @param	coverBefore	是否覆盖之前的延迟执行，默认为 true 。
          */
         once(delay, caller, method, args = null, coverBefore = true) {
             this._create(false, false, delay, caller, method, args, coverBefore);
         }
         /**
          * 定时重复执行。
          * @param	delay	间隔时间(单位毫秒)。
          * @param	caller	执行域(this)。
          * @param	method	定时器回调函数。
          * @param	args	回调参数。
          * @param	coverBefore	是否覆盖之前的延迟执行，默认为 true 。
          * @param	jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
          */
         loop(delay, caller, method, args = null, coverBefore = true, jumpFrame = false) {
             var handler = this._create(false, true, delay, caller, method, args, coverBefore);
             if (handler)
                 handler.jumpFrame = jumpFrame;
         }
         /**
          * 定时执行一次(基于帧率)。
          * @param	delay	延迟几帧(单位为帧)。
          * @param	caller	执行域(this)。
          * @param	method	定时器回调函数。
          * @param	args	回调参数。
          * @param	coverBefore	是否覆盖之前的延迟执行，默认为 true 。
          */
         frameOnce(delay, caller, method, args = null, coverBefore = true) {
             this._create(true, false, delay, caller, method, args, coverBefore);
         }
         /**
          * 定时重复执行(基于帧率)。
          * @param	delay	间隔几帧(单位为帧)。
          * @param	caller	执行域(this)。
          * @param	method	定时器回调函数。
          * @param	args	回调参数。
          * @param	coverBefore	是否覆盖之前的延迟执行，默认为 true 。
          */
         frameLoop(delay, caller, method, args = null, coverBefore = true) {
             this._create(true, true, delay, caller, method, args, coverBefore);
         }
         /** 返回统计信息。*/
         toString() {
             return " handlers:" + this._handlers.length + " pool:" + Timer._pool.length;
         }
         /**
          * 清理定时器。
          * @param	caller 执行域(this)。
          * @param	method 定时器回调函数。
          */
         clear(caller, method) {
             var handler = this._getHandler(caller, method);
             if (handler) {
                 this._map[handler.key] = null;
                 handler.key = 0;
                 handler.clear();
             }
         }
         /**
          * 清理对象身上的所有定时器。
          * @param	caller 执行域(this)。
          */
         clearAll(caller) {
             if (!caller)
                 return;
             for (var i = 0, n = this._handlers.length; i < n; i++) {
                 var handler = this._handlers[i];
                 if (handler.caller === caller) {
                     this._map[handler.key] = null;
                     handler.key = 0;
                     handler.clear();
                 }
             }
         }
         /** @private */
         _getHandler(caller, method) {
             var cid = caller ? caller.$_GID || (caller.$_GID = ILaya.Utils.getGID()) : 0;
             var mid = method.$_TID || (method.$_TID = (Timer._mid++) * 100000);
             return this._map[cid + mid];
         }
         /**
          * 延迟执行。
          * @param	caller 执行域(this)。
          * @param	method 定时器回调函数。
          * @param	args 回调参数。
          */
         callLater(caller, method, args = null) {
             CallLater.I.callLater(caller, method, args);
         }
         /**
          * 立即执行 callLater 。
          * @param	caller 执行域(this)。
          * @param	method 定时器回调函数。
          */
         runCallLater(caller, method) {
             CallLater.I.runCallLater(caller, method);
         }
         /**
          * 立即提前执行定时器，执行之后从队列中删除
          * @param	caller 执行域(this)。
          * @param	method 定时器回调函数。
          */
         runTimer(caller, method) {
             var handler = this._getHandler(caller, method);
             if (handler && handler.method != null) {
                 this._map[handler.key] = null;
                 handler.run(true);
             }
         }
         /**
          * 暂停时钟
          */
         pause() {
             this.scale = 0;
         }
         /**
          * 恢复时钟
          */
         resume() {
             this.scale = 1;
         }
     }
     /**@private */
     Timer.gSysTimer = null;
     /**@private */
     Timer._pool = [];
     /**@private */
     Timer._mid = 1;
     /** @private */
     class TimerHandler {
         clear() {
             this.caller = null;
             this.method = null;
             this.args = null;
         }
         run(withClear) {
             var caller = this.caller;
             if (caller && caller.destroyed)
                 return this.clear();
             var method = this.method;
             var args = this.args;
             withClear && this.clear();
             if (method == null)
                 return;
             args ? method.apply(caller, args) : method.call(caller);
         }
     }

     class SkinSV extends Value2D {
         //TODO:coverage
         constructor(type) {
             super(ShaderDefines2D.SKINMESH, 0);
             this.offsetX = 300;
             this.offsetY = 0;
             var _vlen = 8 * CONST3D2D.BYTES_PE;
             this.position = [2, WebGLContext.FLOAT, false, _vlen, 0];
             this.texcoord = [2, WebGLContext.FLOAT, false, _vlen, 2 * CONST3D2D.BYTES_PE];
             this.color = [4, WebGLContext.FLOAT, false, _vlen, 4 * CONST3D2D.BYTES_PE];
         }
     }

     class PrimitiveSV extends Value2D {
         constructor(args) {
             super(ShaderDefines2D.PRIMITIVE, 0);
             this._attribLocation = ['position', 0, 'attribColor', 1]; // , 'clipDir', 2, 'clipRect', 3];
         }
     }

     class TextureSV extends Value2D {
         constructor(subID = 0) {
             super(ShaderDefines2D.TEXTURE2D, subID);
             this.strength = 0;
             this.blurInfo = null;
             this.colorMat = null;
             this.colorAlpha = null;
             this._attribLocation = ['posuv', 0, 'attribColor', 1, 'attribFlags', 2]; // , 'clipDir', 3, 'clipRect', 4];
         }
         /*override*/ clear() {
             this.texture = null;
             this.shader = null;
             this.defines._value = this.subID + (WebGL.shaderHighPrecision ? ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION : 0);
             //defines.setValue(0);
         }
     }
     // 放在这里容易导致这个文件被排除
     //Value2D._initone(ShaderDefines2D.TEXTURE2D, TextureSV);
     //Value2D._initone(ShaderDefines2D.TEXTURE2D | ShaderDefines2D.FILTERGLOW, TextureSV);

     //import { ShaderCompile } from "././ShaderCompile";
     class InlcudeFile {
         constructor(txt) {
             this.codes = {};
             this.funs = {};
             this.curUseID = -1;
             this.funnames = "";
             this.script = txt;
             var begin = 0, ofs, end;
             while (true) {
                 begin = txt.indexOf("#begin", begin);
                 if (begin < 0)
                     break;
                 end = begin + 5;
                 while (true) {
                     end = txt.indexOf("#end", end);
                     if (end < 0)
                         break;
                     if (txt.charAt(end + 4) === 'i')
                         end += 5;
                     else
                         break;
                 }
                 if (end < 0) {
                     throw "add include err,no #end:" + txt;
                 }
                 ofs = txt.indexOf('\n', begin);
                 var words = ILaya.ShaderCompile.splitToWords(txt.substr(begin, ofs - begin), null);
                 if (words[1] == 'code') {
                     this.codes[words[2]] = txt.substr(ofs + 1, end - ofs - 1);
                 }
                 else if (words[1] == 'function') //#begin function void test()
                  {
                     ofs = txt.indexOf("function", begin);
                     ofs += "function".length;
                     this.funs[words[3]] = txt.substr(ofs + 1, end - ofs - 1);
                     this.funnames += words[3] + ";";
                 }
                 begin = end + 1;
             }
         }
         getWith(name = null) {
             var r = name ? this.codes[name] : this.script;
             if (!r) {
                 throw "get with error:" + name;
             }
             return r;
         }
         getFunsScript(funsdef) {
             var r = "";
             for (var i in this.funs) {
                 if (funsdef.indexOf(i + ";") >= 0) {
                     r += this.funs[i];
                 }
             }
             return r;
         }
     }

     //	import { ShaderCompile } from "./ShaderCompile"
     class ShaderNode {
         constructor(includefiles) {
             this.childs = [];
             this.text = "";
             this.useFuns = "";
             this.z = 0;
             this.includefiles = includefiles;
         }
         setParent(parent) {
             parent.childs.push(this);
             this.z = parent.z + 1;
             this.parent = parent;
         }
         setCondition(condition, type) {
             if (condition) {
                 this.conditionType = type;
                 condition = condition.replace(/(\s*$)/g, "");
                 this.condition = function () {
                     return this[condition];
                 };
                 this.condition.__condition = condition;
             }
         }
         toscript(def, out) {
             return this._toscript(def, out, ++ShaderNode.__id);
         }
         _toscript(def, out, id) {
             if (this.childs.length < 1 && !this.text)
                 return out;
             var outIndex = out.length;
             if (this.condition) {
                 var ifdef = !!this.condition.call(def);
                 this.conditionType === ILaya.ShaderCompile.IFDEF_ELSE && (ifdef = !ifdef);
                 if (!ifdef)
                     return out;
             }
             this.text && out.push(this.text);
             this.childs.length > 0 && this.childs.forEach(function (o, index, arr) {
                 o._toscript(def, out, id);
             });
             if (this.includefiles.length > 0 && this.useFuns.length > 0) {
                 var funsCode;
                 for (var i = 0, n = this.includefiles.length; i < n; i++) {
                     //如果已经加入了，就不要再加
                     if (this.includefiles[i].curUseID == id) {
                         continue;
                     }
                     funsCode = this.includefiles[i].file.getFunsScript(this.useFuns);
                     if (funsCode.length > 0) {
                         this.includefiles[i].curUseID = id;
                         out[0] = funsCode + out[0];
                     }
                 }
             }
             return out;
         }
     }
     ShaderNode.__id = 1;

     /**
      * @private
      * <code>ShaderCompile</code> 类用于实现Shader编译。
      */
     class ShaderCompile {
         constructor(vs, ps, nameMap) {
             this.defs = {};
             let _this = this;
             function _compile(script) {
                 script = script.replace(ShaderCompile._clearCR, ""); //CRLF风格需要先去掉“\r",否则切分字符会出错导致宏定义编译错误等
                 var includefiles = [];
                 var top = new ShaderNode(includefiles);
                 _this._compileToTree(top, script.split('\n'), 0, includefiles, _this.defs);
                 return top;
             }
             //先要去掉注释,还没有完成
             var startTime = Date.now();
             this._VS = _compile(vs);
             this._PS = _compile(ps);
             this._nameMap = nameMap;
             if ((Date.now() - startTime) > 2)
                 console.log("ShaderCompile use time:" + (Date.now() - startTime) + "  size:" + vs.length + "/" + ps.length);
         }
         //TODO:coverage
         static _parseOne(attributes, uniforms, words, i, word, b) {
             var one = { type: ShaderCompile.shaderParamsMap[words[i + 1]], name: words[i + 2], size: isNaN(parseInt(words[i + 3])) ? 1 : parseInt(words[i + 3]) };
             if (b) {
                 if (word == "attribute") {
                     attributes.push(one);
                 }
                 else {
                     uniforms.push(one);
                 }
             }
             if (words[i + 3] == ':') {
                 one.type = words[i + 4];
                 i += 2;
             }
             i += 2;
             return i;
         }
         static addInclude(fileName, txt) {
             if (!txt || txt.length === 0)
                 throw new Error("add shader include file err:" + fileName);
             if (ShaderCompile.includes[fileName])
                 throw new Error("add shader include file err, has add:" + fileName);
             ShaderCompile.includes[fileName] = new InlcudeFile(txt);
         }
         //TODO:coverage
         static preGetParams(vs, ps) {
             var text = [vs, ps];
             var result = {};
             var attributes = [];
             var uniforms = [];
             var definesInfo = {};
             var definesName = [];
             result.attributes = attributes;
             result.uniforms = uniforms;
             result.defines = definesInfo;
             var i, n;
             for (var s = 0; s < 2; s++) {
                 text[s] = text[s].replace(ShaderCompile._removeAnnotation, "");
                 var words = text[s].match(ShaderCompile._reg);
                 var tempelse;
                 for (i = 0, n = words.length; i < n; i++) {
                     var word = words[i];
                     if (word != "attribute" && word != "uniform") {
                         if (word == "#define") {
                             word = words[++i];
                             definesName[word] = 1;
                             continue;
                         }
                         else if (word == "#ifdef") {
                             tempelse = words[++i];
                             var def = definesInfo[tempelse] = definesInfo[tempelse] || [];
                             for (i++; i < n; i++) {
                                 word = words[i];
                                 if (word != "attribute" && word != "uniform") {
                                     if (word == "#else") {
                                         for (i++; i < n; i++) {
                                             word = words[i];
                                             if (word != "attribute" && word != "uniform") {
                                                 if (word == "#endif") {
                                                     break;
                                                 }
                                                 continue;
                                             }
                                             i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, !definesName[tempelse]);
                                         }
                                     }
                                     continue;
                                 }
                                 i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, definesName[tempelse]);
                             }
                         }
                         continue;
                     }
                     i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, true);
                 }
             }
             return result;
         }
         static splitToWords(str, block) {
             var out = [];
             /*
                var words:Array = str.split(_splitToWordExps);
                trace(str);
                trace(words);
              */
             var c;
             var ofs = -1;
             var word;
             for (var i = 0, n = str.length; i < n; i++) {
                 c = str.charAt(i);
                 if (" \t=+-*/&%!<>()'\",;".indexOf(c) >= 0) {
                     if (ofs >= 0 && (i - ofs) > 1) {
                         word = str.substr(ofs, i - ofs);
                         out.push(word);
                     }
                     if (c == '"' || c == "'") {
                         var ofs2 = str.indexOf(c, i + 1);
                         if (ofs2 < 0) {
                             throw "Sharder err:" + str;
                         }
                         out.push(str.substr(i + 1, ofs2 - i - 1));
                         i = ofs2;
                         ofs = -1;
                         continue;
                     }
                     if (c == '(' && block && out.length > 0) {
                         word = out[out.length - 1] + ";";
                         if ("vec4;main;".indexOf(word) < 0)
                             block.useFuns += word;
                     }
                     ofs = -1;
                     continue;
                 }
                 if (ofs < 0)
                     ofs = i;
             }
             if (ofs < n && (n - ofs) > 1) {
                 word = str.substr(ofs, n - ofs);
                 out.push(word);
             }
             return out;
         }
         /**
          * @private
          */
         _compileToTree(parent, lines, start, includefiles, defs) {
             var node, preNode;
             var text, name, fname;
             var ofs, words, noUseNode;
             var i, n, j;
             for (i = start; i < lines.length; i++) {
                 text = lines[i];
                 if (text.length < 1)
                     continue;
                 ofs = text.indexOf("//");
                 if (ofs === 0)
                     continue;
                 if (ofs >= 0)
                     text = text.substr(0, ofs);
                 node = noUseNode || new ShaderNode(includefiles);
                 noUseNode = null;
                 node.text = text;
                 node.noCompile = true;
                 if ((ofs = text.indexOf("#")) >= 0) {
                     name = "#";
                     for (j = ofs + 1, n = text.length; j < n; j++) {
                         var c = text.charAt(j);
                         if (c === ' ' || c === '\t' || c === '?')
                             break;
                         name += c;
                     }
                     node.name = name;
                     switch (name) {
                         case "#ifdef":
                         case "#ifndef":
                             node.src = text;
                             node.noCompile = text.match(/[!&|()=<>]/) != null;
                             if (!node.noCompile) {
                                 words = text.replace(/^\s*/, '').split(/\s+/);
                                 node.setCondition(words[1], name === "#ifdef" ? ShaderCompile.IFDEF_YES : ShaderCompile.IFDEF_ELSE);
                                 node.text = "//" + node.text;
                             }
                             else {
                                 console.log("function():Boolean{return " + text.substr(ofs + node.name.length) + "}");
                             }
                             node.setParent(parent);
                             parent = node;
                             if (defs) {
                                 words = text.substr(j).split(ShaderCompile._splitToWordExps3);
                                 for (j = 0; j < words.length; j++) {
                                     text = words[j];
                                     text.length && (defs[text] = true);
                                 }
                             }
                             continue;
                         case "#if":
                             node.src = text;
                             node.noCompile = true;
                             node.setParent(parent);
                             parent = node;
                             if (defs) {
                                 words = text.substr(j).split(ShaderCompile._splitToWordExps3);
                                 for (j = 0; j < words.length; j++) {
                                     text = words[j];
                                     text.length && text != "defined" && (defs[text] = true);
                                 }
                             }
                             continue;
                         case "#else":
                             node.src = text;
                             parent = parent.parent;
                             preNode = parent.childs[parent.childs.length - 1];
                             node.noCompile = preNode.noCompile;
                             if (!node.noCompile) {
                                 node.condition = preNode.condition;
                                 node.conditionType = preNode.conditionType == ShaderCompile.IFDEF_YES ? ShaderCompile.IFDEF_ELSE : ShaderCompile.IFDEF_YES;
                                 node.text = "//" + node.text + " " + preNode.text + " " + node.conditionType;
                             }
                             node.setParent(parent);
                             parent = node;
                             continue;
                         case "#endif":
                             parent = parent.parent;
                             preNode = parent.childs[parent.childs.length - 1];
                             node.noCompile = preNode.noCompile;
                             if (!node.noCompile) {
                                 node.text = "//" + node.text;
                             }
                             node.setParent(parent);
                             continue;
                         case "#include": //这里有问题,主要是空格
                             words = ShaderCompile.splitToWords(text, null);
                             var inlcudeFile = ShaderCompile.includes[words[1]];
                             if (!inlcudeFile) {
                                 throw "ShaderCompile error no this include file:" + words[1];
                             }
                             if ((ofs = words[0].indexOf("?")) < 0) {
                                 node.setParent(parent);
                                 text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
                                 this._compileToTree(node, text.split('\n'), 0, includefiles, defs);
                                 node.text = "";
                                 continue;
                             }
                             node.setCondition(words[0].substr(ofs + 1), ShaderCompile.IFDEF_YES);
                             node.text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
                             break;
                         case "#import":
                             words = ShaderCompile.splitToWords(text, null);
                             fname = words[1];
                             includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });
                             continue;
                     }
                 }
                 else {
                     preNode = parent.childs[parent.childs.length - 1];
                     if (preNode && !preNode.name) {
                         includefiles.length > 0 && ShaderCompile.splitToWords(text, preNode);
                         noUseNode = node;
                         preNode.text += "\n" + text;
                         continue;
                     }
                     includefiles.length > 0 && ShaderCompile.splitToWords(text, node);
                 }
                 node.setParent(parent);
             }
         }
         createShader(define, shaderName, createShader, bindAttrib) {
             var defMap = {};
             var defineStr = "";
             if (define) {
                 for (var i in define) {
                     defineStr += "#define " + i + "\n";
                     defMap[i] = true;
                 }
             }
             var vs = this._VS.toscript(defMap, []);
             var ps = this._PS.toscript(defMap, []);
             return (createShader || Shader.create)(defineStr + vs.join('\n'), defineStr + ps.join('\n'), shaderName, this._nameMap, bindAttrib);
         }
     }
     ShaderCompile.IFDEF_NO = 0;
     ShaderCompile.IFDEF_YES = 1;
     ShaderCompile.IFDEF_ELSE = 2;
     ShaderCompile.IFDEF_PARENT = 3;
     ShaderCompile._removeAnnotation = new RegExp("(/\\*([^*]|[\\r\\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)", "g");
     ShaderCompile._reg = new RegExp("(\".*\")|('.*')|([#\\w\\*-\\.+/()=<>{}\\\\]+)|([,;:\\\\])", "g");
     ShaderCompile._splitToWordExps = new RegExp("[(\".*\")]+|[('.*')]+|([ \\t=\\+\\-*/&%!<>!%\(\),;])", "g");
     ShaderCompile.includes = {};
     ShaderCompile.shaderParamsMap = { "float": WebGLContext.FLOAT, "int": WebGLContext.INT, "bool": WebGLContext.BOOL, "vec2": WebGLContext.FLOAT_VEC2, "vec3": WebGLContext.FLOAT_VEC3, "vec4": WebGLContext.FLOAT_VEC4, "ivec2": WebGLContext.INT_VEC2, "ivec3": WebGLContext.INT_VEC3, "ivec4": WebGLContext.INT_VEC4, "bvec2": WebGLContext.BOOL_VEC2, "bvec3": WebGLContext.BOOL_VEC3, "bvec4": WebGLContext.BOOL_VEC4, "mat2": WebGLContext.FLOAT_MAT2, "mat3": WebGLContext.FLOAT_MAT3, "mat4": WebGLContext.FLOAT_MAT4, "sampler2D": WebGLContext.SAMPLER_2D, "samplerCube": WebGLContext.SAMPLER_CUBE };
     ShaderCompile._clearCR = new RegExp("\r", "g");
     ShaderCompile._splitToWordExps3 = new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]", "g");

     /**
      * @private
      * Worker Image加载器
      */
     class WorkerLoader extends EventDispatcher {
         constructor() {
             super();
             this.worker = new Worker(WorkerLoader.workerPath);
             this.worker.onmessage = function (evt) {
                 //接收worker传过来的数据函数
                 this.workerMessage(evt.data);
             };
         }
         /**
          * 尝试使用Work加载Image
          * @return 是否启动成功
          */
         static __init__() {
             if (WorkerLoader._preLoadFun != null)
                 return false;
             if (!Worker)
                 return false;
             WorkerLoader._preLoadFun = Loader["prototype"]["_loadImage"];
             Loader["prototype"]["_loadImage"] = WorkerLoader["prototype"]["_loadImage"];
             if (!WorkerLoader.I)
                 WorkerLoader.I = new WorkerLoader();
             return true;
         }
         /**
          * 是否支持worker
          * @return 是否支持worker
          */
         static workerSupported() {
             return Worker ? true : false;
         }
         /**
          * 尝试启用WorkerLoader,只有第一次调用有效
          */
         static enableWorkerLoader() {
             if (!WorkerLoader._tryEnabled) {
                 WorkerLoader.enable = true;
                 WorkerLoader._tryEnabled = true;
             }
         }
         /**
          * 是否启用。
          */
         static set enable(value) {
             if (WorkerLoader._enable != value) {
                 WorkerLoader._enable = value;
                 if (value && WorkerLoader._preLoadFun == null)
                     WorkerLoader._enable = WorkerLoader.__init__();
             }
         }
         static get enable() {
             return WorkerLoader._enable;
         }
         /**
          * @private
          */
         workerMessage(data) {
             if (data) {
                 switch (data.type) {
                     case "Image":
                         this.imageLoaded(data);
                         break;
                     case "Disable":
                         WorkerLoader.enable = false;
                         break;
                 }
             }
         }
         /**
          * @private
          */
         imageLoaded(data) {
             if (!data.dataType || data.dataType != "imageBitmap") {
                 this.event(data.url, null);
                 return;
             }
             var imageData = data.imageBitmap; // imageBitmap
             var tex = new Texture2D();
             tex.loadImageSource(imageData);
             console.log("load:", data.url);
             //canvas = tex;
             this.event(data.url, tex);
         }
         /**
          * 加载图片
          * @param	url 图片地址
          */
         loadImage(url) {
             this.worker.postMessage(url);
         }
         /**
          * @private
          * 加载图片资源。
          * @param	url 资源地址。
          */
         _loadImage(url) {
             var _this = this;
             if (!this._useWorkerLoader || !WorkerLoader._enable) {
                 WorkerLoader._preLoadFun.call(_this, url);
                 return;
             }
             url = URL.formatURL(url);
             function clear() {
                 WorkerLoader.I.off(url, _this, onload);
             }
             var onload = function (image) {
                 clear();
                 if (image) {
                     _this["onLoaded"](image);
                 }
                 else {
                     //失败之后使用原版的加载函数加载重试
                     WorkerLoader._preLoadFun.call(_this, url);
                 }
             };
             WorkerLoader.I.on(url, _this, onload);
             WorkerLoader.I.loadImage(url);
         }
     }
     /**worker.js的路径 */
     WorkerLoader.workerPath = "libs/workerloader.js";
     /**@private */
     WorkerLoader._enable = false;
     /**@private */
     WorkerLoader._tryEnabled = false;

     /**
      * <code>Laya</code> 是全局对象的引用入口集。
      * Laya类引用了一些常用的全局对象，比如Laya.stage：舞台，Laya.timer：时间管理器，Laya.loader：加载管理器，使用时注意大小写。
      */
     class Laya {
         /**
          * 初始化引擎。使用引擎需要先初始化引擎，否则可能会报错。
          * @param	width 初始化的游戏窗口宽度，又称设计宽度。
          * @param	height	初始化的游戏窗口高度，又称设计高度。
          * @param	plugins 插件列表，比如 WebGL（使用WebGL方式渲染）。
          * @return	返回原生canvas引用，方便对canvas属性进行修改
          */
         static init(width, height, ...plugins) {
             if (Laya._isinit)
                 return;
             Laya._isinit = true;
             ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = Laya._arrayBufferSlice);
             Browser.__init__();
             // 创建主画布
             //这个其实在Render中感觉更合理，但是runtime要求第一个canvas是主画布，所以必须在下面的那个离线画布之前
             var mainCanv = Browser.mainCanvas = new HTMLCanvas(true);
             //Render._mainCanvas = mainCanv;
             var style = mainCanv.source.style;
             style.position = 'absolute';
             style.top = style.left = "0px";
             style.background = "#000000";
             if (!Browser.onKGMiniGame) {
                 Browser.container.appendChild(mainCanv.source); //xiaosong add
             }
             // 创建离屏画布
             //创建离线画布
             Browser.canvas = new HTMLCanvas(true);
             Browser.context = Browser.canvas.getContext('2d');
             Browser.supportWebAudio = SoundManager.__init__();
             Browser.supportLocalStorage = LocalStorage.__init__();
             //temp TODO 以后分包
             Laya.systemTimer = new Timer(false);
             Timer.gSysTimer = Laya.systemTimer;
             Laya.startTimer = new Timer(false);
             Laya.physicsTimer = new Timer(false);
             Laya.updateTimer = new Timer(false);
             Laya.lateTimer = new Timer(false);
             Laya.timer = new Timer(false);
             ILaya.startTimer = Laya.startTimer;
             ILaya.lateTimer = Laya.lateTimer;
             ILaya.updateTimer = Laya.updateTimer;
             ILaya.systemTimer = Laya.systemTimer;
             ILaya.timer = Laya.timer;
             ILaya.physicsTimer = Laya.physicsTimer;
             Laya.loader = new LoaderManager();
             ILaya.Laya = Laya;
             ILaya.loader = Laya.loader;
             WeakObject.__init__();
             WebGL.inner_enable();
             for (var i = 0, n = plugins.length; i < n; i++) {
                 if (plugins[i] && plugins[i].enable) {
                     plugins[i].enable();
                 }
             }
             if (ILaya.Render.isConchApp) {
                 Laya.enableNative();
             }
             CacheManger.beginCheck();
             Laya._currentStage = Laya.stage = new Stage();
             ILaya.stage = Laya.stage;
             Utils.gStage = Laya.stage;
             URL.rootPath = URL._basePath = Laya._getUrlPath();
             Laya.render = new Render(0, 0, Browser.mainCanvas);
             Laya.stage.size(width, height);
             window.stage = Laya.stage;
             RenderSprite.__init__();
             KeyBoardManager.__init__();
             MouseManager.instance.__init__(Laya.stage, Render.canvas);
             Input.__init__();
             SoundManager.autoStopMusic = true;
             Stat._StatRender = new StatUI();
             Value2D._initone(ShaderDefines2D.TEXTURE2D, TextureSV);
             Value2D._initone(ShaderDefines2D.TEXTURE2D | ShaderDefines2D.FILTERGLOW, TextureSV);
             Value2D._initone(ShaderDefines2D.PRIMITIVE, PrimitiveSV);
             Value2D._initone(ShaderDefines2D.SKINMESH, SkinSV);
             return Render.canvas;
         }
         /**@private */
         static _getUrlPath() {
             var location = Browser.window.location;
             var pathName = location.pathname;
             // 索引为2的字符如果是':'就是windows file协议
             pathName = pathName.charAt(2) == ':' ? pathName.substring(1) : pathName;
             return URL.getPath(location.protocol == "file:" ? pathName : location.protocol + "//" + location.host + location.pathname);
         }
         /**@private */
         static _arrayBufferSlice(start, end) {
             var arr = this;
             var arrU8List = new Uint8Array(arr, start, end - start);
             var newU8List = new Uint8Array(arrU8List.length);
             newU8List.set(arrU8List);
             return newU8List.buffer;
         }
         /**
          * 表示是否捕获全局错误并弹出提示。默认为false。
          * 适用于移动设备等不方便调试的时候，设置为true后，如有未知错误，可以弹窗抛出详细错误堆栈。
          */
         static set alertGlobalError(value) {
             var erralert = 0;
             if (value) {
                 Browser.window.onerror = function (msg, url, line, column, detail) {
                     if (erralert++ < 5 && detail)
                         this.alert("出错啦，请把此信息截图给研发商\n" + msg + "\n" + detail.stack);
                 };
             }
             else {
                 Browser.window.onerror = null;
             }
         }
         /**@private */
         static _runScript(script) {
             return Browser.window[Laya._evcode](script);
         }
         /**
          * 开启DebugPanel
          * @param	debugJsPath laya.debugtool.js文件路径
          */
         static enableDebugPanel(debugJsPath = "libs/laya.debugtool.js") {
             if (!Laya["DebugPanel"]) {
                 var script = Browser.createElement("script");
                 script.onload = function () {
                     Laya["DebugPanel"].enable();
                 };
                 script.src = debugJsPath;
                 Browser.document.body.appendChild(script);
             }
             else {
                 Laya["DebugPanel"].enable();
             }
         }
         /**@private */
         static enableNative() {
             if (Laya.isNativeRender_enable)
                 return;
             Laya.isNativeRender_enable = true;
             WebGLContext.__init_native();
             Shader.prototype.uploadTexture2D = function (value) {
                 var CTX = WebGLContext;
                 CTX.bindTexture(WebGLContext.mainContext, CTX.TEXTURE_2D, value);
             };
             RenderState2D.width = Browser.window.innerWidth;
             RenderState2D.height = Browser.window.innerHeight;
             Browser.measureText = function (txt, font) {
                 window["conchTextCanvas"].font = font;
                 return window["conchTextCanvas"].measureText(txt);
             };
             Stage.clear = function (color) {
                 Context.set2DRenderConfig(); //渲染2D前要还原2D状态,否则可能受3D影响
                 var c = ColorUtils.create(color).arrColor;
                 var gl = LayaGL.instance;
                 if (c)
                     gl.clearColor(c[0], c[1], c[2], c[3]);
                 gl.clear(WebGLContext.COLOR_BUFFER_BIT | WebGLContext.DEPTH_BUFFER_BIT | WebGLContext.STENCIL_BUFFER_BIT);
                 RenderState2D.clear();
             };
             Sprite.drawToCanvas = Sprite.drawToTexture = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
                 offsetX -= sprite.x;
                 offsetY -= sprite.y;
                 offsetX |= 0;
                 offsetY |= 0;
                 canvasWidth |= 0;
                 canvasHeight |= 0;
                 var canv = new HTMLCanvas(false);
                 var ctx = canv.getContext('2d');
                 canv.size(canvasWidth, canvasHeight);
                 ctx.asBitmap = true;
                 ctx._targets.start();
                 RenderSprite.renders[_renderType]._fun(sprite, ctx, offsetX, offsetY);
                 ctx.flush();
                 ctx._targets.end();
                 ctx._targets.restore();
                 return canv;
             };
             //RenderTexture2D.prototype._uv = RenderTexture2D.flipyuv;
             Object["defineProperty"](RenderTexture2D.prototype, "uv", {
                 "get": function () {
                     return this._uv;
                 },
                 "set": function (v) {
                     this._uv = v;
                 }
             });
             HTMLCanvas.prototype.getTexture = function () {
                 if (!this._texture) {
                     this._texture = this.context._targets;
                     this._texture.uv = RenderTexture2D.flipyuv;
                     this._texture.bitmap = this._texture;
                 }
                 return this._texture;
             };
             if (Render.supportWebGLPlusRendering) {
                 LayaGLRunner.uploadShaderUniforms = LayaGLRunner.uploadShaderUniformsForNative;
                 //替换buffer的函数
                 window.CommandEncoder = window.GLCommandEncoder;
                 window.LayaGL = window.LayaGLContext;
             }
         }
     }
     /*[COMPILER OPTIONS:normal]*/
     /** 舞台对象的引用。*/
     Laya.stage = null;
     /**@private 系统时钟管理器，引擎内部使用*/
     Laya.systemTimer = null;
     /**@private 组件的start时钟管理器*/
     Laya.startTimer = null;
     /**@private 组件的物理时钟管理器*/
     Laya.physicsTimer = null;
     /**@private 组件的update时钟管理器*/
     Laya.updateTimer = null;
     /**@private 组件的lateUpdate时钟管理器*/
     Laya.lateTimer = null;
     /**游戏主时针，同时也是管理场景，动画，缓动等效果时钟，通过控制本时针缩放，达到快进慢播效果*/
     Laya.timer = null;
     /** 加载管理器的引用。*/
     Laya.loader = null;
     /** 当前引擎版本。*/
     Laya.version = "2.1.0beta";
     /**@private */
     Laya._isinit = false;
     /**是否是微信小游戏子域，默认为false**/
     Laya.isWXOpenDataContext = false;
     /**微信小游戏是否需要在主域中自动将加载的文本数据自动传递到子域，默认 false**/
     Laya.isWXPosMsg = false;
     /**@private @internal*/
     Laya.__classmap = null;
     Laya._evcode = "eva" + "l";
     Laya.isNativeRender_enable = false;
     Laya.__classmap = ILaya.__classMap;
     ILaya.Timer = Timer;
     ILaya.Dragging = Dragging;
     ILaya.GraphicsBounds = GraphicsBounds;
     ILaya.Sprite = Sprite;
     ILaya.TextRender = TextRender;
     ILaya.Loader = Loader;
     ILaya.TTFLoader = TTFLoader;
     ILaya.WebAudioSound = WebAudioSound;
     ILaya.SoundManager = SoundManager;
     ILaya.ShaderCompile = ShaderCompile;
     ILaya.ClassUtils = ClassUtils;
     ILaya.SceneUtils = SceneUtils;
     ILaya.Context = Context;
     ILaya.Render = Render;
     ILaya.MouseManager = MouseManager;
     ILaya.Text = Text;
     ILaya.Browser = Browser;
     ILaya.WebGL = WebGL;
     ILaya.AudioSound = AudioSound;
     ILaya.Pool = Pool;
     ILaya.Utils = Utils;
     ILaya.Graphics = Graphics;
     ILaya.Submit = Submit;
     ILaya.Stage = Stage;
     ILaya.Resource = Resource;
     ILaya.WorkerLoader = WorkerLoader;
     //初始化引擎库
     var libs = window._layalibs;
     if (libs) {
         libs.sort(function (a, b) {
             return a.i - b.i;
         });
         for (var j = 0; j < libs.length; j++) {
             libs[j].f(window, window.document, Laya);
         }
     }
     window.Laya = Laya;
     function regClassToEngine(cls) {
         if (cls.name) {
             Laya[cls.name] = cls;
         }
     }
     regClassToEngine(TextRender);
     regClassToEngine(Stage);
     regClassToEngine(Render);
     regClassToEngine(Browser);
     regClassToEngine(Sprite);
     regClassToEngine(Node);
     regClassToEngine(Context);
     regClassToEngine(WebGL);

     /**
      * <code>Color</code> 类用于创建颜色实例。
      */
     class Color {
         /**
          * 创建一个 <code>Color</code> 实例。
          * @param	r  颜色的red分量。
          * @param	g  颜色的green分量。
          * @param	b  颜色的blue分量。
          * @param	a  颜色的alpha分量。
          */
         constructor(r = 1, g = 1, b = 1, a = 1) {
             this.r = r;
             this.g = g;
             this.b = b;
             this.a = a;
         }
         // http://www.opengl.org/registry/specs/EXT/framebuffer_sRGB.txt
         // http://www.opengl.org/registry/specs/EXT/texture_sRGB_decode.txt
         // {  cs / 12.92,                 cs <= 0.04045 }
         // {  ((cs + 0.055)/1.055)^2.4,   cs >  0.04045 }
         static gammaToLinearSpace(value) {
             if (value <= 0.04045)
                 return value / 12.92;
             else if (value < 1.0)
                 return Math.pow((value + 0.055) / 1.055, 2.4);
             else
                 return Math.pow(value, 2.4);
         }
         // http://www.opengl.org/registry/specs/EXT/framebuffer_sRGB.txt
         // http://www.opengl.org/registry/specs/EXT/texture_sRGB_decode.txt
         // {  0.0,                          0         <= cl
         // {  12.92 * c,                    0         <  cl < 0.0031308
         // {  1.055 * cl^0.41666 - 0.055,   0.0031308 <= cl < 1
         // {  1.0,                                       cl >= 1  <- This has been adjusted since we want to maintain HDR colors
         static linearToGammaSpace(value) {
             if (value <= 0.0)
                 return 0.0;
             else if (value <= 0.0031308)
                 return 12.92 * value;
             else if (value <= 1.0)
                 return 1.055 * Math.pow(value, 0.41666) - 0.055;
             else
                 return Math.pow(value, 0.41666);
         }
         /**
          * Gamma空间转换到线性空间。
          * @param	linear 线性空间颜色。
          */
         toLinear(out) {
             out.r = Color.gammaToLinearSpace(this.r);
             out.g = Color.gammaToLinearSpace(this.g);
             out.b = Color.gammaToLinearSpace(this.b);
         }
         /**
          * 线性空间转换到Gamma空间。
          * @param	gamma Gamma空间颜色。
          */
         toGamma(out) {
             out.r = Color.linearToGammaSpace(this.r);
             out.g = Color.linearToGammaSpace(this.g);
             out.b = Color.linearToGammaSpace(this.b);
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destColor = destObject;
             destColor.r = this.r;
             destColor.g = this.g;
             destColor.b = this.b;
             destColor.a = this.a;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new Color();
             this.cloneTo(dest);
             return dest;
         }
         forNativeElement() {
             /*if (nativeElements) {
                 this.elements = nativeElements;
                 this.elements[0] = this.r;
                 this.elements[1] = this.g;
                 this.elements[2] = this.b;
                 this.elements[3] = this.a;
             } else {
                 this.elements = new Float32Array([this.r,this.g,this.b,this.a]);
             }
             Vector2.rewriteNumProperty(this, "r", 0);
             Vector2.rewriteNumProperty(this, "g", 1);
             Vector2.rewriteNumProperty(this, "b", 2);
             Vector2.rewriteNumProperty(this, "a", 3);*/
         }
     }
     /**
      * 红色
      */
     Color.RED = new Color(1, 0, 0, 1);
     /**
      * 绿色
      */
     Color.GREEN = new Color(0, 1, 0, 1);
     /**
      * 蓝色
      */
     Color.BLUE = new Color(0, 0, 1, 1);
     /**
      * 蓝绿色
      */
     Color.CYAN = new Color(0, 1, 1, 1);
     /**
      * 黄色
      */
     Color.YELLOW = new Color(1, 0.92, 0.016, 1);
     /**
      * 品红色
      */
     Color.MAGENTA = new Color(1, 0, 1, 1);
     /**
      * 灰色
      */
     Color.GRAY = new Color(0.5, 0.5, 0.5, 1);
     /**
      * 白色
      */
     Color.WHITE = new Color(1, 1, 1, 1);
     /**
      * 黑色
      */
     Color.BLACK = new Color(0, 0, 0, 1);

     /**
          * <code>MathUtils</code> 类用于创建数学工具。
          */
     class MathUtils3D {
         /**
          * 创建一个 <code>MathUtils</code> 实例。
          */
         constructor() {
         }
         /**
          * 是否在容差的范围内近似于0
          * @param  判断值
          * @return  是否近似于0
          */
         static isZero(v) {
             return Math.abs(v) < MathUtils3D.zeroTolerance;
         }
         /**
          * 两个值是否在容差的范围内近似相等Sqr Magnitude
          * @param  判断值
          * @return  是否近似于0
          */
         static nearEqual(n1, n2) {
             if (MathUtils3D.isZero(n1 - n2))
                 return true;
             return false;
         }
         static fastInvSqrt(value) {
             if (MathUtils3D.isZero(value))
                 return value;
             return 1.0 / Math.sqrt(value);
         }
     }
     /**单精度浮点(float)零的容差*/
     MathUtils3D.zeroTolerance = 1e-6;
     /**浮点数默认最大值*/
     MathUtils3D.MaxValue = 3.40282347e+38;
     /**浮点数默认最小值*/
     MathUtils3D.MinValue = -3.40282347e+38;

     /**
      * <code>Vector2</code> 类用于创建二维向量。
      */
     class Vector2 {
         /**
          * 创建一个 <code>Vector2</code> 实例。
          * @param	x  X轴坐标。
          * @param	y  Y轴坐标。
          */
         constructor(x = 0, y = 0) {
             this.x = x;
             this.y = y;
         }
         /**
          * 设置xy值。
          * @param	x X值。
          * @param	y Y值。
          */
         setValue(x, y) {
             this.x = x;
             this.y = y;
         }
         /**
          * 缩放二维向量。
          * @param	a 源二维向量。
          * @param	b 缩放值。
          * @param	out 输出二维向量。
          */
         static scale(a, b, out) {
             out.x = a.x * b;
             out.y = a.y * b;
         }
         /**
          * 从Array数组拷贝值。
          * @param  array 数组。
          * @param  offset 数组偏移。
          */
         fromArray(array, offset = 0) {
             this.x = array[offset + 0];
             this.y = array[offset + 1];
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destVector2 = destObject;
             destVector2.x = this.x;
             destVector2.y = this.y;
         }
         /**
          * 求两个二维向量的点积。
          * @param	a left向量。
          * @param	b right向量。
          * @return   点积。
          */
         static dot(a, b) {
             return (a.x * b.x) + (a.y * b.y);
         }
         /**
          * 归一化二维向量。
          * @param	s 源三维向量。
          * @param	out 输出三维向量。
          */
         static normalize(s, out) {
             var x = s.x, y = s.y;
             var len = x * x + y * y;
             if (len > 0) {
                 len = 1 / Math.sqrt(len);
                 out.x = x * len;
                 out.y = y * len;
             }
         }
         /**
          * 计算标量长度。
          * @param	a 源三维向量。
          * @return 标量长度。
          */
         static scalarLength(a) {
             var x = a.x, y = a.y;
             return Math.sqrt(x * x + y * y);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destVector2 = new Vector2();
             this.cloneTo(destVector2);
             return destVector2;
         }
         forNativeElement(nativeElements = null) {
             if (nativeElements) {
                 this.elements = nativeElements;
                 this.elements[0] = this.x;
                 this.elements[1] = this.y;
             }
             else {
                 this.elements = new Float32Array([this.x, this.y]);
             }
             Vector2.rewriteNumProperty(this, "x", 0);
             Vector2.rewriteNumProperty(this, "y", 1);
         }
         static rewriteNumProperty(proto, name, index) {
             Object["defineProperty"](proto, name, {
                 "get": function () {
                     return this.elements[index];
                 },
                 "set": function (v) {
                     this.elements[index] = v;
                 }
             });
         }
     }
     /**零向量,禁止修改*/
     Vector2.ZERO = new Vector2(0.0, 0.0);
     /**一向量,禁止修改*/
     Vector2.ONE = new Vector2(1.0, 1.0);

     /**
      * <code>Vector4</code> 类用于创建四维向量。
      */
     class Vector4 {
         /**
          * 创建一个 <code>Vector4</code> 实例。
          * @param	x  X轴坐标。
          * @param	y  Y轴坐标。
          * @param	z  Z轴坐标。
          * @param	w  W轴坐标。
          */
         constructor(x = 0, y = 0, z = 0, w = 0) {
             this.x = x;
             this.y = y;
             this.z = z;
             this.w = w;
         }
         /**
          * 设置xyzw值。
          * @param	x X值。
          * @param	y Y值。
          * @param	z Z值。
          * @param	w W值。
          */
         setValue(x, y, z, w) {
             this.x = x;
             this.y = y;
             this.z = z;
             this.w = w;
         }
         /**
          * 从Array数组拷贝值。
          * @param  array 数组。
          * @param  offset 数组偏移。
          */
         fromArray(array, offset = 0) {
             this.x = array[offset + 0];
             this.y = array[offset + 1];
             this.z = array[offset + 2];
             this.w = array[offset + 3];
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destVector4 = destObject;
             destVector4.x = this.x;
             destVector4.y = this.y;
             destVector4.z = this.z;
             destVector4.w = this.w;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destVector4 = new Vector4();
             this.cloneTo(destVector4);
             return destVector4;
         }
         /**
          * 插值四维向量。
          * @param	a left向量。
          * @param	b right向量。
          * @param	t 插值比例。
          * @param	out 输出向量。
          */
         static lerp(a, b, t, out) {
             var ax = a.x, ay = a.y, az = a.z, aw = a.w;
             out.x = ax + t * (b.x - ax);
             out.y = ay + t * (b.y - ay);
             out.z = az + t * (b.z - az);
             out.w = aw + t * (b.w - aw);
         }
         /**
          * 通过4x4矩阵把一个四维向量转换为另一个四维向量
          * @param	vector4 带转换四维向量。
          * @param	M4x4    4x4矩阵。
          * @param	out     转换后四维向量。
          */
         static transformByM4x4(vector4, m4x4, out) {
             var vx = vector4.x;
             var vy = vector4.y;
             var vz = vector4.z;
             var vw = vector4.w;
             var me = m4x4.elements;
             out.x = vx * me[0] + vy * me[4] + vz * me[8] + vw * me[12];
             out.y = vx * me[1] + vy * me[5] + vz * me[9] + vw * me[13];
             out.z = vx * me[2] + vy * me[6] + vz * me[10] + vw * me[14];
             out.w = vx * me[3] + vy * me[7] + vz * me[11] + vw * me[15];
         }
         /**
          * 判断两个四维向量是否相等。
          * @param	a 四维向量。
          * @param	b 四维向量。
          * @return  是否相等。
          */
         static equals(a, b) {
             return MathUtils3D.nearEqual(Math.abs(a.x), Math.abs(b.x)) && MathUtils3D.nearEqual(Math.abs(a.y), Math.abs(b.y)) && MathUtils3D.nearEqual(Math.abs(a.z), Math.abs(b.z)) && MathUtils3D.nearEqual(Math.abs(a.w), Math.abs(b.w));
         }
         /**
          * 求四维向量的长度。
          * @return  长度。
          */
         length() {
             return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
         }
         /**
          * 求四维向量长度的平方。
          * @return  长度的平方。
          */
         lengthSquared() {
             return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
         }
         /**
          * 归一化四维向量。
          * @param	s   源四维向量。
          * @param	out 输出四维向量。
          */
         static normalize(s, out) {
             var len = s.length();
             if (len > 0) {
                 out.x = s.x * len;
                 out.y = s.y * len;
                 out.z = s.z * len;
                 out.w = s.w * len;
             }
         }
         /**
          * 求两个四维向量的和。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 输出向量。
          */
         static add(a, b, out) {
             out.x = a.x + b.x;
             out.y = a.y + b.y;
             out.z = a.z + b.z;
             out.w = a.w + b.w;
         }
         /**
          * 求两个四维向量的差。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 输出向量。
          */
         static subtract(a, b, out) {
             out.x = a.x - b.x;
             out.y = a.y - b.y;
             out.z = a.z - b.z;
             out.w = a.w - b.w;
         }
         /**
          * 计算两个四维向量的乘积。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 输出向量。
          */
         static multiply(a, b, out) {
             out.x = a.x * b.x;
             out.y = a.y * b.y;
             out.z = a.z * b.z;
             out.w = a.w * b.w;
         }
         /**
          * 缩放四维向量。
          * @param	a   源四维向量。
          * @param	b   缩放值。
          * @param	out 输出四维向量。
          */
         static scale(a, b, out) {
             out.x = a.x * b;
             out.y = a.y * b;
             out.z = a.z * b;
             out.w = a.w * b;
         }
         /**
          * 求一个指定范围的四维向量
          * @param	value clamp向量
          * @param	min   最小
          * @param	max   最大
          * @param   out   输出向量
          */
         static Clamp(value, min, max, out) {
             var x = value.x;
             var y = value.y;
             var z = value.z;
             var w = value.w;
             var mineX = min.x;
             var mineY = min.y;
             var mineZ = min.z;
             var mineW = min.w;
             var maxeX = max.x;
             var maxeY = max.y;
             var maxeZ = max.z;
             var maxeW = max.w;
             x = (x > maxeX) ? maxeX : x;
             x = (x < mineX) ? mineX : x;
             y = (y > maxeY) ? maxeY : y;
             y = (y < mineY) ? mineY : y;
             z = (z > maxeZ) ? maxeZ : z;
             z = (z < mineZ) ? mineZ : z;
             w = (w > maxeW) ? maxeW : w;
             w = (w < mineW) ? mineW : w;
             out.x = x;
             out.y = y;
             out.z = z;
             out.w = w;
         }
         /**
          * 两个四维向量距离的平方。
          * @param	value1 向量1。
          * @param	value2 向量2。
          * @return	距离的平方。
          */
         static distanceSquared(value1, value2) {
             var x = value1.x - value2.x;
             var y = value1.y - value2.y;
             var z = value1.z - value2.z;
             var w = value1.w - value2.w;
             return (x * x) + (y * y) + (z * z) + (w * w);
         }
         /**
          * 两个四维向量距离。
          * @param	value1 向量1。
          * @param	value2 向量2。
          * @return	距离。
          */
         static distance(value1, value2) {
             var x = value1.x - value2.x;
             var y = value1.y - value2.y;
             var z = value1.z - value2.z;
             var w = value1.w - value2.w;
             return Math.sqrt((x * x) + (y * y) + (z * z) + (w * w));
         }
         /**
          * 求两个四维向量的点积。
          * @param	a 向量。
          * @param	b 向量。
          * @return  点积。
          */
         static dot(a, b) {
             return (a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w);
         }
         /**
          * 分别取两个四维向量x、y、z的最小值计算新的四维向量。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 结果三维向量。
          */
         static min(a, b, out) {
             out.x = Math.min(a.x, b.x);
             out.y = Math.min(a.y, b.y);
             out.z = Math.min(a.z, b.z);
             out.w = Math.min(a.w, b.w);
         }
         /**
          * 分别取两个四维向量x、y、z的最大值计算新的四维向量。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 结果三维向量。
          */
         static max(a, b, out) {
             out.x = Math.max(a.x, b.x);
             out.y = Math.max(a.y, b.y);
             out.z = Math.max(a.z, b.z);
             out.w = Math.max(a.w, b.w);
         }
         forNativeElement(nativeElements = null) {
             if (nativeElements) {
                 this.elements = nativeElements;
                 this.elements[0] = this.x;
                 this.elements[1] = this.y;
                 this.elements[2] = this.z;
                 this.elements[3] = this.w;
             }
             else {
                 this.elements = new Float32Array([this.x, this.y, this.z, this.w]);
             }
             Vector2.rewriteNumProperty(this, "x", 0);
             Vector2.rewriteNumProperty(this, "y", 1);
             Vector2.rewriteNumProperty(this, "z", 2);
             Vector2.rewriteNumProperty(this, "w", 3);
         }
     }
     /**零向量，禁止修改*/
     Vector4.ZERO = new Vector4();
     /*一向量，禁止修改*/
     Vector4.ONE = new Vector4(1.0, 1.0, 1.0, 1.0);
     /*X单位向量，禁止修改*/
     Vector4.UnitX = new Vector4(1.0, 0.0, 0.0, 0.0);
     /*Y单位向量，禁止修改*/
     Vector4.UnitY = new Vector4(0.0, 1.0, 0.0, 0.0);
     /*Z单位向量，禁止修改*/
     Vector4.UnitZ = new Vector4(0.0, 0.0, 1.0, 0.0);
     /*W单位向量，禁止修改*/
     Vector4.UnitW = new Vector4(0.0, 0.0, 0.0, 1.0);

     /**
      * <code>Vector3</code> 类用于创建三维向量。
      */
     class Vector3 {
         /**
          * 创建一个 <code>Vector3</code> 实例。
          * @param	x  X轴坐标。
          * @param	y  Y轴坐标。
          * @param	z  Z轴坐标。
          */
         constructor(x = 0, y = 0, z = 0, nativeElements = null /*[NATIVE]*/) {
             this.x = x;
             this.y = y;
             this.z = z;
         }
         /**
          * 两个三维向量距离的平方。
          * @param	value1 向量1。
          * @param	value2 向量2。
          * @return	距离的平方。
          */
         static distanceSquared(value1, value2) {
             var x = value1.x - value2.x;
             var y = value1.y - value2.y;
             var z = value1.z - value2.z;
             return (x * x) + (y * y) + (z * z);
         }
         /**
          * 两个三维向量距离。
          * @param	value1 向量1。
          * @param	value2 向量2。
          * @return	距离。
          */
         static distance(value1, value2) {
             var x = value1.x - value2.x;
             var y = value1.y - value2.y;
             var z = value1.z - value2.z;
             return Math.sqrt((x * x) + (y * y) + (z * z));
         }
         /**
          * 分别取两个三维向量x、y、z的最小值计算新的三维向量。
          * @param	a。
          * @param	b。
          * @param	out。
          */
         static min(a, b, out) {
             out.x = Math.min(a.x, b.x);
             out.y = Math.min(a.y, b.y);
             out.z = Math.min(a.z, b.z);
         }
         /**
          * 分别取两个三维向量x、y、z的最大值计算新的三维向量。
          * @param	a a三维向量。
          * @param	b b三维向量。
          * @param	out 结果三维向量。
          */
         static max(a, b, out) {
             out.x = Math.max(a.x, b.x);
             out.y = Math.max(a.y, b.y);
             out.z = Math.max(a.z, b.z);
         }
         /**
          * 根据四元数旋转三维向量。
          * @param	source 源三维向量。
          * @param	rotation 旋转四元数。
          * @param	out 输出三维向量。
          */
         static transformQuat(source, rotation, out) {
             var x = source.x, y = source.y, z = source.z, qx = rotation.x, qy = rotation.y, qz = rotation.z, qw = rotation.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
             out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
             out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
             out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
         }
         /**
          * 计算标量长度。
          * @param	a 源三维向量。
          * @return 标量长度。
          */
         static scalarLength(a) {
             var x = a.x, y = a.y, z = a.z;
             return Math.sqrt(x * x + y * y + z * z);
         }
         /**
          * 计算标量长度的平方。
          * @param	a 源三维向量。
          * @return 标量长度的平方。
          */
         static scalarLengthSquared(a) {
             var x = a.x, y = a.y, z = a.z;
             return x * x + y * y + z * z;
         }
         /**
          * 归一化三维向量。
          * @param	s 源三维向量。
          * @param	out 输出三维向量。
          */
         static normalize(s, out) {
             var x = s.x, y = s.y, z = s.z;
             var len = x * x + y * y + z * z;
             if (len > 0) {
                 len = 1 / Math.sqrt(len);
                 out.x = s.x * len;
                 out.y = s.y * len;
                 out.z = s.z * len;
             }
         }
         /**
          * 计算两个三维向量的乘积。
          * @param	a left三维向量。
          * @param	b right三维向量。
          * @param	out 输出三维向量。
          */
         static multiply(a, b, out) {
             out.x = a.x * b.x;
             out.y = a.y * b.y;
             out.z = a.z * b.z;
         }
         /**
          * 缩放三维向量。
          * @param	a 源三维向量。
          * @param	b 缩放值。
          * @param	out 输出三维向量。
          */
         static scale(a, b, out) {
             out.x = a.x * b;
             out.y = a.y * b;
             out.z = a.z * b;
         }
         /**
          * 插值三维向量。
          * @param	a left向量。
          * @param	b right向量。
          * @param	t 插值比例。
          * @param	out 输出向量。
          */
         static lerp(a, b, t, out) {
             var ax = a.x, ay = a.y, az = a.z;
             out.x = ax + t * (b.x - ax);
             out.y = ay + t * (b.y - ay);
             out.z = az + t * (b.z - az);
         }
         /**
          * 通过矩阵转换一个三维向量到另外一个三维向量。
          * @param	vector 源三维向量。
          * @param	transform  变换矩阵。
          * @param	result 输出三维向量。
          */
         static transformV3ToV3(vector, transform, result) {
             var intermediate = Vector3._tempVector4;
             Vector3.transformV3ToV4(vector, transform, intermediate);
             result.x = intermediate.x;
             result.y = intermediate.y;
             result.z = intermediate.z;
         }
         /**
          * 通过矩阵转换一个三维向量到另外一个四维向量。
          * @param	vector 源三维向量。
          * @param	transform  变换矩阵。
          * @param	result 输出四维向量。
          */
         static transformV3ToV4(vector, transform, result) {
             var vectorX = vector.x;
             var vectorY = vector.y;
             var vectorZ = vector.z;
             var transformElem = transform.elements;
             result.x = (vectorX * transformElem[0]) + (vectorY * transformElem[4]) + (vectorZ * transformElem[8]) + transformElem[12];
             result.y = (vectorX * transformElem[1]) + (vectorY * transformElem[5]) + (vectorZ * transformElem[9]) + transformElem[13];
             result.z = (vectorX * transformElem[2]) + (vectorY * transformElem[6]) + (vectorZ * transformElem[10]) + transformElem[14];
             result.w = (vectorX * transformElem[3]) + (vectorY * transformElem[7]) + (vectorZ * transformElem[11]) + transformElem[15];
         }
         /**
          * 通过法线矩阵转换一个法线三维向量到另外一个三维向量。
          * @param	normal 源法线三维向量。
          * @param	transform  法线变换矩阵。
          * @param	result 输出法线三维向量。
          */
         static TransformNormal(normal, transform, result) {
             var normalX = normal.x;
             var normalY = normal.y;
             var normalZ = normal.z;
             var transformElem = transform.elements;
             result.x = (normalX * transformElem[0]) + (normalY * transformElem[4]) + (normalZ * transformElem[8]);
             result.y = (normalX * transformElem[1]) + (normalY * transformElem[5]) + (normalZ * transformElem[9]);
             result.z = (normalX * transformElem[2]) + (normalY * transformElem[6]) + (normalZ * transformElem[10]);
         }
         /**
          * 通过矩阵转换一个三维向量到另外一个归一化的三维向量。
          * @param	vector 源三维向量。
          * @param	transform  变换矩阵。
          * @param	result 输出三维向量。
          */
         static transformCoordinate(coordinate, transform, result) {
             var coordinateX = coordinate.x;
             var coordinateY = coordinate.y;
             var coordinateZ = coordinate.z;
             var transformElem = transform.elements;
             var w = ((coordinateX * transformElem[3]) + (coordinateY * transformElem[7]) + (coordinateZ * transformElem[11]) + transformElem[15]);
             result.x = (coordinateX * transformElem[0]) + (coordinateY * transformElem[4]) + (coordinateZ * transformElem[8]) + transformElem[12] / w;
             result.y = (coordinateX * transformElem[1]) + (coordinateY * transformElem[5]) + (coordinateZ * transformElem[9]) + transformElem[13] / w;
             result.z = (coordinateX * transformElem[2]) + (coordinateY * transformElem[6]) + (coordinateZ * transformElem[10]) + transformElem[14] / w;
         }
         /**
          * 求一个指定范围的向量
          * @param	value clamp向量
          * @param	min  最小
          * @param	max  最大
          * @param   out 输出向量
          */
         static Clamp(value, min, max, out) {
             var x = value.x;
             var y = value.y;
             var z = value.z;
             var mineX = min.x;
             var mineY = min.y;
             var mineZ = min.z;
             var maxeX = max.x;
             var maxeY = max.y;
             var maxeZ = max.z;
             x = (x > maxeX) ? maxeX : x;
             x = (x < mineX) ? mineX : x;
             y = (y > maxeY) ? maxeY : y;
             y = (y < mineY) ? mineY : y;
             z = (z > maxeZ) ? maxeZ : z;
             z = (z < mineZ) ? mineZ : z;
             out.x = x;
             out.y = y;
             out.z = z;
         }
         /**
          * 求两个三维向量的和。
          * @param	a left三维向量。
          * @param	b right三维向量。
          * @param	out 输出向量。
          */
         static add(a, b, out) {
             out.x = a.x + b.x;
             out.y = a.y + b.y;
             out.z = a.z + b.z;
         }
         /**
          * 求两个三维向量的差。
          * @param	a  left三维向量。
          * @param	b  right三维向量。
          * @param	o out 输出向量。
          */
         static subtract(a, b, o) {
             o.x = a.x - b.x;
             o.y = a.y - b.y;
             o.z = a.z - b.z;
         }
         /**
          * 求两个三维向量的叉乘。
          * @param	a left向量。
          * @param	b right向量。
          * @param	o 输出向量。
          */
         static cross(a, b, o) {
             var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
             o.x = ay * bz - az * by;
             o.y = az * bx - ax * bz;
             o.z = ax * by - ay * bx;
         }
         /**
          * 求两个三维向量的点积。
          * @param	a left向量。
          * @param	b right向量。
          * @return   点积。
          */
         static dot(a, b) {
             return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
         }
         /**
          * 判断两个三维向量是否相等。
          * @param	a 三维向量。
          * @param	b 三维向量。
          * @return  是否相等。
          */
         static equals(a, b) {
             return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y) && MathUtils3D.nearEqual(a.z, b.z);
         }
         /**
          * 设置xyz值。
          * @param	x X值。
          * @param	y Y值。
          * @param	z Z值。
          */
         setValue(x, y, z) {
             this.x = x;
             this.y = y;
             this.z = z;
         }
         /**
          * 从Array数组拷贝值。
          * @param  array 数组。
          * @param  offset 数组偏移。
          */
         fromArray(array, offset = 0) {
             this.x = array[offset + 0];
             this.y = array[offset + 1];
             this.z = array[offset + 2];
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destVector3 = destObject;
             destVector3.x = this.x;
             destVector3.y = this.y;
             destVector3.z = this.z;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destVector3 = new Vector3();
             this.cloneTo(destVector3);
             return destVector3;
         }
         toDefault() {
             this.x = 0;
             this.y = 0;
             this.z = 0;
         }
         forNativeElement(nativeElements = null) {
             if (nativeElements) {
                 this.elements = nativeElements;
                 this.elements[0] = this.x;
                 this.elements[1] = this.y;
                 this.elements[2] = this.z;
             }
             else {
                 this.elements = new Float32Array([this.x, this.y, this.z]);
             }
             Vector2.rewriteNumProperty(this, "x", 0);
             Vector2.rewriteNumProperty(this, "y", 1);
             Vector2.rewriteNumProperty(this, "z", 2);
         }
     }
     /**@private	*/
     Vector3._tempVector4 = new Vector4();
     /**@private	*/
     Vector3._ZERO = new Vector3(0.0, 0.0, 0.0);
     /**@private	*/
     Vector3._ONE = new Vector3(1.0, 1.0, 1.0);
     /**@private	*/
     Vector3._NegativeUnitX = new Vector3(-1, 0, 0);
     /**@private	*/
     Vector3._UnitX = new Vector3(1, 0, 0);
     /**@private	*/
     Vector3._UnitY = new Vector3(0, 1, 0);
     /**@private	*/
     Vector3._UnitZ = new Vector3(0, 0, 1);
     /**@private	*/
     Vector3._ForwardRH = new Vector3(0, 0, -1);
     /**@private	*/
     Vector3._ForwardLH = new Vector3(0, 0, 1);
     /**@private	*/
     Vector3._Up = new Vector3(0, 1, 0);

     /**
      * <code>Matrix3x3</code> 类用于创建3x3矩阵。
      */
     class Matrix3x3 {
         /**
          * 创建一个 <code>Matrix3x3</code> 实例。
          */
         constructor() {
             var e = this.elements = new Float32Array(9);
             e[0] = 1;
             e[1] = 0;
             e[2] = 0;
             e[3] = 0;
             e[4] = 1;
             e[5] = 0;
             e[6] = 0;
             e[7] = 0;
             e[8] = 1;
         }
         /**
          * 根据指定平移生成3x3矩阵
          * @param	tra 平移
          * @param	out 输出矩阵
          */
         static createFromTranslation(trans, out) {
             var e = out.elements;
             out[0] = 1;
             out[1] = 0;
             out[2] = 0;
             out[3] = 0;
             out[4] = 1;
             out[5] = 0;
             out[6] = trans.x;
             out[7] = trans.y;
             out[8] = 1;
         }
         /**
          * 根据指定旋转生成3x3矩阵
          * @param	rad  旋转值
          * @param	out 输出矩阵
          */
         static createFromRotation(rad, out) {
             var e = out.elements;
             var s = Math.sin(rad), c = Math.cos(rad);
             e[0] = c;
             e[1] = s;
             e[2] = 0;
             e[3] = -s;
             e[4] = c;
             e[5] = 0;
             e[6] = 0;
             e[7] = 0;
             e[8] = 1;
         }
         /**
          * 根据制定缩放生成3x3矩阵
          * @param	scale 缩放值
          * @param	out 输出矩阵
          */
         static createFromScaling(scale, out) {
             var e = out.elements;
             e[0] = scale.x;
             e[1] = 0;
             e[2] = 0;
             e[3] = 0;
             e[4] = scale.y;
             e[5] = 0;
             e[6] = 0;
             e[7] = 0;
             e[8] = 1;
         }
         /**
          * 从4x4矩阵转换为一个3x3的矩阵（原则为upper-left,忽略第四行四列）
          * @param	sou 4x4源矩阵
          * @param	out 3x3输出矩阵
          */
         static createFromMatrix4x4(sou, out) {
             out[0] = sou[0];
             out[1] = sou[1];
             out[2] = sou[2];
             out[3] = sou[4];
             out[4] = sou[5];
             out[5] = sou[6];
             out[6] = sou[8];
             out[7] = sou[9];
             out[8] = sou[10];
         }
         /**
          *  两个3x3矩阵的相乘
          * @param	left 左矩阵
          * @param	right  右矩阵
          * @param	out  输出矩阵
          */
         static multiply(left, right, out) {
             var e = out.elements;
             var f = left.elements;
             var g = right.elements;
             var a00 = f[0], a01 = f[1], a02 = f[2];
             var a10 = f[3], a11 = f[4], a12 = f[5];
             var a20 = f[6], a21 = f[7], a22 = f[8];
             var b00 = g[0], b01 = g[1], b02 = g[2];
             var b10 = g[3], b11 = g[4], b12 = g[5];
             var b20 = g[6], b21 = g[7], b22 = g[8];
             e[0] = b00 * a00 + b01 * a10 + b02 * a20;
             e[1] = b00 * a01 + b01 * a11 + b02 * a21;
             e[2] = b00 * a02 + b01 * a12 + b02 * a22;
             e[3] = b10 * a00 + b11 * a10 + b12 * a20;
             e[4] = b10 * a01 + b11 * a11 + b12 * a21;
             e[5] = b10 * a02 + b11 * a12 + b12 * a22;
             e[6] = b20 * a00 + b21 * a10 + b22 * a20;
             e[7] = b20 * a01 + b21 * a11 + b22 * a21;
             e[8] = b20 * a02 + b21 * a12 + b22 * a22;
         }
         /**
          * 计算3x3矩阵的行列式
          * @return    矩阵的行列式
          */
         determinant() {
             var f = this.elements;
             var a00 = f[0], a01 = f[1], a02 = f[2];
             var a10 = f[3], a11 = f[4], a12 = f[5];
             var a20 = f[6], a21 = f[7], a22 = f[8];
             return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
         }
         /**
          * 通过一个二维向量转换3x3矩阵
          * @param	tra 转换向量
          * @param	out 输出矩阵
          */
         translate(trans, out) {
             var e = out.elements;
             var f = this.elements;
             var a00 = f[0], a01 = f[1], a02 = f[2];
             var a10 = f[3], a11 = f[4], a12 = f[5];
             var a20 = f[6], a21 = f[7], a22 = f[8];
             var x = trans.x, y = trans.y;
             e[0] = a00;
             e[1] = a01;
             e[2] = a02;
             e[3] = a10;
             e[4] = a11;
             e[5] = a12;
             e[6] = x * a00 + y * a10 + a20;
             e[7] = x * a01 + y * a11 + a21;
             e[8] = x * a02 + y * a12 + a22;
         }
         /**
          * 根据指定角度旋转3x3矩阵
          * @param	rad 旋转角度
          * @param	out 输出矩阵
          */
         rotate(rad, out) {
             var e = out.elements;
             var f = this.elements;
             var a00 = f[0], a01 = f[1], a02 = f[2];
             var a10 = f[3], a11 = f[4], a12 = f[5];
             var a20 = f[6], a21 = f[7], a22 = f[8];
             var s = Math.sin(rad);
             var c = Math.cos(rad);
             e[0] = c * a00 + s * a10;
             e[1] = c * a01 + s * a11;
             e[2] = c * a02 + s * a12;
             e[3] = c * a10 - s * a00;
             e[4] = c * a11 - s * a01;
             e[5] = c * a12 - s * a02;
             e[6] = a20;
             e[7] = a21;
             e[8] = a22;
         }
         /**
          *根据制定缩放3x3矩阵
          * @param	scale 缩放值
          * @param	out 输出矩阵
          */
         scale(scale, out) {
             var e = out.elements;
             var f = this.elements;
             var x = scale.x, y = scale.y;
             e[0] = x * f[0];
             e[1] = x * f[1];
             e[2] = x * f[2];
             e[3] = y * f[3];
             e[4] = y * f[4];
             e[5] = y * f[5];
             e[6] = f[6];
             e[7] = f[7];
             e[8] = f[8];
         }
         /**
          * 计算3x3矩阵的逆矩阵
          * @param	out 输出的逆矩阵
          */
         invert(out) {
             var e = out.elements;
             var f = this.elements;
             var a00 = f[0], a01 = f[1], a02 = f[2];
             var a10 = f[3], a11 = f[4], a12 = f[5];
             var a20 = f[6], a21 = f[7], a22 = f[8];
             var b01 = a22 * a11 - a12 * a21;
             var b11 = -a22 * a10 + a12 * a20;
             var b21 = a21 * a10 - a11 * a20;
             // Calculate the determinant
             var det = a00 * b01 + a01 * b11 + a02 * b21;
             if (!det) {
                 out = null;
             }
             det = 1.0 / det;
             e[0] = b01 * det;
             e[1] = (-a22 * a01 + a02 * a21) * det;
             e[2] = (a12 * a01 - a02 * a11) * det;
             e[3] = b11 * det;
             e[4] = (a22 * a00 - a02 * a20) * det;
             e[5] = (-a12 * a00 + a02 * a10) * det;
             e[6] = b21 * det;
             e[7] = (-a21 * a00 + a01 * a20) * det;
             e[8] = (a11 * a00 - a01 * a10) * det;
         }
         /**
          * 计算3x3矩阵的转置矩阵
          * @param 	out 输出矩阵
          */
         transpose(out) {
             var e = out.elements;
             var f = this.elements;
             if (out === this) {
                 var a01 = f[1], a02 = f[2], a12 = f[5];
                 e[1] = f[3];
                 e[2] = f[6];
                 e[3] = a01;
                 e[5] = f[7];
                 e[6] = a02;
                 e[7] = a12;
             }
             else {
                 e[0] = f[0];
                 e[1] = f[3];
                 e[2] = f[6];
                 e[3] = f[1];
                 e[4] = f[4];
                 e[5] = f[7];
                 e[6] = f[2];
                 e[7] = f[5];
                 e[8] = f[8];
             }
         }
         /** 设置已有的矩阵为单位矩阵*/
         identity() {
             var e = this.elements;
             e[0] = 1;
             e[1] = 0;
             e[2] = 0;
             e[3] = 0;
             e[4] = 1;
             e[5] = 0;
             e[6] = 0;
             e[7] = 0;
             e[8] = 1;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var i, s, d;
             s = this.elements;
             d = destObject.elements;
             if (s === d) {
                 return;
             }
             for (i = 0; i < 9; ++i) {
                 d[i] = s[i];
             }
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new Matrix3x3();
             this.cloneTo(dest);
             return dest;
         }
         /**
          * 计算观察3x3矩阵
          * @param	eye    观察者位置
          * @param	target 目标位置
          * @param	up     上向量
          * @param	out    输出3x3矩阵
          */
         static lookAt(eye, target, up, out) {
             Vector3.subtract(eye, target, Matrix3x3._tempV30); //WebGL为右手坐标系统
             Vector3.normalize(Matrix3x3._tempV30, Matrix3x3._tempV30);
             Vector3.cross(up, Matrix3x3._tempV30, Matrix3x3._tempV31);
             Vector3.normalize(Matrix3x3._tempV31, Matrix3x3._tempV31);
             Vector3.cross(Matrix3x3._tempV30, Matrix3x3._tempV31, Matrix3x3._tempV32);
             var v0 = Matrix3x3._tempV30;
             var v1 = Matrix3x3._tempV31;
             var v2 = Matrix3x3._tempV32;
             var me = out.elements;
             me[0] = v1.x;
             me[3] = v1.y;
             me[6] = v1.z;
             me[1] = v2.x;
             me[4] = v2.y;
             me[7] = v2.z;
             me[2] = v0.x;
             me[5] = v0.y;
             me[8] = v0.z;
         }
     }
     /**默认矩阵,禁止修改*/
     Matrix3x3.DEFAULT = new Matrix3x3();
     /** @private */
     Matrix3x3._tempV30 = new Vector3();
     /** @private */
     Matrix3x3._tempV31 = new Vector3();
     /** @private */
     Matrix3x3._tempV32 = new Vector3();

     /**
      * 使用全局类的时候，避免引用其他模块
      */
     class ILaya3D {
     }
     ILaya3D.Scene3D = null;
     ILaya3D.MeshRenderStaticBatchManager = null;
     ILaya3D.MeshRenderDynamicBatchManager = null;
     ILaya3D.SubMeshDynamicBatch = null;
     ILaya3D.Laya3D = null;
     ILaya3D.Matrix4x4 = null;

     /**
      * <code>Quaternion</code> 类用于创建四元数。
      */
     class Quaternion {
         /**
          * 创建一个 <code>Quaternion</code> 实例。
          * @param	x 四元数的x值
          * @param	y 四元数的y值
          * @param	z 四元数的z值
          * @param	w 四元数的w值
          */
         constructor(x = 0, y = 0, z = 0, w = 1, nativeElements = null /*[NATIVE]*/) {
             this.x = x;
             this.y = y;
             this.z = z;
             this.w = w;
         }
         /**
          *  从欧拉角生成四元数（顺序为Yaw、Pitch、Roll）
          * @param	yaw yaw值
          * @param	pitch pitch值
          * @param	roll roll值
          * @param	out 输出四元数
          */
         static createFromYawPitchRoll(yaw, pitch, roll, out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             var halfRoll = roll * 0.5;
             var halfPitch = pitch * 0.5;
             var halfYaw = yaw * 0.5;
             var sinRoll = Math.sin(halfRoll);
             var cosRoll = Math.cos(halfRoll);
             var sinPitch = Math.sin(halfPitch);
             var cosPitch = Math.cos(halfPitch);
             var sinYaw = Math.sin(halfYaw);
             var cosYaw = Math.cos(halfYaw);
             out.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
             out.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
             out.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
             out.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
         }
         /**
          * 计算两个四元数相乘
          * @param	left left四元数
          * @param	right  right四元数
          * @param	out 输出四元数
          */
         static multiply(left, right, out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             var lx = left.x;
             var ly = left.y;
             var lz = left.z;
             var lw = left.w;
             var rx = right.x;
             var ry = right.y;
             var rz = right.z;
             var rw = right.w;
             var a = (ly * rz - lz * ry);
             var b = (lz * rx - lx * rz);
             var c = (lx * ry - ly * rx);
             var d = (lx * rx + ly * ry + lz * rz);
             out.x = (lx * rw + rx * lw) + a;
             out.y = (ly * rw + ry * lw) + b;
             out.z = (lz * rw + rz * lw) + c;
             out.w = lw * rw - d;
         }
         static arcTanAngle(x, y) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             if (x == 0) {
                 if (y == 1)
                     return Math.PI / 2;
                 return -Math.PI / 2;
             }
             if (x > 0)
                 return Math.atan(y / x);
             if (x < 0) {
                 if (y > 0)
                     return Math.atan(y / x) + Math.PI;
                 return Math.atan(y / x) - Math.PI;
             }
             return 0;
         }
         static angleTo(from, location, angle) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             Vector3.subtract(location, from, Quaternion.TEMPVector30);
             Vector3.normalize(Quaternion.TEMPVector30, Quaternion.TEMPVector30);
             angle.x = Math.asin(Quaternion.TEMPVector30.y);
             angle.y = Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z, -Quaternion.TEMPVector30.x);
         }
         /**
          * 从指定的轴和角度计算四元数
          * @param	axis  轴
          * @param	rad  角度
          * @param	out  输出四元数
          */
         static createFromAxisAngle(axis, rad, out) {
             rad = rad * 0.5;
             var s = Math.sin(rad);
             out.x = s * axis.x;
             out.y = s * axis.y;
             out.z = s * axis.z;
             out.w = Math.cos(rad);
         }
         /**
          *  从旋转矩阵计算四元数
          * @param	mat 旋转矩阵
          * @param	out  输出四元数
          */
         static createFromMatrix4x4(mat, out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             var me = mat.elements;
             var sqrt;
             var half;
             var scale = me[0] + me[5] + me[10];
             if (scale > 0.0) {
                 sqrt = Math.sqrt(scale + 1.0);
                 out.w = sqrt * 0.5;
                 sqrt = 0.5 / sqrt;
                 out.x = (me[6] - me[9]) * sqrt;
                 out.y = (me[8] - me[2]) * sqrt;
                 out.z = (me[1] - me[4]) * sqrt;
             }
             else if ((me[0] >= me[5]) && (me[0] >= me[10])) {
                 sqrt = Math.sqrt(1.0 + me[0] - me[5] - me[10]);
                 half = 0.5 / sqrt;
                 out.x = 0.5 * sqrt;
                 out.y = (me[1] + me[4]) * half;
                 out.z = (me[2] + me[8]) * half;
                 out.w = (me[6] - me[9]) * half;
             }
             else if (me[5] > me[10]) {
                 sqrt = Math.sqrt(1.0 + me[5] - me[0] - me[10]);
                 half = 0.5 / sqrt;
                 out.x = (me[4] + me[1]) * half;
                 out.y = 0.5 * sqrt;
                 out.z = (me[9] + me[6]) * half;
                 out.w = (me[8] - me[2]) * half;
             }
             else {
                 sqrt = Math.sqrt(1.0 + me[10] - me[0] - me[5]);
                 half = 0.5 / sqrt;
                 out.x = (me[8] + me[2]) * half;
                 out.y = (me[9] + me[6]) * half;
                 out.z = 0.5 * sqrt;
                 out.w = (me[1] - me[4]) * half;
             }
         }
         /**
          * 球面插值
          * @param	left left四元数
          * @param	right  right四元数
          * @param	a 插值比例
          * @param	out 输出四元数
          * @return   输出Float32Array
          */
         static slerp(left, right, t, out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             var ax = left.x, ay = left.y, az = left.z, aw = left.w, bx = right.x, by = right.y, bz = right.z, bw = right.w;
             var omega, cosom, sinom, scale0, scale1;
             // calc cosine 
             cosom = ax * bx + ay * by + az * bz + aw * bw;
             // adjust signs (if necessary) 
             if (cosom < 0.0) {
                 cosom = -cosom;
                 bx = -bx;
                 by = -by;
                 bz = -bz;
                 bw = -bw;
             }
             // calculate coefficients 
             if ((1.0 - cosom) > 0.000001) {
                 // standard case (slerp) 
                 omega = Math.acos(cosom);
                 sinom = Math.sin(omega);
                 scale0 = Math.sin((1.0 - t) * omega) / sinom;
                 scale1 = Math.sin(t * omega) / sinom;
             }
             else {
                 // "from" and "to" quaternions are very close  
                 //  ... so we can do a linear interpolation 
                 scale0 = 1.0 - t;
                 scale1 = t;
             }
             // calculate final values 
             out.x = scale0 * ax + scale1 * bx;
             out.y = scale0 * ay + scale1 * by;
             out.z = scale0 * az + scale1 * bz;
             out.w = scale0 * aw + scale1 * bw;
             return out;
         }
         /**
          * 计算两个四元数的线性插值
          * @param	left left四元数
          * @param	right right四元数b
          * @param	t 插值比例
          * @param	out 输出四元数
          */
         static lerp(left, right, amount, out) {
             var inverse = 1.0 - amount;
             if (Quaternion.dot(left, right) >= 0) {
                 out.x = (inverse * left.x) + (amount * right.x);
                 out.y = (inverse * left.y) + (amount * right.y);
                 out.z = (inverse * left.z) + (amount * right.z);
                 out.w = (inverse * left.w) + (amount * right.w);
             }
             else {
                 out.x = (inverse * left.x) - (amount * right.x);
                 out.y = (inverse * left.y) - (amount * right.y);
                 out.z = (inverse * left.z) - (amount * right.z);
                 out.w = (inverse * left.w) - (amount * right.w);
             }
             out.normalize(out);
         }
         /**
          * 计算两个四元数的和
          * @param	left  left四元数
          * @param	right right 四元数
          * @param	out 输出四元数
          */
         static add(left, right, out) {
             out.x = left.x + right.x;
             out.y = left.y + right.y;
             out.z = left.z + right.z;
             out.w = left.w + right.w;
         }
         /**
          * 计算两个四元数的点积
          * @param	left left四元数
          * @param	right right四元数
          * @return  点积
          */
         static dot(left, right) {
             return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
         }
         /**
          * 根据缩放值缩放四元数
          * @param	scale 缩放值
          * @param	out 输出四元数
          */
         scaling(scaling, out) {
             out.x = this.x * scaling;
             out.y = this.y * scaling;
             out.z = this.z * scaling;
             out.w = this.w * scaling;
         }
         /**
          * 归一化四元数
          * @param	out 输出四元数
          */
         normalize(out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             var len = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
             if (len > 0) {
                 len = 1 / Math.sqrt(len);
                 out.x = this.x * len;
                 out.y = this.y * len;
                 out.z = this.z * len;
                 out.w = this.w * len;
             }
         }
         /**
          * 计算四元数的长度
          * @return  长度
          */
         length() {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
         }
         /**
          * 根据绕X轴的角度旋转四元数
          * @param	rad 角度
          * @param	out 输出四元数
          */
         rotateX(rad, out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             rad *= 0.5;
             var bx = Math.sin(rad), bw = Math.cos(rad);
             out.x = this.x * bw + this.w * bx;
             out.y = this.y * bw + this.z * bx;
             out.z = this.z * bw - this.y * bx;
             out.w = this.w * bw - this.x * bx;
         }
         /**
          * 根据绕Y轴的制定角度旋转四元数
          * @param	rad 角度
          * @param	out 输出四元数
          */
         rotateY(rad, out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             rad *= 0.5;
             var by = Math.sin(rad), bw = Math.cos(rad);
             out.x = this.x * bw - this.z * by;
             out.y = this.y * bw + this.w * by;
             out.z = this.z * bw + this.x * by;
             out.w = this.w * bw - this.y * by;
         }
         /**
          * 根据绕Z轴的制定角度旋转四元数
          * @param	rad 角度
          * @param	out 输出四元数
          */
         rotateZ(rad, out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             rad *= 0.5;
             var bz = Math.sin(rad), bw = Math.cos(rad);
             out.x = this.x * bw + this.y * bz;
             out.y = this.y * bw - this.x * bz;
             out.z = this.z * bw + this.w * bz;
             out.w = this.w * bw - this.z * bz;
         }
         /**
          * 分解四元数到欧拉角（顺序为Yaw、Pitch、Roll），参考自http://xboxforums.create.msdn.com/forums/p/4574/23988.aspx#23988,问题绕X轴翻转超过±90度时有，会产生瞬间反转
          * @param	quaternion 源四元数
          * @param	out 欧拉角值
          */
         getYawPitchRoll(out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             Vector3.transformQuat(Vector3._ForwardRH, this, Quaternion.TEMPVector31 /*forwarldRH*/);
             Vector3.transformQuat(Vector3._Up, this, Quaternion.TEMPVector32 /*up*/);
             var upe = Quaternion.TEMPVector32;
             Quaternion.angleTo(Vector3._ZERO, Quaternion.TEMPVector31, Quaternion.TEMPVector33 /*angle*/);
             var angle = Quaternion.TEMPVector33;
             if (angle.x == Math.PI / 2) {
                 angle.y = Quaternion.arcTanAngle(upe.z, upe.x);
                 angle.z = 0;
             }
             else if (angle.x == -Math.PI / 2) {
                 angle.y = Quaternion.arcTanAngle(-upe.z, -upe.x);
                 angle.z = 0;
             }
             else {
                 ILaya3D.Matrix4x4.createRotationY(-angle.y, ILaya3D.Matrix4x4.TEMPMatrix0);
                 ILaya3D.Matrix4x4.createRotationX(-angle.x, ILaya3D.Matrix4x4.TEMPMatrix1);
                 Vector3.transformCoordinate(Quaternion.TEMPVector32, ILaya3D.Matrix4x4.TEMPMatrix0, Quaternion.TEMPVector32);
                 Vector3.transformCoordinate(Quaternion.TEMPVector32, ILaya3D.Matrix4x4.TEMPMatrix1, Quaternion.TEMPVector32);
                 angle.z = Quaternion.arcTanAngle(upe.y, -upe.x);
             }
             // Special cases.
             if (angle.y <= -Math.PI)
                 angle.y = Math.PI;
             if (angle.z <= -Math.PI)
                 angle.z = Math.PI;
             if (angle.y >= Math.PI && angle.z >= Math.PI) {
                 angle.y = 0;
                 angle.z = 0;
                 angle.x = Math.PI - angle.x;
             }
             var oe = out;
             oe.x = angle.y;
             oe.y = angle.x;
             oe.z = angle.z;
         }
         /**
          * 求四元数的逆
          * @param	out  输出四元数
          */
         invert(out) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             var a0 = this.x, a1 = this.y, a2 = this.z, a3 = this.w;
             var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
             var invDot = dot ? 1.0 / dot : 0;
             // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
             out.x = -a0 * invDot;
             out.y = -a1 * invDot;
             out.z = -a2 * invDot;
             out.w = a3 * invDot;
         }
         /**
          *设置四元数为单位算数
          * @param out  输出四元数
          */
         identity() {
             this.x = 0;
             this.y = 0;
             this.z = 0;
             this.w = 1;
         }
         /**
          * 从Array数组拷贝值。
          * @param  array 数组。
          * @param  offset 数组偏移。
          */
         fromArray(array, offset = 0) {
             this.x = array[offset + 0];
             this.y = array[offset + 1];
             this.z = array[offset + 2];
             this.w = array[offset + 3];
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             if (this === destObject) {
                 return;
             }
             destObject.x = this.x;
             destObject.y = this.y;
             destObject.z = this.z;
             destObject.w = this.w;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new Quaternion();
             this.cloneTo(dest);
             return dest;
         }
         equals(b) {
             return MathUtils3D.nearEqual(this.x, b.x) && MathUtils3D.nearEqual(this.y, b.y) && MathUtils3D.nearEqual(this.z, b.z) && MathUtils3D.nearEqual(this.w, b.w);
         }
         /**
          * 计算旋转观察四元数
          * @param	forward 方向
          * @param	up     上向量
          * @param	out    输出四元数
          */
         static rotationLookAt(forward, up, out) {
             Quaternion.lookAt(Vector3._ZERO, forward, up, out);
         }
         /**
          * 计算观察四元数
          * @param	eye    观察者位置
          * @param	target 目标位置
          * @param	up     上向量
          * @param	out    输出四元数
          */
         static lookAt(eye, target, up, out) {
             Matrix3x3.lookAt(eye, target, up, Quaternion._tempMatrix3x3);
             Quaternion.rotationMatrix(Quaternion._tempMatrix3x3, out);
         }
         /**
          * 计算长度的平方。
          * @return 长度的平方。
          */
         lengthSquared() {
             return (this.x * this.x) + (this.y * this.y) + (this.z * this.z) + (this.w * this.w);
         }
         /**
          * 计算四元数的逆四元数。
          * @param	value 四元数。
          * @param	out 逆四元数。
          */
         static invert(value, out) {
             var lengthSq = value.lengthSquared();
             if (!MathUtils3D.isZero(lengthSq)) {
                 lengthSq = 1.0 / lengthSq;
                 out.x = -value.x * lengthSq;
                 out.y = -value.y * lengthSq;
                 out.z = -value.z * lengthSq;
                 out.w = value.w * lengthSq;
             }
         }
         /**
          * 通过一个3x3矩阵创建一个四元数
          * @param	matrix3x3  3x3矩阵
          * @param	out        四元数
          */
         static rotationMatrix(matrix3x3, out) {
             var me = matrix3x3.elements;
             var m11 = me[0];
             var m12 = me[1];
             var m13 = me[2];
             var m21 = me[3];
             var m22 = me[4];
             var m23 = me[5];
             var m31 = me[6];
             var m32 = me[7];
             var m33 = me[8];
             var sqrt, half;
             var scale = m11 + m22 + m33;
             if (scale > 0) {
                 sqrt = Math.sqrt(scale + 1);
                 out.w = sqrt * 0.5;
                 sqrt = 0.5 / sqrt;
                 out.x = (m23 - m32) * sqrt;
                 out.y = (m31 - m13) * sqrt;
                 out.z = (m12 - m21) * sqrt;
             }
             else if ((m11 >= m22) && (m11 >= m33)) {
                 sqrt = Math.sqrt(1 + m11 - m22 - m33);
                 half = 0.5 / sqrt;
                 out.x = 0.5 * sqrt;
                 out.y = (m12 + m21) * half;
                 out.z = (m13 + m31) * half;
                 out.w = (m23 - m32) * half;
             }
             else if (m22 > m33) {
                 sqrt = Math.sqrt(1 + m22 - m11 - m33);
                 half = 0.5 / sqrt;
                 out.x = (m21 + m12) * half;
                 out.y = 0.5 * sqrt;
                 out.z = (m32 + m23) * half;
                 out.w = (m31 - m13) * half;
             }
             else {
                 sqrt = Math.sqrt(1 + m33 - m11 - m22);
                 half = 0.5 / sqrt;
                 out.x = (m31 + m13) * half;
                 out.y = (m32 + m23) * half;
                 out.z = 0.5 * sqrt;
                 out.w = (m12 - m21) * half;
             }
         }
         forNativeElement(nativeElements = null) {
             if (nativeElements) {
                 this.elements = nativeElements;
                 this.elements[0] = this.x;
                 this.elements[1] = this.y;
                 this.elements[2] = this.z;
                 this.elements[3] = this.w;
             }
             else {
                 this.elements = new Float32Array([this.x, this.y, this.z, this.w]);
             }
             Vector2.rewriteNumProperty(this, "x", 0);
             Vector2.rewriteNumProperty(this, "y", 1);
             Vector2.rewriteNumProperty(this, "z", 2);
             Vector2.rewriteNumProperty(this, "w", 3);
         }
     }
     /**@private */
     Quaternion.TEMPVector30 = new Vector3();
     /**@private */
     Quaternion.TEMPVector31 = new Vector3();
     /**@private */
     Quaternion.TEMPVector32 = new Vector3();
     /**@private */
     Quaternion.TEMPVector33 = new Vector3();
     /**@private */
     Quaternion._tempMatrix3x3 = new Matrix3x3();
     /**默认矩阵,禁止修改*/
     Quaternion.DEFAULT = new Quaternion();
     /**无效矩阵,禁止修改*/
     Quaternion.NAN = new Quaternion(NaN, NaN, NaN, NaN);

     /**
      * ...
      * @author
      */
     class TextureGenerator {
         constructor() {
         }
         static lightAttenTexture(x, y, maxX, maxY, index, data) {
             var sqrRange = x / maxX;
             var atten = 1.0 / (1.0 + 25.0 * sqrRange);
             if (sqrRange >= 0.64) {
                 if (sqrRange > 1.0) {
                     atten = 0;
                 }
                 else {
                     atten *= 1 - (sqrRange - 0.64) / (1 - 0.64);
                 }
             }
             data[index] = Math.floor(atten * 255.0 + 0.5);
         }
         static haloTexture(x, y, maxX, maxY, index, data) {
             maxX >>= 1;
             maxY >>= 1;
             var xFac = (x - maxX) / maxX;
             var yFac = (y - maxY) / maxY;
             var sqrRange = xFac * xFac + yFac * yFac;
             if (sqrRange > 1.0) {
                 sqrRange = 1.0;
             }
             data[index] = Math.floor((1.0 - sqrRange) * 255.0 + 0.5);
         }
         static _generateTexture2D(texture, textureWidth, textureHeight, func) {
             var index = 0;
             var size = 0;
             switch (texture.format) {
                 case BaseTexture.FORMAT_R8G8B8:
                     size = 3;
                     break;
                 case BaseTexture.FORMAT_R8G8B8A8:
                     size = 4;
                     break;
                 case BaseTexture.FORMAT_ALPHA8:
                     size = 1;
                     break;
                 default:
                     throw "GeneratedTexture._generateTexture: unkonw texture format.";
             }
             var data = new Uint8Array(textureWidth * textureHeight * size);
             for (var y = 0; y < textureHeight; y++) {
                 for (var x = 0; x < textureWidth; x++) {
                     func(x, y, textureWidth, textureHeight, index, data);
                     index += size;
                 }
             }
             texture.setPixels(data);
         }
     }

     /**
      * <code>Utils3D</code> 类用于创建3D工具。
      */
     class Utils3D {
         /**
          * @private
          */
         static _convertToLayaVec3(bVector, out, inverseX) {
             out.x = inverseX ? -bVector.x() : bVector.x();
             out.y = bVector.y();
             out.z = bVector.z();
         }
         /**
          * @private
          */
         static _convertToBulletVec3(lVector, out, inverseX) {
             out.setValue(inverseX ? -lVector.x : lVector.x, lVector.y, lVector.z);
         }
         /**
          *通过数平移、旋转、缩放值计算到结果矩阵数组,骨骼动画专用。
          * @param tx left矩阵数组。
          * @param ty left矩阵数组的偏移。
          * @param tz right矩阵数组。
          * @param qx right矩阵数组的偏移。
          * @param qy 输出矩阵数组。
          * @param qz 输出矩阵数组的偏移。
          * @param qw 输出矩阵数组的偏移。
          * @param sx 输出矩阵数组的偏移。
          * @param sy 输出矩阵数组的偏移。
          * @param sz 输出矩阵数组的偏移。
          * @param outArray 结果矩阵数组。
          * @param outOffset 结果矩阵数组的偏移。
          */
         static _rotationTransformScaleSkinAnimation(tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, outArray, outOffset) {
             var re = Utils3D._tempArray16_0;
             var se = Utils3D._tempArray16_1;
             var tse = Utils3D._tempArray16_2;
             //平移
             //旋转
             var x2 = qx + qx;
             var y2 = qy + qy;
             var z2 = qz + qz;
             var xx = qx * x2;
             var yx = qy * x2;
             var yy = qy * y2;
             var zx = qz * x2;
             var zy = qz * y2;
             var zz = qz * z2;
             var wx = qw * x2;
             var wy = qw * y2;
             var wz = qw * z2;
             //re[3] = re[7] = re[11] = re[12] = re[13] = re[14] = 0;
             re[15] = 1;
             re[0] = 1 - yy - zz;
             re[1] = yx + wz;
             re[2] = zx - wy;
             re[4] = yx - wz;
             re[5] = 1 - xx - zz;
             re[6] = zy + wx;
             re[8] = zx + wy;
             re[9] = zy - wx;
             re[10] = 1 - xx - yy;
             //缩放
             //se[4] = se[8] = se[12] = se[1] = se[9] = se[13] = se[2] = se[6] = se[14] = se[3] = se[7] = se[11] = 0;
             se[15] = 1;
             se[0] = sx;
             se[5] = sy;
             se[10] = sz;
             var i, ai0, ai1, ai2, ai3;
             //mul(rMat, tMat, tsMat)......................................
             for (i = 0; i < 4; i++) {
                 ai0 = re[i];
                 ai1 = re[i + 4];
                 ai2 = re[i + 8];
                 ai3 = re[i + 12];
                 tse[i] = ai0;
                 tse[i + 4] = ai1;
                 tse[i + 8] = ai2;
                 tse[i + 12] = ai0 * tx + ai1 * ty + ai2 * tz + ai3;
             }
             //mul(tsMat, sMat, out)..............................................
             for (i = 0; i < 4; i++) {
                 ai0 = tse[i];
                 ai1 = tse[i + 4];
                 ai2 = tse[i + 8];
                 ai3 = tse[i + 12];
                 outArray[i + outOffset] = ai0 * se[0] + ai1 * se[1] + ai2 * se[2] + ai3 * se[3];
                 outArray[i + outOffset + 4] = ai0 * se[4] + ai1 * se[5] + ai2 * se[6] + ai3 * se[7];
                 outArray[i + outOffset + 8] = ai0 * se[8] + ai1 * se[9] + ai2 * se[10] + ai3 * se[11];
                 outArray[i + outOffset + 12] = ai0 * se[12] + ai1 * se[13] + ai2 * se[14] + ai3 * se[15];
             }
         }
         /** @private */
         static _computeBoneAndAnimationDatasByBindPoseMatrxix(bones, curData, inverGlobalBindPose, outBonesDatas, outAnimationDatas, boneIndexToMesh) {
             var offset = 0;
             var matOffset = 0;
             var i;
             var parentOffset;
             var boneLength = bones.length;
             for (i = 0; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++) {
                 //将旋转平移缩放合成矩阵...........................................
                 Utils3D._rotationTransformScaleSkinAnimation(curData[offset + 0], curData[offset + 1], curData[offset + 2], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 7], curData[offset + 8], curData[offset + 9], outBonesDatas, matOffset);
                 if (i != 0) {
                     parentOffset = bones[i].parentIndex * 16;
                     Utils3D.mulMatrixByArray(outBonesDatas, parentOffset, outBonesDatas, matOffset, outBonesDatas, matOffset);
                 }
             }
             var n = inverGlobalBindPose.length;
             for (i = 0; i < n; i++) //将绝对矩阵乘以反置矩阵................................................
              {
                 Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas, boneIndexToMesh[i] * 16, inverGlobalBindPose[i], outAnimationDatas, i * 16); //TODO:-1处理
             }
         }
         /** @private */
         static _computeAnimationDatasByArrayAndMatrixFast(inverGlobalBindPose, bonesDatas, outAnimationDatas, boneIndexToMesh) {
             for (var i = 0, n = inverGlobalBindPose.length; i < n; i++) //将绝对矩阵乘以反置矩阵
                 Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas, boneIndexToMesh[i] * 16, inverGlobalBindPose[i], outAnimationDatas, i * 16); //TODO:-1处理
         }
         /** @private */
         static _computeBoneAndAnimationDatasByBindPoseMatrxixOld(bones, curData, inverGlobalBindPose, outBonesDatas, outAnimationDatas) {
             var offset = 0;
             var matOffset = 0;
             var i;
             var parentOffset;
             var boneLength = bones.length;
             for (i = 0; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++) {
                 //将旋转平移缩放合成矩阵...........................................
                 Utils3D._rotationTransformScaleSkinAnimation(curData[offset + 7], curData[offset + 8], curData[offset + 9], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 0], curData[offset + 1], curData[offset + 2], outBonesDatas, matOffset);
                 if (i != 0) {
                     parentOffset = bones[i].parentIndex * 16;
                     Utils3D.mulMatrixByArray(outBonesDatas, parentOffset, outBonesDatas, matOffset, outBonesDatas, matOffset);
                 }
             }
             var n = inverGlobalBindPose.length;
             for (i = 0; i < n; i++) //将绝对矩阵乘以反置矩阵................................................
              {
                 var arrayOffset = i * 16;
                 Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas, arrayOffset, inverGlobalBindPose[i], outAnimationDatas, arrayOffset);
             }
         }
         /** @private */
         static _computeAnimationDatasByArrayAndMatrixFastOld(inverGlobalBindPose, bonesDatas, outAnimationDatas) {
             var n = inverGlobalBindPose.length;
             for (var i = 0; i < n; i++) //将绝对矩阵乘以反置矩阵................................................
              {
                 var arrayOffset = i * 16;
                 Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas, arrayOffset, inverGlobalBindPose[i], outAnimationDatas, arrayOffset);
             }
         }
         /** @private */
         static _computeRootAnimationData(bones, curData, animationDatas) {
             for (var i = 0, offset = 0, matOffset = 0, boneLength = bones.length; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++)
                 Utils3D.createAffineTransformationArray(curData[offset + 0], curData[offset + 1], curData[offset + 2], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 7], curData[offset + 8], curData[offset + 9], animationDatas, matOffset);
         }
         /**
          * 根据四元数旋转三维向量。
          * @param	source 源三维向量。
          * @param	rotation 旋转四元数。
          * @param	out 输出三维向量。
          */
         static transformVector3ArrayByQuat(sourceArray, sourceOffset, rotation, outArray, outOffset) {
             var x = sourceArray[sourceOffset], y = sourceArray[sourceOffset + 1], z = sourceArray[sourceOffset + 2], qx = rotation.x, qy = rotation.y, qz = rotation.z, qw = rotation.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
             outArray[outOffset] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
             outArray[outOffset + 1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
             outArray[outOffset + 2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
         }
         /**
          *通过数组数据计算矩阵乘法。
          * @param leftArray left矩阵数组。
          * @param leftOffset left矩阵数组的偏移。
          * @param rightArray right矩阵数组。
          * @param rightOffset right矩阵数组的偏移。
          * @param outArray 输出矩阵数组。
          * @param outOffset 输出矩阵数组的偏移。
          */
         static mulMatrixByArray(leftArray, leftOffset, rightArray, rightOffset, outArray, outOffset) {
             var i, ai0, ai1, ai2, ai3;
             if (outArray === rightArray) {
                 rightArray = Utils3D._tempArray16_3;
                 for (i = 0; i < 16; ++i) {
                     rightArray[i] = outArray[outOffset + i];
                 }
                 rightOffset = 0;
             }
             for (i = 0; i < 4; i++) {
                 ai0 = leftArray[leftOffset + i];
                 ai1 = leftArray[leftOffset + i + 4];
                 ai2 = leftArray[leftOffset + i + 8];
                 ai3 = leftArray[leftOffset + i + 12];
                 outArray[outOffset + i] = ai0 * rightArray[rightOffset + 0] + ai1 * rightArray[rightOffset + 1] + ai2 * rightArray[rightOffset + 2] + ai3 * rightArray[rightOffset + 3];
                 outArray[outOffset + i + 4] = ai0 * rightArray[rightOffset + 4] + ai1 * rightArray[rightOffset + 5] + ai2 * rightArray[rightOffset + 6] + ai3 * rightArray[rightOffset + 7];
                 outArray[outOffset + i + 8] = ai0 * rightArray[rightOffset + 8] + ai1 * rightArray[rightOffset + 9] + ai2 * rightArray[rightOffset + 10] + ai3 * rightArray[rightOffset + 11];
                 outArray[outOffset + i + 12] = ai0 * rightArray[rightOffset + 12] + ai1 * rightArray[rightOffset + 13] + ai2 * rightArray[rightOffset + 14] + ai3 * rightArray[rightOffset + 15];
             }
         }
         /**
          *通过数组数据计算矩阵乘法,rightArray和outArray不能为同一数组引用。
          * @param leftArray left矩阵数组。
          * @param leftOffset left矩阵数组的偏移。
          * @param rightArray right矩阵数组。
          * @param rightOffset right矩阵数组的偏移。
          * @param outArray 结果矩阵数组。
          * @param outOffset 结果矩阵数组的偏移。
          */
         static mulMatrixByArrayFast(leftArray, leftOffset, rightArray, rightOffset, outArray, outOffset) {
             var i, ai0, ai1, ai2, ai3;
             for (i = 0; i < 4; i++) {
                 ai0 = leftArray[leftOffset + i];
                 ai1 = leftArray[leftOffset + i + 4];
                 ai2 = leftArray[leftOffset + i + 8];
                 ai3 = leftArray[leftOffset + i + 12];
                 outArray[outOffset + i] = ai0 * rightArray[rightOffset + 0] + ai1 * rightArray[rightOffset + 1] + ai2 * rightArray[rightOffset + 2] + ai3 * rightArray[rightOffset + 3];
                 outArray[outOffset + i + 4] = ai0 * rightArray[rightOffset + 4] + ai1 * rightArray[rightOffset + 5] + ai2 * rightArray[rightOffset + 6] + ai3 * rightArray[rightOffset + 7];
                 outArray[outOffset + i + 8] = ai0 * rightArray[rightOffset + 8] + ai1 * rightArray[rightOffset + 9] + ai2 * rightArray[rightOffset + 10] + ai3 * rightArray[rightOffset + 11];
                 outArray[outOffset + i + 12] = ai0 * rightArray[rightOffset + 12] + ai1 * rightArray[rightOffset + 13] + ai2 * rightArray[rightOffset + 14] + ai3 * rightArray[rightOffset + 15];
             }
         }
         /**
          *通过数组数据计算矩阵乘法,rightArray和outArray不能为同一数组引用。
          * @param leftArray left矩阵数组。
          * @param leftOffset left矩阵数组的偏移。
          * @param rightMatrix right矩阵。
          * @param outArray 结果矩阵数组。
          * @param outOffset 结果矩阵数组的偏移。
          */
         static mulMatrixByArrayAndMatrixFast(leftArray, leftOffset, rightMatrix, outArray, outOffset) {
             var i, ai0, ai1, ai2, ai3;
             var rightMatrixE = rightMatrix.elements;
             var m11 = rightMatrixE[0], m12 = rightMatrixE[1], m13 = rightMatrixE[2], m14 = rightMatrixE[3];
             var m21 = rightMatrixE[4], m22 = rightMatrixE[5], m23 = rightMatrixE[6], m24 = rightMatrixE[7];
             var m31 = rightMatrixE[8], m32 = rightMatrixE[9], m33 = rightMatrixE[10], m34 = rightMatrixE[11];
             var m41 = rightMatrixE[12], m42 = rightMatrixE[13], m43 = rightMatrixE[14], m44 = rightMatrixE[15];
             var ai0LeftOffset = leftOffset;
             var ai1LeftOffset = leftOffset + 4;
             var ai2LeftOffset = leftOffset + 8;
             var ai3LeftOffset = leftOffset + 12;
             var ai0OutOffset = outOffset;
             var ai1OutOffset = outOffset + 4;
             var ai2OutOffset = outOffset + 8;
             var ai3OutOffset = outOffset + 12;
             for (i = 0; i < 4; i++) {
                 ai0 = leftArray[ai0LeftOffset + i];
                 ai1 = leftArray[ai1LeftOffset + i];
                 ai2 = leftArray[ai2LeftOffset + i];
                 ai3 = leftArray[ai3LeftOffset + i];
                 outArray[ai0OutOffset + i] = ai0 * m11 + ai1 * m12 + ai2 * m13 + ai3 * m14;
                 outArray[ai1OutOffset + i] = ai0 * m21 + ai1 * m22 + ai2 * m23 + ai3 * m24;
                 outArray[ai2OutOffset + i] = ai0 * m31 + ai1 * m32 + ai2 * m33 + ai3 * m34;
                 outArray[ai3OutOffset + i] = ai0 * m41 + ai1 * m42 + ai2 * m43 + ai3 * m44;
             }
         }
         /**
          *通过数平移、旋转、缩放值计算到结果矩阵数组。
          * @param tX left矩阵数组。
          * @param tY left矩阵数组的偏移。
          * @param tZ right矩阵数组。
          * @param qX right矩阵数组的偏移。
          * @param qY 输出矩阵数组。
          * @param qZ 输出矩阵数组的偏移。
          * @param qW 输出矩阵数组的偏移。
          * @param sX 输出矩阵数组的偏移。
          * @param sY 输出矩阵数组的偏移。
          * @param sZ 输出矩阵数组的偏移。
          * @param outArray 结果矩阵数组。
          * @param outOffset 结果矩阵数组的偏移。
          */
         static createAffineTransformationArray(tX, tY, tZ, rX, rY, rZ, rW, sX, sY, sZ, outArray, outOffset) {
             var x2 = rX + rX, y2 = rY + rY, z2 = rZ + rZ;
             var xx = rX * x2, xy = rX * y2, xz = rX * z2, yy = rY * y2, yz = rY * z2, zz = rZ * z2;
             var wx = rW * x2, wy = rW * y2, wz = rW * z2;
             outArray[outOffset + 0] = (1 - (yy + zz)) * sX;
             outArray[outOffset + 1] = (xy + wz) * sX;
             outArray[outOffset + 2] = (xz - wy) * sX;
             outArray[outOffset + 3] = 0;
             outArray[outOffset + 4] = (xy - wz) * sY;
             outArray[outOffset + 5] = (1 - (xx + zz)) * sY;
             outArray[outOffset + 6] = (yz + wx) * sY;
             outArray[outOffset + 7] = 0;
             outArray[outOffset + 8] = (xz + wy) * sZ;
             outArray[outOffset + 9] = (yz - wx) * sZ;
             outArray[outOffset + 10] = (1 - (xx + yy)) * sZ;
             outArray[outOffset + 11] = 0;
             outArray[outOffset + 12] = tX;
             outArray[outOffset + 13] = tY;
             outArray[outOffset + 14] = tZ;
             outArray[outOffset + 15] = 1;
         }
         /**
          * 通过矩阵转换一个三维向量数组到另外一个归一化的三维向量数组。
          * @param	source 源三维向量所在数组。
          * @param	sourceOffset 源三维向量数组偏移。
          * @param	transform  变换矩阵。
          * @param	result 输出三维向量所在数组。
          * @param	resultOffset 输出三维向量数组偏移。
          */
         static transformVector3ArrayToVector3ArrayCoordinate(source, sourceOffset, transform, result, resultOffset) {
             var coordinateX = source[sourceOffset + 0];
             var coordinateY = source[sourceOffset + 1];
             var coordinateZ = source[sourceOffset + 2];
             var transformElem = transform.elements;
             var w = ((coordinateX * transformElem[3]) + (coordinateY * transformElem[7]) + (coordinateZ * transformElem[11]) + transformElem[15]);
             result[resultOffset] = (coordinateX * transformElem[0]) + (coordinateY * transformElem[4]) + (coordinateZ * transformElem[8]) + transformElem[12] / w;
             result[resultOffset + 1] = (coordinateX * transformElem[1]) + (coordinateY * transformElem[5]) + (coordinateZ * transformElem[9]) + transformElem[13] / w;
             result[resultOffset + 2] = (coordinateX * transformElem[2]) + (coordinateY * transformElem[6]) + (coordinateZ * transformElem[10]) + transformElem[14] / w;
         }
         /**
          * @private
          */
         static transformLightingMapTexcoordArray(source, sourceOffset, lightingMapScaleOffset, result, resultOffset) {
             result[resultOffset + 0] = source[sourceOffset + 0] * lightingMapScaleOffset.x + lightingMapScaleOffset.z;
             result[resultOffset + 1] = 1.0 - ((1.0 - source[sourceOffset + 1]) * lightingMapScaleOffset.y + lightingMapScaleOffset.w);
         }
         /**
          * 获取URL版本字符。
          * @param	url
          * @return
          */
         static getURLVerion(url) {
             var index = url.indexOf("?");
             return index >= 0 ? url.substr(index) : null;
         }
         /**
          * @private
          */
         static _createAffineTransformationArray(trans, rot, scale, outE) {
             var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
             var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
             var wx = w * x2, wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
             outE[0] = (1 - (yy + zz)) * sx;
             outE[1] = (xy + wz) * sx;
             outE[2] = (xz - wy) * sx;
             outE[3] = 0;
             outE[4] = (xy - wz) * sy;
             outE[5] = (1 - (xx + zz)) * sy;
             outE[6] = (yz + wx) * sy;
             outE[7] = 0;
             outE[8] = (xz + wy) * sz;
             outE[9] = (yz - wx) * sz;
             outE[10] = (1 - (xx + yy)) * sz;
             outE[11] = 0;
             outE[12] = trans.x;
             outE[13] = trans.y;
             outE[14] = trans.z;
             outE[15] = 1;
         }
         /**
          * @private
          */
         static _mulMatrixArray(leftMatrixE, rightMatrix, outArray, outOffset) {
             var i, ai0, ai1, ai2, ai3;
             var rightMatrixE = rightMatrix.elements;
             var m11 = rightMatrixE[0], m12 = rightMatrixE[1], m13 = rightMatrixE[2], m14 = rightMatrixE[3];
             var m21 = rightMatrixE[4], m22 = rightMatrixE[5], m23 = rightMatrixE[6], m24 = rightMatrixE[7];
             var m31 = rightMatrixE[8], m32 = rightMatrixE[9], m33 = rightMatrixE[10], m34 = rightMatrixE[11];
             var m41 = rightMatrixE[12], m42 = rightMatrixE[13], m43 = rightMatrixE[14], m44 = rightMatrixE[15];
             var ai0OutOffset = outOffset;
             var ai1OutOffset = outOffset + 4;
             var ai2OutOffset = outOffset + 8;
             var ai3OutOffset = outOffset + 12;
             for (i = 0; i < 4; i++) {
                 ai0 = leftMatrixE[i];
                 ai1 = leftMatrixE[i + 4];
                 ai2 = leftMatrixE[i + 8];
                 ai3 = leftMatrixE[i + 12];
                 outArray[ai0OutOffset + i] = ai0 * m11 + ai1 * m12 + ai2 * m13 + ai3 * m14;
                 outArray[ai1OutOffset + i] = ai0 * m21 + ai1 * m22 + ai2 * m23 + ai3 * m24;
                 outArray[ai2OutOffset + i] = ai0 * m31 + ai1 * m32 + ai2 * m33 + ai3 * m34;
                 outArray[ai3OutOffset + i] = ai0 * m41 + ai1 * m42 + ai2 * m43 + ai3 * m44;
             }
         }
         static arcTanAngle(x, y) {
             if (x == 0) {
                 if (y == 1)
                     return Math.PI / 2;
                 return -Math.PI / 2;
             }
             if (x > 0)
                 return Math.atan(y / x);
             if (x < 0) {
                 if (y > 0)
                     return Math.atan(y / x) + Math.PI;
                 return Math.atan(y / x) - Math.PI;
             }
             return 0;
         }
         static angleTo(from, location, angle) {
             Vector3.subtract(location, from, Quaternion.TEMPVector30);
             Vector3.normalize(Quaternion.TEMPVector30, Quaternion.TEMPVector30);
             angle.x = Math.asin(Quaternion.TEMPVector30.y);
             angle.y = Utils3D.arcTanAngle(-Quaternion.TEMPVector30.z, -Quaternion.TEMPVector30.x);
         }
         static transformQuat(source, rotation, out) {
             var re = rotation;
             var x = source.x, y = source.y, z = source.z, qx = re[0], qy = re[1], qz = re[2], qw = re[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
             out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
             out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
             out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
         }
         static quaternionWeight(f, weight, e) {
             e.x = f.x * weight;
             e.y = f.y * weight;
             e.z = f.z * weight;
             e.w = f.w;
         }
         /**
          * @private
          */
         static quaternionConjugate(value, result) {
             result.x = -value.x;
             result.y = -value.y;
             result.z = -value.z;
             result.w = value.w;
         }
         /**
          * @private
          */
         static scaleWeight(s, w, out) {
             var sX = s.x, sY = s.y, sZ = s.z;
             out.x = sX > 0 ? Math.pow(Math.abs(sX), w) : -Math.pow(Math.abs(sX), w);
             out.y = sY > 0 ? Math.pow(Math.abs(sY), w) : -Math.pow(Math.abs(sY), w);
             out.z = sZ > 0 ? Math.pow(Math.abs(sZ), w) : -Math.pow(Math.abs(sZ), w);
         }
         /**
          * @private
          */
         static scaleBlend(sa, sb, w, out) {
             var saw = Utils3D._tempVector3_0;
             var sbw = Utils3D._tempVector3_1;
             Utils3D.scaleWeight(sa, 1.0 - w, saw);
             Utils3D.scaleWeight(sb, w, sbw);
             var sng = w > 0.5 ? sb : sa;
             out.x = sng.x > 0 ? Math.abs(saw.x * sbw.x) : -Math.abs(saw.x * sbw.x);
             out.y = sng.y > 0 ? Math.abs(saw.y * sbw.y) : -Math.abs(saw.y * sbw.y);
             out.z = sng.z > 0 ? Math.abs(saw.z * sbw.z) : -Math.abs(saw.z * sbw.z);
         }
         static matrix4x4MultiplyFFF(a, b, e) {
             var i, ai0, ai1, ai2, ai3;
             if (e === b) {
                 b = new Float32Array(16);
                 for (i = 0; i < 16; ++i) {
                     b[i] = e[i];
                 }
             }
             var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
             var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
             var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
             var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
             for (i = 0; i < 4; i++) {
                 ai0 = a[i];
                 ai1 = a[i + 4];
                 ai2 = a[i + 8];
                 ai3 = a[i + 12];
                 e[i] = ai0 * b0 + ai1 * b1 + ai2 * b2 + ai3 * b3;
                 e[i + 4] = ai0 * b4 + ai1 * b5 + ai2 * b6 + ai3 * b7;
                 e[i + 8] = ai0 * b8 + ai1 * b9 + ai2 * b10 + ai3 * b11;
                 e[i + 12] = ai0 * b12 + ai1 * b13 + ai2 * b14 + ai3 * b15;
             }
         }
         static matrix4x4MultiplyFFFForNative(a, b, e) {
             LayaGL.instance.matrix4x4Multiply(a, b, e);
         }
         static matrix4x4MultiplyMFM(left, right, out) {
             Utils3D.matrix4x4MultiplyFFF(left.elements, right, out.elements);
         }
         /**
          * @private
          */
         static _buildTexture2D(width, height, format, colorFunc, mipmaps = false) {
             var texture = new Texture2D(width, height, format, mipmaps, true);
             texture.anisoLevel = 1;
             texture.filterMode = BaseTexture.FILTERMODE_POINT;
             TextureGenerator._generateTexture2D(texture, width, height, colorFunc);
             return texture;
         }
         /**
          * @private
          */
         static _drawBound(debugLine, boundBox, color) {
             if (debugLine.lineCount + 12 > debugLine.maxLineCount)
                 debugLine.maxLineCount += 12;
             var start = Utils3D._tempVector3_0;
             var end = Utils3D._tempVector3_1;
             var min = boundBox.min;
             var max = boundBox.max;
             start.setValue(min.x, min.y, min.z);
             end.setValue(max.x, min.y, min.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(min.x, min.y, min.z);
             end.setValue(min.x, min.y, max.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(max.x, min.y, min.z);
             end.setValue(max.x, min.y, max.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(min.x, min.y, max.z);
             end.setValue(max.x, min.y, max.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(min.x, min.y, min.z);
             end.setValue(min.x, max.y, min.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(min.x, min.y, max.z);
             end.setValue(min.x, max.y, max.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(max.x, min.y, min.z);
             end.setValue(max.x, max.y, min.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(max.x, min.y, max.z);
             end.setValue(max.x, max.y, max.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(min.x, max.y, min.z);
             end.setValue(max.x, max.y, min.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(min.x, max.y, min.z);
             end.setValue(min.x, max.y, max.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(max.x, max.y, min.z);
             end.setValue(max.x, max.y, max.z);
             debugLine.addLine(start, end, color, color);
             start.setValue(min.x, max.y, max.z);
             end.setValue(max.x, max.y, max.z);
             debugLine.addLine(start, end, color, color);
         }
         ///**@private */
         //private static var _tempHierarchyID:int = 0;
         //
         ///**
         //* @private
         //*/
         //public static function _getSpritesHierarchyID(sprite:Sprite3D, checkSprites:Array, outIDs:Array):void {
         //var index:int = checkSprites.indexOf(sprite);
         //if (index !== -1)
         //outIDs[index] = _tempHierarchyID;
         //_tempHierarchyID++;
         //var children:Array = sprite._children;
         //for (var i:int = 0, n:int = children.length; i < n; i++)
         //_getSpritesHierarchyID(children[i], checkSprites, outIDs);
         //}
         /**
          * @private
          */
         static _getHierarchyPath(rootSprite, checkSprite, path) {
             path.length = 0;
             var sprite = checkSprite;
             while (sprite !== rootSprite) {
                 var parent = sprite._parent;
                 if (parent)
                     path.push(parent.getChildIndex(sprite));
                 else
                     return null;
                 sprite = parent;
             }
             return path;
         }
         /**
          * @private
          */
         static _getNodeByHierarchyPath(rootSprite, invPath) {
             var sprite = rootSprite;
             for (var i = invPath.length - 1; i >= 0; i--) {
                 sprite = sprite.getChildAt(invPath[i]);
             }
             return sprite;
         }
     }
     /** @private */
     Utils3D._tempVector3_0 = new Vector3();
     /** @private */
     Utils3D._tempVector3_1 = new Vector3();
     /** @private */
     Utils3D._tempVector3_2 = new Vector3();
     /**@private */
     Utils3D._tempColor0 = new Color();
     Utils3D._tempArray16_0 = new Float32Array(16);
     /** @private */
     Utils3D._tempArray16_1 = new Float32Array(16);
     /** @private */
     Utils3D._tempArray16_2 = new Float32Array(16);
     /** @private */
     Utils3D._tempArray16_3 = new Float32Array(16);
     /**
      * @private
      */
     Utils3D._compIdToNode = new Object();

     /**
      * @private
      * <code>DynamicBatchManager</code> 类用于管理动态批处理。
      */
     class DynamicBatchManager {
         /**
          * 创建一个 <code>DynamicBatchManager</code> 实例。
          */
         constructor() {
             this._batchRenderElementPool = [];
         }
         /**
          * @private
          */
         static _registerManager(manager) {
             DynamicBatchManager._managers.push(manager);
         }
         /**
          * @private
          */
         _clear() {
             this._batchRenderElementPoolIndex = 0;
         }
         /**
          * @private
          */
         _getBatchRenderElementFromPool() {
             throw "StaticBatch:must override this function.";
         }
         /**
          * @private
          */
         dispose() {
         }
     }
     /** @private [只读]*/
     DynamicBatchManager._managers = [];

     /**
      * <code>Shader3D</code> 类用于创建Shader3D。
      */
     class Shader3D {
         /**
          * 创建一个 <code>Shader3D</code> 实例。
          */
         constructor(name, attributeMap, uniformMap, enableInstancing) {
             /**@private */
             this._attributeMap = null;
             /**@private */
             this._uniformMap = null;
             /**@private */
             this._enableInstancing = false;
             /**@private */
             this._subShaders = [];
             this._name = name;
             this._attributeMap = attributeMap;
             this._uniformMap = uniformMap;
             this._enableInstancing = enableInstancing;
         }
         /**
          * 通过Shader属性名称获得唯一ID。
          * @param name Shader属性名称。
          * @return 唯一ID。
          */
         static propertyNameToID(name) {
             if (Shader3D._propertyNameMap[name] != null) {
                 return Shader3D._propertyNameMap[name];
             }
             else {
                 var id = Shader3D._propertyNameCounter++;
                 Shader3D._propertyNameMap[name] = id;
                 return id;
             }
         }
         /**
          * @private
          */
         static addInclude(fileName, txt) {
             txt = txt.replace(ShaderCompile._clearCR, ""); //CRLF风格需要先去掉“\r",否则切分字符会出错导致宏定义编译错误等
             ShaderCompile.addInclude(fileName, txt);
         }
         /**
          * @private
          */
         static registerPublicDefine(name) {
             var value = Math.pow(2, Shader3D._publicCounter++); //TODO:超界处理
             Shader3D._globleDefines[value] = name;
             return value;
         }
         /**
          * 编译shader。
          * @param	name Shader名称。
          * @param   subShaderIndex 子着色器索引。
          * @param   passIndex  通道索引。
          * @param	publicDefine 公共宏定义值。
          * @param	spriteDefine 精灵宏定义值。
          * @param	materialDefine 材质宏定义值。
          */
         static compileShader(name, subShaderIndex, passIndex, publicDefine, spriteDefine, materialDefine) {
             var shader = Shader3D.find(name);
             if (shader) {
                 var subShader = shader.getSubShaderAt(subShaderIndex);
                 if (subShader) {
                     var pass = subShader._passes[passIndex];
                     if (pass) {
                         if (WebGL.shaderHighPrecision) //部分低端移动设备不支持高精度shader,所以如果在PC端或高端移动设备输出的宏定义值需做判断移除高精度宏定义
                             pass.withCompile(publicDefine, spriteDefine, materialDefine);
                         else
                             pass.withCompile(publicDefine - Shader3D.SHADERDEFINE_HIGHPRECISION, spriteDefine, materialDefine);
                     }
                     else {
                         console.warn("Shader3D: unknown passIndex.");
                     }
                 }
                 else {
                     console.warn("Shader3D: unknown subShaderIndex.");
                 }
             }
             else {
                 console.warn("Shader3D: unknown shader name.");
             }
         }
         /**
          * @private
          * 添加预编译shader文件，主要是处理宏定义
          */
         static add(name, attributeMap = null, uniformMap = null, enableInstancing = false) {
             return Shader3D._preCompileShader[name] = new Shader3D(name, attributeMap, uniformMap, enableInstancing);
         }
         /**
          * 获取ShaderCompile3D。
          * @param	name
          * @return ShaderCompile3D。
          */
         static find(name) {
             return Shader3D._preCompileShader[name];
         }
         /**
          * 添加子着色器。
          * @param 子着色器。
          */
         addSubShader(subShader) {
             this._subShaders.push(subShader);
             subShader._owner = this;
         }
         /**
          * 在特定索引获取子着色器。
          * @param	index 索引。
          * @return 子着色器。
          */
         getSubShaderAt(index) {
             return this._subShaders[index];
         }
     }
     /**渲染状态_剔除。*/
     Shader3D.RENDER_STATE_CULL = 0;
     /**渲染状态_混合。*/
     Shader3D.RENDER_STATE_BLEND = 1;
     /**渲染状态_混合源。*/
     Shader3D.RENDER_STATE_BLEND_SRC = 2;
     /**渲染状态_混合目标。*/
     Shader3D.RENDER_STATE_BLEND_DST = 3;
     /**渲染状态_混合源RGB。*/
     Shader3D.RENDER_STATE_BLEND_SRC_RGB = 4;
     /**渲染状态_混合目标RGB。*/
     Shader3D.RENDER_STATE_BLEND_DST_RGB = 5;
     /**渲染状态_混合源ALPHA。*/
     Shader3D.RENDER_STATE_BLEND_SRC_ALPHA = 6;
     /**渲染状态_混合目标ALPHA。*/
     Shader3D.RENDER_STATE_BLEND_DST_ALPHA = 7;
     /**渲染状态_混合常量颜色。*/
     Shader3D.RENDER_STATE_BLEND_CONST_COLOR = 8;
     /**渲染状态_混合方程。*/
     Shader3D.RENDER_STATE_BLEND_EQUATION = 9;
     /**渲染状态_RGB混合方程。*/
     Shader3D.RENDER_STATE_BLEND_EQUATION_RGB = 10;
     /**渲染状态_ALPHA混合方程。*/
     Shader3D.RENDER_STATE_BLEND_EQUATION_ALPHA = 11;
     /**渲染状态_深度测试。*/
     Shader3D.RENDER_STATE_DEPTH_TEST = 12;
     /**渲染状态_深度写入。*/
     Shader3D.RENDER_STATE_DEPTH_WRITE = 13;
     /**shader变量提交周期，自定义。*/
     Shader3D.PERIOD_CUSTOM = 0;
     /**shader变量提交周期，逐材质。*/
     Shader3D.PERIOD_MATERIAL = 1;
     /**shader变量提交周期，逐精灵和相机，注：因为精灵包含MVP矩阵，为复合属性，所以摄像机发生变化时也应提交。*/
     Shader3D.PERIOD_SPRITE = 2;
     /**shader变量提交周期，逐相机。*/
     Shader3D.PERIOD_CAMERA = 3;
     /**shader变量提交周期，逐场景。*/
     Shader3D.PERIOD_SCENE = 4;
     /**@private */
     Shader3D._propertyNameCounter = 0;
     /**@private */
     Shader3D._propertyNameMap = {};
     /**@private */
     Shader3D._publicCounter = 0;
     /**@private */
     Shader3D._globleDefines = [];
     /**@private */
     Shader3D._preCompileShader = {};
     /**是否开启调试模式。 */
     Shader3D.debugMode = true;

     /**
          * @private
          */
     class ShaderDefines {
         /**
          * @private
          */
         constructor(superDefines = null) {
             /**@private */
             this._counter = 0;
             /**@private [只读]*/
             this.defines = {};
             if (superDefines) {
                 this._counter = superDefines._counter;
                 for (var k in superDefines.defines)
                     this.defines[k] = superDefines.defines[k];
             }
         }
         /**
          * @private
          */
         registerDefine(name) {
             var value = Math.pow(2, this._counter++); //TODO:超界处理
             this.defines[value] = name;
             return value;
         }
     }

     /**
      * <code>AnimatorPlayState</code> 类用于创建动画播放状态信息。
      */
     class AnimatorPlayState {
         /**
          * 获取播放状态的归一化时间,整数为循环次数，小数为单次播放时间。
          */
         get normalizedTime() {
             return this._normalizedTime;
         }
         /**
          * 获取当前动画的持续时间，以秒为单位。
          */
         get duration() {
             return this._duration;
         }
         /**
          * 创建一个 <code>AnimatorPlayState</code> 实例。
          */
         constructor() {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
         }
         /**
          * @private
          */
         _resetPlayState(startTime) {
             this._finish = false;
             this._startPlayTime = startTime;
             this._elapsedTime = startTime;
             this._playEventIndex = 0;
             this._lastIsFront = true;
         }
         /**
          * @private
          */
         _cloneTo(dest) {
             dest._finish = this._finish;
             dest._startPlayTime = this._startPlayTime;
             dest._elapsedTime = this._elapsedTime;
             dest._playEventIndex = this._playEventIndex;
             dest._lastIsFront = this._lastIsFront;
         }
     }

     /**
      * <code>AnimatorControllerLayer</code> 类用于创建动画控制器层。
      */
     class AnimatorControllerLayer {
         /**
          * 创建一个 <code>AnimatorControllerLayer</code> 实例。
          */
         constructor(name) {
             /**@private */
             this._defaultState = null;
             /**@private */
             this._referenceCount = 0;
             /**@private */
             this._statesMap = {};
             /**	激活时是否自动播放*/
             this.playOnWake = true;
             this._playType = -1;
             this._crossMark = 0;
             this._crossDuration = -1;
             this._crossNodesOwnersIndicesMap = {};
             this._crossNodesOwnersCount = 0;
             this._crossNodesOwners = [];
             this._currentPlayState = null;
             this._states = [];
             this._playStateInfo = new AnimatorPlayState();
             this._crossPlayStateInfo = new AnimatorPlayState();
             this._srcCrossClipNodeIndices = [];
             this._destCrossClipNodeIndices = [];
             this.name = name;
             this.defaultWeight = 1.0;
             this.blendingMode = AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
         }
         /**
          * 获取默认动画状态。
          * @return 默认动画状态。
          */
         get defaultState() {
             return this._defaultState;
         }
         /**
          * 设置默认动画状态。
          * @param value 默认动画状态。
          */
         set defaultState(value) {
             this._defaultState = value;
             this._statesMap[value.name] = value;
         }
         /**
          * @private
          */
         _removeClip(clipStateInfos, statesMap, index, state) {
             var clip = state._clip;
             var clipStateInfo = clipStateInfos[index];
             clipStateInfos.splice(index, 1);
             delete statesMap[state.name];
             if (this._animator) {
                 var frameNodes = clip._nodes;
                 var nodeOwners = clipStateInfo._nodeOwners;
                 clip._removeReference();
                 for (var i = 0, n = frameNodes.count; i < n; i++)
                     this._animator._removeKeyframeNodeOwner(nodeOwners, frameNodes.getNodeByIndex(i));
             }
         }
         /**
          * @private
          * [实现IReferenceCounter接口]
          */
         _getReferenceCount() {
             return this._referenceCount;
         }
         /**
          * @private
          * [实现IReferenceCounter接口]
          */
         _addReference(count = 1) {
             for (var i = 0, n = this._states.length; i < n; i++)
                 this._states[i]._addReference(count);
             this._referenceCount += count;
         }
         /**
          * @private
          * [实现IReferenceCounter接口]
          */
         _removeReference(count = 1) {
             for (var i = 0, n = this._states.length; i < n; i++)
                 this._states[i]._removeReference(count);
             this._referenceCount -= count;
         }
         /**
          * @private
          * [实现IReferenceCounter接口]
          */
         _clearReference() {
             this._removeReference(-this._referenceCount);
         }
         /**
          * @private
          */
         getAnimatorState(name) {
             var state = this._statesMap[name];
             return state ? state : null;
         }
         /**
          * 添加动画状态。
          * @param	state 动画状态。
          * @param   layerIndex 层索引。
          */
         addState(state) {
             var stateName = state.name;
             if (this._statesMap[stateName]) {
                 throw "AnimatorControllerLayer:this stat's name has exist.";
             }
             else {
                 this._statesMap[stateName] = state;
                 this._states.push(state);
                 if (this._animator) {
                     state._clip._addReference();
                     this._animator._getOwnersByClip(state);
                 }
             }
         }
         /**
          * 移除动画状态。
          * @param	state 动画状态。
          * @param   layerIndex 层索引。
          */
         removeState(state) {
             var states = this._states;
             var index = -1;
             for (var i = 0, n = states.length; i < n; i++) {
                 if (states[i] === state) {
                     index = i;
                     break;
                 }
             }
             if (index !== -1)
                 this._removeClip(states, this._statesMap, index, state);
         }
         /**
          * @private
          */
         destroy() {
             this._clearReference();
             this._statesMap = null;
             this._states = null;
             this._playStateInfo = null;
             this._crossPlayStateInfo = null;
             this._defaultState = null;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var dest = destObject;
             dest.name = this.name;
             dest.blendingMode = this.blendingMode;
             dest.defaultWeight = this.defaultWeight;
             dest.playOnWake = this.playOnWake;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new AnimatorControllerLayer(this.name);
             this.cloneTo(dest);
             return dest;
         }
     }
     /**@private */
     AnimatorControllerLayer.BLENDINGMODE_OVERRIDE = 0;
     /**@private */
     AnimatorControllerLayer.BLENDINGMODE_ADDTIVE = 1;

     /**
      * <code>AnimatorState</code> 类用于创建动作状态。
      */
     class AnimatorState {
         /**
          * 创建一个 <code>AnimatorState</code> 实例。
          */
         constructor() {
             this._referenceCount = 0;
             /**@private */
             this._clip = null;
             /**@private */
             this._nodeOwners = []; //TODO:提出去
             /**@private */
             this._currentFrameIndices = null;
             /**@private */
             this._scripts = null;
             /**动画播放速度,1.0为正常播放速度。*/
             this.speed = 1.0;
             /**动作播放起始时间。*/
             this.clipStart = 0.0;
             /**动作播放结束时间。*/
             this.clipEnd = 1.0;
         }
         /**
          * 获取动作。
          * @return 动作
          */
         get clip() {
             return this._clip;
         }
         /**
          * 设置动作。
          * @param value 动作。
          */
         set clip(value) {
             if (this._clip !== value) {
                 if (this._clip)
                     (this._referenceCount > 0) && (this._clip._removeReference(this._referenceCount));
                 if (value) {
                     this._currentFrameIndices = new Int16Array(value._nodes.count);
                     this._resetFrameIndices();
                     (this._referenceCount > 0) && (this._clip._addReference(this._referenceCount));
                 }
                 this._clip = value;
             }
         }
         /**
          * @private
          * [实现IReferenceCounter接口]
          */
         _getReferenceCount() {
             return this._referenceCount;
         }
         /**
          * @private
          * [实现IReferenceCounter接口]
          */
         _addReference(count = 1) {
             (this._clip) && (this._clip._addReference(count));
             this._referenceCount += count;
         }
         /**
          * @private
          * [实现IReferenceCounter接口]
          */
         _removeReference(count = 1) {
             (this._clip) && (this._clip._removeReference(count));
             this._referenceCount -= count;
         }
         /**
          * @private
          * [实现IReferenceCounter接口]
          */
         _clearReference() {
             this._removeReference(-this._referenceCount);
         }
         /**
          * @private
          */
         _resetFrameIndices() {
             for (var i = 0, n = this._currentFrameIndices.length; i < n; i++)
                 this._currentFrameIndices[i] = -1; //-1表示没到第0帧,首帧时间可能大于
         }
         /**
          * 添加脚本。
          * @param	type  组件类型。
          * @return 脚本。
          *
          */
         addScript(type) {
             var script = new type();
             this._scripts = this._scripts || [];
             this._scripts.push(script);
             return script;
         }
         /**
          * 获取脚本。
          * @param	type  组件类型。
          * @return 脚本。
          *
          */
         getScript(type) {
             if (this._scripts) {
                 for (var i = 0, n = this._scripts.length; i < n; i++) {
                     var script = this._scripts[i];
                     if (script instanceof type)
                         return script;
                 }
             }
             return null;
         }
         /**
          * 获取脚本集合。
          * @param	type  组件类型。
          * @return 脚本集合。
          *
          */
         getScripts(type) {
             var coms;
             if (this._scripts) {
                 for (var i = 0, n = this._scripts.length; i < n; i++) {
                     var script = this._scripts[i];
                     if (script instanceof type) {
                         coms = coms || [];
                         coms.push(script);
                     }
                 }
             }
             return coms;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var dest = destObject;
             dest.name = this.name;
             dest.speed = this.speed;
             dest.clipStart = this.clipStart;
             dest.clipEnd = this.clipEnd;
             dest.clip = this._clip;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new AnimatorState();
             this.cloneTo(dest);
             return dest;
         }
     }

     /**
      * @private
      * <code>KeyframeNodeOwner</code> 类用于保存帧节点的拥有者信息。
      */
     class KeyframeNodeOwner {
         /**
          * 创建一个 <code>KeyframeNodeOwner</code> 实例。
          */
         constructor() {
             /**@private */
             this.indexInList = -1;
             /**@private */
             this.referenceCount = 0;
             /**@private */
             this.updateMark = -1;
             /**@private */
             this.type = -1;
             /**@private */
             this.fullPath = null;
             /**@private */
             this.propertyOwner = null;
             /**@private */
             this.property = null;
             /**@private */
             this.defaultValue = null;
             /**@private */
             this.crossFixedValue = null;
         }
         /**
          * @private
          */
         saveCrossFixedValue() {
             var pro = this.propertyOwner;
             if (pro) {
                 switch (this.type) {
                     case 0:
                         var proPat = this.property;
                         var m = proPat.length - 1;
                         for (var j = 0; j < m; j++) {
                             pro = pro[proPat[j]];
                             if (!pro) //属性可能或被置空
                                 break;
                         }
                         this.crossFixedValue = pro[proPat[m]];
                         break;
                     case 1:
                         var locPos = pro.localPosition;
                         this.crossFixedValue || (this.crossFixedValue = new Vector3());
                         this.crossFixedValue.x = locPos.x;
                         this.crossFixedValue.y = locPos.y;
                         this.crossFixedValue.z = locPos.z;
                         break;
                     case 2:
                         var locRot = pro.localRotation;
                         this.crossFixedValue || (this.crossFixedValue = new Quaternion());
                         this.crossFixedValue.x = locRot.x;
                         this.crossFixedValue.y = locRot.y;
                         this.crossFixedValue.z = locRot.z;
                         this.crossFixedValue.w = locRot.w;
                         break;
                     case 3:
                         var locSca = pro.localScale;
                         this.crossFixedValue || (this.crossFixedValue = new Vector3());
                         this.crossFixedValue.x = locSca.x;
                         this.crossFixedValue.y = locSca.y;
                         this.crossFixedValue.z = locSca.z;
                         break;
                     case 4:
                         var locEul = pro.localRotationEuler;
                         this.crossFixedValue || (this.crossFixedValue = new Vector3());
                         this.crossFixedValue.x = locEul.x;
                         this.crossFixedValue.y = locEul.y;
                         this.crossFixedValue.z = locEul.z;
                         break;
                     default:
                         throw "Animator:unknown type.";
                 }
             }
         }
     }

     /**
      * <code>Animator</code> 类用于创建动画组件。
      */
     class Animator extends Component {
         /**
          * 创建一个 <code>Animation</code> 实例。
          */
         constructor() {
             super();
             /**@private */
             this._keyframeNodeOwners = [];
             /**@private */
             this._linkAvatarSpritesData = {};
             /**@private */
             this._linkAvatarSprites = [];
             /**@private */
             this._renderableSprites = [];
             /**	裁剪模式*/
             this.cullingMode = Animator.CULLINGMODE_CULLCOMPLETELY;
             this._controllerLayers = [];
             this._linkSprites = {};
             this._speed = 1.0;
             this._keyframeNodeOwnerMap = {};
             this._updateMark = 0;
         }
         /**
          * @private
          */
         static _update(scene) {
             var pool = scene._animatorPool;
             var elements = pool.elements;
             for (var i = 0, n = pool.length; i < n; i++) {
                 var animator = elements[i];
                 (animator && animator.enabled) && (animator._update());
             }
         }
         /**
          * 获取动画的播放速度,1.0为正常播放速度。
          * @return 动画的播放速度。
          */
         get speed() {
             return this._speed;
         }
         /**
          * 设置动画的播放速度,1.0为正常播放速度。
          * @param 动画的播放速度。
          */
         set speed(value) {
             this._speed = value;
         }
         /**
          * @private
          */
         _linkToSprites(linkSprites) {
             for (var k in linkSprites) {
                 var nodeOwner = this.owner;
                 var path = linkSprites[k];
                 for (var j = 0, m = path.length; j < m; j++) {
                     var p = path[j];
                     if (p === "") {
                         break;
                     }
                     else {
                         nodeOwner = nodeOwner.getChildByName(p);
                         if (!nodeOwner)
                             break;
                     }
                 }
                 (nodeOwner) && (this.linkSprite3DToAvatarNode(k, nodeOwner)); //此时Avatar文件已经加载完成
             }
         }
         /**
          * @private
          */
         _addKeyframeNodeOwner(clipOwners, node, propertyOwner) {
             var nodeIndex = node._indexInList;
             var fullPath = node.fullPath;
             var keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath];
             if (keyframeNodeOwner) {
                 keyframeNodeOwner.referenceCount++;
                 clipOwners[nodeIndex] = keyframeNodeOwner;
             }
             else {
                 var property = propertyOwner;
                 for (var i = 0, n = node.propertyCount; i < n; i++) {
                     property = property[node.getPropertyByIndex(i)];
                     if (!property)
                         break;
                 }
                 keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath] = new KeyframeNodeOwner();
                 keyframeNodeOwner.fullPath = fullPath;
                 keyframeNodeOwner.indexInList = this._keyframeNodeOwners.length;
                 keyframeNodeOwner.referenceCount = 1;
                 keyframeNodeOwner.propertyOwner = propertyOwner;
                 var propertyCount = node.propertyCount;
                 var propertys = [];
                 for (i = 0; i < propertyCount; i++)
                     propertys[i] = node.getPropertyByIndex(i);
                 keyframeNodeOwner.property = propertys;
                 keyframeNodeOwner.type = node.type;
                 if (property) { //查询成功后赋默认值
                     if (node.type === 0) {
                         keyframeNodeOwner.defaultValue = property;
                     }
                     else {
                         var defaultValue = new property.constructor();
                         property.cloneTo(defaultValue);
                         keyframeNodeOwner.defaultValue = defaultValue;
                     }
                 }
                 this._keyframeNodeOwners.push(keyframeNodeOwner);
                 clipOwners[nodeIndex] = keyframeNodeOwner;
             }
         }
         /**
          * @private
          */
         _removeKeyframeNodeOwner(nodeOwners, node) {
             var fullPath = node.fullPath;
             var keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath];
             if (keyframeNodeOwner) { //TODO:Avatar中没该节点,但动画文件有,不会保存_keyframeNodeOwnerMap在中,移除会出BUG,例如动画节点下的SkinnedMeshRender有动画帧，但Avatar中忽略了
                 keyframeNodeOwner.referenceCount--;
                 if (keyframeNodeOwner.referenceCount === 0) {
                     delete this._keyframeNodeOwnerMap[fullPath];
                     this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(keyframeNodeOwner), 1);
                 }
                 nodeOwners[node._indexInList] = null;
             }
         }
         /**
          * @private
          */
         _getOwnersByClip(clipStateInfo) {
             var frameNodes = clipStateInfo._clip._nodes;
             var frameNodesCount = frameNodes.count;
             var nodeOwners = clipStateInfo._nodeOwners;
             nodeOwners.length = frameNodesCount;
             for (var i = 0; i < frameNodesCount; i++) {
                 var node = frameNodes.getNodeByIndex(i);
                 var property = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner; //如果有avatar需使用克隆节点
                 for (var j = 0, m = node.ownerPathCount; j < m; j++) {
                     var ownPat = node.getOwnerPathByIndex(j);
                     if (ownPat === "") { //TODO:直接不存
                         break;
                     }
                     else {
                         property = property.getChildByName(ownPat);
                         if (!property)
                             break;
                     }
                 }
                 if (property) {
                     var propertyOwner = node.propertyOwner;
                     (propertyOwner) && (property = property[propertyOwner]);
                     property && this._addKeyframeNodeOwner(nodeOwners, node, property);
                 }
             }
         }
         /**
          * @private
          */
         _updatePlayer(animatorState, playState, elapsedTime, islooping) {
             var clipDuration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
             var lastElapsedTime = playState._elapsedTime;
             var elapsedPlaybackTime = lastElapsedTime + elapsedTime;
             playState._lastElapsedTime = lastElapsedTime;
             playState._elapsedTime = elapsedPlaybackTime;
             var normalizedTime = elapsedPlaybackTime / clipDuration; //TODO:时候可以都统一为归一化时间
             playState._normalizedTime = normalizedTime;
             var playTime = normalizedTime % 1.0;
             playState._normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
             playState._duration = clipDuration;
             var scripts = animatorState._scripts;
             if ((!islooping && elapsedPlaybackTime >= clipDuration)) {
                 playState._finish = true;
                 playState._elapsedTime = clipDuration;
                 playState._normalizedPlayTime = 1.0;
                 if (scripts) {
                     for (var i = 0, n = scripts.length; i < n; i++)
                         scripts[i].onStateExit();
                 }
                 return;
             }
             if (scripts) {
                 for (i = 0, n = scripts.length; i < n; i++)
                     scripts[i].onStateUpdate();
             }
         }
         /**
          * @private
          */
         _eventScript(scripts, events, eventIndex, endTime, front) {
             if (front) {
                 for (var n = events.length; eventIndex < n; eventIndex++) {
                     var event = events[eventIndex];
                     if (event.time <= endTime) {
                         for (var j = 0, m = scripts.length; j < m; j++) {
                             var script = scripts[j];
                             var fun = script[event.eventName];
                             (fun) && (fun.apply(script, event.params));
                         }
                     }
                     else {
                         break;
                     }
                 }
             }
             else {
                 for (; eventIndex >= 0; eventIndex--) {
                     event = events[eventIndex];
                     if (event.time >= endTime) {
                         for (j = 0, m = scripts.length; j < m; j++) {
                             script = scripts[j];
                             fun = script[event.eventName];
                             (fun) && (fun.apply(script, event.params));
                         }
                     }
                     else {
                         break;
                     }
                 }
             }
             return eventIndex;
         }
         /**
          * @private
          */
         _updateEventScript(stateInfo, playStateInfo) {
             var scripts = this.owner._scripts;
             if (scripts) { //TODO:play是否也换成此种计算
                 var clip = stateInfo._clip;
                 var events = clip._animationEvents;
                 var clipDuration = clip._duration;
                 var elapsedTime = playStateInfo._elapsedTime;
                 var time = elapsedTime % clipDuration;
                 var loopCount = Math.abs(Math.floor(elapsedTime / clipDuration) - Math.floor(playStateInfo._lastElapsedTime / clipDuration)); //backPlay可能为负数
                 var frontPlay = playStateInfo._elapsedTime >= playStateInfo._lastElapsedTime;
                 if (playStateInfo._lastIsFront !== frontPlay) {
                     if (frontPlay)
                         playStateInfo._playEventIndex++;
                     else
                         playStateInfo._playEventIndex--;
                     playStateInfo._lastIsFront = frontPlay;
                 }
                 if (loopCount == 0) {
                     playStateInfo._playEventIndex = this._eventScript(scripts, events, playStateInfo._playEventIndex, time, frontPlay);
                 }
                 else {
                     if (frontPlay) {
                         this._eventScript(scripts, events, playStateInfo._playEventIndex, clipDuration, true);
                         for (var i = 0, n = loopCount - 1; i < n; i++)
                             this._eventScript(scripts, events, 0, clipDuration, true);
                         playStateInfo._playEventIndex = this._eventScript(scripts, events, 0, time, true);
                     }
                     else {
                         this._eventScript(scripts, events, playStateInfo._playEventIndex, 0, false);
                         var eventIndex = events.length - 1;
                         for (i = 0, n = loopCount - 1; i < n; i++)
                             this._eventScript(scripts, events, eventIndex, 0, false);
                         playStateInfo._playEventIndex = this._eventScript(scripts, events, eventIndex, time, false);
                     }
                 }
             }
         }
         /**
          * @private
          */
         _updateClipDatas(animatorState, addtive, playStateInfo, scale) {
             var clip = animatorState._clip;
             var clipDuration = clip._duration;
             var curPlayTime = animatorState.clipStart * clipDuration + playStateInfo._normalizedPlayTime * playStateInfo._duration;
             var currentFrameIndices = animatorState._currentFrameIndices;
             var frontPlay = playStateInfo._elapsedTime > playStateInfo._lastElapsedTime;
             clip._evaluateClipDatasRealTime(clip._nodes, curPlayTime, currentFrameIndices, addtive, frontPlay);
         }
         /**
          * @private
          */
         _applyFloat(pro, proName, nodeOwner, additive, weight, isFirstLayer, data) {
             if (nodeOwner.updateMark === this._updateMark) { //一定非第一层
                 if (additive) {
                     pro[proName] += weight * (data);
                 }
                 else {
                     var oriValue = pro[proName];
                     pro[proName] = oriValue + weight * (data - oriValue);
                 }
             }
             else {
                 if (isFirstLayer) {
                     if (additive)
                         pro[proName] = nodeOwner.defaultValue + data;
                     else
                         pro[proName] = data;
                 }
                 else {
                     if (additive) {
                         pro[proName] = nodeOwner.defaultValue + weight * (data);
                     }
                     else {
                         var defValue = nodeOwner.defaultValue;
                         pro[proName] = defValue + weight * (data - defValue);
                     }
                 }
             }
         }
         /**
          * @private
          */
         _applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, data, out) {
             if (nodeOwner.updateMark === this._updateMark) { //一定非第一层
                 if (additive) {
                     out.x += weight * data.x;
                     out.y += weight * data.y;
                     out.z += weight * data.z;
                 }
                 else {
                     var oriX = out.x;
                     var oriY = out.y;
                     var oriZ = out.z;
                     out.x = oriX + weight * (data.x - oriX);
                     out.y = oriY + weight * (data.y - oriY);
                     out.z = oriZ + weight * (data.z - oriZ);
                 }
             }
             else {
                 if (isFirstLayer) {
                     if (additive) {
                         var defValue = nodeOwner.defaultValue;
                         out.x = defValue.x + data.x;
                         out.y = defValue.y + data.y;
                         out.z = defValue.z + data.z;
                     }
                     else {
                         out.x = data.x;
                         out.y = data.y;
                         out.z = data.z;
                     }
                 }
                 else {
                     defValue = nodeOwner.defaultValue;
                     if (additive) {
                         out.x = defValue.x + weight * data.x;
                         out.y = defValue.y + weight * data.y;
                         out.z = defValue.z + weight * data.z;
                     }
                     else {
                         var defX = defValue.x;
                         var defY = defValue.y;
                         var defZ = defValue.z;
                         out.x = defX + weight * (data.x - defX);
                         out.y = defY + weight * (data.y - defY);
                         out.z = defZ + weight * (data.z - defZ);
                     }
                 }
             }
         }
         /**
          * @private
          */
         _applyRotation(nodeOwner, additive, weight, isFirstLayer, clipRot, localRotation) {
             if (nodeOwner.updateMark === this._updateMark) { //一定非第一层
                 if (additive) {
                     var tempQuat = Animator._tempQuaternion1; //使用临时四元数_tempQuaternion1，避免引用错乱
                     Utils3D.quaternionWeight(clipRot, weight, tempQuat);
                     tempQuat.normalize(tempQuat);
                     Quaternion.multiply(localRotation, tempQuat, localRotation);
                 }
                 else {
                     Quaternion.lerp(localRotation, clipRot, weight, localRotation);
                 }
             }
             else {
                 if (isFirstLayer) {
                     if (additive) {
                         var defaultRot = nodeOwner.defaultValue;
                         Quaternion.multiply(defaultRot, clipRot, localRotation);
                     }
                     else {
                         localRotation.x = clipRot.x;
                         localRotation.y = clipRot.y;
                         localRotation.z = clipRot.z;
                         localRotation.w = clipRot.w;
                     }
                 }
                 else {
                     defaultRot = nodeOwner.defaultValue;
                     if (additive) {
                         tempQuat = Animator._tempQuaternion1;
                         Utils3D.quaternionWeight(clipRot, weight, tempQuat);
                         tempQuat.normalize(tempQuat);
                         Quaternion.multiply(defaultRot, tempQuat, localRotation);
                     }
                     else {
                         Quaternion.lerp(defaultRot, clipRot, weight, localRotation);
                     }
                 }
             }
         }
         /**
          * @private
          */
         _applyScale(nodeOwner, additive, weight, isFirstLayer, clipSca, localScale) {
             if (nodeOwner.updateMark === this._updateMark) { //一定非第一层
                 if (additive) {
                     var scale = Animator._tempVector31;
                     Utils3D.scaleWeight(clipSca, weight, scale);
                     localScale.x = localScale.x * scale.x;
                     localScale.y = localScale.y * scale.y;
                     localScale.z = localScale.z * scale.z;
                 }
                 else {
                     Utils3D.scaleBlend(localScale, clipSca, weight, localScale);
                 }
             }
             else {
                 if (isFirstLayer) {
                     if (additive) {
                         var defaultSca = nodeOwner.defaultValue;
                         localScale.x = defaultSca.x * clipSca.x;
                         localScale.y = defaultSca.y * clipSca.y;
                         localScale.z = defaultSca.z * clipSca.z;
                     }
                     else {
                         localScale.x = clipSca.x;
                         localScale.y = clipSca.y;
                         localScale.z = clipSca.z;
                     }
                 }
                 else {
                     defaultSca = nodeOwner.defaultValue;
                     if (additive) {
                         scale = Animator._tempVector31;
                         Utils3D.scaleWeight(clipSca, weight, scale);
                         localScale.x = defaultSca.x * scale.x;
                         localScale.y = defaultSca.y * scale.y;
                         localScale.z = defaultSca.z * scale.z;
                     }
                     else {
                         Utils3D.scaleBlend(defaultSca, clipSca, weight, localScale);
                     }
                 }
             }
         }
         /**
          * @private
          */
         _applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight) {
             var pro = nodeOwner.propertyOwner;
             if (pro) {
                 switch (nodeOwner.type) {
                     case 0: //Float
                         var proPat = nodeOwner.property;
                         var m = proPat.length - 1;
                         for (var j = 0; j < m; j++) {
                             pro = pro[proPat[j]];
                             if (!pro) //属性可能或被置空
                                 break;
                         }
                         var crossValue = srcValue + crossWeight * (desValue - srcValue);
                         this._applyFloat(pro, proPat[m], nodeOwner, additive, weight, isFirstLayer, crossValue);
                         break;
                     case 1: //Position
                         var localPos = pro.localPosition;
                         var position = Animator._tempVector30;
                         var srcX = srcValue.x, srcY = srcValue.y, srcZ = srcValue.z;
                         position.x = srcX + crossWeight * (desValue.x - srcX);
                         position.y = srcY + crossWeight * (desValue.y - srcY);
                         position.z = srcZ + crossWeight * (desValue.z - srcZ);
                         this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, position, localPos);
                         pro.localPosition = localPos;
                         break;
                     case 2: //Rotation
                         var localRot = pro.localRotation;
                         var rotation = Animator._tempQuaternion0;
                         Quaternion.lerp(srcValue, desValue, crossWeight, rotation);
                         this._applyRotation(nodeOwner, additive, weight, isFirstLayer, rotation, localRot);
                         pro.localRotation = localRot;
                         break;
                     case 3: //Scale
                         var localSca = pro.localScale;
                         var scale = Animator._tempVector30;
                         Utils3D.scaleBlend(srcValue, desValue, crossWeight, scale);
                         this._applyScale(nodeOwner, additive, weight, isFirstLayer, scale, localSca);
                         pro.localScale = localSca;
                         break;
                     case 4: //RotationEuler
                         var localEuler = pro.localRotationEuler;
                         var rotationEuler = Animator._tempVector30;
                         srcX = srcValue.x, srcY = srcValue.y, srcZ = srcValue.z;
                         rotationEuler.x = srcX + crossWeight * (desValue.x - srcX);
                         rotationEuler.y = srcY + crossWeight * (desValue.y - srcY);
                         rotationEuler.z = srcZ + crossWeight * (desValue.z - srcZ);
                         this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, rotationEuler, localEuler);
                         pro.localRotationEuler = localEuler;
                         break;
                 }
                 nodeOwner.updateMark = this._updateMark;
             }
         }
         /**
          * @private
          */
         _setClipDatasToNode(stateInfo, additive, weight, isFirstLayer) {
             var nodes = stateInfo._clip._nodes;
             var nodeOwners = stateInfo._nodeOwners;
             for (var i = 0, n = nodes.count; i < n; i++) {
                 var nodeOwner = nodeOwners[i];
                 if (nodeOwner) { //骨骼中没有该节点
                     var pro = nodeOwner.propertyOwner;
                     if (pro) {
                         switch (nodeOwner.type) {
                             case 0: //Float
                                 var proPat = nodeOwner.property;
                                 var m = proPat.length - 1;
                                 for (var j = 0; j < m; j++) {
                                     pro = pro[proPat[j]];
                                     if (!pro) //属性可能或被置空
                                         break;
                                 }
                                 this._applyFloat(pro, proPat[m], nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data);
                                 break;
                             case 1: //Position
                                 var localPos = pro.localPosition;
                                 this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data, localPos);
                                 pro.localPosition = localPos;
                                 break;
                             case 2: //Rotation
                                 var localRot = pro.localRotation;
                                 this._applyRotation(nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data, localRot);
                                 pro.localRotation = localRot;
                                 break;
                             case 3: //Scale
                                 var localSca = pro.localScale;
                                 this._applyScale(nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data, localSca);
                                 pro.localScale = localSca;
                                 break;
                             case 4: //RotationEuler
                                 var localEuler = pro.localRotationEuler;
                                 this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data, localEuler);
                                 pro.localRotationEuler = localEuler;
                                 break;
                         }
                         nodeOwner.updateMark = this._updateMark;
                     }
                 }
             }
         }
         /**
          * @private
          */
         _setCrossClipDatasToNode(controllerLayer, srcState, destState, crossWeight, isFirstLayer) {
             //TODO:srcNodes、destNodes未使用
             var nodeOwners = controllerLayer._crossNodesOwners;
             var ownerCount = controllerLayer._crossNodesOwnersCount;
             var additive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
             var weight = controllerLayer.defaultWeight;
             var destDataIndices = controllerLayer._destCrossClipNodeIndices;
             var destNodes = destState._clip._nodes;
             var destNodeOwners = destState._nodeOwners;
             var srcDataIndices = controllerLayer._srcCrossClipNodeIndices;
             var srcNodeOwners = srcState._nodeOwners;
             var srcNodes = srcState._clip._nodes;
             for (var i = 0; i < ownerCount; i++) {
                 var nodeOwner = nodeOwners[i];
                 if (nodeOwner) {
                     var srcIndex = srcDataIndices[i];
                     var destIndex = destDataIndices[i];
                     var srcValue = srcIndex !== -1 ? srcNodes.getNodeByIndex(srcIndex).data : destNodeOwners[destIndex].defaultValue;
                     var desValue = destIndex !== -1 ? destNodes.getNodeByIndex(destIndex).data : srcNodeOwners[srcIndex].defaultValue;
                     this._applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight);
                 }
             }
         }
         /**
          * @private
          */
         _setFixedCrossClipDatasToNode(controllerLayer, destState, crossWeight, isFirstLayer) {
             var nodeOwners = controllerLayer._crossNodesOwners;
             var ownerCount = controllerLayer._crossNodesOwnersCount;
             var additive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
             var weight = controllerLayer.defaultWeight;
             var destDataIndices = controllerLayer._destCrossClipNodeIndices;
             var destNodes = destState._clip._nodes;
             for (var i = 0; i < ownerCount; i++) {
                 var nodeOwner = nodeOwners[i];
                 if (nodeOwner) {
                     var destIndex = destDataIndices[i];
                     var srcValue = nodeOwner.crossFixedValue;
                     var desValue = destIndex !== -1 ? destNodes.getNodeByIndex(destIndex).data : nodeOwner.defaultValue;
                     this._applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight);
                 }
             }
         }
         /**
          * @private
          */
         _revertDefaultKeyframeNodes(clipStateInfo) {
             var nodeOwners = clipStateInfo._nodeOwners;
             for (var i = 0, n = nodeOwners.length; i < n; i++) {
                 var nodeOwner = nodeOwners[i];
                 if (nodeOwner) {
                     var pro = nodeOwner.propertyOwner;
                     if (pro) {
                         switch (nodeOwner.type) {
                             case 0:
                                 var proPat = nodeOwner.property;
                                 var m = proPat.length - 1;
                                 for (var j = 0; j < m; j++) {
                                     pro = pro[proPat[j]];
                                     if (!pro) //属性可能或被置空
                                         break;
                                 }
                                 pro[proPat[m]] = nodeOwner.defaultValue;
                                 break;
                             case 1:
                                 var locPos = pro.localPosition;
                                 var def = nodeOwner.defaultValue;
                                 locPos.x = def.x;
                                 locPos.y = def.y;
                                 locPos.z = def.z;
                                 pro.localPosition = locPos;
                                 break;
                             case 2:
                                 var locRot = pro.localRotation;
                                 var defQua = nodeOwner.defaultValue;
                                 locRot.x = defQua.x;
                                 locRot.y = defQua.y;
                                 locRot.z = defQua.z;
                                 locRot.w = defQua.w;
                                 pro.localRotation = locRot;
                                 break;
                             case 3:
                                 var locSca = pro.localScale;
                                 def = nodeOwner.defaultValue;
                                 locSca.x = def.x;
                                 locSca.y = def.y;
                                 locSca.z = def.z;
                                 pro.localScale = locSca;
                                 break;
                             case 4:
                                 var locEul = pro.localRotationEuler;
                                 def = nodeOwner.defaultValue;
                                 locEul.x = def.x;
                                 locEul.y = def.y;
                                 locEul.z = def.z;
                                 pro.localRotationEuler = locEul;
                                 break;
                             default:
                                 throw "Animator:unknown type.";
                         }
                     }
                 }
             }
         }
         /**
          * @inheritDoc
          * @override
          */
         _onAdded() {
             var parent = this.owner._parent;
             this.owner._setHierarchyAnimator(this, parent ? parent._hierarchyAnimator : null); //只有动画组件在加载或卸载时才重新组织数据
             this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, true, []);
         }
         /**
          * @inheritDoc
          * @override
          */
         _onDestroy() {
             for (var i = 0, n = this._controllerLayers.length; i < n; i++)
                 this._controllerLayers[i]._removeReference();
             var parent = this.owner._parent;
             this.owner._clearHierarchyAnimator(this, parent ? parent._hierarchyAnimator : null); //只有动画组件在加载或卸载时才重新组织数据
         }
         /**
          * @inheritDoc
          * @override
          */
         _onEnable() {
             this.owner._scene._animatorPool.add(this);
             for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                 if (this._controllerLayers[i].playOnWake) {
                     var defaultClip = this.getDefaultState(i);
                     (defaultClip) && (this.play(null, i, 0));
                 }
             }
         }
         /**
          * @inheritDoc
          * @override
          */
         _onDisable() {
             this.owner._scene._animatorPool.remove(this);
         }
         /**
          * @private
          */
         _handleSpriteOwnersBySprite(isLink, path, sprite) {
             for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                 var clipStateInfos = this._controllerLayers[i]._states;
                 for (var j = 0, m = clipStateInfos.length; j < m; j++) {
                     var clipStateInfo = clipStateInfos[j];
                     var clip = clipStateInfo._clip;
                     var nodePath = path.join("/");
                     var ownersNodes = clip._nodesMap[nodePath];
                     if (ownersNodes) {
                         var nodeOwners = clipStateInfo._nodeOwners;
                         for (var k = 0, p = ownersNodes.length; k < p; k++) {
                             if (isLink)
                                 this._addKeyframeNodeOwner(nodeOwners, ownersNodes[k], sprite);
                             else
                                 this._removeKeyframeNodeOwner(nodeOwners, ownersNodes[k]);
                         }
                     }
                 }
             }
         }
         /**
          * @inheritDoc
          * @override
          */
         _parse(data) {
             var avatarData = data.avatar;
             if (avatarData) {
                 this.avatar = Loader.getRes(avatarData.path);
                 var linkSprites = avatarData.linkSprites;
                 this._linkSprites = linkSprites;
                 this._linkToSprites(linkSprites);
             }
             var clipPaths = data.clipPaths;
             var play = data.playOnWake;
             var layersData = data.layers;
             for (var i = 0; i < layersData.length; i++) {
                 var layerData = layersData[i];
                 var animatorLayer = new AnimatorControllerLayer(layerData.name);
                 if (i === 0)
                     animatorLayer.defaultWeight = 1.0; //TODO:
                 else
                     animatorLayer.defaultWeight = layerData.weight;
                 var blendingModeData = layerData.blendingMode;
                 (blendingModeData) && (animatorLayer.blendingMode = blendingModeData);
                 this.addControllerLayer(animatorLayer);
                 var states = layerData.states;
                 for (var j = 0, m = states.length; j < m; j++) {
                     var state = states[j];
                     var clipPath = state.clipPath;
                     if (clipPath) {
                         var name = state.name;
                         var motion;
                         motion = Loader.getRes(clipPath);
                         if (motion) { //加载失败motion为空
                             var animatorState = new AnimatorState();
                             animatorState.name = name;
                             animatorState.clip = motion;
                             animatorLayer.addState(animatorState);
                             (j === 0) && (this.getControllerLayer(i).defaultState = animatorState);
                         }
                     }
                 }
                 (play !== undefined) && (animatorLayer.playOnWake = play);
             }
             var cullingModeData = data.cullingMode;
             (cullingModeData !== undefined) && (this.cullingMode = cullingModeData);
         }
         /**
          * @private
          */
         _update() {
             if (this._speed === 0)
                 return;
             var needRender;
             if (this.cullingMode === Animator.CULLINGMODE_CULLCOMPLETELY) { //所有渲染精灵不可见时
                 needRender = false;
                 for (var i = 0, n = this._renderableSprites.length; i < n; i++) {
                     if (this._renderableSprites[i]._render._visible) {
                         needRender = true;
                         break;
                     }
                 }
             }
             else {
                 needRender = true;
             }
             this._updateMark++;
             var timer = this.owner._scene.timer;
             var delta = timer._delta / 1000.0; //Laya.timer.delta已结包含Laya.timer.scale
             var timerScale = timer.scale;
             for (i = 0, n = this._controllerLayers.length; i < n; i++) {
                 var controllerLayer = this._controllerLayers[i];
                 var playStateInfo = controllerLayer._playStateInfo;
                 var crossPlayStateInfo = controllerLayer._crossPlayStateInfo;
                 addtive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
                 switch (controllerLayer._playType) {
                     case 0:
                         var animatorState = controllerLayer._currentPlayState;
                         var clip = animatorState._clip;
                         var speed = this._speed * animatorState.speed;
                         var finish = playStateInfo._finish; //提前取出finish,防止最后一帧跳过
                         finish || this._updatePlayer(animatorState, playStateInfo, delta * speed, clip.islooping);
                         if (needRender) {
                             var addtive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
                             this._updateClipDatas(animatorState, addtive, playStateInfo, timerScale * speed); //clipDatas为逐动画文件,防止两个使用同一动画文件的Animator数据错乱,即使动画停止也要updateClipDatas
                             this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, i === 0); //多层动画混合时即使动画停止也要设置数据
                             finish || this._updateEventScript(animatorState, playStateInfo);
                         }
                         break;
                     case 1:
                         animatorState = controllerLayer._currentPlayState;
                         clip = animatorState._clip;
                         var crossClipState = controllerLayer._crossPlayState;
                         var crossClip = crossClipState._clip;
                         var crossDuratuion = controllerLayer._crossDuration;
                         var startPlayTime = crossPlayStateInfo._startPlayTime;
                         var crossClipDuration = crossClip._duration - startPlayTime;
                         var crossScale = crossDuratuion > crossClipDuration ? crossClipDuration / crossDuratuion : 1.0; //如果过度时间大于过度动作时间,则减慢速度
                         var crossSpeed = this._speed * crossClipState.speed;
                         this._updatePlayer(crossClipState, crossPlayStateInfo, delta * crossScale * crossSpeed, crossClip.islooping);
                         var crossWeight = ((crossPlayStateInfo._elapsedTime - startPlayTime) / crossScale) / crossDuratuion;
                         if (crossWeight >= 1.0) {
                             if (needRender) {
                                 this._updateClipDatas(crossClipState, addtive, crossPlayStateInfo, timerScale * crossSpeed);
                                 this._setClipDatasToNode(crossClipState, addtive, controllerLayer.defaultWeight, i === 0);
                                 controllerLayer._playType = 0; //完成融合,切换到正常播放状态
                                 controllerLayer._currentPlayState = crossClipState;
                                 crossPlayStateInfo._cloneTo(playStateInfo);
                             }
                         }
                         else {
                             if (!playStateInfo._finish) {
                                 speed = this._speed * animatorState.speed;
                                 this._updatePlayer(animatorState, playStateInfo, delta * speed, clip.islooping);
                                 if (needRender) {
                                     this._updateClipDatas(animatorState, addtive, playStateInfo, timerScale * speed);
                                 }
                             }
                             if (needRender) {
                                 this._updateClipDatas(crossClipState, addtive, crossPlayStateInfo, timerScale * crossScale * crossSpeed);
                                 this._setCrossClipDatasToNode(controllerLayer, animatorState, crossClipState, crossWeight, i === 0);
                             }
                         }
                         if (needRender) {
                             this._updateEventScript(animatorState, playStateInfo);
                             this._updateEventScript(crossClipState, crossPlayStateInfo);
                         }
                         break;
                     case 2:
                         crossClipState = controllerLayer._crossPlayState;
                         crossClip = crossClipState._clip;
                         crossDuratuion = controllerLayer._crossDuration;
                         startPlayTime = crossPlayStateInfo._startPlayTime;
                         crossClipDuration = crossClip._duration - startPlayTime;
                         crossScale = crossDuratuion > crossClipDuration ? crossClipDuration / crossDuratuion : 1.0; //如果过度时间大于过度动作时间,则减慢速度
                         crossSpeed = this._speed * crossClipState.speed;
                         this._updatePlayer(crossClipState, crossPlayStateInfo, delta * crossScale * crossSpeed, crossClip.islooping);
                         if (needRender) {
                             crossWeight = ((crossPlayStateInfo._elapsedTime - startPlayTime) / crossScale) / crossDuratuion;
                             if (crossWeight >= 1.0) {
                                 this._updateClipDatas(crossClipState, addtive, crossPlayStateInfo, timerScale * crossSpeed);
                                 this._setClipDatasToNode(crossClipState, addtive, 1.0, i === 0);
                                 controllerLayer._playType = 0; //完成融合,切换到正常播放状态
                                 controllerLayer._currentPlayState = crossClipState;
                                 crossPlayStateInfo._cloneTo(playStateInfo);
                             }
                             else {
                                 this._updateClipDatas(crossClipState, addtive, crossPlayStateInfo, timerScale * crossScale * crossSpeed);
                                 this._setFixedCrossClipDatasToNode(controllerLayer, crossClipState, crossWeight, i === 0);
                             }
                             this._updateEventScript(crossClipState, crossPlayStateInfo);
                         }
                         break;
                 }
             }
             if (needRender) {
                 if (this._avatar) {
                     Render.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices); //[NATIVE]
                     this._updateAvatarNodesToSprite();
                 }
             }
         }
         /**
          * @private
          * @override
          */
         _cloneTo(dest) {
             var animator = dest;
             animator.avatar = this.avatar;
             animator.cullingMode = this.cullingMode;
             for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                 var controllLayer = this._controllerLayers[i];
                 animator.addControllerLayer(controllLayer.clone());
                 var animatorStates = controllLayer._states;
                 for (var j = 0, m = animatorStates.length; j < m; j++) {
                     var state = animatorStates[j].clone();
                     var cloneLayer = animator.getControllerLayer(i);
                     cloneLayer.addState(state);
                     (j == 0) && (cloneLayer.defaultState = state);
                 }
             }
             animator._linkSprites = this._linkSprites; //TODO:需要统一概念
             animator._linkToSprites(this._linkSprites);
         }
         /**
          * 获取默认动画状态。
          * @param	layerIndex 层索引。
          * @return 默认动画状态。
          */
         getDefaultState(layerIndex = 0) {
             var controllerLayer = this._controllerLayers[layerIndex];
             return controllerLayer.defaultState;
         }
         /**
          * 添加动画状态。
          * @param	state 动画状态。
          * @param   layerIndex 层索引。
          */
         addState(state, layerIndex = 0) {
             var controllerLayer = this._controllerLayers[layerIndex];
             controllerLayer.addState(state);
             console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.");
         }
         /**
          * 移除动画状态。
          * @param	state 动画状态。
          * @param   layerIndex 层索引。
          */
         removeState(state, layerIndex = 0) {
             var controllerLayer = this._controllerLayers[layerIndex];
             controllerLayer.removeState(state);
             console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.");
         }
         /**
          * 添加控制器层。
          */
         addControllerLayer(controllderLayer) {
             this._controllerLayers.push(controllderLayer);
             controllderLayer._animator = this; //TODO:可以复用,不应该这么设计
             controllderLayer._addReference();
             var states = controllderLayer._states;
             for (var i = 0, n = states.length; i < n; i++)
                 this._getOwnersByClip(states[i]);
         }
         /**
          * 获取控制器层。
          */
         getControllerLayer(layerInex = 0) {
             return this._controllerLayers[layerInex];
         }
         /**
          * 获取当前的播放状态。
          *	@param   layerIndex 层索引。
          * 	@return  动画播放状态。
          */
         getCurrentAnimatorPlayState(layerInex = 0) {
             return this._controllerLayers[layerInex]._playStateInfo;
         }
         /**
          * 播放动画。
          * @param	name 如果为null则播放默认动画，否则按名字播放动画片段。
          * @param	layerIndex 层索引。
          * @param	normalizedTime 归一化的播放起始时间。
          */
         play(name = null, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
             var controllerLayer = this._controllerLayers[layerIndex];
             if (controllerLayer) {
                 var defaultState = controllerLayer.defaultState;
                 if (!name && !defaultState)
                     throw new Error("Animator:must have  default clip value,please set clip property.");
                 var curPlayState = controllerLayer._currentPlayState;
                 var playStateInfo = controllerLayer._playStateInfo;
                 var animatorState = name ? controllerLayer._statesMap[name] : defaultState;
                 var clipDuration = animatorState._clip._duration;
                 if (curPlayState !== animatorState) {
                     if (normalizedTime !== Number.NEGATIVE_INFINITY)
                         playStateInfo._resetPlayState(clipDuration * normalizedTime);
                     else
                         playStateInfo._resetPlayState(0.0);
                     (curPlayState !== null && curPlayState !== animatorState) && (this._revertDefaultKeyframeNodes(curPlayState));
                     controllerLayer._playType = 0;
                     controllerLayer._currentPlayState = animatorState;
                 }
                 else {
                     if (normalizedTime !== Number.NEGATIVE_INFINITY) {
                         playStateInfo._resetPlayState(clipDuration * normalizedTime);
                         controllerLayer._playType = 0;
                     }
                 }
                 var scripts = animatorState._scripts;
                 if (scripts) {
                     for (var i = 0, n = scripts.length; i < n; i++)
                         scripts[i].onStateEnter();
                 }
             }
             else {
                 console.warn("Invalid layerIndex " + layerIndex + ".");
             }
         }
         /**
          * 在当前动画状态和目标动画状态之间进行融合过渡播放。
          * @param	name 目标动画状态。
          * @param	transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。
          * @param	layerIndex 层索引。
          * @param	normalizedTime 归一化的播放起始时间。
          */
         crossFade(name, transitionDuration, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
             var controllerLayer = this._controllerLayers[layerIndex];
             if (controllerLayer) {
                 var destAnimatorState = controllerLayer._statesMap[name];
                 if (destAnimatorState) {
                     var playType = controllerLayer._playType;
                     if (playType === -1) {
                         this.play(name, layerIndex, normalizedTime); //如果未层调用过play则回滚到play方法
                         return;
                     }
                     var crossPlayStateInfo = controllerLayer._crossPlayStateInfo;
                     var crossNodeOwners = controllerLayer._crossNodesOwners;
                     var crossNodeOwnerIndicesMap = controllerLayer._crossNodesOwnersIndicesMap;
                     var srcAnimatorState = controllerLayer._currentPlayState;
                     var destNodeOwners = destAnimatorState._nodeOwners;
                     var destCrossClipNodeIndices = controllerLayer._destCrossClipNodeIndices;
                     var destClip = destAnimatorState._clip;
                     var destNodes = destClip._nodes;
                     var destNodesMap = destClip._nodesDic;
                     switch (playType) {
                         case 0:
                             var srcNodeOwners = srcAnimatorState._nodeOwners;
                             var scrCrossClipNodeIndices = controllerLayer._srcCrossClipNodeIndices;
                             var srcClip = srcAnimatorState._clip;
                             var srcNodes = srcClip._nodes;
                             var srcNodesMap = srcClip._nodesDic;
                             controllerLayer._playType = 1;
                             var crossMark = ++controllerLayer._crossMark;
                             var crossCount = controllerLayer._crossNodesOwnersCount = 0;
                             for (var i = 0, n = srcNodes.count; i < n; i++) {
                                 var srcNode = srcNodes.getNodeByIndex(i);
                                 var srcIndex = srcNode._indexInList;
                                 var srcNodeOwner = srcNodeOwners[srcIndex];
                                 if (srcNodeOwner) {
                                     var srcFullPath = srcNode.fullPath;
                                     scrCrossClipNodeIndices[crossCount] = srcIndex;
                                     var destNode = destNodesMap[srcFullPath];
                                     if (destNode)
                                         destCrossClipNodeIndices[crossCount] = destNode._indexInList;
                                     else
                                         destCrossClipNodeIndices[crossCount] = -1;
                                     crossNodeOwnerIndicesMap[srcFullPath] = crossMark;
                                     crossNodeOwners[crossCount] = srcNodeOwner;
                                     crossCount++;
                                 }
                             }
                             for (i = 0, n = destNodes.count; i < n; i++) {
                                 destNode = destNodes.getNodeByIndex(i);
                                 var destIndex = destNode._indexInList;
                                 var destNodeOwner = destNodeOwners[destIndex];
                                 if (destNodeOwner) {
                                     var destFullPath = destNode.fullPath;
                                     if (!srcNodesMap[destFullPath]) {
                                         scrCrossClipNodeIndices[crossCount] = -1;
                                         destCrossClipNodeIndices[crossCount] = destIndex;
                                         crossNodeOwnerIndicesMap[destFullPath] = crossMark;
                                         crossNodeOwners[crossCount] = destNodeOwner;
                                         crossCount++;
                                     }
                                 }
                             }
                             break;
                         case 1:
                         case 2:
                             controllerLayer._playType = 2;
                             for (i = 0, n = crossNodeOwners.length; i < n; i++) {
                                 var nodeOwner = crossNodeOwners[i];
                                 nodeOwner.saveCrossFixedValue();
                                 destNode = destNodesMap[nodeOwner.fullPath];
                                 if (destNode)
                                     destCrossClipNodeIndices[i] = destNode._indexInList;
                                 else
                                     destCrossClipNodeIndices[i] = -1;
                             }
                             crossCount = controllerLayer._crossNodesOwnersCount;
                             crossMark = controllerLayer._crossMark;
                             for (i = 0, n = destNodes.count; i < n; i++) {
                                 destNode = destNodes.getNodeByIndex(i);
                                 destIndex = destNode._indexInList;
                                 destNodeOwner = destNodeOwners[destIndex];
                                 if (destNodeOwner) {
                                     destFullPath = destNode.fullPath;
                                     if (crossNodeOwnerIndicesMap[destFullPath] !== crossMark) {
                                         destCrossClipNodeIndices[crossCount] = destIndex;
                                         crossNodeOwnerIndicesMap[destFullPath] = crossMark;
                                         nodeOwner = destNodeOwners[destIndex];
                                         crossNodeOwners[crossCount] = nodeOwner;
                                         nodeOwner.saveCrossFixedValue();
                                         crossCount++;
                                     }
                                 }
                             }
                             break;
                         default:
                     }
                     controllerLayer._crossNodesOwnersCount = crossCount;
                     controllerLayer._crossPlayState = destAnimatorState;
                     controllerLayer._crossDuration = srcAnimatorState._clip._duration * transitionDuration;
                     if (normalizedTime !== Number.NEGATIVE_INFINITY)
                         crossPlayStateInfo._resetPlayState(destClip._duration * normalizedTime);
                     else
                         crossPlayStateInfo._resetPlayState(0.0);
                     var scripts = destAnimatorState._scripts;
                     if (scripts) {
                         for (i = 0, n = scripts.length; i < n; i++)
                             scripts[i].onStateEnter();
                     }
                 }
                 else {
                     console.warn("Invalid name " + layerIndex + ".");
                 }
             }
             else {
                 console.warn("Invalid layerIndex " + layerIndex + ".");
             }
         }
         /**
          * 获取avatar。
          * @return avator。
          */
         get avatar() {
             return this._avatar;
         }
         /**
          * 设置avatar。
          * @param value avatar。
          */
         set avatar(value) {
             if (this._avatar !== value) {
                 this._avatar = value;
                 if (value) {
                     this._getAvatarOwnersAndInitDatasAsync();
                     this.owner._changeHierarchyAnimatorAvatar(this, value);
                 }
                 else {
                     var parent = this.owner._parent;
                     this.owner._changeHierarchyAnimatorAvatar(this, parent ? parent._hierarchyAnimator._avatar : null);
                 }
             }
         }
         /**
          * @private
          */
         _getAvatarOwnersAndInitDatasAsync() {
             for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                 var clipStateInfos = this._controllerLayers[i]._states;
                 for (var j = 0, m = clipStateInfos.length; j < m; j++)
                     this._getOwnersByClip(clipStateInfos[j]);
             }
             this._avatar._cloneDatasToAnimator(this);
             for (var k in this._linkAvatarSpritesData) {
                 var sprites = this._linkAvatarSpritesData[k];
                 if (sprites) {
                     for (var c = 0, p = sprites.length; c < p; c++)
                         this._isLinkSpriteToAnimationNode(sprites[c], k, true); //TODO:对应移除
                 }
             }
         }
         /**
          * @private
          */
         _isLinkSpriteToAnimationNode(sprite, nodeName, isLink) {
             if (this._avatar) {
                 var node = this._avatarNodeMap[nodeName];
                 if (node) {
                     if (isLink) {
                         sprite._transform._dummy = node.transform;
                         this._linkAvatarSprites.push(sprite);
                         var nodeTransform = node.transform; //nodeTransform为空时表示avatar中暂时无此节点
                         var spriteTransform = sprite.transform;
                         if (!spriteTransform.owner.isStatic && nodeTransform) { //Avatar跟节点始终为false,不会更新,Scene无transform
                             //TODO:spriteTransform.owner.isStatic外部判断
                             var spriteWorldMatrix = spriteTransform.worldMatrix;
                             var ownParTra = this.owner._transform._parent;
                             if (ownParTra) {
                                 Utils3D.matrix4x4MultiplyMFM(ownParTra.worldMatrix, nodeTransform.getWorldMatrix(), spriteWorldMatrix); //TODO:还可优化
                             }
                             else {
                                 var sprWorE = spriteWorldMatrix.elements;
                                 var nodWorE = nodeTransform.getWorldMatrix();
                                 for (var i = 0; i < 16; i++)
                                     sprWorE[i] = nodWorE[i];
                             }
                             spriteTransform.worldMatrix = spriteWorldMatrix;
                         }
                     }
                     else {
                         sprite._transform._dummy = null;
                         this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(sprite), 1);
                     }
                 }
             }
         }
         /**
          * @private
          */
         _isLinkSpriteToAnimationNodeData(sprite, nodeName, isLink) {
             var linkSprites = this._linkAvatarSpritesData[nodeName]; //存储挂点数据
             if (isLink) {
                 linkSprites || (this._linkAvatarSpritesData[nodeName] = linkSprites = []);
                 linkSprites.push(sprite);
             }
             else {
                 var index = linkSprites.indexOf(sprite);
                 linkSprites.splice(index, 1);
             }
         }
         /**
          *@private
          */
         _updateAvatarNodesToSprite() {
             for (var i = 0, n = this._linkAvatarSprites.length; i < n; i++) {
                 var sprite = this._linkAvatarSprites[i];
                 var nodeTransform = sprite.transform._dummy; //nodeTransform为空时表示avatar中暂时无此节点
                 var spriteTransform = sprite.transform;
                 if (!spriteTransform.owner.isStatic && nodeTransform) {
                     var spriteWorldMatrix = spriteTransform.worldMatrix;
                     var ownTra = this.owner._transform;
                     Utils3D.matrix4x4MultiplyMFM(ownTra.worldMatrix, nodeTransform.getWorldMatrix(), spriteWorldMatrix);
                     spriteTransform.worldMatrix = spriteWorldMatrix;
                 }
             }
         }
         /**
          * 关联精灵节点到Avatar节点,此Animator必须有Avatar文件。
          * @param nodeName 关联节点的名字。
          * @param sprite3D 精灵节点。
          * @return 是否关联成功。
          */
         linkSprite3DToAvatarNode(nodeName, sprite3D) {
             this._isLinkSpriteToAnimationNodeData(sprite3D, nodeName, true);
             this._isLinkSpriteToAnimationNode(sprite3D, nodeName, true);
             return true;
         }
         /**
          * 解除精灵节点到Avatar节点的关联,此Animator必须有Avatar文件。
          * @param sprite3D 精灵节点。
          * @return 是否解除关联成功。
          */
         unLinkSprite3DToAvatarNode(sprite3D) {
             if (sprite3D._hierarchyAnimator === this) {
                 var dummy = sprite3D.transform._dummy;
                 if (dummy) {
                     var nodeName = dummy._owner.name;
                     this._isLinkSpriteToAnimationNodeData(sprite3D, nodeName, false);
                     this._isLinkSpriteToAnimationNode(sprite3D, nodeName, false);
                     return true;
                 }
                 else {
                     return false;
                 }
             }
             else {
                 throw ("Animator:sprite3D must belong to this Animator");
                 return false;
             }
         }
         /**
          *@private
          * [NATIVE]
          */
         _updateAnimationNodeWorldMatix(localPositions, localRotations, localScales, worldMatrixs, parentIndices) {
             LayaGL.instance.updateAnimationNodeWorldMatix(localPositions, localRotations, localScales, parentIndices, worldMatrixs);
         }
     }
     /** @private */
     Animator._tempVector30 = new Vector3();
     /** @private */
     Animator._tempVector31 = new Vector3();
     /** @private */
     Animator._tempQuaternion0 = new Quaternion();
     /** @private */
     Animator._tempQuaternion1 = new Quaternion();
     /** @private */
     Animator._tempVector3Array0 = new Float32Array(3);
     /** @private */
     Animator._tempVector3Array1 = new Float32Array(3);
     /** @private */
     Animator._tempQuaternionArray0 = new Float32Array(4);
     /** @private */
     Animator._tempQuaternionArray1 = new Float32Array(4);
     /** 裁剪模式_始终播放动画。*/
     Animator.CULLINGMODE_ALWAYSANIMATE = 0;
     /** 裁剪模式_不可见时完全不播放动画。*/
     Animator.CULLINGMODE_CULLCOMPLETELY = 2;

     /**
      * <code>Matrix4x4</code> 类用于创建4x4矩阵。
      */
     class Matrix4x4 {
         /**
          * 创建一个 <code>Matrix4x4</code> 实例。
          * @param	4x4矩阵的各元素
          */
         constructor(m11 = 1, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 1, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 1, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 1, elements = null) {
             var e = elements ? this.elements = elements : this.elements = new Float32Array(16); //TODO:[NATIVE]临时
             e[0] = m11;
             e[1] = m12;
             e[2] = m13;
             e[3] = m14;
             e[4] = m21;
             e[5] = m22;
             e[6] = m23;
             e[7] = m24;
             e[8] = m31;
             e[9] = m32;
             e[10] = m33;
             e[11] = m34;
             e[12] = m41;
             e[13] = m42;
             e[14] = m43;
             e[15] = m44;
         }
         /**
          * 绕X轴旋转
          * @param	rad  旋转角度
          * @param	out 输出矩阵
          */
         static createRotationX(rad, out) {
             var oe = out.elements;
             var s = Math.sin(rad), c = Math.cos(rad);
             oe[1] = oe[2] = oe[3] = oe[4] = oe[7] = oe[8] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
             oe[0] = oe[15] = 1;
             oe[5] = oe[10] = c;
             oe[6] = s;
             oe[9] = -s;
         }
         /**
          *
          * 绕Y轴旋转
          * @param	rad  旋转角度
          * @param	out 输出矩阵
          */
         static createRotationY(rad, out) {
             var oe = out.elements;
             var s = Math.sin(rad), c = Math.cos(rad);
             oe[1] = oe[3] = oe[4] = oe[6] = oe[7] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
             oe[5] = oe[15] = 1;
             oe[0] = oe[10] = c;
             oe[2] = -s;
             oe[8] = s;
         }
         /**
          * 绕Z轴旋转
          * @param	rad  旋转角度
          * @param	out 输出矩阵
          */
         static createRotationZ(rad, out) {
             var oe = out.elements;
             var s = Math.sin(rad), c = Math.cos(rad);
             oe[2] = oe[3] = oe[6] = oe[7] = oe[8] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
             oe[10] = oe[15] = 1;
             oe[0] = oe[5] = c;
             oe[1] = s;
             oe[4] = -s;
         }
         /**
          * 通过yaw pitch roll旋转创建旋转矩阵。
          * @param	yaw
          * @param	pitch
          * @param	roll
          * @param	result
          */
         static createRotationYawPitchRoll(yaw, pitch, roll, result) {
             Quaternion.createFromYawPitchRoll(yaw, pitch, roll, Matrix4x4._tempQuaternion);
             Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion, result);
         }
         /**
          * 通过旋转轴axis和旋转角度angle计算旋转矩阵。
          * @param	axis 旋转轴,假定已经归一化。
          * @param	angle 旋转角度。
          * @param	result 结果矩阵。
          */
         static createRotationAxis(axis, angle, result) {
             var x = axis.x;
             var y = axis.y;
             var z = axis.z;
             var cos = Math.cos(angle);
             var sin = Math.sin(angle);
             var xx = x * x;
             var yy = y * y;
             var zz = z * z;
             var xy = x * y;
             var xz = x * z;
             var yz = y * z;
             var resultE = result.elements;
             resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
             resultE[15] = 1.0;
             resultE[0] = xx + (cos * (1.0 - xx));
             resultE[1] = (xy - (cos * xy)) + (sin * z);
             resultE[2] = (xz - (cos * xz)) - (sin * y);
             resultE[4] = (xy - (cos * xy)) - (sin * z);
             resultE[5] = yy + (cos * (1.0 - yy));
             resultE[6] = (yz - (cos * yz)) + (sin * x);
             resultE[8] = (xz - (cos * xz)) + (sin * y);
             resultE[9] = (yz - (cos * yz)) - (sin * x);
             resultE[10] = zz + (cos * (1.0 - zz));
         }
         setRotation(rotation) {
             var rotationX = rotation.x;
             var rotationY = rotation.y;
             var rotationZ = rotation.z;
             var rotationW = rotation.w;
             var xx = rotationX * rotationX;
             var yy = rotationY * rotationY;
             var zz = rotationZ * rotationZ;
             var xy = rotationX * rotationY;
             var zw = rotationZ * rotationW;
             var zx = rotationZ * rotationX;
             var yw = rotationY * rotationW;
             var yz = rotationY * rotationZ;
             var xw = rotationX * rotationW;
             var e = this.elements;
             e[0] = 1.0 - (2.0 * (yy + zz));
             e[1] = 2.0 * (xy + zw);
             e[2] = 2.0 * (zx - yw);
             e[4] = 2.0 * (xy - zw);
             e[5] = 1.0 - (2.0 * (zz + xx));
             e[6] = 2.0 * (yz + xw);
             e[8] = 2.0 * (zx + yw);
             e[9] = 2.0 * (yz - xw);
             e[10] = 1.0 - (2.0 * (yy + xx));
         }
         setPosition(position) {
             var e = this.elements;
             e[12] = position.x;
             e[13] = position.y;
             e[14] = position.z;
         }
         /**
          * 通过四元数创建旋转矩阵。
          * @param	rotation 旋转四元数。
          * @param	result 输出旋转矩阵
          */
         static createRotationQuaternion(rotation, result) {
             var resultE = result.elements;
             var rotationX = rotation.x;
             var rotationY = rotation.y;
             var rotationZ = rotation.z;
             var rotationW = rotation.w;
             var xx = rotationX * rotationX;
             var yy = rotationY * rotationY;
             var zz = rotationZ * rotationZ;
             var xy = rotationX * rotationY;
             var zw = rotationZ * rotationW;
             var zx = rotationZ * rotationX;
             var yw = rotationY * rotationW;
             var yz = rotationY * rotationZ;
             var xw = rotationX * rotationW;
             resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
             resultE[15] = 1.0;
             resultE[0] = 1.0 - (2.0 * (yy + zz));
             resultE[1] = 2.0 * (xy + zw);
             resultE[2] = 2.0 * (zx - yw);
             resultE[4] = 2.0 * (xy - zw);
             resultE[5] = 1.0 - (2.0 * (zz + xx));
             resultE[6] = 2.0 * (yz + xw);
             resultE[8] = 2.0 * (zx + yw);
             resultE[9] = 2.0 * (yz - xw);
             resultE[10] = 1.0 - (2.0 * (yy + xx));
         }
         /**
          * 根据平移计算输出矩阵
          * @param	trans  平移向量
          * @param	out 输出矩阵
          */
         static createTranslate(trans, out) {
             var oe = out.elements;
             oe[4] = oe[8] = oe[1] = oe[9] = oe[2] = oe[6] = oe[3] = oe[7] = oe[11] = 0;
             oe[0] = oe[5] = oe[10] = oe[15] = 1;
             oe[12] = trans.x;
             oe[13] = trans.y;
             oe[14] = trans.z;
         }
         /**
          * 根据缩放计算输出矩阵
          * @param	scale  缩放值
          * @param	out 输出矩阵
          */
         static createScaling(scale, out) {
             var oe = out.elements;
             oe[0] = scale.x;
             oe[5] = scale.y;
             oe[10] = scale.z;
             oe[1] = oe[4] = oe[8] = oe[12] = oe[9] = oe[13] = oe[2] = oe[6] = oe[14] = oe[3] = oe[7] = oe[11] = 0;
             oe[15] = 1;
         }
         /**
          * 计算两个矩阵的乘法
          * @param	left left矩阵
          * @param	right  right矩阵
          * @param	out  输出矩阵
          */
         static multiply(left, right, out) {
             var i, e, a, b, ai0, ai1, ai2, ai3;
             e = out.elements;
             a = left.elements;
             b = right.elements;
             if (e === b) {
                 b = new Float32Array(16);
                 for (i = 0; i < 16; ++i) {
                     b[i] = e[i];
                 }
             }
             var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
             var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
             var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
             var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
             for (i = 0; i < 4; i++) {
                 ai0 = a[i];
                 ai1 = a[i + 4];
                 ai2 = a[i + 8];
                 ai3 = a[i + 12];
                 e[i] = ai0 * b0 + ai1 * b1 + ai2 * b2 + ai3 * b3;
                 e[i + 4] = ai0 * b4 + ai1 * b5 + ai2 * b6 + ai3 * b7;
                 e[i + 8] = ai0 * b8 + ai1 * b9 + ai2 * b10 + ai3 * b11;
                 e[i + 12] = ai0 * b12 + ai1 * b13 + ai2 * b14 + ai3 * b15;
             }
         }
         static multiplyForNative(left, right, out) {
             LayaGL.instance.matrix4x4Multiply(left.elements, right.elements, out.elements);
         }
         /**
          * 从四元数计算旋转矩阵
          * @param	rotation 四元数
          * @param	out 输出矩阵
          */
         static createFromQuaternion(rotation, out) {
             var e = out.elements;
             var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
             var x2 = x + x;
             var y2 = y + y;
             var z2 = z + z;
             var xx = x * x2;
             var yx = y * x2;
             var yy = y * y2;
             var zx = z * x2;
             var zy = z * y2;
             var zz = z * z2;
             var wx = w * x2;
             var wy = w * y2;
             var wz = w * z2;
             e[0] = 1 - yy - zz;
             e[1] = yx + wz;
             e[2] = zx - wy;
             e[3] = 0;
             e[4] = yx - wz;
             e[5] = 1 - xx - zz;
             e[6] = zy + wx;
             e[7] = 0;
             e[8] = zx + wy;
             e[9] = zy - wx;
             e[10] = 1 - xx - yy;
             e[11] = 0;
             e[12] = 0;
             e[13] = 0;
             e[14] = 0;
             e[15] = 1;
         }
         /**
          * 计算仿射矩阵
          * @param	trans 平移
          * @param	rot 旋转
          * @param	scale 缩放
          * @param	out 输出矩阵
          */
         static createAffineTransformation(trans, rot, scale, out) {
             var oe = out.elements;
             var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
             var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
             var wx = w * x2, wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
             oe[0] = (1 - (yy + zz)) * sx;
             oe[1] = (xy + wz) * sx;
             oe[2] = (xz - wy) * sx;
             oe[3] = 0;
             oe[4] = (xy - wz) * sy;
             oe[5] = (1 - (xx + zz)) * sy;
             oe[6] = (yz + wx) * sy;
             oe[7] = 0;
             oe[8] = (xz + wy) * sz;
             oe[9] = (yz - wx) * sz;
             oe[10] = (1 - (xx + yy)) * sz;
             oe[11] = 0;
             oe[12] = trans.x;
             oe[13] = trans.y;
             oe[14] = trans.z;
             oe[15] = 1;
         }
         /**
          *  计算观察矩阵
          * @param	eye 视点位置
          * @param	center 视点目标
          * @param	up 向上向量
          * @param	out 输出矩阵
          */
         static createLookAt(eye, target, up, out) {
             //注:WebGL为右手坐标系统
             var oE = out.elements;
             var xaxis = Matrix4x4._tempVector0;
             var yaxis = Matrix4x4._tempVector1;
             var zaxis = Matrix4x4._tempVector2;
             Vector3.subtract(eye, target, zaxis);
             Vector3.normalize(zaxis, zaxis);
             Vector3.cross(up, zaxis, xaxis);
             Vector3.normalize(xaxis, xaxis);
             Vector3.cross(zaxis, xaxis, yaxis);
             out.identity();
             oE[0] = xaxis.x;
             oE[4] = xaxis.y;
             oE[8] = xaxis.z;
             oE[1] = yaxis.x;
             oE[5] = yaxis.y;
             oE[9] = yaxis.z;
             oE[2] = zaxis.x;
             oE[6] = zaxis.y;
             oE[10] = zaxis.z;
             oE[12] = -Vector3.dot(xaxis, eye);
             oE[13] = -Vector3.dot(yaxis, eye);
             oE[14] = -Vector3.dot(zaxis, eye);
         }
         /**
          * 通过FOV创建透视投影矩阵。
          * @param	fov  视角。
          * @param	aspect 横纵比。
          * @param	near 近裁面。
          * @param	far 远裁面。
          * @param	out 输出矩阵。
          */
         static createPerspective(fov, aspect, znear, zfar, out) {
             var yScale = 1.0 / Math.tan(fov * 0.5);
             var xScale = yScale / aspect;
             var halfWidth = znear / xScale;
             var halfHeight = znear / yScale;
             Matrix4x4.createPerspectiveOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, znear, zfar, out);
         }
         /**
          * 创建透视投影矩阵。
          * @param	left 视椎左边界。
          * @param	right 视椎右边界。
          * @param	bottom 视椎底边界。
          * @param	top 视椎顶边界。
          * @param	znear 视椎近边界。
          * @param	zfar 视椎远边界。
          * @param	out 输出矩阵。
          */
         static createPerspectiveOffCenter(left, right, bottom, top, znear, zfar, out) {
             var oe = out.elements;
             var zRange = zfar / (zfar - znear);
             oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[7] = oe[12] = oe[13] = oe[15] = 0;
             oe[0] = 2.0 * znear / (right - left);
             oe[5] = 2.0 * znear / (top - bottom);
             oe[8] = (left + right) / (right - left);
             oe[9] = (top + bottom) / (top - bottom);
             oe[10] = -zRange;
             oe[11] = -1.0;
             oe[14] = -znear * zRange;
         }
         /**
          * 计算正交投影矩阵。
          * @param	left 视椎左边界。
          * @param	right 视椎右边界。
          * @param	bottom 视椎底边界。
          * @param	top 视椎顶边界。
          * @param	near 视椎近边界。
          * @param	far 视椎远边界。
          * @param	out 输出矩阵。
          */
         static createOrthoOffCenter(left, right, bottom, top, znear, zfar, out) {
             var oe = out.elements;
             var zRange = 1.0 / (zfar - znear);
             oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[8] = oe[7] = oe[9] = oe[11] = 0;
             oe[15] = 1;
             oe[0] = 2.0 / (right - left);
             oe[5] = 2.0 / (top - bottom);
             oe[10] = -zRange;
             oe[12] = (left + right) / (left - right);
             oe[13] = (top + bottom) / (bottom - top);
             oe[14] = -znear * zRange;
         }
         getElementByRowColumn(row, column) {
             if (row < 0 || row > 3)
                 throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
             if (column < 0 || column > 3)
                 throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
             return this.elements[(row * 4) + column];
         }
         setElementByRowColumn(row, column, value) {
             if (row < 0 || row > 3)
                 throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
             if (column < 0 || column > 3)
                 throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
             this.elements[(row * 4) + column] = value;
         }
         /**
          * 判断两个4x4矩阵的值是否相等。
          * @param	other 4x4矩阵
          */
         equalsOtherMatrix(other) {
             var e = this.elements;
             var oe = other.elements;
             return (MathUtils3D.nearEqual(e[0], oe[0]) && MathUtils3D.nearEqual(e[1], oe[1]) && MathUtils3D.nearEqual(e[2], oe[2]) && MathUtils3D.nearEqual(e[3], oe[3]) && MathUtils3D.nearEqual(e[4], oe[4]) && MathUtils3D.nearEqual(e[5], oe[5]) && MathUtils3D.nearEqual(e[6], oe[6]) && MathUtils3D.nearEqual(e[7], oe[7]) && MathUtils3D.nearEqual(e[8], oe[8]) && MathUtils3D.nearEqual(e[9], oe[9]) && MathUtils3D.nearEqual(e[10], oe[10]) && MathUtils3D.nearEqual(e[11], oe[11]) && MathUtils3D.nearEqual(e[12], oe[12]) && MathUtils3D.nearEqual(e[13], oe[13]) && MathUtils3D.nearEqual(e[14], oe[14]) && MathUtils3D.nearEqual(e[15], oe[15]));
         }
         /**
          * 分解矩阵为平移向量、旋转四元数、缩放向量。
          * @param	translation 平移向量。
          * @param	rotation 旋转四元数。
          * @param	scale 缩放向量。
          * @return 是否分解成功。
          */
         decomposeTransRotScale(translation, rotation, scale) {
             var rotationMatrix = Matrix4x4._tempMatrix4x4;
             if (this.decomposeTransRotMatScale(translation, rotationMatrix, scale)) {
                 Quaternion.createFromMatrix4x4(rotationMatrix, rotation);
                 return true;
             }
             else {
                 rotation.identity();
                 return false;
             }
         }
         /**
          * 分解矩阵为平移向量、旋转矩阵、缩放向量。
          * @param	translation 平移向量。
          * @param	rotationMatrix 旋转矩阵。
          * @param	scale 缩放向量。
          * @return 是否分解成功。
          */
         decomposeTransRotMatScale(translation, rotationMatrix, scale) {
             var e = this.elements;
             var te = translation;
             var re = rotationMatrix.elements;
             var se = scale;
             //Get the translation. 
             te.x = e[12];
             te.y = e[13];
             te.z = e[14];
             //Scaling is the length of the rows. 
             var m11 = e[0], m12 = e[1], m13 = e[2];
             var m21 = e[4], m22 = e[5], m23 = e[6];
             var m31 = e[8], m32 = e[9], m33 = e[10];
             var sX = se.x = Math.sqrt((m11 * m11) + (m12 * m12) + (m13 * m13));
             var sY = se.y = Math.sqrt((m21 * m21) + (m22 * m22) + (m23 * m23));
             var sZ = se.z = Math.sqrt((m31 * m31) + (m32 * m32) + (m33 * m33));
             //If any of the scaling factors are zero, than the rotation matrix can not exist. 
             if (MathUtils3D.isZero(sX) || MathUtils3D.isZero(sY) || MathUtils3D.isZero(sZ)) {
                 re[1] = re[2] = re[3] = re[4] = re[6] = re[7] = re[8] = re[9] = re[11] = re[12] = re[13] = re[14] = 0;
                 re[0] = re[5] = re[10] = re[15] = 1;
                 return false;
             }
             // Calculate an perfect orthonormal matrix (no reflections)
             var at = Matrix4x4._tempVector0;
             at.x = m31 / sZ;
             at.y = m32 / sZ;
             at.z = m33 / sZ;
             var tempRight = Matrix4x4._tempVector1;
             tempRight.x = m11 / sX;
             tempRight.y = m12 / sX;
             tempRight.z = m13 / sX;
             var up = Matrix4x4._tempVector2;
             Vector3.cross(at, tempRight, up);
             var right = Matrix4x4._tempVector1;
             Vector3.cross(up, at, right);
             re[3] = re[7] = re[11] = re[12] = re[13] = re[14] = 0;
             re[15] = 1;
             re[0] = right.x;
             re[1] = right.y;
             re[2] = right.z;
             re[4] = up.x;
             re[5] = up.y;
             re[6] = up.z;
             re[8] = at.x;
             re[9] = at.y;
             re[10] = at.z;
             // In case of reflexions//TODO:是否不用计算dot后的值即为结果
             ((re[0] * m11 + re[1] * m12 + re[2] * m13) /*Vector3.dot(right,Right)*/ < 0.0) && (se[0] = -sX);
             ((re[4] * m21 + re[5] * m22 + re[6] * m23) /* Vector3.dot(up, Up)*/ < 0.0) && (se[1] = -sY);
             ((re[8] * m31 + re[9] * m32 + re[10] * m33) /*Vector3.dot(at, Backward)*/ < 0.0) && (se[2] = -sZ);
             return true;
         }
         /**
          * 分解旋转矩阵的旋转为YawPitchRoll欧拉角。
          * @param	out float yaw
          * @param	out float pitch
          * @param	out float roll
          * @return
          */
         decomposeYawPitchRoll(yawPitchRoll) {
             var pitch = Math.asin(-this.elements[9]);
             yawPitchRoll.y = pitch;
             // Hardcoded constant - burn him, he's a witch
             // double threshold = 0.001; 
             var test = Math.cos(pitch);
             if (test > MathUtils3D.zeroTolerance) {
                 yawPitchRoll.z = Math.atan2(this.elements[1], this.elements[5]);
                 yawPitchRoll.x = Math.atan2(this.elements[8], this.elements[10]);
             }
             else {
                 yawPitchRoll.z = Math.atan2(-this.elements[4], this.elements[0]);
                 yawPitchRoll.x = 0.0;
             }
         }
         /**归一化矩阵 */
         normalize() {
             var v = this.elements;
             var c = v[0], d = v[1], e = v[2], g = Math.sqrt(c * c + d * d + e * e);
             if (g) {
                 if (g == 1)
                     return;
             }
             else {
                 v[0] = 0;
                 v[1] = 0;
                 v[2] = 0;
                 return;
             }
             g = 1 / g;
             v[0] = c * g;
             v[1] = d * g;
             v[2] = e * g;
         }
         /**计算矩阵的转置矩阵*/
         transpose() {
             var e, t;
             e = this.elements;
             t = e[1];
             e[1] = e[4];
             e[4] = t;
             t = e[2];
             e[2] = e[8];
             e[8] = t;
             t = e[3];
             e[3] = e[12];
             e[12] = t;
             t = e[6];
             e[6] = e[9];
             e[9] = t;
             t = e[7];
             e[7] = e[13];
             e[13] = t;
             t = e[11];
             e[11] = e[14];
             e[14] = t;
             return this;
         }
         /**
          * 计算一个矩阵的逆矩阵
          * @param	out 输出矩阵
          */
         invert(out) {
             var ae = this.elements;
             var oe = out.elements;
             var a00 = ae[0], a01 = ae[1], a02 = ae[2], a03 = ae[3], a10 = ae[4], a11 = ae[5], a12 = ae[6], a13 = ae[7], a20 = ae[8], a21 = ae[9], a22 = ae[10], a23 = ae[11], a30 = ae[12], a31 = ae[13], a32 = ae[14], a33 = ae[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, 
             // Calculate the determinant 
             det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
             if (Math.abs(det) === 0.0) {
                 return;
             }
             det = 1.0 / det;
             oe[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
             oe[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
             oe[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
             oe[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
             oe[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
             oe[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
             oe[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
             oe[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
             oe[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
             oe[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
             oe[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
             oe[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
             oe[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
             oe[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
             oe[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
             oe[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
         }
         /**
          * 计算BlillBoard矩阵
          * @param	objectPosition 物体位置
          * @param	cameraPosition 相机位置
          * @param	cameraUp       相机上向量
          * @param	cameraForward  相机前向量
          * @param	mat            变换矩阵
          */
         static billboard(objectPosition, cameraPosition, cameraRight, cameraUp, cameraForward, mat) {
             Vector3.subtract(objectPosition, cameraPosition, Matrix4x4._tempVector0);
             var lengthSq = Vector3.scalarLengthSquared(Matrix4x4._tempVector0);
             if (MathUtils3D.isZero(lengthSq)) {
                 Vector3.scale(cameraForward, -1, Matrix4x4._tempVector1);
                 Matrix4x4._tempVector1.cloneTo(Matrix4x4._tempVector0);
             }
             else {
                 Vector3.scale(Matrix4x4._tempVector0, 1 / Math.sqrt(lengthSq), Matrix4x4._tempVector0);
             }
             Vector3.cross(cameraUp, Matrix4x4._tempVector0, Matrix4x4._tempVector2);
             Vector3.normalize(Matrix4x4._tempVector2, Matrix4x4._tempVector2);
             Vector3.cross(Matrix4x4._tempVector0, Matrix4x4._tempVector2, Matrix4x4._tempVector3);
             var crosse = Matrix4x4._tempVector2;
             var finale = Matrix4x4._tempVector3;
             var diffee = Matrix4x4._tempVector0;
             var obpose = objectPosition;
             var mate = mat.elements;
             mate[0] = crosse.x;
             mate[1] = crosse.y;
             mate[2] = crosse.z;
             mate[3] = 0.0;
             mate[4] = finale.x;
             mate[5] = finale.y;
             mate[6] = finale.z;
             mate[7] = 0.0;
             mate[8] = diffee.x;
             mate[9] = diffee.y;
             mate[10] = diffee.z;
             mate[11] = 0.0;
             mate[12] = obpose.x;
             mate[13] = obpose.y;
             mate[14] = obpose.z;
             mate[15] = 1.0;
         }
         /**设置矩阵为单位矩阵*/
         identity() {
             var e = this.elements;
             e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0;
             e[0] = e[5] = e[10] = e[15] = 1;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var i, s, d;
             s = this.elements;
             d = destObject.elements;
             if (s === d) {
                 return;
             }
             for (i = 0; i < 16; ++i) {
                 d[i] = s[i];
             }
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new Matrix4x4();
             this.cloneTo(dest);
             return dest;
         }
         static translation(v3, out) {
             var oe = out.elements;
             oe[0] = oe[5] = oe[10] = oe[15] = 1;
             oe[12] = v3.x;
             oe[13] = v3.y;
             oe[14] = v3.z;
         }
         /**
          * 获取平移向量。
          * @param	out 平移向量。
          */
         getTranslationVector(out) {
             var me = this.elements;
             out.x = me[12];
             out.y = me[13];
             out.z = me[14];
         }
         /**
          * 设置平移向量。
          * @param	translate 平移向量。
          */
         setTranslationVector(translate) {
             var me = this.elements;
             var ve = translate;
             me[12] = ve.x;
             me[13] = ve.y;
             me[14] = ve.z;
         }
         /**
          * 获取前向量。
          * @param	out 前向量。
          */
         getForward(out) {
             var me = this.elements;
             out.x = -me[8];
             out.y = -me[9];
             out.z = -me[10];
         }
         /**
          * 设置前向量。
          * @param	forward 前向量。
          */
         setForward(forward) {
             var me = this.elements;
             me[8] = -forward.x;
             me[9] = -forward.y;
             me[10] = -forward.z;
         }
     }
     /**@private */
     Matrix4x4._tempMatrix4x4 = new Matrix4x4();
     /**@private */
     Matrix4x4.TEMPMatrix0 = new Matrix4x4();
     /**@private */
     Matrix4x4.TEMPMatrix1 = new Matrix4x4();
     /**@private */
     Matrix4x4._tempVector0 = new Vector3();
     /**@private */
     Matrix4x4._tempVector1 = new Vector3();
     /**@private */
     Matrix4x4._tempVector2 = new Vector3();
     /**@private */
     Matrix4x4._tempVector3 = new Vector3();
     /**@private */
     Matrix4x4._tempQuaternion = new Quaternion();
     /**默认矩阵,禁止修改*/
     Matrix4x4.DEFAULT = new Matrix4x4();
     /**默认矩阵,禁止修改*/
     Matrix4x4.ZERO = new Matrix4x4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

     /**
      * <code>Transform3D</code> 类用于实现3D变换。
      */
     class Transform3D extends EventDispatcher {
         /**
          * 创建一个 <code>Transform3D</code> 实例。
          * @param owner 所属精灵。
          */
         constructor(owner) {
             super();
             /** @private */
             this._localPosition = new Vector3(0, 0, 0);
             /** @private */
             this._localRotation = new Quaternion(0, 0, 0, 1);
             /** @private */
             this._localScale = new Vector3(1, 1, 1);
             /**@private */
             this._localRotationEuler = new Vector3(0, 0, 0);
             /** @private */
             this._localMatrix = new Matrix4x4();
             /** @private */
             this._position = new Vector3(0, 0, 0);
             /** @private */
             this._rotation = new Quaternion(0, 0, 0, 1);
             /** @private */
             this._scale = new Vector3(1, 1, 1);
             /**@private */
             this._rotationEuler = new Vector3(0, 0, 0);
             /** @private */
             this._worldMatrix = new Matrix4x4();
             /** @private */
             this._children = null;
             /** @private */
             this._parent = null;
             /**@private */
             this._dummy = null;
             /**@private */
             this._transformFlag = 0;
             this._owner = owner;
             this._children = [];
             this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, false);
             this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE | Transform3D.TRANSFORM_WORLDMATRIX, true);
         }
         /**
          * @private
          */
         get _isFrontFaceInvert() {
             var scale = this.scale;
             var isInvert = scale.x < 0;
             (scale.y < 0) && (isInvert = !isInvert);
             (scale.z < 0) && (isInvert = !isInvert);
             return isInvert;
         }
         /**
          * 获取所属精灵。
          */
         get owner() {
             return this._owner;
         }
         /**
          * 获取世界矩阵是否需要更新。
          * @return	世界矩阵是否需要更新。
          */
         get worldNeedUpdate() {
             return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX);
         }
         /**
          * 获取局部位置X轴分量。
          * @return	局部位置X轴分量。
          */
         get localPositionX() {
             return this._localPosition.x;
         }
         /**
          * 设置局部位置X轴分量。
          * @param x	局部位置X轴分量。
          */
         set localPositionX(x) {
             this._localPosition.x = x;
             this.localPosition = this._localPosition;
         }
         /**
          * 获取局部位置Y轴分量。
          * @return	局部位置Y轴分量。
          */
         get localPositionY() {
             return this._localPosition.y;
         }
         /**
          * 设置局部位置Y轴分量。
          * @param y	局部位置Y轴分量。
          */
         set localPositionY(y) {
             this._localPosition.y = y;
             this.localPosition = this._localPosition;
         }
         /**
          * 获取局部位置Z轴分量。
          * @return	局部位置Z轴分量。
          */
         get localPositionZ() {
             return this._localPosition.z;
         }
         /**
          * 设置局部位置Z轴分量。
          * @param z	局部位置Z轴分量。
          */
         set localPositionZ(z) {
             this._localPosition.z = z;
             this.localPosition = this._localPosition;
         }
         /**
          * 获取局部位置。
          * @return	局部位置。
          */
         get localPosition() {
             return this._localPosition;
         }
         /**
          * 设置局部位置。
          * @param value	局部位置。
          */
         set localPosition(value) {
             if (this._localPosition !== value)
                 value.cloneTo(this._localPosition);
             this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, true);
             this._onWorldPositionTransform();
         }
         /**
          * 获取局部旋转四元数X分量。
          * @return	局部旋转四元数X分量。
          */
         get localRotationX() {
             return this.localRotation.x;
         }
         /**
          * 设置局部旋转四元数X分量。
          * @param x	局部旋转四元数X分量。
          */
         set localRotationX(x) {
             this._localRotation.x = x;
             this.localRotation = this._localRotation;
         }
         /**
          * 获取局部旋转四元数Y分量。
          * @return	局部旋转四元数Y分量。
          */
         get localRotationY() {
             return this.localRotation.y;
         }
         /**
          * 设置局部旋转四元数Y分量。
          * @param y	局部旋转四元数Y分量。
          */
         set localRotationY(y) {
             this._localRotation.y = y;
             this.localRotation = this._localRotation;
         }
         /**
          * 获取局部旋转四元数Z分量。
          * @return	局部旋转四元数Z分量。
          */
         get localRotationZ() {
             return this.localRotation.z;
         }
         /**
          * 设置局部旋转四元数Z分量。
          * @param z	局部旋转四元数Z分量。
          */
         set localRotationZ(z) {
             this._localRotation.z = z;
             this.localRotation = this._localRotation;
         }
         /**
          * 获取局部旋转四元数W分量。
          * @return	局部旋转四元数W分量。
          */
         get localRotationW() {
             return this.localRotation.w;
         }
         /**
          * 设置局部旋转四元数W分量。
          * @param w	局部旋转四元数W分量。
          */
         set localRotationW(w) {
             this._localRotation.w = w;
             this.localRotation = this._localRotation;
         }
         /**
          * 获取局部旋转。
          * @return	局部旋转。
          */
         get localRotation() {
             if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION)) {
                 var eulerE = this._localRotationEuler;
                 Quaternion.createFromYawPitchRoll(eulerE.y / Transform3D._angleToRandin, eulerE.x / Transform3D._angleToRandin, eulerE.z / Transform3D._angleToRandin, this._localRotation);
                 this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, false);
             }
             return this._localRotation;
         }
         /**
          * 设置局部旋转。
          * @param value	局部旋转。
          */
         set localRotation(value) {
             if (this._localRotation !== value)
                 value.cloneTo(this._localRotation);
             this._localRotation.normalize(this._localRotation);
             this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, true);
             this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, false);
             this._onWorldRotationTransform();
         }
         /**
          * 获取局部缩放X。
          * @return	局部缩放X。
          */
         get localScaleX() {
             return this._localScale.x;
         }
         /**
          * 设置局部缩放X。
          * @param	value 局部缩放X。
          */
         set localScaleX(value) {
             this._localScale.x = value;
             this.localScale = this._localScale;
         }
         /**
          * 获取局部缩放Y。
          * @return	局部缩放Y。
          */
         get localScaleY() {
             return this._localScale.y;
         }
         /**
          * 设置局部缩放Y。
          * @param	value 局部缩放Y。
          */
         set localScaleY(value) {
             this._localScale.y = value;
             this.localScale = this._localScale;
         }
         /**
          * 获取局部缩放Z。
          * @return	局部缩放Z。
          */
         get localScaleZ() {
             return this._localScale.z;
         }
         /**
          * 设置局部缩放Z。
          * @param	value 局部缩放Z。
          */
         set localScaleZ(value) {
             this._localScale.z = value;
             this.localScale = this._localScale;
         }
         /**
          * 获取局部缩放。
          * @return	局部缩放。
          */
         get localScale() {
             return this._localScale;
         }
         /**
          * 设置局部缩放。
          * @param	value 局部缩放。
          */
         set localScale(value) {
             if (this._localScale !== value)
                 value.cloneTo(this._localScale);
             this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, true);
             this._onWorldScaleTransform();
         }
         /**
          * 获取局部空间的X轴欧拉角。
          * @return	局部空间的X轴欧拉角。
          */
         get localRotationEulerX() {
             return this.localRotationEuler.x;
         }
         /**
          * 设置局部空间的X轴欧拉角。
          * @param	value 局部空间的X轴欧拉角。
          */
         set localRotationEulerX(value) {
             this._localRotationEuler.x = value;
             this.localRotationEuler = this._localRotationEuler;
         }
         /**
          * 获取局部空间的Y轴欧拉角。
          * @return	局部空间的Y轴欧拉角。
          */
         get localRotationEulerY() {
             return this.localRotationEuler.y;
         }
         /**
          * 设置局部空间的Y轴欧拉角。
          * @param	value 局部空间的Y轴欧拉角。
          */
         set localRotationEulerY(value) {
             this._localRotationEuler.y = value;
             this.localRotationEuler = this._localRotationEuler;
         }
         /**
          * 获取局部空间的Z轴欧拉角。
          * @return	局部空间的Z轴欧拉角。
          */
         get localRotationEulerZ() {
             return this.localRotationEuler.z;
         }
         /**
          * 设置局部空间的Z轴欧拉角。
          * @param	value 局部空间的Z轴欧拉角。
          */
         set localRotationEulerZ(value) {
             this._localRotationEuler.z = value;
             this.localRotationEuler = this._localRotationEuler;
         }
         /**
          * 获取局部空间欧拉角。
          * @return	欧拉角的旋转值。
          */
         get localRotationEuler() {
             if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALEULER)) {
                 this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
                 var euler = Transform3D._tempVector30;
                 var localRotationEuler = this._localRotationEuler;
                 localRotationEuler.x = euler.y * Transform3D._angleToRandin;
                 localRotationEuler.y = euler.x * Transform3D._angleToRandin;
                 localRotationEuler.z = euler.z * Transform3D._angleToRandin;
                 this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, false);
             }
             return this._localRotationEuler;
         }
         /**
          * 设置局部空间的欧拉角。
          * @param	value 欧拉角的旋转值。
          */
         set localRotationEuler(value) {
             if (this._localRotationEuler !== value)
                 value.cloneTo(this._localRotationEuler);
             this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, false);
             this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALMATRIX, true);
             this._onWorldRotationTransform();
         }
         /**
          * 获取局部矩阵。
          * @return	局部矩阵。
          */
         get localMatrix() {
             if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX)) {
                 this._updateLocalMatrix();
                 this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, false);
             }
             return this._localMatrix;
         }
         /**
          * 设置局部矩阵。
          * @param value	局部矩阵。
          */
         set localMatrix(value) {
             if (this._localMatrix !== value)
                 value.cloneTo(this._localMatrix);
             this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale);
             this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, false);
             this._onWorldTransform();
         }
         /**
          * 获取世界位置。
          * @return	世界位置。
          */
         get position() {
             if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                 if (this._parent != null) {
                     var parentPosition = this._parent.position; //放到下面会影响_tempVector30计算，造成混乱
                     Vector3.multiply(this._localPosition, this._parent.scale, Transform3D._tempVector30);
                     Vector3.transformQuat(Transform3D._tempVector30, this._parent.rotation, Transform3D._tempVector30);
                     Vector3.add(parentPosition, Transform3D._tempVector30, this._position);
                 }
                 else {
                     this._localPosition.cloneTo(this._position);
                 }
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, false);
             }
             return this._position;
         }
         /**
          * 设置世界位置。
          * @param	value 世界位置。
          */
         set position(value) {
             if (this._parent != null) {
                 Vector3.subtract(value, this._parent.position, this._localPosition);
                 var parentScale = this._parent.scale;
                 var psX = parentScale.x, psY = parentScale.y, psZ = parentScale.z;
                 if (psX !== 1.0 || psY !== 1.0 || psZ !== 1.0) {
                     var invertScale = Transform3D._tempVector30;
                     invertScale.x = 1.0 / psX;
                     invertScale.y = 1.0 / psY;
                     invertScale.z = 1.0 / psZ;
                     Vector3.multiply(this._localPosition, invertScale, this._localPosition);
                 }
                 var parentRotation = this._parent.rotation;
                 parentRotation.invert(Transform3D._tempQuaternion0);
                 Vector3.transformQuat(this._localPosition, Transform3D._tempQuaternion0, this._localPosition);
             }
             else {
                 value.cloneTo(this._localPosition);
             }
             this.localPosition = this._localPosition;
             if (this._position !== value)
                 value.cloneTo(this._position);
             this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, false);
         }
         /**
          * 获取世界旋转。
          * @return	世界旋转。
          */
         get rotation() {
             if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION)) {
                 if (this._parent != null)
                     Quaternion.multiply(this._parent.rotation, this.localRotation, this._rotation); //使用localRotation不使用_localRotation,内部需要计算
                 else
                     this.localRotation.cloneTo(this._rotation);
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, false);
             }
             return this._rotation;
         }
         /**
          * 设置世界旋转。
          * @param value	世界旋转。
          */
         set rotation(value) {
             if (this._parent != null) {
                 this._parent.rotation.invert(Transform3D._tempQuaternion0);
                 Quaternion.multiply(Transform3D._tempQuaternion0, value, this._localRotation);
             }
             else {
                 value.cloneTo(this._localRotation);
             }
             this.localRotation = this._localRotation;
             if (value !== this._rotation)
                 value.cloneTo(this._rotation);
             this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, false);
         }
         /**
          * 获取世界缩放。
          * @return	世界缩放。
          */
         get scale() {
             if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE))
                 return this._scale;
             if (this._parent !== null)
                 Vector3.multiply(this._parent.scale, this._localScale, this._scale);
             else
                 this._localScale.cloneTo(this._scale);
             this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, false);
             return this._scale;
         }
         /**
          * 设置世界缩放。
          * @param value	世界缩放。
          */
         set scale(value) {
             if (this._parent !== null) {
                 var parScale = this._parent.scale;
                 var invParScale = Transform3D._tempVector30;
                 invParScale.x = 1.0 / parScale.x;
                 invParScale.y = 1.0 / parScale.y;
                 invParScale.z = 1.0 / parScale.z;
                 Vector3.multiply(value, Transform3D._tempVector30, this._localScale);
             }
             else {
                 value.cloneTo(this._localScale);
             }
             this.localScale = this._localScale;
             if (this._scale !== value)
                 value.cloneTo(this._scale);
             this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, false);
         }
         /**
          * 获取世界空间的旋转角度。
          * @return	欧拉角的旋转值，顺序为x、y、z。
          */
         get rotationEuler() {
             if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                 this.rotation.getYawPitchRoll(Transform3D._tempVector30); //使用rotation属性,可能需要更新
                 var eulerE = Transform3D._tempVector30;
                 var rotationEulerE = this._rotationEuler;
                 rotationEulerE.x = eulerE.y * Transform3D._angleToRandin;
                 rotationEulerE.y = eulerE.x * Transform3D._angleToRandin;
                 rotationEulerE.z = eulerE.z * Transform3D._angleToRandin;
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, false);
             }
             return this._rotationEuler;
         }
         /**
          * 设置世界空间的旋转角度。
          * @param	欧拉角的旋转值，顺序为x、y、z。
          */
         set rotationEuler(value) {
             Quaternion.createFromYawPitchRoll(value.y / Transform3D._angleToRandin, value.x / Transform3D._angleToRandin, value.z / Transform3D._angleToRandin, this._rotation);
             this.rotation = this._rotation;
             if (this._rotationEuler !== value)
                 value.cloneTo(this._rotationEuler);
             this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, false);
         }
         /**
          * 获取世界矩阵。
          * @return	世界矩阵。
          */
         get worldMatrix() {
             if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX)) {
                 if (this._parent != null)
                     Matrix4x4.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix);
                 else
                     this.localMatrix.cloneTo(this._worldMatrix);
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, false);
             }
             return this._worldMatrix;
         }
         /**
          * 设置世界矩阵。
          * @param	value 世界矩阵。
          */
         set worldMatrix(value) {
             if (this._parent === null) {
                 value.cloneTo(this._localMatrix);
             }
             else {
                 this._parent.worldMatrix.invert(this._localMatrix);
                 Matrix4x4.multiply(this._localMatrix, value, this._localMatrix);
             }
             this.localMatrix = this._localMatrix;
             if (this._worldMatrix !== value)
                 value.cloneTo(this._worldMatrix);
             this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, false);
         }
         /**
          * @private
          */
         _setTransformFlag(type, value) {
             if (value)
                 this._transformFlag |= type;
             else
                 this._transformFlag &= ~type;
         }
         /**
          * @private
          */
         _getTransformFlag(type) {
             return (this._transformFlag & type) != 0;
         }
         /**
          * @private
          */
         _setParent(value) {
             if (this._parent !== value) {
                 if (this._parent) {
                     var parentChilds = this._parent._children;
                     var index = parentChilds.indexOf(this);
                     parentChilds.splice(index, 1);
                 }
                 if (value) {
                     value._children.push(this);
                     (value) && (this._onWorldTransform());
                 }
                 this._parent = value;
             }
         }
         /**
          * @private
          */
         _updateLocalMatrix() {
             Matrix4x4.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix);
         }
         /**
          * @private
          */
         _onWorldPositionRotationTransform() {
             if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, true);
                 this.event(Event.TRANSFORM_CHANGED, this._transformFlag);
                 for (var i = 0, n = this._children.length; i < n; i++)
                     this._children[i]._onWorldPositionRotationTransform();
             }
         }
         /**
          * @private
          */
         _onWorldPositionScaleTransform() {
             if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDSCALE, true);
                 this.event(Event.TRANSFORM_CHANGED, this._transformFlag);
                 for (var i = 0, n = this._children.length; i < n; i++)
                     this._children[i]._onWorldPositionScaleTransform();
             }
         }
         /**
          * @private
          */
         _onWorldPositionTransform() {
             if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION, true);
                 this.event(Event.TRANSFORM_CHANGED, this._transformFlag);
                 for (var i = 0, n = this._children.length; i < n; i++)
                     this._children[i]._onWorldPositionTransform();
             }
         }
         /**
          * @private
          */
         _onWorldRotationTransform() {
             if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, true);
                 this.event(Event.TRANSFORM_CHANGED, this._transformFlag);
                 for (var i = 0, n = this._children.length; i < n; i++)
                     this._children[i]._onWorldPositionRotationTransform(); //父节点旋转发生变化，子节点的世界位置和旋转都需要更新
             }
         }
         /**
          * @private
          */
         _onWorldScaleTransform() {
             if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDSCALE, true);
                 this.event(Event.TRANSFORM_CHANGED, this._transformFlag);
                 for (var i = 0, n = this._children.length; i < n; i++)
                     this._children[i]._onWorldPositionScaleTransform(); //父节点缩放发生变化，子节点的世界位置和缩放都需要更新
             }
         }
         /**
          * @private
          */
         _onWorldTransform() {
             if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE, true);
                 this.event(Event.TRANSFORM_CHANGED, this._transformFlag);
                 for (var i = 0, n = this._children.length; i < n; i++)
                     this._children[i]._onWorldTransform();
             }
         }
         /**
          * 平移变换。
          * @param 	translation 移动距离。
          * @param 	isLocal 是否局部空间。
          */
         translate(translation, isLocal = true) {
             if (isLocal) {
                 Matrix4x4.createFromQuaternion(this.localRotation, Transform3D._tempMatrix0);
                 Vector3.transformCoordinate(translation, Transform3D._tempMatrix0, Transform3D._tempVector30);
                 Vector3.add(this.localPosition, Transform3D._tempVector30, this._localPosition);
                 this.localPosition = this._localPosition;
             }
             else {
                 Vector3.add(this.position, translation, this._position);
                 this.position = this._position;
             }
         }
         /**
          * 旋转变换。
          * @param 	rotations 旋转幅度。
          * @param 	isLocal 是否局部空间。
          * @param 	isRadian 是否弧度制。
          */
         rotate(rotation, isLocal = true, isRadian = true) {
             var rot;
             if (isRadian) {
                 rot = rotation;
             }
             else {
                 Vector3.scale(rotation, Math.PI / 180.0, Transform3D._tempVector30);
                 rot = Transform3D._tempVector30;
             }
             Quaternion.createFromYawPitchRoll(rot.y, rot.x, rot.z, Transform3D._tempQuaternion0);
             if (isLocal) {
                 Quaternion.multiply(this._localRotation, Transform3D._tempQuaternion0, this._localRotation);
                 this.localRotation = this._localRotation;
             }
             else {
                 Quaternion.multiply(Transform3D._tempQuaternion0, this.rotation, this._rotation);
                 this.rotation = this._rotation;
             }
         }
         /**
          * 获取向前方向。
          * @param 前方向。
          */
         getForward(forward) {
             var worldMatElem = this.worldMatrix.elements;
             forward.x = -worldMatElem[8];
             forward.y = -worldMatElem[9];
             forward.z = -worldMatElem[10];
         }
         /**
          * 获取向上方向。
          * @param 上方向。
          */
         getUp(up) {
             var worldMatElem = this.worldMatrix.elements;
             up.x = worldMatElem[4];
             up.y = worldMatElem[5];
             up.z = worldMatElem[6];
         }
         /**
          * 获取向右方向。
          * @param 右方向。
          */
         getRight(right) {
             var worldMatElem = this.worldMatrix.elements;
             right.x = worldMatElem[0];
             right.y = worldMatElem[1];
             right.z = worldMatElem[2];
         }
         /**
          * 观察目标位置。
          * @param	target 观察目标。
          * @param	up 向上向量。
          * @param	isLocal 是否局部空间。
          */
         lookAt(target, up, isLocal = false) {
             var eye;
             if (isLocal) {
                 eye = this._localPosition;
                 if (Math.abs(eye.x - target.x) < MathUtils3D.zeroTolerance && Math.abs(eye.y - target.y) < MathUtils3D.zeroTolerance && Math.abs(eye.z - target.z) < MathUtils3D.zeroTolerance)
                     return;
                 Quaternion.lookAt(this._localPosition, target, up, this._localRotation);
                 this._localRotation.invert(this._localRotation);
                 this.localRotation = this._localRotation;
             }
             else {
                 var worldPosition = this.position;
                 eye = worldPosition;
                 if (Math.abs(eye.x - target.x) < MathUtils3D.zeroTolerance && Math.abs(eye.y - target.y) < MathUtils3D.zeroTolerance && Math.abs(eye.z - target.z) < MathUtils3D.zeroTolerance)
                     return;
                 Quaternion.lookAt(worldPosition, target, up, this._rotation);
                 this._rotation.invert(this._rotation);
                 this.rotation = this._rotation;
             }
         }
     }
     /** @private */
     Transform3D._tempVector30 = new Vector3();
     /** @private */
     Transform3D._tempVector31 = new Vector3();
     /** @private */
     Transform3D._tempVector32 = new Vector3();
     /** @private */
     Transform3D._tempVector33 = new Vector3();
     /** @private */
     Transform3D._tempQuaternion0 = new Quaternion();
     /** @private */
     Transform3D._tempMatrix0 = new Matrix4x4();
     /**@private */
     Transform3D.TRANSFORM_LOCALQUATERNION = 0x01;
     /**@private */
     Transform3D.TRANSFORM_LOCALEULER = 0x02;
     /**@private */
     Transform3D.TRANSFORM_LOCALMATRIX = 0x04;
     /**@private */
     Transform3D.TRANSFORM_WORLDPOSITION = 0x08;
     /**@private */
     Transform3D.TRANSFORM_WORLDQUATERNION = 0x10;
     /**@private */
     Transform3D.TRANSFORM_WORLDSCALE = 0x20;
     /**@private */
     Transform3D.TRANSFORM_WORLDMATRIX = 0x40;
     /**@private */
     Transform3D.TRANSFORM_WORLDEULER = 0x80;
     /**@private */
     Transform3D._angleToRandin = 180 / Math.PI;

     /**
      * <code>Sprite3D</code> 类用于实现3D精灵。
      */
     class Sprite3D extends Node {
         /**
          * 创建一个 <code>Sprite3D</code> 实例。
          * @param name 精灵名称。
          * @param isStatic 是否为静态。
          */
         constructor(name = null, isStatic = false) {
             super();
             /** @private */
             this._needProcessCollisions = false;
             /** @private */
             this._needProcessTriggers = false;
             this._id = ++Sprite3D._uniqueIDCounter;
             this._transform = new Transform3D(this);
             this._isStatic = isStatic;
             this.layer = 0;
             this.name = name ? name : "New Sprite3D";
         }
         /**
          * @private
          */
         static __init__() {
         }
         /**
          * 创建精灵的克隆实例。
          * @param	original  原始精灵。
          * @param   parent    父节点。
          * @param   worldPositionStays 是否保持自身世界变换。
          * @param	position  世界位置,worldPositionStays为false时生效。
          * @param	rotation  世界旋转,worldPositionStays为false时生效。
          * @return  克隆实例。
          */
         static instantiate(original, parent = null, worldPositionStays = true, position = null, rotation = null) {
             var destSprite3D = original.clone();
             (parent) && (parent.addChild(destSprite3D));
             var transform = destSprite3D.transform;
             if (worldPositionStays) {
                 var worldMatrix = transform.worldMatrix;
                 original.transform.worldMatrix.cloneTo(worldMatrix);
                 transform.worldMatrix = worldMatrix;
             }
             else {
                 (position) && (transform.position = position);
                 (rotation) && (transform.rotation = rotation);
             }
             return destSprite3D;
         }
         /**
          * 加载网格模板。
          * @param url 模板地址。
          * @param complete 完成回掉。
          */
         static load(url, complete) {
             Laya.loader.create(url, complete, null, Sprite3D.HIERARCHY);
         }
         /**
          * 获取唯一标识ID。
          *   @return	唯一标识ID。
          */
         get id() {
             return this._id;
         }
         /**
          * 获取蒙版。
          * @return	蒙版。
          */
         get layer() {
             return this._layer;
         }
         /**
          * 设置蒙版。
          * @param	value 蒙版。
          */
         set layer(value) {
             if (this._layer !== value) {
                 if (value >= 0 && value <= 30) {
                     this._layer = value;
                 }
                 else {
                     throw new Error("Layer value must be 0-30.");
                 }
             }
         }
         /**
          * 获取资源的URL地址。
          * @return URL地址。
          */
         get url() {
             return this._url;
         }
         /**
          * 获取是否为静态。
          * @return 是否为静态。
          */
         get isStatic() {
             return this._isStatic;
         }
         /**
          * 获取精灵变换。
          * @return 精灵变换。
          */
         get transform() {
             return this._transform;
         }
         /**
          * @private
          */
         _setCreateURL(url) {
             this._url = URL.formatURL(url); //perfab根节点会设置URL
         }
         /**
          * @private
          */
         _changeAnimatorsToLinkSprite3D(sprite3D, isLink, path) {
             var animator = this.getComponent(Animator);
             if (animator) {
                 if (!animator.avatar)
                     sprite3D._changeAnimatorToLinkSprite3DNoAvatar(animator, isLink, path);
             }
             if (this._parent && this._parent instanceof Sprite3D) {
                 path.unshift(this._parent.name);
                 var p = this._parent;
                 (p._hierarchyAnimator) && (p._changeAnimatorsToLinkSprite3D(sprite3D, isLink, path));
             }
         }
         /**
          * @private
          */
         _setHierarchyAnimator(animator, parentAnimator) {
             this._changeHierarchyAnimator(animator);
             this._changeAnimatorAvatar(animator.avatar);
             for (var i = 0, n = this._children.length; i < n; i++) {
                 var child = this._children[i];
                 (child._hierarchyAnimator == parentAnimator) && (child._setHierarchyAnimator(animator, parentAnimator));
             }
         }
         /**
          * @private
          */
         _clearHierarchyAnimator(animator, parentAnimator) {
             this._changeHierarchyAnimator(parentAnimator);
             this._changeAnimatorAvatar(parentAnimator ? parentAnimator.avatar : null);
             for (var i = 0, n = this._children.length; i < n; i++) {
                 var child = this._children[i];
                 (child._hierarchyAnimator == animator) && (child._clearHierarchyAnimator(animator, parentAnimator));
             }
         }
         /**
          * @private
          */
         _changeHierarchyAnimatorAvatar(animator, avatar) {
             this._changeAnimatorAvatar(avatar);
             for (var i = 0, n = this._children.length; i < n; i++) {
                 var child = this._children[i];
                 (child._hierarchyAnimator == animator) && (child._changeHierarchyAnimatorAvatar(animator, avatar));
             }
         }
         /**
          * @private
          */
         _changeAnimatorToLinkSprite3DNoAvatar(animator, isLink, path) {
             animator._handleSpriteOwnersBySprite(isLink, path, this);
             for (var i = 0, n = this._children.length; i < n; i++) {
                 var child = this._children[i];
                 var index = path.length;
                 path.push(child.name);
                 child._changeAnimatorToLinkSprite3DNoAvatar(animator, isLink, path);
                 path.splice(index, 1);
             }
         }
         /**
          * @private
          */
         _changeHierarchyAnimator(animator) {
             this._hierarchyAnimator = animator;
         }
         /**
          * @private
          */
         _changeAnimatorAvatar(avatar) {
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onAdded() {
             if (this._parent instanceof Sprite3D) {
                 var parent3D = this._parent;
                 this.transform._setParent(parent3D.transform);
                 if (parent3D._hierarchyAnimator) {
                     (!this._hierarchyAnimator) && (this._setHierarchyAnimator(parent3D._hierarchyAnimator, null)); //执行条件为sprite3D._hierarchyAnimator==parentAnimator,只有一种情况sprite3D._hierarchyAnimator=null成立,且_hierarchyAnimator不为空有意义
                     parent3D._changeAnimatorsToLinkSprite3D(this, true, [this.name]); //TODO:是否获取默认值函数移到active事件函数内，U3D修改active会重新获取默认值
                 }
             }
             super._onAdded();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onRemoved() {
             super._onRemoved();
             if (this._parent instanceof Sprite3D) {
                 var parent3D = this._parent;
                 this.transform._setParent(null);
                 if (parent3D._hierarchyAnimator) {
                     (this._hierarchyAnimator == parent3D._hierarchyAnimator) && (this._clearHierarchyAnimator(parent3D._hierarchyAnimator, null)); //_hierarchyAnimator不为空有意义
                     parent3D._changeAnimatorsToLinkSprite3D(this, false, [this.name]); //TODO:是否获取默认值函数移到active事件函数内，U3D修改active会重新获取默认值
                 }
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             (data.isStatic !== undefined) && (this._isStatic = data.isStatic);
             (data.active !== undefined) && (this.active = data.active);
             (data.name != undefined) && (this.name = data.name);
             if (data.position !== undefined) {
                 var loccalPosition = this.transform.localPosition;
                 loccalPosition.fromArray(data.position);
                 this.transform.localPosition = loccalPosition;
             }
             if (data.rotationEuler !== undefined) {
                 var localRotationEuler = this.transform.localRotationEuler;
                 localRotationEuler.fromArray(data.rotationEuler);
                 this.transform.localRotationEuler = localRotationEuler;
             }
             if (data.rotation !== undefined) {
                 var localRotation = this.transform.localRotation;
                 localRotation.fromArray(data.rotation);
                 this.transform.localRotation = localRotation;
             }
             if (data.scale !== undefined) {
                 var localScale = this.transform.localScale;
                 localScale.fromArray(data.scale);
                 this.transform.localScale = localScale;
             }
             (data.layer != undefined) && (this.layer = data.layer);
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         /*override*/ _cloneTo(destObject, srcRoot, dstRoot) {
             if (this.destroyed)
                 throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
             var destSprite3D = destObject;
             destSprite3D.name = this.name /* + "(clone)"*/; //TODO:克隆后不能播放刚体动画，找不到名字
             destSprite3D.destroyed = this.destroyed;
             destSprite3D.active = this.active;
             var destLocalPosition = destSprite3D.transform.localPosition;
             this.transform.localPosition.cloneTo(destLocalPosition);
             destSprite3D.transform.localPosition = destLocalPosition;
             var destLocalRotation = destSprite3D.transform.localRotation;
             this.transform.localRotation.cloneTo(destLocalRotation);
             destSprite3D.transform.localRotation = destLocalRotation;
             var destLocalScale = destSprite3D.transform.localScale;
             this.transform.localScale.cloneTo(destLocalScale);
             destSprite3D.transform.localScale = destLocalScale;
             destSprite3D._isStatic = this._isStatic;
             destSprite3D.layer = this.layer;
             super._cloneTo(destSprite3D, srcRoot, dstRoot);
         }
         /**
          * @private
          */
         static _createSprite3DInstance(scrSprite) {
             var node = scrSprite._create();
             var children = scrSprite._children;
             for (var i = 0, n = children.length; i < n; i++) {
                 var child = Sprite3D._createSprite3DInstance(children[i]);
                 node.addChild(child);
             }
             return node;
         }
         /**
          * @private
          */
         static _parseSprite3DInstance(srcRoot, dstRoot, scrSprite, dstSprite) {
             //scrSprite._cloneTo(dstSprite,srcRoot,dstRoot);//TODO:因为根据名字找Owner,子节点名字还未赋值有BUG
             var srcChildren = scrSprite._children;
             var dstChildren = dstSprite._children;
             for (var i = 0, n = srcChildren.length; i < n; i++)
                 Sprite3D._parseSprite3DInstance(srcRoot, dstRoot, srcChildren[i], dstChildren[i]);
             scrSprite._cloneTo(dstSprite, srcRoot, dstRoot);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dstSprite3D = Sprite3D._createSprite3DInstance(this);
             Sprite3D._parseSprite3DInstance(this, dstSprite3D, this, dstSprite3D);
             return dstSprite3D;
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy(destroyChild = true) {
             if (this.destroyed)
                 return;
             super.destroy(destroyChild);
             this._transform = null;
             this._scripts = null;
             this._url && Loader.clearRes(this._url);
         }
         /**
          * @private
          */
         _create() {
             return new Sprite3D();
         }
     }
     /**Hierarchy资源。*/
     Sprite3D.HIERARCHY = "HIERARCHY";
     /**@private 着色器变量名，世界矩阵。*/
     Sprite3D.WORLDMATRIX = Shader3D.propertyNameToID("u_WorldMat");
     /**@private 着色器变量名，世界视图投影矩阵。*/
     Sprite3D.MVPMATRIX = Shader3D.propertyNameToID("u_MvpMatrix");
     /*;*/
     /**@private */
     Sprite3D._uniqueIDCounter = 0;

     /**
      * <code>RenderableSprite3D</code> 类用于可渲染3D精灵的父类，抽象类不允许实例。
      */
     class RenderableSprite3D extends Sprite3D {
         /**
          * 创建一个 <code>RenderableSprite3D</code> 实例。
          */
         constructor(name) {
             super(name);
         }
         /**
          * @private
          */
         static __init__() {
             RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = RenderableSprite3D.shaderDefines.registerDefine("RECEIVESHADOW");
             RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV = RenderableSprite3D.shaderDefines.registerDefine("SCALEOFFSETLIGHTINGMAPUV");
             RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = RenderableSprite3D.shaderDefines.registerDefine("LIGHTMAP");
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onInActive() {
             super._onInActive();
             var scene3D = this._scene;
             scene3D._removeRenderObject(this._render);
             (this._render.castShadow) && (scene3D._removeShadowCastRenderObject(this._render));
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onActive() {
             super._onActive();
             var scene3D = this._scene;
             scene3D._addRenderObject(this._render);
             (this._render.castShadow) && (scene3D._addShadowCastRenderObject(this._render));
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onActiveInScene() {
             super._onActiveInScene();
             if (ILaya3D.Laya3D._editerEnvironment) {
                 var scene = this._scene;
                 var pickColor = new Vector4();
                 scene._allotPickColorByID(this.id, pickColor);
                 scene._pickIdToSprite[this.id] = this;
                 this._render._shaderValues.setVector(RenderableSprite3D.PICKCOLOR, pickColor);
             }
         }
         /**
          * @private
          */
         _addToInitStaticBatchManager() {
         }
         /**
          * @inheritDoc
          */
         /*override*/ _setBelongScene(scene) {
             super._setBelongScene(scene);
             this._render._setBelongScene(scene);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _setUnBelongScene() {
             this._render._shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
             super._setUnBelongScene();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _changeHierarchyAnimator(animator) {
             if (this._hierarchyAnimator) {
                 var renderableSprites = this._hierarchyAnimator._renderableSprites;
                 renderableSprites.splice(renderableSprites.indexOf(this), 1);
             }
             if (animator)
                 animator._renderableSprites.push(this);
             super._changeHierarchyAnimator(animator);
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy(destroyChild = true) {
             super.destroy(destroyChild);
             this._render._destroy();
             this._render = null;
         }
         /**
          * @private
          */
         _create() {
             return new RenderableSprite3D(this.name);
         }
     }
     /**着色器变量名，光照贴图缩放和偏移。*/
     RenderableSprite3D.LIGHTMAPSCALEOFFSET = Shader3D.propertyNameToID("u_LightmapScaleOffset");
     /**着色器变量名，光照贴图。*/
     RenderableSprite3D.LIGHTMAP = Shader3D.propertyNameToID("u_LightMap");
     /**拾取颜色。*/
     RenderableSprite3D.PICKCOLOR = Shader3D.propertyNameToID("u_PickColor");
     /**@private */
     RenderableSprite3D.shaderDefines = new ShaderDefines();

     /**
      * <code>StaticBatchManager</code> 类用于静态批处理管理的父类。
      */
     class StaticBatchManager {
         /**
          * 创建一个 <code>StaticBatchManager</code> 实例。
          */
         constructor() {
             this._initBatchSprites = [];
             this._staticBatches = {};
             this._batchRenderElementPoolIndex = 0;
             this._batchRenderElementPool = [];
         }
         /**
          * @private
          */
         static _registerManager(manager) {
             StaticBatchManager._managers.push(manager);
         }
         /**
          * @private
          */
         static _addToStaticBatchQueue(sprite3D, renderableSprite3D) {
             if (sprite3D instanceof RenderableSprite3D && sprite3D.isStatic)
                 renderableSprite3D.push(sprite3D);
             for (var i = 0, n = sprite3D.numChildren; i < n; i++)
                 StaticBatchManager._addToStaticBatchQueue(sprite3D._children[i], renderableSprite3D);
         }
         /**
          * 静态批处理合并，合并后子节点修改Transform属性无效，根节点staticBatchRoot可为null,如果根节点不为null，根节点可移动。
          * 如果renderableSprite3Ds为null，合并staticBatchRoot以及其所有子节点为静态批处理，staticBatchRoot作为静态根节点。
          * 如果renderableSprite3Ds不为null,合并renderableSprite3Ds为静态批处理，staticBatchRoot作为静态根节点。
          * @param staticBatchRoot 静态批处理根节点。
          * @param renderableSprite3Ds 静态批处理子节点队列。
          */
         static combine(staticBatchRoot, renderableSprite3Ds = null) {
             //TODO:合并条件是否取消静态，外面判断
             //TODO:每次有新物体合并都会重构一次Buffer,无论是否有变化
             if (!renderableSprite3Ds) {
                 renderableSprite3Ds = [];
                 if (staticBatchRoot)
                     StaticBatchManager._addToStaticBatchQueue(staticBatchRoot, renderableSprite3Ds);
             }
             var batchSpritesCount = renderableSprite3Ds.length;
             if (batchSpritesCount > 0) {
                 for (var i = 0; i < batchSpritesCount; i++) {
                     var renderableSprite3D = renderableSprite3Ds[i];
                     (renderableSprite3D.isStatic) && (renderableSprite3D._addToInitStaticBatchManager());
                 }
                 for (var k = 0, m = StaticBatchManager._managers.length; k < m; k++) {
                     var manager = StaticBatchManager._managers[k];
                     manager._initStaticBatchs(staticBatchRoot);
                 }
             }
         }
         /**
          * @private
          */
         _partition(items, left, right) {
             var pivot = items[Math.floor((right + left) / 2)];
             while (left <= right) {
                 while (this._compare(items[left], pivot) < 0)
                     left++;
                 while (this._compare(items[right], pivot) > 0)
                     right--;
                 if (left < right) {
                     var temp = items[left];
                     items[left] = items[right];
                     items[right] = temp;
                     left++;
                     right--;
                 }
                 else if (left === right) {
                     left++;
                     break;
                 }
             }
             return left;
         }
         /**
          * @private
          */
         _quickSort(items, left, right) {
             if (items.length > 1) {
                 var index = this._partition(items, left, right);
                 var leftIndex = index - 1;
                 if (left < leftIndex)
                     this._quickSort(items, left, leftIndex);
                 if (index < right)
                     this._quickSort(items, index, right);
             }
         }
         /**
          * @private
          */
         _compare(left, right) {
             throw "StaticBatch:must override this function.";
         }
         /**
          * @private
          */
         _initStaticBatchs(rootSprite) {
             throw "StaticBatch:must override this function.";
         }
         /**
          * @private
          */
         _getBatchRenderElementFromPool() {
             throw "StaticBatch:must override this function.";
         }
         /**
          * @private
          */
         _addBatchSprite(renderableSprite3D) {
             this._initBatchSprites.push(renderableSprite3D);
         }
         /**
          * @private
          */
         _clear() {
             this._batchRenderElementPoolIndex = 0;
         }
         /**
          * @private
          */
         _garbageCollection() {
             throw "StaticBatchManager: must override it.";
         }
         /**
          * @private
          */
         dispose() {
             this._staticBatches = null;
         }
     }
     /** @private [只读]*/
     StaticBatchManager._managers = [];

     /**
      * @private
      * <code>FrustumCulling</code> 类用于裁剪。
      */
     class FrustumCulling {
         /**
          * 创建一个 <code>FrustumCulling</code> 实例。
          */
         constructor() {
         }
         /**
          * @private
          */
         static __init__() {
             if (Render.supportWebGLPlusCulling) { //[NATIVE]
                 FrustumCulling._cullingBufferLength = 0;
                 FrustumCulling._cullingBuffer = new Float32Array(4096);
             }
         }
         /**
          * @private
          */
         static _drawTraversalCullingBound(renderList, debugTool) {
             var validCount = renderList.length;
             var renders = renderList.elements;
             for (var i = 0, n = renderList.length; i < n; i++) {
                 var color = FrustumCulling._tempColor0;
                 color.r = 0;
                 color.g = 1;
                 color.b = 0;
                 color.a = 1;
                 Utils3D._drawBound(debugTool, renders[i].bounds._getBoundBox(), color);
             }
         }
         /**
          * @private
          */
         static _traversalCulling(camera, scene, context, renderList, customShader, replacementTag) {
             var validCount = renderList.length;
             var renders = renderList.elements;
             var boundFrustum = camera.boundFrustum;
             var camPos = camera._transform.position;
             for (var i = 0; i < validCount; i++) {
                 var render = renders[i];
                 if (camera._isLayerVisible(render._owner._layer) && render._enable) {
                     Stat.frustumCulling++;
                     if (!camera.useOcclusionCulling || render._needRender(boundFrustum)) {
                         render._visible = true;
                         render._distanceForSort = Vector3.distance(render.bounds.getCenter(), camPos); //TODO:合并计算浪费,或者合并后取平均值
                         var elements = render._renderElements;
                         for (var j = 0, m = elements.length; j < m; j++)
                             elements[j]._update(scene, context, customShader, replacementTag);
                     }
                     else {
                         render._visible = false;
                     }
                 }
                 else {
                     render._visible = false;
                 }
             }
         }
         /**
          * @private
          */
         static renderObjectCulling(camera, scene, context, renderList, customShader, replacementTag) {
             var i, n;
             var opaqueQueue = scene._opaqueQueue;
             var transparentQueue = scene._transparentQueue;
             opaqueQueue.clear();
             transparentQueue.clear();
             var staticBatchManagers = StaticBatchManager._managers;
             for (i = 0, n = staticBatchManagers.length; i < n; i++)
                 staticBatchManagers[i]._clear();
             var dynamicBatchManagers = DynamicBatchManager._managers;
             for (i = 0, n = dynamicBatchManagers.length; i < n; i++)
                 dynamicBatchManagers[i]._clear();
             var octree = scene._octree;
             if (octree) {
                 octree.updateMotionObjects();
                 octree.shrinkRootIfPossible();
                 octree.getCollidingWithFrustum(context, customShader, replacementTag);
             }
             //else {//包围盒不完善的节点走遍历裁剪
             FrustumCulling._traversalCulling(camera, scene, context, renderList, customShader, replacementTag);
             //}
             if (FrustumCulling.debugFrustumCulling) {
                 var debugTool = scene._debugTool;
                 debugTool.clear();
                 if (octree) {
                     octree.drawAllBounds(debugTool);
                     octree.drawAllObjects(debugTool);
                 }
                 //else {//包围盒不完善的节点走遍历裁剪
                 FrustumCulling._drawTraversalCullingBound(renderList, debugTool);
                 //}
             }
             var count = opaqueQueue.elements.length;
             (count > 0) && (opaqueQueue._quickSort(0, count - 1));
             count = transparentQueue.elements.length;
             (count > 0) && (transparentQueue._quickSort(0, count - 1));
         }
         /**
          * @private [NATIVE]
          */
         static renderObjectCullingNative(camera, scene, context, renderList, customShader, replacementTag) {
             var i, n, j, m;
             var opaqueQueue = scene._opaqueQueue;
             var transparentQueue = scene._transparentQueue;
             opaqueQueue.clear();
             transparentQueue.clear();
             var staticBatchManagers = StaticBatchManager._managers;
             for (i = 0, n = staticBatchManagers.length; i < n; i++)
                 staticBatchManagers[i]._clear();
             var dynamicBatchManagers = DynamicBatchManager._managers;
             for (i = 0, n = dynamicBatchManagers.length; i < n; i++)
                 dynamicBatchManagers[i]._clear();
             var validCount = renderList.length;
             var renders = renderList.elements;
             for (i = 0; i < validCount; i++) {
                 renders[i].bounds;
             }
             var boundFrustum = camera.boundFrustum;
             FrustumCulling.cullingNative(camera._boundFrustumBuffer, FrustumCulling._cullingBuffer, scene._cullingBufferIndices, validCount, scene._cullingBufferResult);
             var camPos = context.camera._transform.position;
             for (i = 0; i < validCount; i++) {
                 var render = renders[i];
                 if (camera._isLayerVisible(render._owner._layer) && render._enable && scene._cullingBufferResult[i]) { //TODO:需要剥离部分函数
                     render._visible = true;
                     render._distanceForSort = Vector3.distance(render.bounds.getCenter(), camPos); //TODO:合并计算浪费,或者合并后取平均值
                     var elements = render._renderElements;
                     for (j = 0, m = elements.length; j < m; j++) {
                         var element = elements[j];
                         element._update(scene, context, customShader, replacementTag);
                     }
                 }
                 else {
                     render._visible = false;
                 }
             }
             var count = opaqueQueue.elements.length;
             (count > 0) && (opaqueQueue._quickSort(0, count - 1));
             count = transparentQueue.elements.length;
             (count > 0) && (transparentQueue._quickSort(0, count - 1));
         }
         /**
          * @private [NATIVE]
          */
         static cullingNative(boundFrustumBuffer, cullingBuffer, cullingBufferIndices, cullingCount, cullingBufferResult) {
             return LayaGL.instance.culling(boundFrustumBuffer, cullingBuffer, cullingBufferIndices, cullingCount, cullingBufferResult);
         }
     }
     /**@private */
     FrustumCulling._tempVector3 = new Vector3();
     /**@private */
     FrustumCulling._tempColor0 = new Color();
     /**@private */
     FrustumCulling.debugFrustumCulling = false;

     /**
          * <code>Plane</code> 类用于创建平面。
          */
     class Plane {
         /**
          * 创建一个 <code>Plane</code> 实例。
          * @param	normal 平面的向量
          * @param	d  平面到原点的距离
          */
         constructor(normal, d = 0) {
             this.normal = normal;
             this.distance = d;
         }
         /**
          * 创建一个 <code>Plane</code> 实例。
          * @param	point1 第一点
          * @param	point2 第二点
          * @param	point3 第三点
          */
         static createPlaneBy3P(point1, point2, point3) {
             var x1 = point2.x - point1.x;
             var y1 = point2.y - point1.y;
             var z1 = point2.z - point1.z;
             var x2 = point3.x - point1.x;
             var y2 = point3.y - point1.y;
             var z2 = point3.z - point1.z;
             var yz = (y1 * z2) - (z1 * y2);
             var xz = (z1 * x2) - (x1 * z2);
             var xy = (x1 * y2) - (y1 * x2);
             var invPyth = 1 / (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));
             var x = yz * invPyth;
             var y = xz * invPyth;
             var z = xy * invPyth;
             Plane._TEMPVec3.x = x;
             Plane._TEMPVec3.y = y;
             Plane._TEMPVec3.z = z;
             var d = -((x * point1.x) + (y * point1.y) + (z * point1.z));
             var plane = new Plane(Plane._TEMPVec3, d);
             return plane;
         }
         /**
          * 更改平面法线向量的系数，使之成单位长度。
          */
         normalize() {
             var normalEX = this.normal.x;
             var normalEY = this.normal.y;
             var normalEZ = this.normal.z;
             var magnitude = 1 / Math.sqrt(normalEX * normalEX + normalEY * normalEY + normalEZ * normalEZ);
             this.normal.x = normalEX * magnitude;
             this.normal.y = normalEY * magnitude;
             this.normal.z = normalEZ * magnitude;
             this.distance *= magnitude;
         }
     }
     /** @private */
     Plane._TEMPVec3 = new Vector3();
     /**平面与其他几何体相交类型*/
     Plane.PlaneIntersectionType_Back = 0;
     Plane.PlaneIntersectionType_Front = 1;
     Plane.PlaneIntersectionType_Intersecting = 2;

     /**
          * <code>Ray</code> 类用于创建射线。
          */
     class Ray {
         /**
          * 创建一个 <code>Ray</code> 实例。
          * @param	origin 射线的起点
          * @param	direction  射线的方向
          */
         constructor(origin, direction) {
             this.origin = origin;
             this.direction = direction;
         }
     }

     /**
      * <code>ContainmentType</code> 类用于定义空间物体位置关系。
      */
     class ContainmentType {
     }
     /*不相交*/
     ContainmentType.Disjoint = 0;
     /*包含*/
     ContainmentType.Contains = 1;
     /*相交*/
     ContainmentType.Intersects = 2;

     /**
          * <code>Collision</code> 类用于检测碰撞。
          */
     class CollisionUtils {
         /**
          * 创建一个 <code>Collision</code> 实例。
          */
         constructor() {
         }
         /**
          * 空间中点到平面的距离
          * @param	plane 平面
          * @param	point 点
          */
         static distancePlaneToPoint(plane, point) {
             var dot = Vector3.dot(plane.normal, point);
             return dot - plane.distance;
         }
         /**
          * 空间中点到包围盒的距离
          * @param	box 包围盒
          * @param	point 点
          */
         static distanceBoxToPoint(box, point) {
             var boxMin = box.min;
             var boxMineX = boxMin.x;
             var boxMineY = boxMin.y;
             var boxMineZ = boxMin.z;
             var boxMax = box.max;
             var boxMaxeX = boxMax.x;
             var boxMaxeY = boxMax.y;
             var boxMaxeZ = boxMax.z;
             var pointeX = point.x;
             var pointeY = point.y;
             var pointeZ = point.z;
             var distance = 0;
             if (pointeX < boxMineX)
                 distance += (boxMineX - pointeX) * (boxMineX - pointeX);
             if (pointeX > boxMaxeX)
                 distance += (boxMaxeX - pointeX) * (boxMaxeX - pointeX);
             if (pointeY < boxMineY)
                 distance += (boxMineY - pointeY) * (boxMineY - pointeY);
             if (pointeY > boxMaxeY)
                 distance += (boxMaxeY - pointeY) * (boxMaxeY - pointeY);
             if (pointeZ < boxMineZ)
                 distance += (boxMineZ - pointeZ) * (boxMineZ - pointeZ);
             if (pointeZ > boxMaxeZ)
                 distance += (boxMaxeZ - pointeZ) * (boxMaxeZ - pointeZ);
             return Math.sqrt(distance);
         }
         /**
          * 空间中包围盒到包围盒的距离
          * @param	box1 包围盒1
          * @param	box2 包围盒2
          */
         static distanceBoxToBox(box1, box2) {
             var box1Mine = box1.min;
             var box1MineX = box1Mine.x;
             var box1MineY = box1Mine.y;
             var box1MineZ = box1Mine.z;
             var box1Maxe = box1.max;
             var box1MaxeX = box1Maxe.x;
             var box1MaxeY = box1Maxe.y;
             var box1MaxeZ = box1Maxe.z;
             var box2Mine = box2.min;
             var box2MineX = box2Mine.x;
             var box2MineY = box2Mine.y;
             var box2MineZ = box2Mine.z;
             var box2Maxe = box2.max;
             var box2MaxeX = box2Maxe.x;
             var box2MaxeY = box2Maxe.y;
             var box2MaxeZ = box2Maxe.z;
             var distance = 0;
             var delta;
             if (box1MineX > box2MaxeX) {
                 delta = box1MineX - box2MaxeX;
                 distance += delta * delta;
             }
             else if (box2MineX > box1MaxeX) {
                 delta = box2MineX - box1MaxeX;
                 distance += delta * delta;
             }
             if (box1MineY > box2MaxeY) {
                 delta = box1MineY - box2MaxeY;
                 distance += delta * delta;
             }
             else if (box2MineY > box1MaxeY) {
                 delta = box2MineY - box1MaxeY;
                 distance += delta * delta;
             }
             if (box1MineZ > box2MaxeZ) {
                 delta = box1MineZ - box2MaxeZ;
                 distance += delta * delta;
             }
             else if (box2MineZ > box1MaxeZ) {
                 delta = box2MineZ - box1MaxeZ;
                 distance += delta * delta;
             }
             return Math.sqrt(distance);
         }
         /**
          * 空间中点到包围球的距离
          * @param	sphere 包围球
          * @param	point  点
          */
         static distanceSphereToPoint(sphere, point) {
             var distance = Math.sqrt(Vector3.distanceSquared(sphere.center, point));
             distance -= sphere.radius;
             return Math.max(distance, 0);
         }
         /**
          * 空间中包围球到包围球的距离
          * @param	sphere1 包围球1
          * @param	sphere2 包围球2
          */
         static distanceSphereToSphere(sphere1, sphere2) {
             var distance = Math.sqrt(Vector3.distanceSquared(sphere1.center, sphere2.center));
             distance -= sphere1.radius + sphere2.radius;
             return Math.max(distance, 0);
         }
         /**
          * 空间中射线和三角面是否相交,输出距离
          * @param	ray 射线
          * @param	vertex1 三角面顶点1
          * @param	vertex2	三角面顶点2
          * @param	vertex3 三角面顶点3
          * @param	out 点和三角面的距离
          * @return  是否相交
          */
         static intersectsRayAndTriangleRD(ray, vertex1, vertex2, vertex3, out) {
             var rayO = ray.origin;
             var rayOeX = rayO.x;
             var rayOeY = rayO.y;
             var rayOeZ = rayO.z;
             var rayD = ray.direction;
             var rayDeX = rayD.x;
             var rayDeY = rayD.y;
             var rayDeZ = rayD.z;
             var v1eX = vertex1.x;
             var v1eY = vertex1.y;
             var v1eZ = vertex1.z;
             var v2eX = vertex2.x;
             var v2eY = vertex2.y;
             var v2eZ = vertex2.z;
             var v3eX = vertex3.x;
             var v3eY = vertex3.y;
             var v3eZ = vertex3.z;
             var _tempV30eX = CollisionUtils._tempV30.x;
             var _tempV30eY = CollisionUtils._tempV30.y;
             var _tempV30eZ = CollisionUtils._tempV30.z;
             _tempV30eX = v2eX - v1eX;
             _tempV30eY = v2eY - v1eY;
             _tempV30eZ = v2eZ - v1eZ;
             var _tempV31eX = CollisionUtils._tempV31.x;
             var _tempV31eY = CollisionUtils._tempV31.y;
             var _tempV31eZ = CollisionUtils._tempV31.z;
             _tempV31eX = v3eX - v1eX;
             _tempV31eY = v3eY - v1eY;
             _tempV31eZ = v3eZ - v1eZ;
             var _tempV32eX = CollisionUtils._tempV32.x;
             var _tempV32eY = CollisionUtils._tempV32.y;
             var _tempV32eZ = CollisionUtils._tempV32.z;
             _tempV32eX = (rayDeY * _tempV31eZ) - (rayDeZ * _tempV31eY);
             _tempV32eY = (rayDeZ * _tempV31eX) - (rayDeX * _tempV31eZ);
             _tempV32eZ = (rayDeX * _tempV31eY) - (rayDeY * _tempV31eX);
             var determinant = (_tempV30eX * _tempV32eX) + (_tempV30eY * _tempV32eY) + (_tempV30eZ * _tempV32eZ);
             if (MathUtils3D.isZero(determinant)) {
                 out = 0;
                 return false;
             }
             var inversedeterminant = 1 / determinant;
             var _tempV33eX = CollisionUtils._tempV33.x;
             var _tempV33eY = CollisionUtils._tempV33.y;
             var _tempV33eZ = CollisionUtils._tempV33.z;
             _tempV33eX = rayOeX - v1eX;
             _tempV33eY = rayOeY - v1eY;
             _tempV33eZ = rayOeZ - v1eZ;
             var triangleU = (_tempV33eX * _tempV32eX) + (_tempV33eY * _tempV32eY) + (_tempV33eZ * _tempV32eZ);
             triangleU *= inversedeterminant;
             if (triangleU < 0 || triangleU > 1) {
                 out = 0;
                 return false;
             }
             var _tempV34eX = CollisionUtils._tempV34.x;
             var _tempV34eY = CollisionUtils._tempV34.y;
             var _tempV34eZ = CollisionUtils._tempV34.z;
             _tempV34eX = (_tempV33eY * _tempV30eZ) - (_tempV33eZ * _tempV30eY);
             _tempV34eY = (_tempV33eZ * _tempV30eX) - (_tempV33eX * _tempV30eZ);
             _tempV34eZ = (_tempV33eX * _tempV30eY) - (_tempV33eY * _tempV30eX);
             var triangleV = ((rayDeX * _tempV34eX) + (rayDeY * _tempV34eY)) + (rayDeZ * _tempV34eZ);
             triangleV *= inversedeterminant;
             if (triangleV < 0 || triangleU + triangleV > 1) {
                 out = 0;
                 return false;
             }
             var raydistance = (_tempV31eX * _tempV34eX) + (_tempV31eY * _tempV34eY) + (_tempV31eZ * _tempV34eZ);
             raydistance *= inversedeterminant;
             if (raydistance < 0) {
                 out = 0;
                 return false;
             }
             out = raydistance;
             return true;
         }
         /**
          * 空间中射线和三角面是否相交,输出相交点
          * @param	ray 射线
          * @param	vertex1 三角面顶点1
          * @param	vertex2	三角面顶点2
          * @param	vertex3 三角面顶点3
          * @param	out 相交点
          * @return  是否相交
          */
         static intersectsRayAndTriangleRP(ray, vertex1, vertex2, vertex3, out) {
             var distance;
             if (!CollisionUtils.intersectsRayAndTriangleRD(ray, vertex1, vertex2, vertex3, distance)) {
                 out = Vector3._ZERO;
                 return false;
             }
             Vector3.scale(ray.direction, distance, CollisionUtils._tempV30);
             Vector3.add(ray.origin, CollisionUtils._tempV30, out);
             return true;
         }
         /**
          * 空间中射线和点是否相交
          * @param	sphere1 包围球1
          * @param	sphere2 包围球2
          */
         static intersectsRayAndPoint(ray, point) {
             Vector3.subtract(ray.origin, point, CollisionUtils._tempV30);
             var b = Vector3.dot(CollisionUtils._tempV30, ray.direction);
             var c = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - MathUtils3D.zeroTolerance;
             if (c > 0 && b > 0)
                 return false;
             var discriminant = b * b - c;
             if (discriminant < 0)
                 return false;
             return true;
         }
         /**
          * 空间中射线和射线是否相交
          * @param	ray1 射线1
          * @param	ray2 射线2
          * @param	out 相交点
          */
         static intersectsRayAndRay(ray1, ray2, out) {
             var ray1o = ray1.origin;
             var ray1oeX = ray1o.x;
             var ray1oeY = ray1o.y;
             var ray1oeZ = ray1o.z;
             var ray1d = ray1.direction;
             var ray1deX = ray1d.x;
             var ray1deY = ray1d.y;
             var ray1deZ = ray1d.z;
             var ray2o = ray2.origin;
             var ray2oeX = ray2o.x;
             var ray2oeY = ray2o.y;
             var ray2oeZ = ray2o.z;
             var ray2d = ray2.direction;
             var ray2deX = ray2d.x;
             var ray2deY = ray2d.y;
             var ray2deZ = ray2d.z;
             Vector3.cross(ray1d, ray2d, CollisionUtils._tempV30);
             var tempV3 = CollisionUtils._tempV30;
             var denominator = Vector3.scalarLength(CollisionUtils._tempV30);
             if (MathUtils3D.isZero(denominator)) {
                 if (MathUtils3D.nearEqual(ray2oeX, ray1oeX) && MathUtils3D.nearEqual(ray2oeY, ray1oeY) && MathUtils3D.nearEqual(ray2oeZ, ray1oeZ)) {
                     out = Vector3._ZERO;
                     return true;
                 }
             }
             denominator = denominator * denominator;
             var m11 = ray2oeX - ray1oeX;
             var m12 = ray2oeY - ray1oeY;
             var m13 = ray2oeZ - ray1oeZ;
             var m21 = ray2deX;
             var m22 = ray2deY;
             var m23 = ray2deZ;
             var m31 = tempV3.x;
             var m32 = tempV3.y;
             var m33 = tempV3.z;
             var dets = m11 * m22 * m33 + m12 * m23 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 - m13 * m22 * m31;
             m21 = ray1deX;
             m22 = ray1deY;
             m23 = ray1deZ;
             var s = dets / denominator;
             Vector3.scale(ray1d, s, CollisionUtils._tempV30);
             Vector3.scale(ray2d, s, CollisionUtils._tempV31);
             Vector3.add(ray1o, CollisionUtils._tempV30, CollisionUtils._tempV32);
             Vector3.add(ray2o, CollisionUtils._tempV31, CollisionUtils._tempV33);
             var point1e = CollisionUtils._tempV32;
             var point2e = CollisionUtils._tempV33;
             if (!MathUtils3D.nearEqual(point2e.x, point1e.x) || !MathUtils3D.nearEqual(point2e.y, point1e.y) || !MathUtils3D.nearEqual(point2e.z, point1e.z)) {
                 out = Vector3._ZERO;
                 return false;
             }
             out = CollisionUtils._tempV32;
             return true;
         }
         /**
          * 空间中平面和三角面是否相交
          * @param	plane 平面
          * @param	vertex1 三角面顶点1
          * @param	vertex2 三角面顶点2
          * @param	vertex3 三角面顶点3
          * @return  返回空间位置关系
          */
         static intersectsPlaneAndTriangle(plane, vertex1, vertex2, vertex3) {
             var test1 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex1);
             var test2 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex2);
             var test3 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex3);
             if (test1 == Plane.PlaneIntersectionType_Front && test2 == Plane.PlaneIntersectionType_Front && test3 == Plane.PlaneIntersectionType_Front)
                 return Plane.PlaneIntersectionType_Front;
             if (test1 == Plane.PlaneIntersectionType_Back && test2 == Plane.PlaneIntersectionType_Back && test3 == Plane.PlaneIntersectionType_Back)
                 return Plane.PlaneIntersectionType_Back;
             return Plane.PlaneIntersectionType_Intersecting;
         }
         /**
          * 空间中射线和平面是否相交
          * @param	ray   射线
          * @param	plane 平面
          * @param	out 相交距离,如果为0,不相交
          */
         static intersectsRayAndPlaneRD(ray, plane, out) {
             var planeNor = plane.normal;
             var direction = Vector3.dot(planeNor, ray.direction);
             if (MathUtils3D.isZero(direction)) {
                 out = 0;
                 return false;
             }
             var position = Vector3.dot(planeNor, ray.origin);
             out = (-plane.distance - position) / direction;
             if (out < 0) {
                 out = 0;
                 return false;
             }
             return true;
         }
         /**
          * 空间中射线和平面是否相交
          * @param	ray   射线
          * @param	plane 平面
          * @param	out 相交点
          */
         static intersectsRayAndPlaneRP(ray, plane, out) {
             var distance;
             if (!CollisionUtils.intersectsRayAndPlaneRD(ray, plane, distance)) {
                 out = Vector3._ZERO;
                 return false;
             }
             Vector3.scale(ray.direction, distance, CollisionUtils._tempV30);
             Vector3.add(ray.origin, CollisionUtils._tempV30, CollisionUtils._tempV31);
             out = CollisionUtils._tempV31;
             return true;
         }
         /**
          * 空间中射线和包围盒是否相交
          * @param	ray 射线
          * @param	box	包围盒
          * @param	out 相交距离,如果为0,不相交
          */
         static intersectsRayAndBoxRD(ray, box) {
             var rayoe = ray.origin;
             var rayoeX = rayoe.x;
             var rayoeY = rayoe.y;
             var rayoeZ = rayoe.z;
             var rayde = ray.direction;
             var raydeX = rayde.x;
             var raydeY = rayde.y;
             var raydeZ = rayde.z;
             var boxMine = box.min;
             var boxMineX = boxMine.x;
             var boxMineY = boxMine.y;
             var boxMineZ = boxMine.z;
             var boxMaxe = box.max;
             var boxMaxeX = boxMaxe.x;
             var boxMaxeY = boxMaxe.y;
             var boxMaxeZ = boxMaxe.z;
             var out = 0;
             var tmax = MathUtils3D.MaxValue;
             if (MathUtils3D.isZero(raydeX)) {
                 if (rayoeX < boxMineX || rayoeX > boxMaxeX) {
                     //out = 0;
                     return -1;
                 }
             }
             else {
                 var inverse = 1 / raydeX;
                 var t1 = (boxMineX - rayoeX) * inverse;
                 var t2 = (boxMaxeX - rayoeX) * inverse;
                 if (t1 > t2) {
                     var temp = t1;
                     t1 = t2;
                     t2 = temp;
                 }
                 out = Math.max(t1, out);
                 tmax = Math.min(t2, tmax);
                 if (out > tmax) {
                     //out = 0;
                     return -1;
                 }
             }
             if (MathUtils3D.isZero(raydeY)) {
                 if (rayoeY < boxMineY || rayoeY > boxMaxeY) {
                     //out = 0;
                     return -1;
                 }
             }
             else {
                 var inverse1 = 1 / raydeY;
                 var t3 = (boxMineY - rayoeY) * inverse1;
                 var t4 = (boxMaxeY - rayoeY) * inverse1;
                 if (t3 > t4) {
                     var temp1 = t3;
                     t3 = t4;
                     t4 = temp1;
                 }
                 out = Math.max(t3, out);
                 tmax = Math.min(t4, tmax);
                 if (out > tmax) {
                     //out = 0;
                     return -1;
                 }
             }
             if (MathUtils3D.isZero(raydeZ)) {
                 if (rayoeZ < boxMineZ || rayoeZ > boxMaxeZ) {
                     //out = 0;
                     return -1;
                 }
             }
             else {
                 var inverse2 = 1 / raydeZ;
                 var t5 = (boxMineZ - rayoeZ) * inverse2;
                 var t6 = (boxMaxeZ - rayoeZ) * inverse2;
                 if (t5 > t6) {
                     var temp2 = t5;
                     t5 = t6;
                     t6 = temp2;
                 }
                 out = Math.max(t5, out);
                 tmax = Math.min(t6, tmax);
                 if (out > tmax) {
                     //out = 0;
                     return -1;
                 }
             }
             return out;
         }
         /**
          * 空间中射线和包围盒是否相交
          * @param	ray 射线
          * @param	box	包围盒
          * @param	out 相交点
          */
         static intersectsRayAndBoxRP(ray, box, out) {
             var distance = CollisionUtils.intersectsRayAndBoxRD(ray, box);
             if (distance === -1) {
                 Vector3._ZERO.cloneTo(out);
                 return distance;
             }
             Vector3.scale(ray.direction, distance, CollisionUtils._tempV30);
             Vector3.add(ray.origin, CollisionUtils._tempV30, CollisionUtils._tempV31);
             CollisionUtils._tempV31.cloneTo(out);
             return distance;
         }
         /**
          * 空间中射线和包围球是否相交
          * @param	ray    射线
          * @param	sphere 包围球
          * @return	相交距离,-1表示不相交
          */
         static intersectsRayAndSphereRD(ray, sphere) {
             var sphereR = sphere.radius;
             Vector3.subtract(ray.origin, sphere.center, CollisionUtils._tempV30);
             var b = Vector3.dot(CollisionUtils._tempV30, ray.direction);
             var c = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - (sphereR * sphereR);
             if (c > 0 && b > 0) {
                 return -1;
             }
             var discriminant = b * b - c;
             if (discriminant < 0) {
                 return -1;
             }
             var distance = -b - Math.sqrt(discriminant);
             if (distance < 0)
                 distance = 0;
             return distance;
         }
         /**
          * 空间中射线和包围球是否相交
          * @param	ray    射线
          * @param	sphere 包围球
          * @param	out    相交点
          * @return  相交距离,-1表示不相交
          */
         static intersectsRayAndSphereRP(ray, sphere, out) {
             var distance = CollisionUtils.intersectsRayAndSphereRD(ray, sphere);
             if (distance === -1) {
                 Vector3._ZERO.cloneTo(out);
                 return distance;
             }
             Vector3.scale(ray.direction, distance, CollisionUtils._tempV30);
             Vector3.add(ray.origin, CollisionUtils._tempV30, CollisionUtils._tempV31);
             CollisionUtils._tempV31.cloneTo(out);
             return distance;
         }
         /**
          * 空间中包围球和三角面是否相交
          * @param	sphere 包围球
          * @param	vertex1 三角面顶点1
          * @param	vertex2 三角面顶点2
          * @param	vertex3 三角面顶点3
          * @return  返回是否相交
          */
         static intersectsSphereAndTriangle(sphere, vertex1, vertex2, vertex3) {
             var sphereC = sphere.center;
             var sphereR = sphere.radius;
             CollisionUtils.closestPointPointTriangle(sphereC, vertex1, vertex2, vertex3, CollisionUtils._tempV30);
             Vector3.subtract(CollisionUtils._tempV30, sphereC, CollisionUtils._tempV31);
             var dot = Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV31);
             return dot <= sphereR * sphereR;
         }
         /**
          * 空间中点和平面是否相交
          * @param	plane  平面
          * @param	point  点
          * @return  碰撞状态
          */
         static intersectsPlaneAndPoint(plane, point) {
             var distance = Vector3.dot(plane.normal, point) + plane.distance;
             if (distance > 0)
                 return Plane.PlaneIntersectionType_Front;
             if (distance < 0)
                 return Plane.PlaneIntersectionType_Back;
             return Plane.PlaneIntersectionType_Intersecting;
         }
         /**
          * 空间中平面和平面是否相交
          * @param	plane1 平面1
          * @param	plane2 平面2
          * @return  是否相交
          */
         static intersectsPlaneAndPlane(plane1, plane2) {
             Vector3.cross(plane1.normal, plane2.normal, CollisionUtils._tempV30);
             var denominator = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV30);
             if (MathUtils3D.isZero(denominator))
                 return false;
             return true;
         }
         /**
          * 空间中平面和平面是否相交
          * @param	plane1 平面1
          * @param	plane2 平面2
          * @param	line   相交线
          * @return  是否相交
          */
         static intersectsPlaneAndPlaneRL(plane1, plane2, line) {
             var plane1nor = plane1.normal;
             var plane2nor = plane2.normal;
             Vector3.cross(plane1nor, plane2nor, CollisionUtils._tempV34);
             var denominator = Vector3.dot(CollisionUtils._tempV34, CollisionUtils._tempV34);
             if (MathUtils3D.isZero(denominator))
                 return false;
             Vector3.scale(plane2nor, plane1.distance, CollisionUtils._tempV30);
             Vector3.scale(plane1nor, plane2.distance, CollisionUtils._tempV31);
             Vector3.subtract(CollisionUtils._tempV30, CollisionUtils._tempV31, CollisionUtils._tempV32);
             Vector3.cross(CollisionUtils._tempV32, CollisionUtils._tempV34, CollisionUtils._tempV33);
             Vector3.normalize(CollisionUtils._tempV34, CollisionUtils._tempV34);
             line = new Ray(CollisionUtils._tempV33, CollisionUtils._tempV34);
             return true;
         }
         /**
          * 空间中平面和包围盒是否相交
          * @param	plane 平面
          * @param   box  包围盒
          * @return  碰撞状态
          */
         static intersectsPlaneAndBox(plane, box) {
             var planeD = plane.distance;
             var planeNor = plane.normal;
             var planeNoreX = planeNor.x;
             var planeNoreY = planeNor.y;
             var planeNoreZ = planeNor.z;
             var boxMine = box.min;
             var boxMineX = boxMine.x;
             var boxMineY = boxMine.y;
             var boxMineZ = boxMine.z;
             var boxMaxe = box.max;
             var boxMaxeX = boxMaxe.x;
             var boxMaxeY = boxMaxe.y;
             var boxMaxeZ = boxMaxe.z;
             CollisionUtils._tempV30.x = (planeNoreX > 0) ? boxMineX : boxMaxeX;
             CollisionUtils._tempV30.y = (planeNoreY > 0) ? boxMineY : boxMaxeY;
             CollisionUtils._tempV30.z = (planeNoreZ > 0) ? boxMineZ : boxMaxeZ;
             CollisionUtils._tempV31.x = (planeNoreX > 0) ? boxMaxeX : boxMineX;
             CollisionUtils._tempV31.y = (planeNoreY > 0) ? boxMaxeY : boxMineY;
             CollisionUtils._tempV31.z = (planeNoreZ > 0) ? boxMaxeZ : boxMineZ;
             var distance = Vector3.dot(planeNor, CollisionUtils._tempV30);
             if (distance + planeD > 0)
                 return Plane.PlaneIntersectionType_Front;
             distance = Vector3.dot(planeNor, CollisionUtils._tempV31);
             if (distance + planeD < 0)
                 return Plane.PlaneIntersectionType_Back;
             return Plane.PlaneIntersectionType_Intersecting;
         }
         /**
          * 空间中平面和包围球是否相交
          * @param	plane 平面
          * @param   sphere 包围球
          * @return  碰撞状态
          */
         static intersectsPlaneAndSphere(plane, sphere) {
             var sphereR = sphere.radius;
             var distance = Vector3.dot(plane.normal, sphere.center) + plane.distance;
             if (distance > sphereR)
                 return Plane.PlaneIntersectionType_Front;
             if (distance < -sphereR)
                 return Plane.PlaneIntersectionType_Back;
             return Plane.PlaneIntersectionType_Intersecting;
         }
         /**
          * 空间中包围盒和包围盒是否相交
          * @param	box1 包围盒1
          * @param   box2 包围盒2
          * @return  是否相交
          */
         static intersectsBoxAndBox(box1, box2) {
             var box1Mine = box1.min;
             var box1Maxe = box1.max;
             var box2Mine = box2.min;
             var box2Maxe = box2.max;
             if (box1Mine.x > box2Maxe.x || box2Mine.x > box1Maxe.x)
                 return false;
             if (box1Mine.y > box2Maxe.y || box2Mine.y > box1Maxe.y)
                 return false;
             if (box1Mine.z > box2Maxe.z || box2Mine.z > box1Maxe.z)
                 return false;
             return true;
         }
         /**
          * 空间中包围盒和包围球是否相交
          * @param	box 包围盒
          * @param   sphere 包围球
          * @return  是否相交
          */
         static intersectsBoxAndSphere(box, sphere) {
             var sphereC = sphere.center;
             var sphereR = sphere.radius;
             Vector3.Clamp(sphereC, box.min, box.max, CollisionUtils._tempV30);
             var distance = Vector3.distanceSquared(sphereC, CollisionUtils._tempV30);
             return distance <= sphereR * sphereR;
         }
         /**
          * 空间中包围球和包围球是否相交
          * @param	sphere1 包围球1
          * @param   sphere2 包围球2
          * @return  是否相交
          */
         static intersectsSphereAndSphere(sphere1, sphere2) {
             var radiisum = sphere1.radius + sphere2.radius;
             return Vector3.distanceSquared(sphere1.center, sphere2.center) <= radiisum * radiisum;
         }
         /**
          * 空间中包围盒是否包含另一个点
          * @param	box 包围盒
          * @param   point 点
          * @return  位置关系:0 不想交,1 包含, 2 相交
          */
         static boxContainsPoint(box, point) {
             var boxMine = box.min;
             var boxMaxe = box.max;
             if (boxMine.x <= point.x && boxMaxe.x >= point.x && boxMine.y <= point.y && boxMaxe.y >= point.y && boxMine.z <= point.z && boxMaxe.z >= point.z)
                 return ContainmentType.Contains;
             return ContainmentType.Disjoint;
         }
         /**
          * 空间中包围盒是否包含另一个包围盒
          * @param	box1 包围盒1
          * @param   box2 包围盒2
          * @return  位置关系:0 不想交,1 包含, 2 相交
          */
         static boxContainsBox(box1, box2) {
             var box1Mine = box1.min;
             var box1MineX = box1Mine.x;
             var box1MineY = box1Mine.y;
             var box1MineZ = box1Mine.z;
             var box1Maxe = box1.max;
             var box1MaxeX = box1Maxe.x;
             var box1MaxeY = box1Maxe.y;
             var box1MaxeZ = box1Maxe.z;
             var box2Mine = box2.min;
             var box2MineX = box2Mine.x;
             var box2MineY = box2Mine.y;
             var box2MineZ = box2Mine.z;
             var box2Maxe = box2.max;
             var box2MaxeX = box2Maxe.x;
             var box2MaxeY = box2Maxe.y;
             var box2MaxeZ = box2Maxe.z;
             if (box1MaxeX < box2MineX || box1MineX > box2MaxeX)
                 return ContainmentType.Disjoint;
             if (box1MaxeY < box2MineY || box1MineY > box2MaxeY)
                 return ContainmentType.Disjoint;
             if (box1MaxeZ < box2MineZ || box1MineZ > box2MaxeZ)
                 return ContainmentType.Disjoint;
             if (box1MineX <= box2MineX && box2MaxeX <= box1MaxeX && box1MineY <= box2MineY && box2MaxeY <= box1MaxeY && box1MineZ <= box2MineZ && box2MaxeZ <= box1MaxeZ) {
                 return ContainmentType.Contains;
             }
             return ContainmentType.Intersects;
         }
         /**
          * 空间中包围盒是否包含另一个包围球
          * @param	box 包围盒
          * @param   sphere 包围球
          * @return  位置关系:0 不想交,1 包含, 2 相交
          */
         static boxContainsSphere(box, sphere) {
             var boxMin = box.min;
             var boxMineX = boxMin.x;
             var boxMineY = boxMin.y;
             var boxMineZ = boxMin.z;
             var boxMax = box.max;
             var boxMaxeX = boxMax.x;
             var boxMaxeY = boxMax.y;
             var boxMaxeZ = boxMax.z;
             var sphereC = sphere.center;
             var sphereCeX = sphereC.x;
             var sphereCeY = sphereC.y;
             var sphereCeZ = sphereC.z;
             var sphereR = sphere.radius;
             Vector3.Clamp(sphereC, boxMin, boxMax, CollisionUtils._tempV30);
             var distance = Vector3.distanceSquared(sphereC, CollisionUtils._tempV30);
             if (distance > sphereR * sphereR)
                 return ContainmentType.Disjoint;
             if ((((boxMineX + sphereR <= sphereCeX) && (sphereCeX <= boxMaxeX - sphereR)) && ((boxMaxeX - boxMineX > sphereR) &&
                 (boxMineY + sphereR <= sphereCeY))) && (((sphereCeY <= boxMaxeY - sphereR) && (boxMaxeY - boxMineY > sphereR)) &&
                 (((boxMineZ + sphereR <= sphereCeZ) && (sphereCeZ <= boxMaxeZ - sphereR)) && (boxMaxeZ - boxMineZ > sphereR))))
                 return ContainmentType.Contains;
             return ContainmentType.Intersects;
         }
         /**
          * 空间中包围球是否包含另一个点
          * @param	sphere 包围球
          * @param   point 点
          * @return  位置关系:0 不想交,1 包含, 2 相交
          */
         static sphereContainsPoint(sphere, point) {
             if (Vector3.distanceSquared(point, sphere.center) <= sphere.radius * sphere.radius)
                 return ContainmentType.Contains;
             return ContainmentType.Disjoint;
         }
         /**
          * 空间中包围球是否包含另一个三角面
          * @param	sphere
          * @param	vertex1 三角面顶点1
          * @param	vertex2 三角面顶点2
          * @param	vertex3 三角面顶点3
          * @return  返回空间位置关系
          */
         static sphereContainsTriangle(sphere, vertex1, vertex2, vertex3) {
             var test1 = CollisionUtils.sphereContainsPoint(sphere, vertex1);
             var test2 = CollisionUtils.sphereContainsPoint(sphere, vertex2);
             var test3 = CollisionUtils.sphereContainsPoint(sphere, vertex3);
             if (test1 == ContainmentType.Contains && test2 == ContainmentType.Contains && test3 == ContainmentType.Contains)
                 return ContainmentType.Contains;
             if (CollisionUtils.intersectsSphereAndTriangle(sphere, vertex1, vertex2, vertex3))
                 return ContainmentType.Intersects;
             return ContainmentType.Disjoint;
         }
         /**
          * 空间中包围球是否包含另一包围盒
          * @param	sphere 包围球
          * @param   box 包围盒
          * @return  位置关系:0 不想交,1 包含, 2 相交
          */
         static sphereContainsBox(sphere, box) {
             var sphereC = sphere.center;
             var sphereCeX = sphereC.x;
             var sphereCeY = sphereC.y;
             var sphereCeZ = sphereC.z;
             var sphereR = sphere.radius;
             var boxMin = box.min;
             var boxMineX = boxMin.x;
             var boxMineY = boxMin.y;
             var boxMineZ = boxMin.z;
             var boxMax = box.max;
             var boxMaxeX = boxMax.x;
             var boxMaxeY = boxMax.y;
             var boxMaxeZ = boxMax.z;
             var _tempV30e = CollisionUtils._tempV30;
             var _tempV30eX = _tempV30e.x;
             var _tempV30eY = _tempV30e.y;
             var _tempV30eZ = _tempV30e.z;
             if (!CollisionUtils.intersectsBoxAndSphere(box, sphere))
                 return ContainmentType.Disjoint;
             var radiusSquared = sphereR * sphereR;
             _tempV30eX = sphereCeX - boxMineX;
             _tempV30eY = sphereCeY - boxMaxeY;
             _tempV30eZ = sphereCeZ - boxMaxeZ;
             if (Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                 return ContainmentType.Intersects;
             _tempV30eX = sphereCeX - boxMaxeX;
             _tempV30eY = sphereCeY - boxMaxeY;
             _tempV30eZ = sphereCeZ - boxMaxeZ;
             if (Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                 return ContainmentType.Intersects;
             _tempV30eX = sphereCeX - boxMaxeX;
             _tempV30eY = sphereCeY - boxMineY;
             _tempV30eZ = sphereCeZ - boxMaxeZ;
             if (Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                 return ContainmentType.Intersects;
             _tempV30eX = sphereCeX - boxMineX;
             _tempV30eY = sphereCeY - boxMineY;
             _tempV30eZ = sphereCeZ - boxMaxeZ;
             if (Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                 return ContainmentType.Intersects;
             _tempV30eX = sphereCeX - boxMineX;
             _tempV30eY = sphereCeY - boxMaxeY;
             _tempV30eZ = sphereCeZ - boxMineZ;
             if (Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                 return ContainmentType.Intersects;
             _tempV30eX = sphereCeX - boxMaxeX;
             _tempV30eY = sphereCeY - boxMaxeY;
             _tempV30eZ = sphereCeZ - boxMineZ;
             if (Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                 return ContainmentType.Intersects;
             _tempV30eX = sphereCeX - boxMaxeX;
             _tempV30eY = sphereCeY - boxMineY;
             _tempV30eZ = sphereCeZ - boxMineZ;
             if (Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                 return ContainmentType.Intersects;
             _tempV30eX = sphereCeX - boxMineX;
             _tempV30eY = sphereCeY - boxMineY;
             _tempV30eZ = sphereCeZ - boxMineZ;
             if (Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                 return ContainmentType.Intersects;
             return ContainmentType.Contains;
         }
         /**
          * 空间中包围球是否包含另一包围球
          * @param	sphere1 包围球
          * @param   sphere2 包围球
          * @return  位置关系:0 不想交,1 包含, 2 相交
          */
         static sphereContainsSphere(sphere1, sphere2) {
             var sphere1R = sphere1.radius;
             var sphere2R = sphere2.radius;
             var distance = Vector3.distance(sphere1.center, sphere2.center);
             if (sphere1R + sphere2R < distance)
                 return ContainmentType.Disjoint;
             if (sphere1R - sphere2R < distance)
                 return ContainmentType.Intersects;
             return ContainmentType.Contains;
         }
         /**
          * 空间中点与三角面的最近点
          * @param	point 点
          * @param	vertex1 三角面顶点1
          * @param	vertex2	三角面顶点2
          * @param	vertex3 三角面顶点3
          * @param	out 最近点
          */
         static closestPointPointTriangle(point, vertex1, vertex2, vertex3, out) {
             Vector3.subtract(vertex2, vertex1, CollisionUtils._tempV30);
             Vector3.subtract(vertex3, vertex1, CollisionUtils._tempV31);
             Vector3.subtract(point, vertex1, CollisionUtils._tempV32);
             Vector3.subtract(point, vertex2, CollisionUtils._tempV33);
             Vector3.subtract(point, vertex3, CollisionUtils._tempV34);
             var d1 = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV32);
             var d2 = Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV32);
             var d3 = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV33);
             var d4 = Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV33);
             var d5 = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV34);
             var d6 = Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV34);
             if (d1 <= 0 && d2 <= 0) {
                 vertex1.cloneTo(out);
                 return;
             }
             if (d3 >= 0 && d4 <= d3) {
                 vertex2.cloneTo(out);
                 return;
             }
             var vc = d1 * d4 - d3 * d2;
             if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                 var v = d1 / (d1 - d3);
                 Vector3.scale(CollisionUtils._tempV30, v, out);
                 Vector3.add(vertex1, out, out);
                 return;
             }
             if (d6 >= 0 && d5 <= d6) {
                 vertex3.cloneTo(out);
                 return;
             }
             var vb = d5 * d2 - d1 * d6;
             if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                 var w = d2 / (d2 - d6);
                 Vector3.scale(CollisionUtils._tempV31, w, out);
                 Vector3.add(vertex1, out, out);
                 return;
             }
             var va = d3 * d6 - d5 * d4;
             if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                 var w3 = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                 Vector3.subtract(vertex3, vertex2, out);
                 Vector3.scale(out, w3, out);
                 Vector3.add(vertex2, out, out);
                 return;
             }
             var denom = 1 / (va + vb + vc);
             var v2 = vb * denom;
             var w2 = vc * denom;
             Vector3.scale(CollisionUtils._tempV30, v2, CollisionUtils._tempV35);
             Vector3.scale(CollisionUtils._tempV31, w2, CollisionUtils._tempV36);
             Vector3.add(CollisionUtils._tempV35, CollisionUtils._tempV36, out);
             Vector3.add(vertex1, out, out);
         }
         /**
          * 空间中平面与一点的最近点
          * @param	plane 平面
          * @param	point 点
          * @param	out 最近点
          */
         static closestPointPlanePoint(plane, point, out) {
             var planeN = plane.normal;
             var t = Vector3.dot(planeN, point) - plane.distance;
             Vector3.scale(planeN, t, CollisionUtils._tempV30);
             Vector3.subtract(point, CollisionUtils._tempV30, out);
         }
         /**
          * 空间中包围盒与一点的最近点
          * @param	box 包围盒
          * @param	point 点
          * @param	out 最近点
          */
         static closestPointBoxPoint(box, point, out) {
             Vector3.max(point, box.min, CollisionUtils._tempV30);
             Vector3.min(CollisionUtils._tempV30, box.max, out);
         }
         /**
          * 空间中包围球与一点的最近点
          * @param	sphere 包围球
          * @param	point 点
          * @param	out 最近点
          */
         static closestPointSpherePoint(sphere, point, out) {
             var sphereC = sphere.center;
             Vector3.subtract(point, sphereC, out);
             Vector3.normalize(out, out);
             Vector3.scale(out, sphere.radius, out);
             Vector3.add(out, sphereC, out);
         }
         /**
          * 空间中包围球与包围球的最近点
          * @param	sphere1 包围球1
          * @param	sphere2 包围球2
          * @param	out 最近点
          */
         static closestPointSphereSphere(sphere1, sphere2, out) {
             var sphere1C = sphere1.center;
             Vector3.subtract(sphere2.center, sphere1C, out);
             Vector3.normalize(out, out);
             Vector3.scale(out, sphere1.radius, out);
             Vector3.add(out, sphere1C, out);
         }
     }
     /** @private */
     CollisionUtils._tempV30 = new Vector3();
     /** @private */
     CollisionUtils._tempV31 = new Vector3();
     /** @private */
     CollisionUtils._tempV32 = new Vector3();
     /** @private */
     CollisionUtils._tempV33 = new Vector3();
     /** @private */
     CollisionUtils._tempV34 = new Vector3();
     /** @private */
     CollisionUtils._tempV35 = new Vector3();
     /** @private */
     CollisionUtils._tempV36 = new Vector3();

     /**
          * <code>BoundFrustum</code> 类用于创建锥截体。
          */
     class BoundFrustum {
         /**
          * 创建一个 <code>BoundFrustum</code> 实例。
          * @param	matrix 锥截体的描述4x4矩阵。
          */
         constructor(matrix) {
             this._matrix = matrix;
             this._near = new Plane(new Vector3());
             this._far = new Plane(new Vector3());
             this._left = new Plane(new Vector3());
             this._right = new Plane(new Vector3());
             this._top = new Plane(new Vector3());
             this._bottom = new Plane(new Vector3());
             BoundFrustum._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
         }
         /**
          * 获取描述矩阵。
          * @return  描述矩阵。
          */
         get matrix() {
             return this._matrix;
         }
         /**
          * 设置描述矩阵。
          * @param matrix 描述矩阵。
          */
         set matrix(matrix) {
             this._matrix = matrix;
             BoundFrustum._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
         }
         /**
          * 获取近平面。
          * @return  近平面。
          */
         get near() {
             return this._near;
         }
         /**
          * 获取远平面。
          * @return  远平面。
          */
         get far() {
             return this._far;
         }
         /**
          * 获取左平面。
          * @return  左平面。
          */
         get left() {
             return this._left;
         }
         /**
          * 获取右平面。
          * @return  右平面。
          */
         get right() {
             return this._right;
         }
         /**
          * 获取顶平面。
          * @return  顶平面。
          */
         get top() {
             return this._top;
         }
         /**
          * 获取底平面。
          * @return  底平面。
          */
         get bottom() {
             return this._bottom;
         }
         /**
          * 判断是否与其他锥截体相等。
          * @param	other 锥截体。
          */
         equalsBoundFrustum(other) {
             return this._matrix.equalsOtherMatrix(other.matrix);
         }
         /**
          * 判断是否与其他对象相等。
          * @param	obj 对象。
          */
         equalsObj(obj) {
             if (obj instanceof BoundFrustum) {
                 var bf = obj;
                 return this.equalsBoundFrustum(bf);
             }
             return false;
         }
         /**
          * 获取锥截体的任意一平面。
          * 0:近平面
          * 1:远平面
          * 2:左平面
          * 3:右平面
          * 4:顶平面
          * 5:底平面
          * @param	index 索引。
          */
         getPlane(index) {
             switch (index) {
                 case 0:
                     return this._near;
                 case 1:
                     return this._far;
                 case 2:
                     return this._left;
                 case 3:
                     return this._right;
                 case 4:
                     return this._top;
                 case 5:
                     return this._bottom;
                 default:
                     return null;
             }
         }
         /**
          * 根据描述矩阵获取锥截体的6个面。
          * @param  m 描述矩阵。
          * @param  np   近平面。
          * @param  fp    远平面。
          * @param  lp   左平面。
          * @param  rp  右平面。
          * @param  tp    顶平面。
          * @param  bp 底平面。
          */
         static _getPlanesFromMatrix(m, np, fp, lp, rp, tp, bp) {
             var matrixE = m.elements;
             var m11 = matrixE[0];
             var m12 = matrixE[1];
             var m13 = matrixE[2];
             var m14 = matrixE[3];
             var m21 = matrixE[4];
             var m22 = matrixE[5];
             var m23 = matrixE[6];
             var m24 = matrixE[7];
             var m31 = matrixE[8];
             var m32 = matrixE[9];
             var m33 = matrixE[10];
             var m34 = matrixE[11];
             var m41 = matrixE[12];
             var m42 = matrixE[13];
             var m43 = matrixE[14];
             var m44 = matrixE[15];
             //近平面
             var nearNorE = np.normal;
             nearNorE.x = m14 + m13;
             nearNorE.y = m24 + m23;
             nearNorE.z = m34 + m33;
             np.distance = m44 + m43;
             np.normalize();
             //远平面
             var farNorE = fp.normal;
             farNorE.x = m14 - m13;
             farNorE.y = m24 - m23;
             farNorE.z = m34 - m33;
             fp.distance = m44 - m43;
             fp.normalize();
             //左平面
             var leftNorE = lp.normal;
             leftNorE.x = m14 + m11;
             leftNorE.y = m24 + m21;
             leftNorE.z = m34 + m31;
             lp.distance = m44 + m41;
             lp.normalize();
             //右平面
             var rightNorE = rp.normal;
             rightNorE.x = m14 - m11;
             rightNorE.y = m24 - m21;
             rightNorE.z = m34 - m31;
             rp.distance = m44 - m41;
             rp.normalize();
             //顶平面
             var topNorE = tp.normal;
             topNorE.x = m14 - m12;
             topNorE.y = m24 - m22;
             topNorE.z = m34 - m32;
             tp.distance = m44 - m42;
             tp.normalize();
             //底平面
             var bottomNorE = bp.normal;
             bottomNorE.x = m14 + m12;
             bottomNorE.y = m24 + m22;
             bottomNorE.z = m34 + m32;
             bp.distance = m44 + m42;
             bp.normalize();
         }
         /**
          * 锥截体三个相交平面的交点。
          * @param  p1  平面1。
          * @param  p2  平面2。
          * @param  p3  平面3。
          */
         static _get3PlaneInterPoint(p1, p2, p3) {
             var p1Nor = p1.normal;
             var p2Nor = p2.normal;
             var p3Nor = p3.normal;
             Vector3.cross(p2Nor, p3Nor, BoundFrustum._tempV30);
             Vector3.cross(p3Nor, p1Nor, BoundFrustum._tempV31);
             Vector3.cross(p1Nor, p2Nor, BoundFrustum._tempV32);
             var a = Vector3.dot(p1Nor, BoundFrustum._tempV30);
             var b = Vector3.dot(p2Nor, BoundFrustum._tempV31);
             var c = Vector3.dot(p3Nor, BoundFrustum._tempV32);
             Vector3.scale(BoundFrustum._tempV30, -p1.distance / a, BoundFrustum._tempV33);
             Vector3.scale(BoundFrustum._tempV31, -p2.distance / b, BoundFrustum._tempV34);
             Vector3.scale(BoundFrustum._tempV32, -p3.distance / c, BoundFrustum._tempV35);
             Vector3.add(BoundFrustum._tempV33, BoundFrustum._tempV34, BoundFrustum._tempV36);
             Vector3.add(BoundFrustum._tempV35, BoundFrustum._tempV36, BoundFrustum._tempV37);
             var v = BoundFrustum._tempV37;
             return v;
         }
         /**
          * 锥截体的8个顶点。
          * @param  corners  返回顶点的输出队列。
          */
         getCorners(corners) {
             BoundFrustum._get3PlaneInterPoint(this._near, this._bottom, this._right).cloneTo(corners[0]);
             BoundFrustum._get3PlaneInterPoint(this._near, this._top, this._right).cloneTo(corners[1]);
             BoundFrustum._get3PlaneInterPoint(this._near, this._top, this._left).cloneTo(corners[2]);
             BoundFrustum._get3PlaneInterPoint(this._near, this._bottom, this._left).cloneTo(corners[3]);
             BoundFrustum._get3PlaneInterPoint(this._far, this._bottom, this._right).cloneTo(corners[4]);
             BoundFrustum._get3PlaneInterPoint(this._far, this._top, this._right).cloneTo(corners[5]);
             BoundFrustum._get3PlaneInterPoint(this._far, this._top, this._left).cloneTo(corners[6]);
             BoundFrustum._get3PlaneInterPoint(this._far, this._bottom, this._left).cloneTo(corners[7]);
         }
         /**
          * 与点的位置关系。返回-1,包涵;0,相交;1,不相交
          * @param  point  点。
          */
         containsPoint(point) {
             var result = Plane.PlaneIntersectionType_Front;
             var planeResult = Plane.PlaneIntersectionType_Front;
             for (var i = 0; i < 6; i++) {
                 switch (i) {
                     case 0:
                         planeResult = CollisionUtils.intersectsPlaneAndPoint(this._near, point);
                         break;
                     case 1:
                         planeResult = CollisionUtils.intersectsPlaneAndPoint(this._far, point);
                         break;
                     case 2:
                         planeResult = CollisionUtils.intersectsPlaneAndPoint(this._left, point);
                         break;
                     case 3:
                         planeResult = CollisionUtils.intersectsPlaneAndPoint(this._right, point);
                         break;
                     case 4:
                         planeResult = CollisionUtils.intersectsPlaneAndPoint(this._top, point);
                         break;
                     case 5:
                         planeResult = CollisionUtils.intersectsPlaneAndPoint(this._bottom, point);
                         break;
                 }
                 switch (planeResult) {
                     case Plane.PlaneIntersectionType_Back:
                         return ContainmentType.Disjoint;
                     case Plane.PlaneIntersectionType_Intersecting:
                         result = Plane.PlaneIntersectionType_Intersecting;
                         break;
                 }
             }
             switch (result) {
                 case Plane.PlaneIntersectionType_Intersecting:
                     return ContainmentType.Intersects;
                 default:
                     return ContainmentType.Contains;
             }
         }
         /**
          * 与包围盒的位置关系。返回-1,包涵;0,相交;1,不相交
          * @param  box  包围盒。
          */
         containsBoundBox(box) {
             var p = BoundFrustum._tempV30, n = BoundFrustum._tempV31;
             var boxMin = box.min;
             var boxMax = box.max;
             var result = ContainmentType.Contains;
             for (var i = 0; i < 6; i++) {
                 var plane = this.getPlane(i);
                 var planeNor = plane.normal;
                 if (planeNor.x >= 0) {
                     p.x = boxMax.x;
                     n.x = boxMin.x;
                 }
                 else {
                     p.x = boxMin.x;
                     n.x = boxMax.x;
                 }
                 if (planeNor.y >= 0) {
                     p.y = boxMax.y;
                     n.y = boxMin.y;
                 }
                 else {
                     p.y = boxMin.y;
                     n.y = boxMax.y;
                 }
                 if (planeNor.z >= 0) {
                     p.z = boxMax.z;
                     n.z = boxMin.z;
                 }
                 else {
                     p.z = boxMin.z;
                     n.z = boxMax.z;
                 }
                 if (CollisionUtils.intersectsPlaneAndPoint(plane, p) === Plane.PlaneIntersectionType_Back)
                     return ContainmentType.Disjoint;
                 if (CollisionUtils.intersectsPlaneAndPoint(plane, n) === Plane.PlaneIntersectionType_Back)
                     result = ContainmentType.Intersects;
             }
             return result;
         }
         /**
          * 与包围球的位置关系。返回-1,包涵;0,相交;1,不相交
          * @param  sphere  包围球。
          */
         containsBoundSphere(sphere) {
             var result = Plane.PlaneIntersectionType_Front;
             var planeResult = Plane.PlaneIntersectionType_Front;
             for (var i = 0; i < 6; i++) {
                 switch (i) {
                     case 0:
                         planeResult = CollisionUtils.intersectsPlaneAndSphere(this._near, sphere);
                         break;
                     case 1:
                         planeResult = CollisionUtils.intersectsPlaneAndSphere(this._far, sphere);
                         break;
                     case 2:
                         planeResult = CollisionUtils.intersectsPlaneAndSphere(this._left, sphere);
                         break;
                     case 3:
                         planeResult = CollisionUtils.intersectsPlaneAndSphere(this._right, sphere);
                         break;
                     case 4:
                         planeResult = CollisionUtils.intersectsPlaneAndSphere(this._top, sphere);
                         break;
                     case 5:
                         planeResult = CollisionUtils.intersectsPlaneAndSphere(this._bottom, sphere);
                         break;
                 }
                 switch (planeResult) {
                     case Plane.PlaneIntersectionType_Back:
                         return ContainmentType.Disjoint;
                     case Plane.PlaneIntersectionType_Intersecting:
                         result = Plane.PlaneIntersectionType_Intersecting;
                         break;
                 }
             }
             switch (result) {
                 case Plane.PlaneIntersectionType_Intersecting:
                     return ContainmentType.Intersects;
                 default:
                     return ContainmentType.Contains;
             }
         }
     }
     /** @private */
     BoundFrustum._tempV30 = new Vector3();
     /** @private */
     BoundFrustum._tempV31 = new Vector3();
     /** @private */
     BoundFrustum._tempV32 = new Vector3();
     /** @private */
     BoundFrustum._tempV33 = new Vector3();
     /** @private */
     BoundFrustum._tempV34 = new Vector3();
     /** @private */
     BoundFrustum._tempV35 = new Vector3();
     /** @private */
     BoundFrustum._tempV36 = new Vector3();
     /** @private */
     BoundFrustum._tempV37 = new Vector3();

     /**
          * <code>Viewport</code> 类用于创建视口。
          */
     class Viewport {
         /**
          * 创建一个 <code>Viewport</code> 实例。
          * @param	x x坐标。
          * @param	y y坐标。
          * @param	width 宽度。
          * @param	height 高度。
          */
         constructor(x, y, width, height) {
             this.minDepth = 0.0; //TODO:待确认，-1。
             this.maxDepth = 1.0;
             this.x = x;
             this.y = y;
             this.width = width;
             this.height = height;
         }
         /**
          * 变换一个三维向量。
          * @param	source 源三维向量。
          * @param	matrix 变换矩阵。
          * @param	vector 输出三维向量。
          */
         project(source, matrix, out) {
             Vector3.transformV3ToV3(source, matrix, out);
             var matrixEleme = matrix.elements;
             var a = (((source.x * matrixEleme[3]) + (source.y * matrixEleme[7])) + (source.z * matrixEleme[11])) + matrixEleme[15];
             if (a !== 1.0) //待优化，经过计算得出的a可能会永远只近似于1，因为是Number类型
              {
                 out.x = out.x / a;
                 out.y = out.y / a;
                 out.z = out.z / a;
             }
             out.x = (((out.x + 1.0) * 0.5) * this.width) + this.x;
             out.y = (((-out.y + 1.0) * 0.5) * this.height) + this.y;
             out.z = (out.z * (this.maxDepth - this.minDepth)) + this.minDepth;
         }
         project1(source, matrix, out) {
             var v4 = Vector3._tempVector4;
             Vector3.transformV3ToV4(source, matrix, v4);
             //v4e[3]是z，是相对于摄像机的位置。注意有时候可能为0
             var dist = v4.w;
             if (dist < 1e-1 && dist > -1e-6)
                 dist = 1e-6;
             v4.x /= dist;
             v4.y /= dist;
             v4.z /= dist;
             out.x = (v4.x + 1) * this.width / 2 + this.x;
             out.y = (-v4.y + 1) * this.height / 2 + this.y;
             out.z = v4.w;
             return;
         }
         /**
          * 反变换一个三维向量。
          * @param	source 源三维向量。
          * @param	matrix 变换矩阵。
          * @param	vector 输出三维向量。
          */
         unprojectFromMat(source, matrix, out) {
             var matrixEleme = matrix.elements;
             out.x = (((source.x - this.x) / (this.width)) * 2.0) - 1.0;
             out.y = -((((source.y - this.y) / (this.height)) * 2.0) - 1.0);
             var halfDepth = (this.maxDepth - this.minDepth) / 2;
             out.z = (source.z - this.minDepth - halfDepth) / halfDepth;
             var a = (((out.x * matrixEleme[3]) + (out.y * matrixEleme[7])) + (out.z * matrixEleme[11])) + matrixEleme[15];
             Vector3.transformV3ToV3(out, matrix, out);
             if (a !== 1.0) //待优化，经过计算得出的a可能会永远只近似于1，因为是Number类型
              {
                 out.x = out.x / a;
                 out.y = out.y / a;
                 out.z = out.z / a;
             }
         }
         /**
          * 反变换一个三维向量。
          * @param	source 源三维向量。
          * @param	projection  透视投影矩阵。
          * @param	view 视图矩阵。
          * @param	world 世界矩阵,可设置为null。
          * @param   out 输出向量。
          */
         unprojectFromWVP(source, projection, view, world, out) {
             Matrix4x4.multiply(projection, view, Viewport._tempMatrix4x4);
             (world) && (Matrix4x4.multiply(Viewport._tempMatrix4x4, world, Viewport._tempMatrix4x4));
             Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4);
             this.unprojectFromMat(source, Viewport._tempMatrix4x4, out);
         }
         /**
          * 克隆
          * @param	out
          */
         cloneTo(out) {
             out.x = this.x;
             out.y = this.y;
             out.width = this.width;
             out.height = this.height;
             out.minDepth = this.minDepth;
             out.maxDepth = this.maxDepth;
         }
     }
     Viewport._tempMatrix4x4 = new Matrix4x4();

     /**
        //* <code>RenderTexture</code> 类用于创建渲染目标。
      */
     class RenderTexture extends BaseTexture {
         /**
          * @param width  宽度。
          * @param height 高度。
          * @param format 纹理格式。
          * @param depthStencilFormat 深度格式。
          * 创建一个 <code>RenderTexture</code> 实例。
          */
         constructor(width, height, format = BaseTexture.FORMAT_R8G8B8, depthStencilFormat = BaseTexture.FORMAT_DEPTH_16) {
             super(format, false);
             /** @private */
             this._inPool = false;
             this._glTextureType = WebGLContext.TEXTURE_2D;
             this._width = width;
             this._height = height;
             this._depthStencilFormat = depthStencilFormat;
             this._create(width, height);
         }
         /**
          * 获取当前激活的Rendertexture。
          */
         static get currentActive() {
             return RenderTexture._currentActive;
         }
         /**
          *从对象池获取临时渲染目标。
          */
         static createFromPool(width, height, format = BaseTexture.FORMAT_R8G8B8, depthStencilFormat = BaseTexture.FORMAT_DEPTH_16, filterMode = BaseTexture.FILTERMODE_BILINEAR) {
             var tex;
             for (var i = 0, n = RenderTexture._pool.length; i < n; i++) {
                 tex = RenderTexture._pool[i];
                 if (tex._width == width && tex._height == height && tex._format == format && tex._depthStencilFormat == depthStencilFormat && tex._filterMode == filterMode) {
                     tex._inPool = false;
                     var end = RenderTexture._pool[n - 1];
                     RenderTexture._pool[i] = end;
                     RenderTexture._pool.length -= 1;
                     return tex;
                 }
             }
             tex = new RenderTexture(width, height, format, depthStencilFormat);
             tex.filterMode = filterMode;
             tex.lock = true; //TODO:资源不加锁会被GC掉,或GC时对象池清空
             return tex;
         }
         /**
          * 回收渲染目标到对象池,释放后可通过createFromPool复用。
          */
         static recoverToPool(renderTexture) {
             if (renderTexture._inPool)
                 return;
             RenderTexture._pool.push(renderTexture);
             renderTexture._inPool = true;
         }
         /**
          * 获取深度格式。
          *@return 深度格式。
          */
         get depthStencilFormat() {
             return this._depthStencilFormat;
         }
         /**
          * @inheritDoc
          */
         /*override*/ get defaulteTexture() {
             return Texture2D.grayTexture;
         }
         /**
          * @private
          */
         _texImage2D(gl, glTextureType, width, height) {
             switch (this._format) {
                 case BaseTexture.FORMAT_R8G8B8:
                     gl.texImage2D(glTextureType, 0, WebGLContext.RGB, width, height, 0, WebGLContext.RGB, WebGLContext.UNSIGNED_BYTE, null);
                     break;
                 case BaseTexture.FORMAT_R8G8B8A8:
                     gl.texImage2D(glTextureType, 0, WebGLContext.RGBA, width, height, 0, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, null);
                     break;
                 case BaseTexture.FORMAT_ALPHA8:
                     gl.texImage2D(glTextureType, 0, WebGLContext.ALPHA, width, height, 0, WebGLContext.ALPHA, WebGLContext.UNSIGNED_BYTE, null);
                     break;
                 case BaseTexture.RENDERTEXTURE_FORMAT_RGBA_HALF_FLOAT:
                     if (LayaGL.layaGPUInstance._isWebGL2)
                         gl.texImage2D(this._glTextureType, 0, WebGLContext.RGBA16F, width, height, 0, WebGLContext.RGBA, WebGLContext.HALF_FLOAT, null);
                     else
                         gl.texImage2D(this._glTextureType, 0, WebGLContext.RGBA, width, height, 0, WebGLContext.RGBA, LayaGL.layaGPUInstance._oesTextureHalfFloat.HALF_FLOAT_OES, null); //内部格式仍为RGBA
                     break;
                 default:
                     break;
             }
         }
         /**
          * @private
          */
         _create(width, height) {
             var gl = LayaGL.instance;
             this._frameBuffer = gl.createFramebuffer();
             WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
             this._texImage2D(gl, this._glTextureType, width, height);
             this._setGPUMemory(width * height * 4);
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, this._frameBuffer);
             gl.framebufferTexture2D(WebGLContext.FRAMEBUFFER, WebGLContext.COLOR_ATTACHMENT0, WebGLContext.TEXTURE_2D, this._glTexture, 0);
             if (this._depthStencilFormat !== BaseTexture.FORMAT_DEPTHSTENCIL_NONE) {
                 this._depthStencilBuffer = gl.createRenderbuffer();
                 gl.bindRenderbuffer(WebGLContext.RENDERBUFFER, this._depthStencilBuffer);
                 switch (this._depthStencilFormat) {
                     case BaseTexture.FORMAT_DEPTH_16:
                         gl.renderbufferStorage(WebGLContext.RENDERBUFFER, WebGLContext.DEPTH_COMPONENT16, width, height);
                         gl.framebufferRenderbuffer(WebGLContext.FRAMEBUFFER, WebGLContext.DEPTH_ATTACHMENT, WebGLContext.RENDERBUFFER, this._depthStencilBuffer);
                         break;
                     case BaseTexture.FORMAT_STENCIL_8:
                         gl.renderbufferStorage(WebGLContext.RENDERBUFFER, WebGLContext.STENCIL_INDEX8, width, height);
                         gl.framebufferRenderbuffer(WebGLContext.FRAMEBUFFER, WebGLContext.STENCIL_ATTACHMENT, WebGLContext.RENDERBUFFER, this._depthStencilBuffer);
                         break;
                     case BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                         gl.renderbufferStorage(WebGLContext.RENDERBUFFER, WebGLContext.DEPTH_STENCIL, width, height);
                         gl.framebufferRenderbuffer(WebGLContext.FRAMEBUFFER, WebGLContext.DEPTH_STENCIL_ATTACHMENT, WebGLContext.RENDERBUFFER, this._depthStencilBuffer);
                         break;
                     default:
                         throw "RenderTexture: unkonw depth format.";
                 }
             }
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
             gl.bindRenderbuffer(WebGLContext.RENDERBUFFER, null);
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_S, this._wrapModeU);
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_T, this._wrapModeV);
             this._setFilterMode(this._filterMode);
             this._setAnisotropy(this._anisoLevel);
             this._readyed = true;
             this._activeResource();
         }
         /**
          * @private
          */
         _start() {
             LayaGL.instance.bindFramebuffer(WebGLContext.FRAMEBUFFER, this._frameBuffer);
             RenderTexture._currentActive = this;
             this._readyed = false;
         }
         /**
          * @private
          */
         _end() {
             LayaGL.instance.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
             RenderTexture._currentActive = null;
             this._readyed = true;
         }
         /**
          * 获得像素数据。
          * @param x X像素坐标。
          * @param y Y像素坐标。
          * @param width 宽度。
          * @param height 高度。
          * @return 像素数据。
          */
         getData(x, y, width, height, out) {
             if (Render.isConchApp && window.conchConfig.threadMode == 2) {
                 throw "native 2 thread mode use getDataAsync";
             }
             var gl = LayaGL.instance;
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, this._frameBuffer);
             var canRead = (gl.checkFramebufferStatus(WebGLContext.FRAMEBUFFER) === WebGLContext.FRAMEBUFFER_COMPLETE);
             if (!canRead) {
                 gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
                 return null;
             }
             gl.readPixels(x, y, width, height, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, out);
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
             return out;
         }
         /**
          * native多线程
          */
         getDataAsync(x, y, width, height, callBack) {
             var gl = LayaGL.instance;
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, this._frameBuffer);
             gl.readPixelsAsync(x, y, width, height, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, function (data) {
                 callBack(new Uint8Array(data));
             });
             gl.bindFramebuffer(WebGLContext.FRAMEBUFFER, null);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _disposeResource() {
             if (this._frameBuffer) {
                 var gl = LayaGL.instance;
                 gl.deleteTexture(this._glTexture);
                 gl.deleteFramebuffer(this._frameBuffer);
                 gl.deleteRenderbuffer(this._depthStencilBuffer);
                 this._glTexture = null;
                 this._frameBuffer = null;
                 this._depthStencilBuffer = null;
                 this._setGPUMemory(0);
             }
         }
     }
     /** @private */
     RenderTexture._pool = [];

     /**
      * <code>DefineDatas</code> 类用于创建宏定义数据。
      */
     class DefineDatas {
         /**
          * 创建一个 <code>DefineDatas</code> 实例。
          */
         constructor() {
             this.value = 0;
         }
         /**
          * @private
          */
         add(define) {
             this.value |= define;
         }
         /**
          * @private
          */
         remove(define) {
             this.value &= ~define;
         }
         /**
          * @private
          */
         has(define) {
             return (this.value & define) > 0;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destDefineData = destObject;
             destDefineData.value = this.value;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new DefineDatas();
             this.cloneTo(dest);
             return dest;
         }
     }

     /**
      * @private
      */
     class ShaderData {
         /**
          * @private
          */
         constructor(ownerResource = null) {
             /**@private */
             this._ownerResource = null;
             /**@private */
             this._data = null;
             /** @private */
             this._defineDatas = new DefineDatas();
             /**@private [NATIVE]*/
             this._runtimeCopyValues = [];
             this._ownerResource = ownerResource;
             this._initData();
         }
         /**
          * @private
          */
         _initData() {
             this._data = new Object();
         }
         /**
          * @private
          */
         getData() {
             return this._data;
         }
         /**
          * 增加Shader宏定义。
          * @param value 宏定义。
          */
         addDefine(define) {
             this._defineDatas.add(define);
         }
         /**
          * 移除Shader宏定义。
          * @param value 宏定义。
          */
         removeDefine(define) {
             this._defineDatas.remove(define);
         }
         /**
          * 是否包含Shader宏定义。
          * @param value 宏定义。
          */
         hasDefine(define) {
             return (this._defineDatas.value & define) > 0;
         }
         /**
          * 清空宏定义。
          */
         clearDefine() {
             this._defineDatas.value = 0;
         }
         /**
          * 获取布尔。
          * @param	index shader索引。
          * @return  布尔。
          */
         getBool(index) {
             return this._data[index];
         }
         /**
          * 设置布尔。
          * @param	index shader索引。
          * @param	value 布尔。
          */
         setBool(index, value) {
             this._data[index] = value;
         }
         /**
          * 获取整形。
          * @param	index shader索引。
          * @return  整形。
          */
         getInt(index) {
             return this._data[index];
         }
         /**
          * 设置整型。
          * @param	index shader索引。
          * @param	value 整形。
          */
         setInt(index, value) {
             this._data[index] = value;
         }
         /**
          * 获取浮点。
          * @param	index shader索引。
          * @return  浮点。
          */
         getNumber(index) {
             return this._data[index];
         }
         /**
          * 设置浮点。
          * @param	index shader索引。
          * @param	value 浮点。
          */
         setNumber(index, value) {
             this._data[index] = value;
         }
         /**
          * 获取Vector2向量。
          * @param	index shader索引。
          * @return Vector2向量。
          */
         getVector2(index) {
             return this._data[index];
         }
         /**
          * 设置Vector2向量。
          * @param	index shader索引。
          * @param	value Vector2向量。
          */
         setVector2(index, value) {
             this._data[index] = value;
         }
         /**
          * 获取Vector3向量。
          * @param	index shader索引。
          * @return Vector3向量。
          */
         getVector3(index) {
             return this._data[index];
         }
         /**
          * 设置Vector3向量。
          * @param	index shader索引。
          * @param	value Vector3向量。
          */
         setVector3(index, value) {
             this._data[index] = value;
         }
         /**
          * 获取颜色。
          * @param	index shader索引。
          * @return 颜色向量。
          */
         getVector(index) {
             return this._data[index];
         }
         /**
          * 设置向量。
          * @param	index shader索引。
          * @param	value 向量。
          */
         setVector(index, value) {
             this._data[index] = value;
         }
         /**
          * 获取四元数。
          * @param	index shader索引。
          * @return 四元。
          */
         getQuaternion(index) {
             return this._data[index];
         }
         /**
          * 设置四元数。
          * @param	index shader索引。
          * @param	value 四元数。
          */
         setQuaternion(index, value) {
             this._data[index] = value;
         }
         /**
          * 获取矩阵。
          * @param	index shader索引。
          * @return  矩阵。
          */
         getMatrix4x4(index) {
             return this._data[index];
         }
         /**
          * 设置矩阵。
          * @param	index shader索引。
          * @param	value  矩阵。
          */
         setMatrix4x4(index, value) {
             this._data[index] = value;
         }
         /**
          * 获取Buffer。
          * @param	index shader索引。
          * @return
          */
         getBuffer(shaderIndex) {
             return this._data[shaderIndex];
         }
         /**
          * 设置Buffer。
          * @param	index shader索引。
          * @param	value  buffer数据。
          */
         setBuffer(index, value) {
             this._data[index] = value;
         }
         /**
          * 设置纹理。
          * @param	index shader索引。
          * @param	value 纹理。
          */
         setTexture(index, value) {
             var lastValue = this._data[index];
             this._data[index] = value;
             if (this._ownerResource && this._ownerResource.referenceCount > 0) {
                 (lastValue) && (lastValue._removeReference());
                 (value) && (value._addReference());
             }
         }
         /**
          * 获取纹理。
          * @param	index shader索引。
          * @return  纹理。
          */
         getTexture(index) {
             return this._data[index];
         }
         /**
          * 设置Attribute。
          * @param	index shader索引。
          * @param	value 纹理。
          */
         setAttribute(index, value) {
             this._data[index] = value;
         }
         /**
          * 获取Attribute。
          * @param	index shader索引。
          * @return  纹理。
          */
         getAttribute(index) {
             return this._data[index];
         }
         /**
          * 获取长度。
          * @return 长度。
          */
         getLength() {
             return this._data.length;
         }
         /**
          * 设置长度。
          * @param 长度。
          */
         setLength(value) {
             this._data.length = value;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var dest = destObject;
             var destData = dest._data;
             for (var k in this._data) { //TODO:需要优化,杜绝is判断，慢
                 var value = this._data[k];
                 if (value != null) {
                     if (typeof (value) == 'number') {
                         destData[k] = value;
                     }
                     else if (typeof (value) == 'number') {
                         destData[k] = value;
                     }
                     else if (typeof (value) == "boolean") {
                         destData[k] = value;
                     }
                     else if (value instanceof Vector2) {
                         var v2 = (destData[k]) || (destData[k] = new Vector2());
                         value.cloneTo(v2);
                         destData[k] = v2;
                     }
                     else if (value instanceof Vector3) {
                         var v3 = (destData[k]) || (destData[k] = new Vector3());
                         value.cloneTo(v3);
                         destData[k] = v3;
                     }
                     else if (value instanceof Vector4) {
                         var v4 = (destData[k]) || (destData[k] = new Vector4());
                         value.cloneTo(v4);
                         destData[k] = v4;
                     }
                     else if (value instanceof Matrix4x4) {
                         var mat = (destData[k]) || (destData[k] = new Matrix4x4());
                         value.cloneTo(mat);
                         destData[k] = mat;
                     }
                     else if (value instanceof BaseTexture) {
                         destData[k] = value;
                     }
                 }
             }
             this._defineDatas.cloneTo(dest._defineDatas);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new ShaderData();
             this.cloneTo(dest);
             return dest;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneToForNative(destObject) {
             var dest = destObject;
             var diffSize = this._int32Data.length - dest._int32Data.length;
             if (diffSize > 0) {
                 dest.needRenewArrayBufferForNative(this._int32Data.length);
             }
             dest._int32Data.set(this._int32Data, 0);
             var destData = dest._nativeArray;
             var dataCount = this._nativeArray.length;
             destData.length = dataCount; //TODO:runtime
             for (var i = 0; i < dataCount; i++) { //TODO:需要优化,杜绝is判断，慢
                 var value = this._nativeArray[i];
                 if (value) {
                     if (typeof (value) == 'number') {
                         destData[i] = value;
                         dest.setNumber(i, value);
                     }
                     else if (typeof (value) == 'number') {
                         destData[i] = value;
                         dest.setInt(i, value);
                     }
                     else if (typeof (value) == "boolean") {
                         destData[i] = value;
                         dest.setBool(i, value);
                     }
                     else if (value instanceof Vector2) {
                         var v2 = (destData[i]) || (destData[i] = new Vector2());
                         value.cloneTo(v2);
                         destData[i] = v2;
                         dest.setVector2(i, v2);
                     }
                     else if (value instanceof Vector3) {
                         var v3 = (destData[i]) || (destData[i] = new Vector3());
                         value.cloneTo(v3);
                         destData[i] = v3;
                         dest.setVector3(i, v3);
                     }
                     else if (value instanceof Vector4) {
                         var v4 = (destData[i]) || (destData[i] = new Vector4());
                         value.cloneTo(v4);
                         destData[i] = v4;
                         dest.setVector(i, v4);
                     }
                     else if (value instanceof Matrix4x4) {
                         var mat = (destData[i]) || (destData[i] = new Matrix4x4());
                         value.cloneTo(mat);
                         destData[i] = mat;
                         dest.setMatrix4x4(i, mat);
                     }
                     else if (value instanceof BaseTexture) {
                         destData[i] = value;
                         dest.setTexture(i, value);
                     }
                 }
             }
         }
         /**
          * @private [NATIVE]
          */
         _initDataForNative() {
             var length = 8; //默认分配8个
             this._frameCount = -1;
             this._runtimeCopyValues.length = 0;
             this._nativeArray = [];
             this._data = new ArrayBuffer(length * 4);
             this._int32Data = new Int32Array(this._data);
             this._float32Data = new Float32Array(this._data);
             LayaGL.createArrayBufferRef(this._data, LayaGL.ARRAY_BUFFER_TYPE_DATA, true);
         }
         needRenewArrayBufferForNative(index) {
             if (index >= this._int32Data.length) {
                 var nByteLen = (index + 1) * 4;
                 var pre = this._int32Data;
                 var preConchRef = this._data["conchRef"];
                 var prePtrID = this._data["_ptrID"];
                 this._data = new ArrayBuffer(nByteLen);
                 this._int32Data = new Int32Array(this._data);
                 this._float32Data = new Float32Array(this._data);
                 this._data["conchRef"] = preConchRef;
                 this._data["_ptrID"] = prePtrID;
                 pre && this._int32Data.set(pre, 0);
                 window.conch.updateArrayBufferRef(this._data['_ptrID'], preConchRef.isSyncToRender(), this._data);
             }
         }
         getDataForNative() {
             return this._nativeArray;
         }
         /**
          *@private [NATIVE]
          */
         getIntForNative(index) {
             return this._int32Data[index];
         }
         /**
          *@private [NATIVE]
          */
         setIntForNative(index, value) {
             this.needRenewArrayBufferForNative(index);
             this._int32Data[index] = value;
             this._nativeArray[index] = value;
         }
         /**
          *@private [NATIVE]
          */
         getBoolForNative(index) {
             return this._int32Data[index] == 1;
         }
         /**
          *@private [NATIVE]
          */
         setBoolForNative(index, value) {
             this.needRenewArrayBufferForNative(index);
             this._int32Data[index] = value ? 1 : 0;
             this._nativeArray[index] = value;
         }
         /**
          *@private [NATIVE]
          */
         getNumberForNative(index) {
             return this._float32Data[index];
         }
         /**
          *@private [NATIVE]
          */
         setNumberForNative(index, value) {
             this.needRenewArrayBufferForNative(index);
             this._float32Data[index] = value;
             this._nativeArray[index] = value;
         }
         /**
          *@private [NATIVE]
          */
         getMatrix4x4ForNative(index) {
             return this._nativeArray[index];
         }
         /**
          *@private [NATIVE]
          */
         setMatrix4x4ForNative(index, value) {
             this.needRenewArrayBufferForNative(index);
             this._nativeArray[index] = value; //保存引用
             var nPtrID = this.setReferenceForNative(value.elements);
             this._int32Data[index] = nPtrID;
         }
         /**
          *@private [NATIVE]
          */
         getVectorForNative(index) {
             return this._nativeArray[index];
         }
         /**
          *@private [NATIVE]
          */
         setVectorForNative(index, value) {
             this.needRenewArrayBufferForNative(index);
             this._nativeArray[index] = value; //保存引用
             if (!value.elements) {
                 value.forNativeElement();
             }
             var nPtrID = this.setReferenceForNative(value.elements);
             this._int32Data[index] = nPtrID;
         }
         /**
          *@private [NATIVE]
          */
         getVector2ForNative(index) {
             return this._nativeArray[index];
         }
         /**
          *@private [NATIVE]
          */
         setVector2ForNative(index, value) {
             this.needRenewArrayBufferForNative(index);
             this._nativeArray[index] = value; //保存引用
             if (!value.elements) {
                 value.forNativeElement();
             }
             var nPtrID = this.setReferenceForNative(value.elements);
             this._int32Data[index] = nPtrID;
         }
         /**
          *@private [NATIVE]
          */
         getVector3ForNative(index) {
             return this._nativeArray[index];
         }
         /**
          *@private [NATIVE]
          */
         setVector3ForNative(index, value) {
             this.needRenewArrayBufferForNative(index);
             this._nativeArray[index] = value; //保存引用
             if (!value.elements) {
                 value.forNativeElement();
             }
             var nPtrID = this.setReferenceForNative(value.elements);
             this._int32Data[index] = nPtrID;
         }
         /**
          *@private [NATIVE]
          */
         getQuaternionForNative(index) {
             return this._nativeArray[index];
         }
         /**
          *@private [NATIVE]
          */
         setQuaternionForNative(index, value) {
             this.needRenewArrayBufferForNative(index);
             this._nativeArray[index] = value; //保存引用
             if (!value.elements) {
                 value.forNativeElement();
             }
             var nPtrID = this.setReferenceForNative(value.elements);
             this._int32Data[index] = nPtrID;
         }
         /**
          *@private [NATIVE]
          */
         getBufferForNative(shaderIndex) {
             return this._nativeArray[shaderIndex];
         }
         /**
          *@private [NATIVE]
          */
         setBufferForNative(index, value) {
             this.needRenewArrayBufferForNative(index);
             this._nativeArray[index] = value; //保存引用
             var nPtrID = this.setReferenceForNative(value);
             this._int32Data[index] = nPtrID;
         }
         /**
          *@private [NATIVE]
          */
         getAttributeForNative(index) {
             return this._nativeArray[index];
         }
         /**
          *@private [NATIVE]
          */
         setAttributeForNative(index, value) {
             this._nativeArray[index] = value; //保存引用
             if (!value["_ptrID"]) {
                 LayaGL.createArrayBufferRef(value, LayaGL.ARRAY_BUFFER_TYPE_DATA, true);
             }
             LayaGL.syncBufferToRenderThread(value);
             this._int32Data[index] = value["_ptrID"];
         }
         /**
          *@private [NATIVE]
          */
         getTextureForNative(index) {
             return this._nativeArray[index];
         }
         /**
          *@private [NATIVE]
          */
         setTextureForNative(index, value) {
             if (!value)
                 return;
             this.needRenewArrayBufferForNative(index);
             var lastValue = this._nativeArray[index];
             this._nativeArray[index] = value; //保存引用
             this._int32Data[index] = value._glTexture.id;
             if (this._ownerResource && this._ownerResource.referenceCount > 0) {
                 (lastValue) && (lastValue._removeReference());
                 (value) && (value._addReference());
             }
         }
         setReferenceForNative(value) {
             //清空保存的数据
             this.clearRuntimeCopyArray();
             var nRefID = 0;
             var nPtrID = 0;
             if (ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_) {
                 LayaGL.createArrayBufferRefs(value, LayaGL.ARRAY_BUFFER_TYPE_DATA, true, LayaGL.ARRAY_BUFFER_REF_REFERENCE);
                 nRefID = 0;
                 nPtrID = value.getPtrID(nRefID);
             }
             else {
                 LayaGL.createArrayBufferRefs(value, LayaGL.ARRAY_BUFFER_TYPE_DATA, true, LayaGL.ARRAY_BUFFER_REF_COPY);
                 nRefID = value.getRefNum() - 1;
                 nPtrID = value.getPtrID(nRefID);
                 //TODO 应该只用到value
                 this._runtimeCopyValues.push({ "obj": value, "refID": nRefID, "ptrID": nPtrID });
             }
             LayaGL.syncBufferToRenderThread(value, nRefID);
             return nPtrID;
         }
         static setRuntimeValueMode(bReference) {
             ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = bReference;
         }
         clearRuntimeCopyArray() {
             var currentFrame = LayaGL.getFrameCount();
             if (this._frameCount != currentFrame) {
                 this._frameCount = currentFrame;
                 for (var i = 0, n = this._runtimeCopyValues.length; i < n; i++) {
                     var obj = this._runtimeCopyValues[i];
                     obj.obj.clearRefNum();
                 }
                 this._runtimeCopyValues.length = 0;
             }
         }
     }
     /**@private [NATIVE]*/
     ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = true;

     /**
      * <code>Picker</code> 类用于创建拾取。
      */
     class Picker {
         /**
          * 创建一个 <code>Picker</code> 实例。
          */
         constructor() {
         }
         /**
          * 计算鼠标生成的射线。
          * @param	point 鼠标位置。
          * @param	viewPort 视口。
          * @param	projectionMatrix 透视投影矩阵。
          * @param	viewMatrix 视图矩阵。
          * @param	world 世界偏移矩阵。
          * @return  out  输出射线。
          */
         static calculateCursorRay(point, viewPort, projectionMatrix, viewMatrix, world, out) {
             var x = point.x;
             var y = point.y;
             var nearSource = Picker._tempVector30;
             var nerSourceE = nearSource;
             nerSourceE.x = x;
             nerSourceE.y = y;
             nerSourceE.z = viewPort.minDepth;
             var farSource = Picker._tempVector31;
             var farSourceE = farSource;
             farSourceE.x = x;
             farSourceE.y = y;
             farSourceE.z = viewPort.maxDepth;
             var nearPoint = out.origin;
             var farPoint = Picker._tempVector32;
             viewPort.unprojectFromWVP(nearSource, projectionMatrix, viewMatrix, world, nearPoint);
             viewPort.unprojectFromWVP(farSource, projectionMatrix, viewMatrix, world, farPoint);
             var outDire = out.direction;
             outDire.x = farPoint.x - nearPoint.x;
             outDire.y = farPoint.y - nearPoint.y;
             outDire.z = farPoint.z - nearPoint.z;
             Vector3.normalize(out.direction, out.direction);
         }
         /**
          * 计算射线和三角形碰撞并返回碰撞距离。
          * @param	ray 射线。
          * @param	vertex1 顶点1。
          * @param	vertex2 顶点2。
          * @param	vertex3 顶点3。
          * @return   射线距离三角形的距离，返回Number.NaN则不相交。
          */
         static rayIntersectsTriangle(ray, vertex1, vertex2, vertex3) {
             var result;
             // Compute vectors along two edges of the triangle.
             var edge1 = Picker._tempVector30, edge2 = Picker._tempVector31;
             Vector3.subtract(vertex2, vertex1, edge1);
             Vector3.subtract(vertex3, vertex1, edge2);
             // Compute the determinant.
             var directionCrossEdge2 = Picker._tempVector32;
             Vector3.cross(ray.direction, edge2, directionCrossEdge2);
             var determinant;
             determinant = Vector3.dot(edge1, directionCrossEdge2);
             // If the ray is parallel to the triangle plane, there is no collision.
             if (determinant > -Number.MIN_VALUE && determinant < Number.MIN_VALUE) {
                 result = Number.NaN;
                 return result;
             }
             var inverseDeterminant = 1.0 / determinant;
             // Calculate the U parameter of the intersection point.
             var distanceVector = Picker._tempVector33;
             Vector3.subtract(ray.origin, vertex1, distanceVector);
             var triangleU;
             triangleU = Vector3.dot(distanceVector, directionCrossEdge2);
             triangleU *= inverseDeterminant;
             // Make sure it is inside the triangle.
             if (triangleU < 0 || triangleU > 1) {
                 result = Number.NaN;
                 return result;
             }
             // Calculate the V parameter of the intersection point.
             var distanceCrossEdge1 = Picker._tempVector34;
             Vector3.cross(distanceVector, edge1, distanceCrossEdge1);
             var triangleV;
             triangleV = Vector3.dot(ray.direction, distanceCrossEdge1);
             triangleV *= inverseDeterminant;
             // Make sure it is inside the triangle.
             if (triangleV < 0 || triangleU + triangleV > 1) {
                 result = Number.NaN;
                 return result;
             }
             // Compute the distance along the ray to the triangle.
             var rayDistance;
             rayDistance = Vector3.dot(edge2, distanceCrossEdge1);
             rayDistance *= inverseDeterminant;
             // Is the triangle behind the ray origin?
             if (rayDistance < 0) {
                 result = Number.NaN;
                 return result;
             }
             result = rayDistance;
             return result;
         }
     }
     Picker._tempVector30 = new Vector3();
     Picker._tempVector31 = new Vector3();
     Picker._tempVector32 = new Vector3();
     Picker._tempVector33 = new Vector3();
     Picker._tempVector34 = new Vector3();

     /**
      * @private
      * <code>BufferState</code> 类用于实现渲染所需的Buffer状态集合。
      */
     class BufferState extends BufferStateBase {
         /**
          * 创建一个 <code>BufferState</code> 实例。
          */
         constructor() {
             super();
         }
         /**
          * @private
          * vertexBuffer的vertexDeclaration不能为空,该函数比较消耗性能，建议初始化时使用。
          */
         applyVertexBuffer(vertexBuffer) {
             if (BufferStateBase._curBindedBufferState === this) {
                 var gl = LayaGL.instance;
                 var verDec = vertexBuffer.vertexDeclaration;
                 var valueData = null;
                 if (Render.supportWebGLPlusRendering)
                     valueData = verDec._shaderValues._nativeArray;
                 else
                     valueData = verDec._shaderValues.getData();
                 vertexBuffer.bind();
                 for (var k in valueData) {
                     var loc = parseInt(k);
                     var attribute = valueData[k];
                     gl.enableVertexAttribArray(loc);
                     gl.vertexAttribPointer(loc, attribute[0], attribute[1], !!attribute[2], attribute[3], attribute[4]);
                 }
             }
             else {
                 throw "BufferState: must call bind() function first.";
             }
         }
         /**
          * @private
          * vertexBuffers中的vertexDeclaration不能为空,该函数比较消耗性能，建议初始化时使用。
          */
         applyVertexBuffers(vertexBuffers) {
             if (BufferStateBase._curBindedBufferState === this) {
                 var gl = LayaGL.instance;
                 for (var i = 0, n = vertexBuffers.length; i < n; i++) {
                     var verBuf = vertexBuffers[i];
                     var verDec = verBuf.vertexDeclaration;
                     var valueData = null;
                     if (Render.supportWebGLPlusRendering)
                         valueData = verDec._shaderValues._nativeArray;
                     else
                         valueData = verDec._shaderValues.getData();
                     verBuf.bind();
                     for (var k in valueData) {
                         var loc = parseInt(k);
                         var attribute = valueData[k];
                         gl.enableVertexAttribArray(loc);
                         gl.vertexAttribPointer(loc, attribute[0], attribute[1], !!attribute[2], attribute[3], attribute[4]);
                     }
                 }
             }
             else {
                 throw "BufferState: must call bind() function first.";
             }
         }
         /**
          * @private
          */
         applyInstanceVertexBuffer(vertexBuffer) {
             if (LayaGL.layaGPUInstance.supportInstance()) { //判断是否支持Instance
                 if (BufferStateBase._curBindedBufferState === this) {
                     var gl = LayaGL.instance;
                     var verDec = vertexBuffer.vertexDeclaration;
                     var valueData = null;
                     if (Render.supportWebGLPlusRendering)
                         valueData = verDec._shaderValues._nativeArray;
                     else
                         valueData = verDec._shaderValues.getData();
                     vertexBuffer.bind();
                     for (var k in valueData) {
                         var loc = parseInt(k);
                         var attribute = valueData[k];
                         gl.enableVertexAttribArray(loc);
                         gl.vertexAttribPointer(loc, attribute[0], attribute[1], !!attribute[2], attribute[3], attribute[4]);
                         LayaGL.layaGPUInstance.vertexAttribDivisor(loc, 1);
                     }
                 }
                 else {
                     throw "BufferState: must call bind() function first.";
                 }
             }
         }
         /**
          * @private
          */
         applyIndexBuffer(indexBuffer) {
             if (BufferStateBase._curBindedBufferState === this) {
                 if (this._bindedIndexBuffer !== indexBuffer) {
                     indexBuffer._bindForVAO(); //TODO:可和vao合并bind
                     this._bindedIndexBuffer = indexBuffer;
                 }
             }
             else {
                 throw "BufferState: must call bind() function first.";
             }
         }
     }

     /**
      * <code>IndexBuffer3D</code> 类用于创建索引缓冲。
      */
     class IndexBuffer3D extends Buffer {
         /**
          * 创建一个 <code>IndexBuffer3D,不建议开发者使用并用IndexBuffer3D.create()代替</code> 实例。
          * @param	indexType 索引类型。
          * @param	indexCount 索引个数。
          * @param	bufferUsage IndexBuffer3D用途类型。
          * @param	canRead 是否可读。
          */
         constructor(indexType, indexCount, bufferUsage = 0x88E4 /*WebGLContext.STATIC_DRAW*/, canRead = false) {
             super();
             this._indexType = indexType;
             this._indexCount = indexCount;
             this._bufferUsage = bufferUsage;
             this._bufferType = WebGLContext.ELEMENT_ARRAY_BUFFER;
             this._canRead = canRead;
             var byteLength;
             if (indexType == IndexBuffer3D.INDEXTYPE_USHORT)
                 this._indexTypeByteCount = 2;
             else if (indexType == IndexBuffer3D.INDEXTYPE_UBYTE)
                 this._indexTypeByteCount = 1;
             else
                 throw new Error("unidentification index type.");
             byteLength = this._indexTypeByteCount * indexCount;
             this._byteLength = byteLength;
             var curBufSta = BufferStateBase._curBindedBufferState;
             if (curBufSta) {
                 if (curBufSta._bindedIndexBuffer === this) {
                     LayaGL.instance.bufferData(this._bufferType, byteLength, this._bufferUsage);
                 }
                 else {
                     curBufSta.unBind(); //避免影响VAO
                     this.bind();
                     LayaGL.instance.bufferData(this._bufferType, byteLength, this._bufferUsage);
                     curBufSta.bind();
                 }
             }
             else {
                 this.bind();
                 LayaGL.instance.bufferData(this._bufferType, byteLength, this._bufferUsage);
             }
             if (canRead) {
                 if (indexType == IndexBuffer3D.INDEXTYPE_USHORT)
                     this._buffer = new Uint16Array(indexCount);
                 else if (indexType == IndexBuffer3D.INDEXTYPE_UBYTE)
                     this._buffer = new Uint8Array(indexCount);
             }
         }
         /**
          * 获取索引类型。
          *   @return	索引类型。
          */
         get indexType() {
             return this._indexType;
         }
         /**
          * 获取索引类型字节数量。
          *   @return	索引类型字节数量。
          */
         get indexTypeByteCount() {
             return this._indexTypeByteCount;
         }
         /**
          * 获取索引个数。
          *   @return	索引个数。
          */
         get indexCount() {
             return this._indexCount;
         }
         /**
          * 获取是否可读。
          *   @return	是否可读。
          */
         get canRead() {
             return this._canRead;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _bindForVAO() {
             if (BufferStateBase._curBindedBufferState) {
                 LayaGL.instance.bindBuffer(WebGLContext.ELEMENT_ARRAY_BUFFER, this._glBuffer);
             }
             else {
                 throw "IndexBuffer3D: must bind current BufferState.";
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ bind() {
             if (BufferStateBase._curBindedBufferState) {
                 throw "IndexBuffer3D: must unbind current BufferState.";
             }
             else {
                 if (Buffer._bindedIndexBuffer !== this._glBuffer) {
                     LayaGL.instance.bindBuffer(WebGLContext.ELEMENT_ARRAY_BUFFER, this._glBuffer);
                     Buffer._bindedIndexBuffer = this._glBuffer;
                     return true;
                 }
                 else {
                     return false;
                 }
             }
         }
         /**
          * 设置数据。
          * @param	data 索引数据。
          * @param	bufferOffset 索引缓冲中的偏移。
          * @param	dataStartIndex 索引数据的偏移。
          * @param	dataCount 索引数据的数量。
          */
         setData(data, bufferOffset = 0, dataStartIndex = 0, dataCount = 4294967295 /*uint.MAX_VALUE*/) {
             var byteCount;
             if (this._indexType == IndexBuffer3D.INDEXTYPE_USHORT) {
                 byteCount = 2;
                 if (dataStartIndex !== 0 || dataCount !== 4294967295 /*uint.MAX_VALUE*/)
                     data = new Uint16Array(data.buffer, dataStartIndex * byteCount, dataCount);
             }
             else if (this._indexType == IndexBuffer3D.INDEXTYPE_UBYTE) {
                 byteCount = 1;
                 if (dataStartIndex !== 0 || dataCount !== 4294967295 /*uint.MAX_VALUE*/)
                     data = new Uint8Array(data.buffer, dataStartIndex * byteCount, dataCount);
             }
             var curBufSta = BufferStateBase._curBindedBufferState;
             if (curBufSta) {
                 if (curBufSta._bindedIndexBuffer === this) {
                     LayaGL.instance.bufferSubData(this._bufferType, bufferOffset * byteCount, data); //offset==0情况下，某些特殊设备或情况下直接bufferData速度是否优于bufferSubData
                 }
                 else {
                     curBufSta.unBind(); //避免影响VAO
                     this.bind();
                     LayaGL.instance.bufferSubData(this._bufferType, bufferOffset * byteCount, data);
                     curBufSta.bind();
                 }
             }
             else {
                 this.bind();
                 LayaGL.instance.bufferSubData(this._bufferType, bufferOffset * byteCount, data);
             }
             if (this._canRead) {
                 if (bufferOffset !== 0 || dataStartIndex !== 0 || dataCount !== 4294967295 /*uint.MAX_VALUE*/) {
                     var maxLength = this._buffer.length - bufferOffset;
                     if (dataCount > maxLength)
                         dataCount = maxLength;
                     for (var i = 0; i < dataCount; i++)
                         this._buffer[bufferOffset + i] = data[i];
                 }
                 else {
                     this._buffer = data;
                 }
             }
         }
         /**
          * 获取索引数据。
          *   @return	索引数据。
          */
         getData() {
             if (this._canRead)
                 return this._buffer;
             else
                 throw new Error("Can't read data from VertexBuffer with only write flag!");
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy() {
             super.destroy();
             this._buffer = null;
         }
     }
     /** 8位ubyte无符号索引类型。*/
     IndexBuffer3D.INDEXTYPE_UBYTE = "ubyte";
     /** 16位ushort无符号索引类型。*/
     IndexBuffer3D.INDEXTYPE_USHORT = "ushort";

     /**
      * ...
      * @author ...
      */
     class VertexElementFormat {
         /**
          * 获取顶点元素格式信息。
          */
         static getElementInfos(element) {
             var info = VertexElementFormat._elementInfos[element];
             if (info)
                 return info;
             else
                 throw "VertexElementFormat: this vertexElementFormat is not implement.";
         }
     }
     VertexElementFormat.Single = "single";
     VertexElementFormat.Vector2 = "vector2";
     VertexElementFormat.Vector3 = "vector3";
     VertexElementFormat.Vector4 = "vector4";
     VertexElementFormat.Color = "color";
     VertexElementFormat.Byte4 = "byte4";
     VertexElementFormat.Short2 = "short2";
     VertexElementFormat.Short4 = "short4";
     VertexElementFormat.NormalizedShort2 = "normalizedshort2";
     VertexElementFormat.NormalizedShort4 = "normalizedshort4";
     VertexElementFormat.HalfVector2 = "halfvector2";
     VertexElementFormat.HalfVector4 = "halfvector4";
     /** @private [组数量,数据类型,是否归一化:0为false]。*/
     VertexElementFormat._elementInfos = {
         "single": [1, WebGLContext.FLOAT, 0],
         "vector2": [2, WebGLContext.FLOAT, 0],
         "vector3": [3, WebGLContext.FLOAT, 0],
         "vector4": [4, WebGLContext.FLOAT, 0],
         "color": [4, WebGLContext.FLOAT, 0],
         "byte4": [4, WebGLContext.UNSIGNED_BYTE, 0],
         "short2": [2, WebGLContext.FLOAT, 0],
         "short4": [4, WebGLContext.FLOAT, 0],
         "normalizedshort2": [2, WebGLContext.FLOAT, 0],
         "normalizedshort4": [4, WebGLContext.FLOAT, 0],
         "halfvector2": [2, WebGLContext.FLOAT, 0],
         "halfvector4": [4, WebGLContext.FLOAT, 0]
     };

     /**
      * @private
      * <code>VertexDeclaration</code> 类用于生成顶点声明。
      */
     class VertexDeclaration {
         /**
          * 创建一个 <code>VertexDeclaration</code> 实例。
          * @param	vertexStride 顶点跨度。
          * @param	vertexElements 顶点元素集合。
          */
         constructor(vertexStride, vertexElements) {
             this._id = ++VertexDeclaration._uniqueIDCounter;
             this._vertexElementsDic = {};
             this._vertexStride = vertexStride;
             this.vertexElements = vertexElements;
             var count = vertexElements.length;
             this._shaderValues = new ShaderData(null);
             for (var j = 0; j < count; j++) {
                 var vertexElement = vertexElements[j];
                 var name = vertexElement.elementUsage;
                 this._vertexElementsDic[name] = vertexElement;
                 var value = new Int32Array(5);
                 var elmentInfo = VertexElementFormat.getElementInfos(vertexElement.elementFormat);
                 value[0] = elmentInfo[0];
                 value[1] = elmentInfo[1];
                 value[2] = elmentInfo[2];
                 value[3] = this._vertexStride;
                 value[4] = vertexElement.offset;
                 this._shaderValues.setAttribute(name, value);
             }
         }
         /**
          * 获取唯一标识ID(通常用于优化或识别)。
          * @return 唯一标识ID
          */
         get id() {
             return this._id;
         }
         /**
          * @private
          */
         get vertexStride() {
             return this._vertexStride;
         }
         /**
          * @private
          */
         getVertexElementByUsage(usage) {
             return this._vertexElementsDic[usage];
         }
         /**
          * @private
          */
         unBinding() {
         }
     }
     /**@private */
     VertexDeclaration._uniqueIDCounter = 1;

     /**
          * <code>VertexElement</code> 类用于创建顶点结构分配。
          */
     class VertexElement {
         //public var usageIndex:int;//TODO:待确定是否添加
         constructor(offset, elementFormat, elementUsage) {
             this.offset = offset;
             this.elementFormat = elementFormat;
             this.elementUsage = elementUsage;
             //this.usageIndex = usageIndex;
         }
     }

     /**
      * ...
      * @author ...
      */
     class VertexMesh {
         /**
          * 获取顶点声明。
          * @param vertexFlag 顶点声明标记字符,格式为:"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT"。
          * @return 顶点声明。
          */
         static getVertexDeclaration(vertexFlag, compatible = true) {
             var verDec = VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")]; //TODO:兼容模式
             if (!verDec) {
                 var subFlags = vertexFlag.split(",");
                 var offset = 0;
                 var elements = [];
                 for (var i = 0, n = subFlags.length; i < n; i++) {
                     var element;
                     switch (subFlags[i]) {
                         case "POSITION":
                             element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0);
                             offset += 12;
                             break;
                         case "NORMAL":
                             element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_NORMAL0);
                             offset += 12;
                             break;
                         case "COLOR":
                             element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0);
                             offset += 16;
                             break;
                         case "UV":
                             element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0);
                             offset += 8;
                             break;
                         case "UV1":
                             element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE1);
                             offset += 8;
                             break;
                         case "BLENDWEIGHT":
                             element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDWEIGHT0);
                             offset += 16;
                             break;
                         case "BLENDINDICES":
                             if (compatible) {
                                 element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDINDICES0); //兼容
                                 offset += 16;
                             }
                             else {
                                 element = new VertexElement(offset, VertexElementFormat.Byte4, VertexMesh.MESH_BLENDINDICES0);
                                 offset += 4;
                             }
                             break;
                         case "TANGENT":
                             element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_TANGENT0);
                             offset += 16;
                             break;
                         default:
                             throw "VertexMesh: unknown vertex flag.";
                     }
                     elements.push(element);
                 }
                 verDec = new VertexDeclaration(offset, elements);
                 VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")] = verDec; //TODO:兼容模式
             }
             return verDec;
         }
     }
     VertexMesh.MESH_POSITION0 = 0;
     VertexMesh.MESH_COLOR0 = 1;
     VertexMesh.MESH_TEXTURECOORDINATE0 = 2;
     VertexMesh.MESH_NORMAL0 = 3;
     VertexMesh.MESH_TANGENT0 = 4;
     VertexMesh.MESH_BLENDINDICES0 = 5;
     VertexMesh.MESH_BLENDWEIGHT0 = 6;
     VertexMesh.MESH_TEXTURECOORDINATE1 = 7;
     VertexMesh.MESH_WORLDMATRIX_ROW0 = 8;
     VertexMesh.MESH_WORLDMATRIX_ROW1 = 9;
     VertexMesh.MESH_WORLDMATRIX_ROW2 = 10;
     VertexMesh.MESH_WORLDMATRIX_ROW3 = 11;
     VertexMesh.MESH_MVPMATRIX_ROW0 = 12;
     VertexMesh.MESH_MVPMATRIX_ROW1 = 13;
     VertexMesh.MESH_MVPMATRIX_ROW2 = 14;
     VertexMesh.MESH_MVPMATRIX_ROW3 = 15;
     VertexMesh.instanceWorldMatrixDeclaration = new VertexDeclaration(64, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW0),
         new VertexElement(16, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW1),
         new VertexElement(32, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW2),
         new VertexElement(48, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW3)]);
     VertexMesh.instanceMVPMatrixDeclaration = new VertexDeclaration(64, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_MVPMATRIX_ROW0),
         new VertexElement(16, VertexElementFormat.Vector4, VertexMesh.MESH_MVPMATRIX_ROW1),
         new VertexElement(32, VertexElementFormat.Vector4, VertexMesh.MESH_MVPMATRIX_ROW2),
         new VertexElement(48, VertexElementFormat.Vector4, VertexMesh.MESH_MVPMATRIX_ROW3)]);
     /**@private */
     VertexMesh._vertexDeclarationMap = {};

     /**
      * <code>VertexBuffer3D</code> 类用于创建顶点缓冲。
      */
     class VertexBuffer3D extends Buffer {
         /**
          * 创建一个 <code>VertexBuffer3D,不建议开发者使用并用VertexBuffer3D.create()代替</code> 实例。
          * @param	vertexCount 顶点个数。
          * @param	bufferUsage VertexBuffer3D用途类型。
          * @param	canRead 是否可读。
          * @param   dateType 数据类型。
          */
         constructor(byteLength, bufferUsage, canRead = false, dateType = VertexBuffer3D.DATATYPE_FLOAT32ARRAY) {
             super();
             this._vertexCount = -1;
             this._bufferUsage = bufferUsage;
             this._bufferType = WebGLContext.ARRAY_BUFFER;
             this._canRead = canRead;
             this._dataType = dateType;
             this._byteLength = byteLength;
             this.bind();
             LayaGL.instance.bufferData(this._bufferType, this._byteLength, this._bufferUsage);
             if (canRead) {
                 switch (dateType) {
                     case VertexBuffer3D.DATATYPE_FLOAT32ARRAY:
                         this._buffer = new Float32Array(byteLength / 4);
                         break;
                     case VertexBuffer3D.DATATYPE_UINT8ARRAY:
                         this._buffer = new Uint8Array(byteLength);
                         break;
                 }
             }
         }
         /**
          * 获取顶点声明。
          */
         get vertexDeclaration() {
             return this._vertexDeclaration;
         }
         /**
          * 获取顶点声明。
          */
         set vertexDeclaration(value) {
             if (this._vertexDeclaration !== value) {
                 this._vertexDeclaration = value;
                 this._vertexCount = value ? this._byteLength / value.vertexStride : -1;
             }
         }
         /**
          * 获取顶点个数。
          *   @return	顶点个数。
          */
         get vertexCount() {
             return this._vertexCount;
         }
         /**
          * 获取是否可读。
          *   @return	是否可读。
          */
         get canRead() {
             return this._canRead;
         }
         /**
          * @inheritDoc
          */
         /*override*/ bind() {
             if (Buffer._bindedVertexBuffer !== this._glBuffer) {
                 LayaGL.instance.bindBuffer(WebGLContext.ARRAY_BUFFER, this._glBuffer);
                 Buffer._bindedVertexBuffer = this._glBuffer;
                 return true;
             }
             else {
                 return false;
             }
         }
         /**
          * 设置数据。
          * @param	data 顶点数据。
          * @param	bufferOffset 顶点缓冲中的偏移。
          * @param	dataStartIndex 顶点数据的偏移。
          * @param	dataCount 顶点数据的数量。
          */
         setData(data, bufferOffset = 0, dataStartIndex = 0, dataCount = 4294967295 /*uint.MAX_VALUE*/) {
             this.bind();
             var needSubData = dataStartIndex !== 0 || dataCount !== 4294967295 /*uint.MAX_VALUE*/;
             if (needSubData) {
                 switch (this._dataType) {
                     case VertexBuffer3D.DATATYPE_FLOAT32ARRAY:
                         data = new Float32Array(data.buffer, dataStartIndex * 4, dataCount);
                         break;
                     case VertexBuffer3D.DATATYPE_UINT8ARRAY:
                         data = new Uint8Array(data.buffer, dataStartIndex, dataCount);
                         break;
                 }
             }
             switch (this._dataType) {
                 case VertexBuffer3D.DATATYPE_FLOAT32ARRAY:
                     LayaGL.instance.bufferSubData(this._bufferType, bufferOffset * 4, data);
                     break;
                 case VertexBuffer3D.DATATYPE_UINT8ARRAY:
                     LayaGL.instance.bufferSubData(this._bufferType, bufferOffset, data);
                     break;
             }
             if (this._canRead)
                 this._buffer.set(data, bufferOffset);
         }
         /**
          * 获取顶点数据。
          * @return	顶点数据。
          */
         getData() {
             if (this._canRead)
                 return this._buffer;
             else
                 throw new Error("Can't read data from VertexBuffer with only write flag!");
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy() {
             super.destroy();
             this._buffer = null;
             this._vertexDeclaration = null;
         }
     }
     /**数据类型_Float32Array类型。*/
     VertexBuffer3D.DATATYPE_FLOAT32ARRAY = 0;
     /**数据类型_Uint8Array类型。*/
     VertexBuffer3D.DATATYPE_UINT8ARRAY = 1;

     /**
      * <code>SkyMesh</code> 类用于实现天空网格。
      */
     class SkyMesh {
         /**
          * 创建一个新的 <code>SkyMesh</code> 实例。
          */
         constructor() {
         }
         /**
          * @private
          */
         _render(state) {
         }
     }

     /**
      * <code>SkyBox</code> 类用于创建天空盒。
      */
     class SkyBox extends SkyMesh {
         /**
          * @private
          */
         static __init__() {
             SkyBox.instance = new SkyBox(); //TODO:移植为标准Mesh后需要加锁
         }
         /**
          * 创建一个 <code>SkyBox</code> 实例。
          */
         constructor() {
             super();
             var halfHeight = 0.5;
             var halfWidth = 0.5;
             var halfDepth = 0.5;
             var vertices = new Float32Array([-halfDepth, halfHeight, -halfWidth, halfDepth, halfHeight, -halfWidth, halfDepth, halfHeight, halfWidth, -halfDepth, halfHeight, halfWidth,
                 -halfDepth, -halfHeight, -halfWidth, halfDepth, -halfHeight, -halfWidth, halfDepth, -halfHeight, halfWidth, -halfDepth, -halfHeight, halfWidth]); //下
             var indices = new Uint8Array([
                 0, 1, 2, 2, 3, 0,
                 4, 7, 6, 6, 5, 4,
                 0, 3, 7, 7, 4, 0,
                 1, 5, 6, 6, 2, 1,
                 3, 2, 6, 6, 7, 3,
                 0, 4, 5, 5, 1, 0
             ]); //后
             var verDec = VertexMesh.getVertexDeclaration("POSITION");
             this._vertexBuffer = new VertexBuffer3D(verDec.vertexStride * 8, WebGLContext.STATIC_DRAW, false);
             this._vertexBuffer.vertexDeclaration = verDec;
             this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_UBYTE, 36, WebGLContext.STATIC_DRAW, false);
             this._vertexBuffer.setData(vertices);
             this._indexBuffer.setData(indices);
             var bufferState = new BufferState();
             bufferState.bind();
             bufferState.applyVertexBuffer(this._vertexBuffer);
             bufferState.applyIndexBuffer(this._indexBuffer);
             bufferState.unBind();
             this._bufferState = bufferState;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _render(state) {
             LayaGL.instance.drawElements(WebGLContext.TRIANGLES, 36, WebGLContext.UNSIGNED_BYTE, 0);
             Stat.trianglesFaces += 12;
             Stat.renderBatches++;
         }
     }

     /**
      * <code>SkyRenderer</code> 类用于实现天空渲染器。
      */
     class SkyRenderer {
         /**
          * 创建一个新的 <code>SkyRenderer</code> 实例。
          */
         constructor() {
             /** @private */
             this._mesh = SkyBox.instance;
         }
         /**
          * 获取材质。
          * @return 材质。
          */
         get material() {
             return this._material;
         }
         /**
          * 设置材质。
          * @param 材质。
          */
         set material(value) {
             if (this._material !== value) {
                 (this._material) && (this._material._removeReference());
                 (value) && (value._addReference());
                 this._material = value;
             }
         }
         /**
          * 获取网格。
          * @return 网格。
          */
         get mesh() {
             return this._mesh;
         }
         /**
          * 设置网格。
          * @param 网格。
          */
         set mesh(value) {
             if (this._mesh !== value) {
                 //(_mesh) && (_mesh._removeReference());//TODO:SkyMesh换成Mesh
                 //value._addReference();
                 this._mesh = value;
             }
         }
         /**
          * @private
          * 是否可用。
          */
         _isAvailable() {
             return this._material && this._mesh ? true : false;
         }
         /**
          * @private
          */
         _render(state) {
             if (this._material && this._mesh) {
                 var gl = LayaGL.instance;
                 var scene = state.scene;
                 var camera = state.camera;
                 WebGLContext.setCullFace(gl, false);
                 WebGLContext.setDepthFunc(gl, WebGLContext.LEQUAL);
                 WebGLContext.setDepthMask(gl, false);
                 var shader = state.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(0, 0, this._material._shaderValues._defineDatas.value); //TODO:调整SubShader代码
                 var switchShader = shader.bind(); //纹理需要切换shader时重新绑定 其他uniform不需要
                 var switchShaderLoop = (Stat.loopCount !== shader._uploadMark);
                 var uploadScene = (shader._uploadScene !== scene) || switchShaderLoop;
                 if (uploadScene || switchShader) {
                     shader.uploadUniforms(shader._sceneUniformParamsMap, scene._shaderValues, uploadScene);
                     shader._uploadScene = scene;
                 }
                 var uploadCamera = (shader._uploadCamera !== camera) || switchShaderLoop;
                 if (uploadCamera || switchShader) {
                     shader.uploadUniforms(shader._cameraUniformParamsMap, camera._shaderValues, uploadCamera);
                     shader._uploadCamera = camera;
                 }
                 var uploadMaterial = (shader._uploadMaterial !== this._material) || switchShaderLoop;
                 if (uploadMaterial || switchShader) {
                     shader.uploadUniforms(shader._materialUniformParamsMap, this._material._shaderValues, uploadMaterial);
                     shader._uploadMaterial = this._material;
                 }
                 this._mesh._bufferState.bind();
                 this._mesh._render(state);
                 WebGLContext.setDepthFunc(gl, WebGLContext.LESS);
                 WebGLContext.setDepthMask(gl, true);
             }
         }
         /**
          * @private
          */
         destroy() {
             if (this._material) {
                 this._material._removeReference();
                 this._material = null;
             }
         }
     }

     /**
      * <code>BaseCamera</code> 类用于创建摄像机的父类。
      */
     class BaseCamera extends Sprite3D {
         /**
          * 创建一个 <code>BaseCamera</code> 实例。
          * @param	fieldOfView 视野。
          * @param	nearPlane 近裁面。
          * @param	farPlane 远裁面。
          */
         constructor(nearPlane = 0.3, farPlane = 1000) {
             super();
             /**@private */
             this._skyRenderer = new SkyRenderer();
             /**@private */
             this._forward = new Vector3();
             /**@private */
             this._up = new Vector3();
             /**摄像机的清除颜色,默认颜色为CornflowerBlue。*/
             this.clearColor = new Vector4(100 / 255, 149 / 255, 237 / 255, 255 / 255);
             this._shaderValues = new ShaderData(null);
             this._fieldOfView = 60;
             this._useUserProjectionMatrix = false;
             this._orthographic = false;
             this._orthographicVerticalSize = 10;
             this.renderingOrder = 0;
             this._nearPlane = nearPlane;
             this._farPlane = farPlane;
             this.cullingMask = 2147483647 /*int.MAX_VALUE*/;
             this.clearFlag = BaseCamera.CLEARFLAG_SOLIDCOLOR;
             this.useOcclusionCulling = true;
         }
         /**
          * 获取天空渲染器。
          * @return 天空渲染器。
          */
         get skyRenderer() {
             return this._skyRenderer;
         }
         /**
          * 获取视野。
          * @return 视野。
          */
         get fieldOfView() {
             return this._fieldOfView;
         }
         /**
          * 设置视野。
          * @param value 视野。
          */
         set fieldOfView(value) {
             this._fieldOfView = value;
             this._calculateProjectionMatrix();
         }
         /**
          * 获取近裁面。
          * @return 近裁面。
          */
         get nearPlane() {
             return this._nearPlane;
         }
         /**
          * 设置近裁面。
          * @param value 近裁面。
          */
         set nearPlane(value) {
             this._nearPlane = value;
             this._calculateProjectionMatrix();
         }
         /**
          * 获取远裁面。
          * @return 远裁面。
          */
         get farPlane() {
             return this._farPlane;
         }
         /**
          * 设置远裁面。
          * @param value 远裁面。
          */
         set farPlane(vaule) {
             this._farPlane = vaule;
             this._calculateProjectionMatrix();
         }
         /**
          * 获取是否正交投影矩阵。
          * @return 是否正交投影矩阵。
          */
         get orthographic() {
             return this._orthographic;
         }
         /**
          * 设置是否正交投影矩阵。
          * @param 是否正交投影矩阵。
          */
         set orthographic(vaule) {
             this._orthographic = vaule;
             this._calculateProjectionMatrix();
         }
         /**
          * 获取正交投影垂直矩阵尺寸。
          * @return 正交投影垂直矩阵尺寸。
          */
         get orthographicVerticalSize() {
             return this._orthographicVerticalSize;
         }
         /**
          * 设置正交投影垂直矩阵尺寸。
          * @param 正交投影垂直矩阵尺寸。
          */
         set orthographicVerticalSize(vaule) {
             this._orthographicVerticalSize = vaule;
             this._calculateProjectionMatrix();
         }
         get renderingOrder() {
             return this._renderingOrder;
         }
         set renderingOrder(value) {
             this._renderingOrder = value;
             this._sortCamerasByRenderingOrder();
         }
         /**
          * 通过RenderingOrder属性对摄像机机型排序。
          */
         _sortCamerasByRenderingOrder() {
             if (this.displayedInStage) {
                 var cameraPool = this.scene._cameraPool; //TODO:可优化，从队列中移除再加入
                 var n = cameraPool.length - 1;
                 for (var i = 0; i < n; i++) {
                     if (cameraPool[i].renderingOrder > cameraPool[n].renderingOrder) {
                         var tempCamera = cameraPool[i];
                         cameraPool[i] = cameraPool[n];
                         cameraPool[n] = tempCamera;
                     }
                 }
             }
         }
         /**
          * @private
          */
         _calculateProjectionMatrix() {
         }
         /**
          * @private
          */
         _onScreenSizeChanged() {
             this._calculateProjectionMatrix();
         }
         /**
          * @private
          */
         _prepareCameraToRender() {
             this.transform.getForward(this._forward);
             this.transform.getUp(this._up);
             var cameraSV = this._shaderValues;
             cameraSV.setVector3(BaseCamera.CAMERAPOS, this.transform.position);
             cameraSV.setVector3(BaseCamera.CAMERADIRECTION, this._forward);
             cameraSV.setVector3(BaseCamera.CAMERAUP, this._up);
         }
         /**
          * @private
          */
         _prepareCameraViewProject(vieMat, proMat, viewProject, vieProNoTraSca) {
             var shaderData = this._shaderValues;
             shaderData.setMatrix4x4(BaseCamera.VIEWMATRIX, vieMat);
             shaderData.setMatrix4x4(BaseCamera.PROJECTMATRIX, proMat);
             shaderData.setMatrix4x4(BaseCamera.VIEWPROJECTMATRIX, viewProject);
             this.transform.worldMatrix.cloneTo(BaseCamera._tempMatrix4x40); //视图矩阵逆矩阵的转置矩阵，移除平移和缩放
             BaseCamera._tempMatrix4x40.transpose();
             Matrix4x4.multiply(proMat, BaseCamera._tempMatrix4x40, vieProNoTraSca);
             shaderData.setMatrix4x4(BaseCamera.VPMATRIX_NO_TRANSLATE, vieProNoTraSca);
         }
         /**
          * 相机渲染。
          * @param	shader 着色器。
          * @param   replacementTag 着色器替换标记。
          */
         render(shader = null, replacementTag = null) {
         }
         /**
          * 增加可视图层,layer值为0到31层。
          * @param layer 图层。
          */
         addLayer(layer) {
             this.cullingMask |= Math.pow(2, layer);
         }
         /**
          * 移除可视图层,layer值为0到31层。
          * @param layer 图层。
          */
         removeLayer(layer) {
             this.cullingMask &= ~Math.pow(2, layer);
         }
         /**
          * 增加所有图层。
          */
         addAllLayers() {
             this.cullingMask = 2147483647 /*int.MAX_VALUE*/;
         }
         /**
          * 移除所有图层。
          */
         removeAllLayers() {
             this.cullingMask = 0;
         }
         resetProjectionMatrix() {
             this._useUserProjectionMatrix = false;
             this._calculateProjectionMatrix();
         }
         //public void BoundingFrustumViewSpace(Vector3[] cornersViewSpace)
         //{
         //if (cornersViewSpace.Length != 4)
         //throw new ArgumentOutOfRangeException("cornersViewSpace");
         //boundingFrustum.Matrix = ViewMatrix * ProjectionMatrix;
         //boundingFrustum.GetCorners(cornersWorldSpace);
         //// Transform form world space to view space
         //for (int i = 0; i < 4; i++)
         //{
         //cornersViewSpace[i] = Vector3.Transform(cornersWorldSpace[i + 4], ViewMatrix);
         //}
         //
         //// Swap the last 2 values.
         //Vector3 temp = cornersViewSpace[3];
         //cornersViewSpace[3] = cornersViewSpace[2];
         //cornersViewSpace[2] = temp;
         //} // BoundingFrustumViewSpace
         //public void BoundingFrustumWorldSpace(Vector3[] cornersWorldSpaceResult)
         //{
         //if (cornersWorldSpaceResult.Length != 4)
         //throw new ArgumentOutOfRangeException("cornersViewSpace");
         //boundingFrustum.Matrix = ViewMatrix * ProjectionMatrix;
         //boundingFrustum.GetCorners(cornersWorldSpace);
         //// Transform form world space to view space
         //for (int i = 0; i < 4; i++)
         //{
         //cornersWorldSpaceResult[i] = cornersWorldSpace[i + 4];
         //}
         //
         //// Swap the last 2 values.
         //Vector3 temp = cornersWorldSpaceResult[3];
         //cornersWorldSpaceResult[3] = cornersWorldSpaceResult[2];
         //cornersWorldSpaceResult[2] = temp;
         //} // BoundingFrustumWorldSpace
         /**
          * @inheritDoc
          */
         /*override*/ _onActive() {
             this._scene._addCamera(this);
             super._onActive();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onInActive() {
             this._scene._removeCamera(this);
             super._onInActive();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             super._parse(data, spriteMap);
             var clearFlagData = data.clearFlag;
             (clearFlagData !== undefined) && (this.clearFlag = clearFlagData);
             this.orthographic = data.orthographic;
             this.fieldOfView = data.fieldOfView;
             this.nearPlane = data.nearPlane;
             this.farPlane = data.farPlane;
             var color = data.clearColor;
             this.clearColor = new Vector4(color[0], color[1], color[2], color[3]);
             var skyboxMaterial = data.skyboxMaterial;
             if (skyboxMaterial) {
                 this._skyRenderer.material = Loader.getRes(skyboxMaterial.path);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy(destroyChild = true) {
             //postProcess = null;
             //AmbientLight = null;
             this._skyRenderer.destroy();
             this._skyRenderer = null;
             Laya.stage.off(Event.RESIZE, this, this._onScreenSizeChanged);
             super.destroy(destroyChild);
         }
         /**
          * @private
          */
         _create() {
             return new BaseCamera();
         }
     }
     /** @private */
     BaseCamera._tempMatrix4x40 = new Matrix4x4();
     BaseCamera.CAMERAPOS = Shader3D.propertyNameToID("u_CameraPos");
     BaseCamera.VIEWMATRIX = Shader3D.propertyNameToID("u_View");
     BaseCamera.PROJECTMATRIX = Shader3D.propertyNameToID("u_Projection");
     BaseCamera.VIEWPROJECTMATRIX = Shader3D.propertyNameToID("u_ViewProjection");
     BaseCamera.VPMATRIX_NO_TRANSLATE = Shader3D.propertyNameToID("u_MvpMatrix");
     BaseCamera.CAMERADIRECTION = Shader3D.propertyNameToID("u_CameraDirection");
     BaseCamera.CAMERAUP = Shader3D.propertyNameToID("u_CameraUp");
     /**渲染模式,延迟光照渲染，暂未开放。*/
     BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING";
     /**渲染模式,前向渲染。*/
     BaseCamera.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING";
     /**清除标记，固定颜色。*/
     BaseCamera.CLEARFLAG_SOLIDCOLOR = 0;
     /**清除标记，天空。*/
     BaseCamera.CLEARFLAG_SKY = 1;
     /**清除标记，仅深度。*/
     BaseCamera.CLEARFLAG_DEPTHONLY = 2;
     /**清除标记，不清除。*/
     BaseCamera.CLEARFLAG_NONE = 3;
     /** @private */
     BaseCamera._invertYScaleMatrix = new Matrix4x4(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); //Matrix4x4.createScaling(new Vector3(1, -1, 1), _invertYScaleMatrix);
     /** @private */
     BaseCamera._invertYProjectionMatrix = new Matrix4x4();
     /** @private */
     BaseCamera._invertYProjectionViewMatrix = new Matrix4x4();

     /**
      * <code>RenderContext3D</code> 类用于实现渲染状态。
      */
     class RenderContext3D {
         /**
          * 创建一个 <code>RenderContext3D</code> 实例。
          */
         constructor() {
         }
     }
     /** @private */
     RenderContext3D._instance = new RenderContext3D();

     /**
      * <code>ScreenQuad</code> 类用于创建全屏四边形。
      */
     class ScreenQuad extends Resource {
         /**
          * 创建一个 <code>ScreenQuad</code> 实例,禁止使用。
          */
         constructor() {
             super();
             /** @private */
             this._bufferState = new BufferState();
             /** @private */
             this._bufferStateInvertUV = new BufferState();
             this._vertexBuffer = new VertexBuffer3D(16 * 4, WebGLContext.STATIC_DRAW, false);
             this._vertexBuffer.vertexDeclaration = ScreenQuad._vertexDeclaration;
             this._vertexBuffer.setData(ScreenQuad._vertices);
             this._bufferState.bind();
             this._bufferState.applyVertexBuffer(this._vertexBuffer);
             this._bufferState.unBind();
             this._vertexBufferInvertUV = new VertexBuffer3D(16 * 4, WebGLContext.STATIC_DRAW, false);
             this._vertexBufferInvertUV.vertexDeclaration = ScreenQuad._vertexDeclaration;
             this._vertexBufferInvertUV.setData(ScreenQuad._verticesInvertUV);
             this._bufferStateInvertUV.bind();
             this._bufferStateInvertUV.applyVertexBuffer(this._vertexBufferInvertUV);
             this._bufferStateInvertUV.unBind();
             this._setGPUMemory(this._vertexBuffer._byteLength + this._vertexBufferInvertUV._byteLength);
         }
         /**
          * @private
          */
         static __init__() {
             ScreenQuad.instance = new ScreenQuad();
             ScreenQuad.instance.lock = true;
         }
         /**
          * @private
          */
         render() {
             this._bufferState.bind();
             LayaGL.instance.drawArrays(WebGLContext.TRIANGLE_STRIP, 0, 4);
             Stat.renderBatches++;
         }
         /**
          * @private
          */
         renderInvertUV() {
             this._bufferStateInvertUV.bind();
             LayaGL.instance.drawArrays(WebGLContext.TRIANGLE_STRIP, 0, 4);
             Stat.renderBatches++;
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy() {
             super.destroy();
             this._bufferState.destroy();
             this._vertexBuffer.destroy();
             this._bufferStateInvertUV.destroy();
             this._vertexBufferInvertUV.destroy();
             this._setGPUMemory(0);
         }
     }
     /** @private */
     ScreenQuad.SCREENQUAD_POSITION_UV = 0;
     /** @private */
     ScreenQuad._vertexDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, ScreenQuad.SCREENQUAD_POSITION_UV)]);
     /** @private */
     ScreenQuad._vertices = new Float32Array([1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1]);
     /** @private */
     ScreenQuad._verticesInvertUV = new Float32Array([1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0, 0]);

     /**
      * <code>ScreenTriangle</code> 类用于创建全屏三角形。
      */
     class ScreenTriangle extends Resource {
         /**
          * 创建一个 <code>ScreenTriangle</code> 实例,禁止使用。
          */
         constructor() {
             super();
             /** @private */
             this._bufferState = new BufferState();
             /** @private */
             this._bufferStateInvertUV = new BufferState();
             this._vertexBuffer = new VertexBuffer3D(12 * 4, WebGLContext.STATIC_DRAW, false);
             this._vertexBuffer.vertexDeclaration = ScreenTriangle._vertexDeclaration;
             this._vertexBuffer.setData(ScreenTriangle._vertices);
             this._bufferState.bind();
             this._bufferState.applyVertexBuffer(this._vertexBuffer);
             this._bufferState.unBind();
             this._vertexBufferInvertUV = new VertexBuffer3D(12 * 4, WebGLContext.STATIC_DRAW, false);
             this._vertexBufferInvertUV.vertexDeclaration = ScreenTriangle._vertexDeclaration;
             this._vertexBufferInvertUV.setData(ScreenTriangle._verticesInvertUV);
             this._bufferStateInvertUV.bind();
             this._bufferStateInvertUV.applyVertexBuffer(this._vertexBufferInvertUV);
             this._bufferStateInvertUV.unBind();
             this._setGPUMemory(this._vertexBuffer._byteLength + this._vertexBufferInvertUV._byteLength);
         }
         /**
          * @private
          */
         static __init__() {
             ScreenTriangle.instance = new ScreenTriangle();
             ScreenTriangle.instance.lock = true;
         }
         /**
          * @private
          */
         render() {
             this._bufferState.bind();
             LayaGL.instance.drawArrays(WebGLContext.TRIANGLES, 0, 3);
             Stat.renderBatches++;
         }
         /**
          * @private
          */
         renderInvertUV() {
             this._bufferStateInvertUV.bind();
             LayaGL.instance.drawArrays(WebGLContext.TRIANGLES, 0, 3);
             Stat.renderBatches++;
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy() {
             super.destroy();
             this._bufferState.destroy();
             this._vertexBuffer.destroy();
             this._bufferStateInvertUV.destroy();
             this._vertexBufferInvertUV.destroy();
             this._setGPUMemory(0);
         }
     }
     /** @private */
     ScreenTriangle.SCREENTRIANGLE_POSITION_UV = 0;
     /** @private */
     ScreenTriangle._vertexDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, ScreenTriangle.SCREENTRIANGLE_POSITION_UV)]);
     /** @private */
     ScreenTriangle._vertices = new Float32Array([-1, -1, 0, 1, -1, 3, 0, -1, 3, -1, 2, 1]);
     /** @private */
     ScreenTriangle._verticesInvertUV = new Float32Array([-1, -1, 0, 0, -1, 3, 0, 2, 3, -1, 2, 0]);

     /**
      * @private
      * <code>Command</code> 类用于创建指令。
      */
     class Command {
         /**
          * 创建一个 <code>Command</code> 实例。
          */
         constructor() {
             /**@private */
             this._commandBuffer = null;
         }
         /**
         * @private
         */
         static __init__() {
             Command._screenShaderData = new ShaderData();
             Command._screenShader = Shader3D.find("BlitScreen");
         }
         /**
          *@private
          */
         run() {
         }
         /**
          *@private
          */
         recover() {
             this._commandBuffer = null;
         }
     }
     /** @private */
     Command.SCREENTEXTURE_NAME = "u_MainTex"; //todo：
     /** @private */
     Command.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize"; //todo：
     /** @private */
     Command.SCREENTEXTURE_ID = Shader3D.propertyNameToID(Command.SCREENTEXTURE_NAME); //todo：
     /** @private */
     Command.MAINTEXTURE_TEXELSIZE_ID = Shader3D.propertyNameToID(Command.MAINTEXTURE_TEXELSIZE_NAME); //todo：

     /**
      * @private
      * <code>BlitCMD</code> 类用于创建从一张渲染目标输出到另外一张渲染目标指令。
      */
     class BlitScreenQuadCMD extends Command {
         constructor() {
             super(...arguments);
             /**@private */
             this._source = null;
             /**@private */
             this._dest = null;
             /**@private */
             this._shader = null;
             /**@private */
             this._shaderData = null;
             /**@private */
             this._subShader = 0;
             /**@private */
             this._sourceTexelSize = new Vector4();
             /**@private */
             this._screenType = 0;
         }
         /**
          * @private
          */
         static create(source, dest, shader = null, shaderData = null, subShader = 0, screenType = BlitScreenQuadCMD._SCREENTYPE_QUAD) {
             var cmd;
             cmd = BlitScreenQuadCMD._pool.length > 0 ? BlitScreenQuadCMD._pool.pop() : new BlitScreenQuadCMD();
             cmd._source = source;
             cmd._dest = dest;
             cmd._shader = shader;
             cmd._shaderData = shaderData;
             cmd._subShader = subShader;
             cmd._screenType = screenType;
             return cmd;
         }
         /**
          * @inheritDoc
          */
         /*override*/ run() {
             var shader = this._shader || Command._screenShader;
             var shaderData = this._shaderData || Command._screenShaderData;
             var dest = this._dest;
             LayaGL.instance.viewport(0, 0, dest ? dest.width : RenderContext3D.clientWidth, dest ? dest.height : RenderContext3D.clientHeight); //TODO:是否在此
             //TODO:优化
             shaderData.setTexture(Command.SCREENTEXTURE_ID, this._source);
             this._sourceTexelSize.setValue(1.0 / this._source.width, 1.0 / this._source.height, this._source.width, this._source.height);
             shaderData.setVector(Command.MAINTEXTURE_TEXELSIZE_ID, this._sourceTexelSize);
             (dest) && (dest._start());
             var subShader = shader.getSubShaderAt(this._subShader);
             var passes = subShader._passes;
             for (var i = 0, n = passes.length; i < n; i++) {
                 var shaderPass = passes[i].withCompile(0, 0, shaderData._defineDatas.value); //TODO:define处理
                 shaderPass.bind();
                 shaderPass.uploadUniforms(shaderPass._materialUniformParamsMap, shaderData, true); //TODO:最后一个参数处理
                 shaderPass.uploadRenderStateBlendDepth(shaderData);
                 shaderPass.uploadRenderStateFrontFace(shaderData, false, null); //TODO: //利用UV翻转,无需设置为true
                 switch (this._screenType) {
                     case BlitScreenQuadCMD._SCREENTYPE_QUAD:
                         dest ? ScreenQuad.instance.renderInvertUV() : ScreenQuad.instance.render();
                         break;
                     case BlitScreenQuadCMD._SCREENTYPE_TRIANGLE:
                         dest ? ScreenTriangle.instance.renderInvertUV() : ScreenTriangle.instance.render();
                         break;
                         throw "BlitScreenQuadCMD:unknown screen Type.";
                 }
             }
             (dest) && (dest._end());
         }
         /**
          * @inheritDoc
          */
         /*override*/ recover() {
             BlitScreenQuadCMD._pool.push(this);
             this._dest = null;
             this._shader = null;
             this._shaderData = null;
             super.recover();
         }
     }
     /**@private */
     BlitScreenQuadCMD._SCREENTYPE_QUAD = 0;
     /**@private */
     BlitScreenQuadCMD._SCREENTYPE_TRIANGLE = 1;
     /**@private */
     BlitScreenQuadCMD._pool = [];

     /**
      * @private
      * <code>SetRenderTargetCMD</code> 类用于创建设置渲染目标指令。
      */
     class SetRenderTargetCMD extends Command {
         constructor() {
             super(...arguments);
             /**@private */
             this._renderTexture = null;
         }
         /**
          * @private
          */
         static create(renderTexture) {
             var cmd;
             cmd = SetRenderTargetCMD._pool.length > 0 ? SetRenderTargetCMD._pool.pop() : new SetRenderTargetCMD();
             cmd._renderTexture = renderTexture;
             return cmd;
         }
         /**
          * @inheritDoc
          */
         /*override*/ run() {
             this._renderTexture._start();
         }
         /**
          * @inheritDoc
          */
         /*override*/ recover() {
             SetRenderTargetCMD._pool.push(this);
             this._renderTexture = null;
         }
     }
     /**@private */
     SetRenderTargetCMD._pool = [];

     /**
      * @private
      * <code>SetShaderDataTextureCMD</code> 类用于创建设置渲染目标指令。
      */
     class SetShaderDataTextureCMD extends Command {
         constructor() {
             super(...arguments);
             /**@private */
             this._shaderData = null;
             /**@private */
             this._nameID = 0;
             /**@private */
             this._texture = null;
         }
         /**
          * @private
          */
         static create(shaderData, nameID, texture) {
             var cmd;
             cmd = SetShaderDataTextureCMD._pool.length > 0 ? SetShaderDataTextureCMD._pool.pop() : new SetShaderDataTextureCMD();
             cmd._shaderData = shaderData;
             cmd._nameID = nameID;
             cmd._texture = texture;
             return cmd;
         }
         /**
          * @inheritDoc
          */
         /*override*/ run() {
             this._shaderData.setTexture(this._nameID, this._texture);
         }
         /**
          * @inheritDoc
          */
         /*override*/ recover() {
             SetShaderDataTextureCMD._pool.push(this);
             this._shaderData = null;
             this._nameID = 0;
             this._texture = null;
         }
     }
     /**@private */
     SetShaderDataTextureCMD._pool = [];

     /**
      * <code>CommandBuffer</code> 类用于创建命令流。
      */
     class CommandBuffer {
         /**
          * 创建一个 <code>CommandBuffer</code> 实例。
          */
         constructor() {
             /**@private */
             this._camera = null;
             /**@private */
             this._commands = [];
         }
         /**
          *@private
          */
         _apply() {
             for (var i = 0, n = this._commands.length; i < n; i++)
                 this._commands[i].run();
         }
         /**
          *@private
          */
         setShaderDataTexture(shaderData, nameID, source) {
             this._commands.push(SetShaderDataTextureCMD.create(shaderData, nameID, source));
         }
         /**
          * 添加一条通过全屏四边形将源纹理渲染到目标渲染纹理指令。
          * @param	source 源纹理。
          * @param	dest  目标纹理。
          * @param	shader 着色器,如果为null使用内部拷贝着色器,不做任何处理。
          * @param	shaderData 着色器数据,如果为null只接收sourceTexture。
          * @param	subShader subShader索引,默认值为0。
          */
         blitScreenQuad(source, dest, shader = null, shaderData = null, subShader = 0) {
             this._commands.push(BlitScreenQuadCMD.create(source, dest, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_QUAD));
         }
         /**
          * 添加一条通过全屏三角形将源纹理渲染到目标渲染纹理指令。
          * @param	source 源纹理。
          * @param	dest  目标纹理。
          * @param	shader 着色器,如果为null使用内部拷贝着色器,不做任何处理。
          * @param	shaderData 着色器数据,如果为null只接收sourceTexture。
          * @param	subShader subShader索引,默认值为0。
          */
         blitScreenTriangle(source, dest, shader = null, shaderData = null, subShader = 0) {
             this._commands.push(BlitScreenQuadCMD.create(source, dest, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_TRIANGLE));
         }
         /**
          *@private
          */
         setRenderTarget(renderTexture) {
             this._commands.push(SetRenderTargetCMD.create(renderTexture));
         }
         /**
          *@private
          */
         clear() {
             for (var i = 0, n = this._commands.length; i < n; i++)
                 this._commands[i].recover();
             this._commands.length = 0;
         }
     }

     class Scene3DShaderDeclaration {
     }

     /**
      * <code>Camera</code> 类用于创建摄像机。
      */
     class Camera extends BaseCamera {
         /**
          * 创建一个 <code>Camera</code> 实例。
          * @param	aspectRatio 横纵比。
          * @param	nearPlane 近裁面。
          * @param	farPlane 远裁面。
          */
         constructor(aspectRatio = 0, nearPlane = 0.3, farPlane = 1000) {
             super(nearPlane, farPlane);
             /** @private */
             this._updateViewMatrix = true;
             /** @private 渲染目标。*/
             this._offScreenRenderTexture = null;
             /**@private */
             this._postProcess = null;
             /**@private */
             this._enableHDR = false;
             /**@private */
             this._renderTexture = null;
             /** @private */
             this._postProcessCommandBuffers = [];
             /**是否允许渲染。*/
             this.enableRender = true;
             this._viewMatrix = new Matrix4x4();
             this._projectionMatrix = new Matrix4x4();
             this._projectionViewMatrix = new Matrix4x4();
             this._projectionViewMatrixNoTranslateScale = new Matrix4x4();
             this._viewport = new Viewport(0, 0, 0, 0);
             this._normalizedViewport = new Viewport(0, 0, 1, 1);
             this._aspectRatio = aspectRatio;
             this._boundFrustum = new BoundFrustum(Matrix4x4.DEFAULT);
             if (Render.supportWebGLPlusCulling)
                 this._boundFrustumBuffer = new Float32Array(24);
             this._calculateProjectionMatrix();
             Laya.stage.on(Event.RESIZE, this, this._onScreenSizeChanged);
             this.transform.on(Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
         }
         /**
          * 获取横纵比。
          * @return 横纵比。
          */
         get aspectRatio() {
             if (this._aspectRatio === 0) {
                 var vp = this.viewport;
                 return vp.width / vp.height;
             }
             return this._aspectRatio;
         }
         /**
          * 设置横纵比。
          * @param value 横纵比。
          */
         set aspectRatio(value) {
             if (value < 0)
                 throw new Error("Camera: the aspect ratio has to be a positive real number.");
             this._aspectRatio = value;
             this._calculateProjectionMatrix();
         }
         /**
          * 获取屏幕像素坐标的视口。
          * @return 屏幕像素坐标的视口。
          */
         get viewport() {
             if (this._offScreenRenderTexture)
                 this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height);
             else
                 this._calculationViewport(this._normalizedViewport, RenderContext3D.clientWidth, RenderContext3D.clientHeight); //屏幕尺寸会动态变化,需要重置
             return this._viewport;
         }
         /**
          * 设置屏幕像素坐标的视口。
          * @param 屏幕像素坐标的视口。
          */
         set viewport(value) {
             var width;
             var height;
             if (this._offScreenRenderTexture) {
                 width = this._offScreenRenderTexture.width;
                 height = this._offScreenRenderTexture.height;
             }
             else {
                 width = RenderContext3D.clientWidth;
                 height = RenderContext3D.clientHeight;
             }
             this._normalizedViewport.x = value.x / width;
             this._normalizedViewport.y = value.y / height;
             this._normalizedViewport.width = value.width / width;
             this._normalizedViewport.height = value.height / height;
             this._calculationViewport(this._normalizedViewport, width, height);
             this._calculateProjectionMatrix();
         }
         /**
          * 获取裁剪空间的视口。
          * @return 裁剪空间的视口。
          */
         get normalizedViewport() {
             return this._normalizedViewport;
         }
         /**
          * 设置裁剪空间的视口。
          * @return 裁剪空间的视口。
          */
         set normalizedViewport(value) {
             var width;
             var height;
             if (this._offScreenRenderTexture) {
                 width = this._offScreenRenderTexture.width;
                 height = this._offScreenRenderTexture.height;
             }
             else {
                 width = RenderContext3D.clientWidth;
                 height = RenderContext3D.clientHeight;
             }
             if (this._normalizedViewport !== value)
                 value.cloneTo(this._normalizedViewport);
             this._calculationViewport(value, width, height);
             this._calculateProjectionMatrix();
         }
         /**
          * 获取视图矩阵。
          * @return 视图矩阵。
          */
         get viewMatrix() {
             if (this._updateViewMatrix) {
                 var scale = this.transform.scale;
                 var scaleX = scale.x;
                 var scaleY = scale.y;
                 var scaleZ = scale.z;
                 var viewMatE = this._viewMatrix.elements;
                 this.transform.worldMatrix.cloneTo(this._viewMatrix);
                 viewMatE[0] /= scaleX; //忽略缩放
                 viewMatE[1] /= scaleX;
                 viewMatE[2] /= scaleX;
                 viewMatE[4] /= scaleY;
                 viewMatE[5] /= scaleY;
                 viewMatE[6] /= scaleY;
                 viewMatE[8] /= scaleZ;
                 viewMatE[9] /= scaleZ;
                 viewMatE[10] /= scaleZ;
                 this._viewMatrix.invert(this._viewMatrix);
                 this._updateViewMatrix = false;
             }
             return this._viewMatrix;
         }
         /**获取投影矩阵。*/
         get projectionMatrix() {
             return this._projectionMatrix;
         }
         /**设置投影矩阵。*/
         set projectionMatrix(value) {
             this._projectionMatrix = value;
             this._useUserProjectionMatrix = true;
         }
         /**
          * 获取视图投影矩阵。
          * @return 视图投影矩阵。
          */
         get projectionViewMatrix() {
             Matrix4x4.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix);
             return this._projectionViewMatrix;
         }
         /**
          * 获取摄像机视锥。
          */
         get boundFrustum() {
             this._boundFrustum.matrix = this.projectionViewMatrix;
             if (Render.supportWebGLPlusCulling) {
                 var near = this._boundFrustum.near;
                 var far = this._boundFrustum.far;
                 var left = this._boundFrustum.left;
                 var right = this._boundFrustum.right;
                 var top = this._boundFrustum.top;
                 var bottom = this._boundFrustum.bottom;
                 var nearNE = near.normal;
                 var farNE = far.normal;
                 var leftNE = left.normal;
                 var rightNE = right.normal;
                 var topNE = top.normal;
                 var bottomNE = bottom.normal;
                 var buffer = this._boundFrustumBuffer;
                 buffer[0] = nearNE.x, buffer[1] = nearNE.y, buffer[2] = nearNE.z, buffer[3] = near.distance;
                 buffer[4] = farNE.x, buffer[5] = farNE.y, buffer[6] = farNE.z, buffer[7] = far.distance;
                 buffer[8] = leftNE.x, buffer[9] = leftNE.y, buffer[10] = leftNE.z, buffer[11] = left.distance;
                 buffer[12] = rightNE.x, buffer[13] = rightNE.y, buffer[14] = rightNE.z, buffer[15] = right.distance;
                 buffer[16] = topNE.x, buffer[17] = topNE.y, buffer[18] = topNE.z, buffer[19] = top.distance;
                 buffer[20] = bottomNE.x, buffer[21] = bottomNE.y, buffer[22] = bottomNE.z, buffer[23] = bottom.distance;
             }
             return this._boundFrustum;
         }
         /**
          * 获取自定义渲染场景的渲染目标。
          * @return 自定义渲染场景的渲染目标。
          */
         get renderTarget() {
             return this._offScreenRenderTexture;
         }
         /**
          * 设置自定义渲染场景的渲染目标。
          * @param value 自定义渲染场景的渲染目标。
          */
         set renderTarget(value) {
             if (this._offScreenRenderTexture !== value) {
                 this._offScreenRenderTexture = value;
                 this._calculateProjectionMatrix();
             }
         }
         /**
          * 获取后期处理。
          * @return 后期处理。
          */
         get postProcess() {
             return this._postProcess;
         }
         /**
          * 设置后期处理。
          * @param value 后期处理。
          */
         set postProcess(value) {
             this._postProcess = value;
             var postProcessCommandBuffer = new CommandBuffer();
             this.addCommandBuffer(Camera.CAMERAEVENT_POSTPROCESS, postProcessCommandBuffer);
             value._init(this, postProcessCommandBuffer);
         }
         /**
          * 获取是否开启HDR。
          */
         get enableHDR() {
             return this._enableHDR;
         }
         /**
          * 设置是否开启HDR。
          */
         set enableHDR(value) {
             this._enableHDR = value;
         }
         /**
          *	通过蒙版值获取蒙版是否显示。
          * 	@param  layer 层。
          * 	@return 是否显示。
          */
         _isLayerVisible(layer) {
             return (Math.pow(2, layer) & this.cullingMask) != 0;
         }
         /**
          * @private
          */
         _onTransformChanged(flag) {
             flag &= Transform3D.TRANSFORM_WORLDMATRIX; //过滤有用TRANSFORM标记
             (flag) && (this._updateViewMatrix = true);
         }
         /**
          * @private
          */
         _calculationViewport(normalizedViewport, width, height) {
             var lx = normalizedViewport.x * width; //不应限制x范围
             var ly = normalizedViewport.y * height; //不应限制y范围
             var rx = lx + Math.max(normalizedViewport.width * width, 0);
             var ry = ly + Math.max(normalizedViewport.height * height, 0);
             var ceilLeftX = Math.ceil(lx);
             var ceilLeftY = Math.ceil(ly);
             var floorRightX = Math.floor(rx);
             var floorRightY = Math.floor(ry);
             var pixelLeftX = ceilLeftX - lx >= 0.5 ? Math.floor(lx) : ceilLeftX;
             var pixelLeftY = ceilLeftY - ly >= 0.5 ? Math.floor(ly) : ceilLeftY;
             var pixelRightX = rx - floorRightX >= 0.5 ? Math.ceil(rx) : floorRightX;
             var pixelRightY = ry - floorRightY >= 0.5 ? Math.ceil(ry) : floorRightY;
             this._viewport.x = pixelLeftX;
             this._viewport.y = pixelLeftY;
             this._viewport.width = pixelRightX - pixelLeftX;
             this._viewport.height = pixelRightY - pixelLeftY;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             super._parse(data, spriteMap);
             var viewport = data.viewport;
             this.normalizedViewport = new Viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
             var enableHDR = data.enableHDR;
             (enableHDR !== undefined) && (this.enableHDR = enableHDR);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _calculateProjectionMatrix() {
             if (!this._useUserProjectionMatrix) {
                 if (this._orthographic) {
                     var halfWidth = this.orthographicVerticalSize * this.aspectRatio * 0.5;
                     var halfHeight = this.orthographicVerticalSize * 0.5;
                     Matrix4x4.createOrthoOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, this.nearPlane, this.farPlane, this._projectionMatrix);
                 }
                 else {
                     Matrix4x4.createPerspective(3.1416 * this.fieldOfView / 180.0, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
                 }
             }
         }
         /**
          * @private
          */
         _getCanvasHeight() {
             if (this._offScreenRenderTexture)
                 return this._offScreenRenderTexture.height;
             else
                 return RenderContext3D.clientHeight;
         }
         /**
          * @private
          */
         _applyPostProcessCommandBuffers() {
             for (var i = 0, n = this._postProcessCommandBuffers.length; i < n; i++)
                 this._postProcessCommandBuffers[i]._apply();
         }
         /**
          * @private
          */
         _getRenderTextureFormat() {
             if (this._enableHDR)
                 return BaseTexture.RENDERTEXTURE_FORMAT_RGBA_HALF_FLOAT;
             else
                 return BaseTexture.FORMAT_R8G8B8;
         }
         /**
          * @inheritDoc
          */
         render(shader = null, replacementTag = null) {
             if (!this._scene) //自定义相机渲染需要加保护判断是否在场景中,否则报错
                 return;
             var createRenderTexture = this._postProcess || this._enableHDR ? true : false;
             if (createRenderTexture) //需要强制配置渲染纹理的条件
                 this._renderTexture = RenderTexture.createFromPool(RenderContext3D.clientWidth, RenderContext3D.clientHeight, this._getRenderTextureFormat(), BaseTexture.FORMAT_DEPTH_16, BaseTexture.FILTERMODE_BILINEAR);
             var gl = LayaGL.instance;
             var context = RenderContext3D._instance;
             var scene = context.scene = this._scene;
             if (scene.parallelSplitShadowMaps[0]) { //TODO:SM
                 ShaderData.setRuntimeValueMode(false);
                 var parallelSplitShadowMap = scene.parallelSplitShadowMaps[0];
                 parallelSplitShadowMap._calcAllLightCameraInfo(this);
                 scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_CAST_SHADOW); //增加宏定义
                 for (var i = 0, n = parallelSplitShadowMap.shadowMapCount; i < n; i++) {
                     var smCamera = parallelSplitShadowMap.cameras[i];
                     context.camera = smCamera;
                     context.projectionViewMatrix = smCamera.projectionViewMatrix; //TODO:重复计算浪费
                     FrustumCulling.renderObjectCulling(smCamera, scene, context, scene._castShadowRenders, shader, replacementTag);
                     var shadowMap = parallelSplitShadowMap.cameras[i + 1].renderTarget;
                     shadowMap._start();
                     context.camera = smCamera;
                     context.viewport = smCamera.viewport;
                     smCamera._prepareCameraToRender();
                     smCamera._prepareCameraViewProject(smCamera.viewMatrix, smCamera.projectionMatrix, context.projectionViewMatrix, smCamera._projectionViewMatrixNoTranslateScale);
                     scene._clear(gl, context);
                     var queue = scene._opaqueQueue; //阴影均为非透明队列
                     queue._render(context, false); //TODO:临时改为False
                     shadowMap._end();
                 }
                 scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_CAST_SHADOW); //去掉宏定义
                 ShaderData.setRuntimeValueMode(true);
             }
             context.camera = this;
             scene._preRenderScript(); //TODO:duo相机是否重复
             var viewMat, projectMat;
             viewMat = context.viewMatrix = this.viewMatrix;
             var renderTar = this._renderTexture || this._offScreenRenderTexture; //如果有临时renderTexture则画到临时renderTexture,最后再画到屏幕或者离屏画布,如果无临时renderTexture则直接画到屏幕或离屏画布
             if (renderTar) {
                 renderTar._start();
                 Matrix4x4.multiply(BaseCamera._invertYScaleMatrix, this._projectionMatrix, BaseCamera._invertYProjectionMatrix);
                 Matrix4x4.multiply(BaseCamera._invertYScaleMatrix, this.projectionViewMatrix, BaseCamera._invertYProjectionViewMatrix);
                 projectMat = context.projectionMatrix = BaseCamera._invertYProjectionMatrix; //TODO:
                 context.projectionViewMatrix = BaseCamera._invertYProjectionViewMatrix; //TODO:
             }
             else {
                 projectMat = context.projectionMatrix = this._projectionMatrix; //TODO:
                 context.projectionViewMatrix = this.projectionViewMatrix; //TODO:
             }
             context.viewport = this.viewport;
             this._prepareCameraToRender();
             this._prepareCameraViewProject(viewMat, projectMat, context.projectionViewMatrix, this._projectionViewMatrixNoTranslateScale);
             scene._preCulling(context, this, shader, replacementTag);
             scene._clear(gl, context);
             scene._renderScene(context);
             scene._postRenderScript(); //TODO:duo相机是否重复
             (renderTar) && (renderTar._end());
             if (createRenderTexture) {
                 if (this._postProcess) {
                     this._postProcess._render();
                     this._applyPostProcessCommandBuffers();
                 }
                 else if (this._enableHDR) {
                     var blit = BlitScreenQuadCMD.create(this._renderTexture, this._offScreenRenderTexture ? this._offScreenRenderTexture : null);
                     blit.run();
                     blit.recover();
                 }
                 RenderTexture.recoverToPool(this._renderTexture);
             }
         }
         /**
          * 计算从屏幕空间生成的射线。
          * @param	point 屏幕空间的位置位置。
          * @return  out  输出射线。
          */
         viewportPointToRay(point, out) {
             Picker.calculateCursorRay(point, this.viewport, this._projectionMatrix, this.viewMatrix, null, out);
         }
         /**
          * 计算从裁切空间生成的射线。
          * @param	point 裁切空间的位置。。
          * @return  out  输出射线。
          */
         normalizedViewportPointToRay(point, out) {
             var finalPoint = Camera._tempVector20;
             var vp = this.viewport;
             finalPoint.x = point.x * vp.width;
             finalPoint.y = point.y * vp.height;
             Picker.calculateCursorRay(finalPoint, this.viewport, this._projectionMatrix, this.viewMatrix, null, out);
         }
         /**
          * 计算从世界空间准换三维坐标到屏幕空间。
          * @param	position 世界空间的位置。
          * @return  out  输出位置。
          */
         worldToViewportPoint(position, out) {
             Matrix4x4.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix);
             this.viewport.project(position, this._projectionViewMatrix, out);
             //if (out.z < 0.0 || out.z > 1.0)// TODO:是否需要近似判断
             //{
             //outE[0] = outE[1] = outE[2] = NaN;
             //} else {
             out.x = out.x / Laya.stage.clientScaleX;
             out.y = out.y / Laya.stage.clientScaleY;
             //}
         }
         /**
          * 计算从世界空间准换三维坐标到裁切空间。
          * @param	position 世界空间的位置。
          * @return  out  输出位置。
          */
         worldToNormalizedViewportPoint(position, out) {
             Matrix4x4.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix);
             this.normalizedViewport.project(position, this._projectionViewMatrix, out);
             //if (out.z < 0.0 || out.z > 1.0)// TODO:是否需要近似判断
             //{
             //outE[0] = outE[1] = outE[2] = NaN;
             //} else {
             out.x = out.x / Laya.stage.clientScaleX;
             out.y = out.y / Laya.stage.clientScaleY;
             //}
         }
         /**
          * 转换2D屏幕坐标系统到3D正交投影下的坐标系统，注:只有正交模型下有效。
          * @param   source 源坐标。
          * @param   out 输出坐标。
          * @return 是否转换成功。
          */
         convertScreenCoordToOrthographicCoord(source, out) {
             if (this._orthographic) {
                 var clientWidth = RenderContext3D.clientWidth;
                 var clientHeight = RenderContext3D.clientHeight;
                 var ratioX = this.orthographicVerticalSize * this.aspectRatio / clientWidth;
                 var ratioY = this.orthographicVerticalSize / clientHeight;
                 out.x = (-clientWidth / 2 + source.x) * ratioX;
                 out.y = (clientHeight / 2 - source.y) * ratioY;
                 out.z = (this.nearPlane - this.farPlane) * (source.z + 1) / 2 - this.nearPlane;
                 Vector3.transformCoordinate(out, this.transform.worldMatrix, out);
                 return true;
             }
             else {
                 return false;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy(destroyChild = true) {
             this._offScreenRenderTexture = null;
             this.transform.off(Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
             super.destroy(destroyChild);
         }
         /**
          * 在特定渲染管线阶段添加指令缓存。
          */
         addCommandBuffer(event, commandBuffer) {
             switch (event) {
                 case Camera.CAMERAEVENT_POSTPROCESS:
                     this._postProcessCommandBuffers.push(commandBuffer);
                     commandBuffer._camera = this;
                     break;
                 default:
                     throw "Camera:unknown event.";
             }
         }
         /**
          * 在特定渲染管线阶段移除指令缓存。
          */
         removeCommandBuffer(event, commandBuffer) {
             switch (event) {
                 case Camera.CAMERAEVENT_POSTPROCESS:
                     var index = this._postProcessCommandBuffers.indexOf(commandBuffer);
                     if (index !== -1)
                         this._postProcessCommandBuffers.splice(index, 1);
                     break;
                 default:
                     throw "Camera:unknown event.";
             }
         }
         /**
          * 在特定渲染管线阶段移除所有指令缓存。
          */
         removeCommandBuffers(event) {
             switch (event) {
                 case Camera.CAMERAEVENT_POSTPROCESS:
                     this._postProcessCommandBuffers.length = 0;
                     break;
                 default:
                     throw "Camera:unknown event.";
             }
         }
     }
     /** @private */
     Camera.CAMERAEVENT_POSTPROCESS = 0;
     /** @private */
     Camera._tempVector20 = new Vector2();
     /** @private */
     Camera._updateMark = 0;

     /**
      * <code>BoundBox</code> 类用于创建包围盒。
      */
     class BoundBox {
         /**
          * 创建一个 <code>BoundBox</code> 实例。
          * @param	min 包围盒的最小顶点。
          * @param	max 包围盒的最大顶点。
          */
         constructor(min, max) {
             this.min = min;
             this.max = max;
         }
         /**
          * @private
          */
         _rotateExtents(extents, rotation, out) {
             var extentsX = extents.x;
             var extentsY = extents.y;
             var extentsZ = extents.z;
             var matElements = rotation.elements;
             out.x = Math.abs(matElements[0] * extentsX) + Math.abs(matElements[4] * extentsY) + Math.abs(matElements[8] * extentsZ);
             out.y = Math.abs(matElements[1] * extentsX) + Math.abs(matElements[5] * extentsY) + Math.abs(matElements[9] * extentsZ);
             out.z = Math.abs(matElements[2] * extentsX) + Math.abs(matElements[6] * extentsY) + Math.abs(matElements[10] * extentsZ);
         }
         /**
          * 获取包围盒的8个角顶点。
          * @param	corners 返回顶点的输出队列。
          */
         getCorners(corners) {
             corners.length = 8;
             var minX = this.min.x;
             var minY = this.min.y;
             var minZ = this.min.z;
             var maxX = this.max.x;
             var maxY = this.max.y;
             var maxZ = this.max.z;
             corners[0] = new Vector3(minX, maxY, maxZ);
             corners[1] = new Vector3(maxX, maxY, maxZ);
             corners[2] = new Vector3(maxX, minY, maxZ);
             corners[3] = new Vector3(minX, minY, maxZ);
             corners[4] = new Vector3(minX, maxY, minZ);
             corners[5] = new Vector3(maxX, maxY, minZ);
             corners[6] = new Vector3(maxX, minY, minZ);
             corners[7] = new Vector3(minX, minY, minZ);
         }
         /**
          * 获取中心点。
          * @param	out
          */
         getCenter(out) {
             Vector3.add(this.min, this.max, out);
             Vector3.scale(out, 0.5, out);
         }
         /**
          * 获取范围。
          * @param	out
          */
         getExtent(out) {
             Vector3.subtract(this.max, this.min, out);
             Vector3.scale(out, 0.5, out);
         }
         /**
          * 设置中心点和范围。
          * @param	center
          */
         setCenterAndExtent(center, extent) {
             Vector3.subtract(center, extent, this.min);
             Vector3.add(center, extent, this.max);
         }
         /**
          * @private
          */
         tranform(matrix, out) {
             var center = BoundBox._tempVector30;
             var extent = BoundBox._tempVector31;
             this.getCenter(center);
             this.getExtent(extent);
             Vector3.transformCoordinate(center, matrix, center);
             this._rotateExtents(extent, matrix, extent);
             out.setCenterAndExtent(center, extent);
         }
         toDefault() {
             this.min.toDefault();
             this.max.toDefault();
         }
         /**
          * 从顶点生成包围盒。
          * @param	points 所需顶点队列。
          * @param	out 生成的包围盒。
          */
         static createfromPoints(points, out) {
             if (points == null)
                 throw new Error("points");
             var min = out.min;
             var max = out.max;
             min.x = Number.MAX_VALUE;
             min.y = Number.MAX_VALUE;
             min.z = Number.MAX_VALUE;
             max.x = -Number.MAX_VALUE;
             max.y = -Number.MAX_VALUE;
             max.z = -Number.MAX_VALUE;
             for (var i = 0, n = points.length; i < n; ++i) {
                 Vector3.min(min, points[i], min);
                 Vector3.max(max, points[i], max);
             }
         }
         /**
          * 合并两个包围盒。
          * @param	box1 包围盒1。
          * @param	box2 包围盒2。
          * @param	out 生成的包围盒。
          */
         static merge(box1, box2, out) {
             Vector3.min(box1.min, box2.min, out.min);
             Vector3.max(box1.max, box2.max, out.max);
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var dest = destObject;
             this.min.cloneTo(dest.min);
             this.max.cloneTo(dest.max);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new BoundBox(new Vector3(), new Vector3());
             this.cloneTo(dest);
             return dest;
         }
     }
     /**@private */
     BoundBox._tempVector30 = new Vector3();
     /**@private */
     BoundBox._tempVector31 = new Vector3();

     /**
      * <code>BoundSphere</code> 类用于创建包围球。
      */
     class BoundSphere {
         /**
          * 创建一个 <code>BoundSphere</code> 实例。
          * @param	center 包围球的中心。
          * @param	radius 包围球的半径。
          */
         constructor(center, radius) {
             this.center = center;
             this.radius = radius;
         }
         toDefault() {
             this.center.toDefault();
             this.radius = 0;
         }
         /**
          * 从顶点的子队列生成包围球。
          * @param	points 顶点的队列。
          * @param	start 顶点子队列的起始偏移。
          * @param	count 顶点子队列的顶点数。
          * @param	result 生成的包围球。
          */
         static createFromSubPoints(points, start, count, out) {
             if (points == null) {
                 throw new Error("points");
             }
             // Check that start is in the correct range 
             if (start < 0 || start >= points.length) {
                 throw new Error("start" + start + "Must be in the range [0, " + (points.length - 1) + "]");
             }
             // Check that count is in the correct range 
             if (count < 0 || (start + count) > points.length) {
                 throw new Error("count" + count + "Must be in the range <= " + points.length + "}");
             }
             var upperEnd = start + count;
             //Find the center of all points. 
             var center = BoundSphere._tempVector3;
             center.x = 0;
             center.y = 0;
             center.z = 0;
             for (var i = start; i < upperEnd; ++i) {
                 Vector3.add(points[i], center, center);
             }
             var outCenter = out.center;
             //This is the center of our sphere. 
             Vector3.scale(center, 1 / count, outCenter);
             //Find the radius of the sphere 
             var radius = 0.0;
             for (i = start; i < upperEnd; ++i) {
                 //We are doing a relative distance comparison to find the maximum distance 
                 //from the center of our sphere. 
                 var distance = Vector3.distanceSquared(outCenter, points[i]);
                 if (distance > radius)
                     radius = distance;
             }
             //Find the real distance from the DistanceSquared. 
             out.radius = Math.sqrt(radius);
         }
         /**
          * 从顶点队列生成包围球。
          * @param	points 顶点的队列。
          * @param	result 生成的包围球。
          */
         static createfromPoints(points, out) {
             if (points == null) {
                 throw new Error("points");
             }
             BoundSphere.createFromSubPoints(points, 0, points.length, out);
         }
         /**
          * 判断射线是否与碰撞球交叉，并返回交叉距离。
          * @param	ray 射线。
          * @return 距离交叉点的距离，-1表示不交叉。
          */
         intersectsRayDistance(ray) {
             return CollisionUtils.intersectsRayAndSphereRD(ray, this);
         }
         /**
          * 判断射线是否与碰撞球交叉，并返回交叉点。
          * @param	ray  射线。
          * @param	outPoint 交叉点。
          * @return  距离交叉点的距离，-1表示不交叉。
          */
         intersectsRayPoint(ray, outPoint) {
             return CollisionUtils.intersectsRayAndSphereRP(ray, this, outPoint);
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var dest = destObject;
             this.center.cloneTo(dest.center);
             dest.radius = this.radius;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new BoundSphere(new Vector3(), 0);
             this.cloneTo(dest);
             return dest;
         }
     }
     BoundSphere._tempVector3 = new Vector3();

     /**
      * ...
      * @author ...
      */
     class ParallelSplitShadowMap {
         constructor() {
             /**@private */
             this._spiltDistance = [];
             /**@private */
             this._currentPSSM = -1;
             /**@private */
             this._shadowMapCount = 3;
             /**@private */
             this._maxDistance = 200.0;
             /**@private */
             this._ratioOfDistance = 1.0 / this._shadowMapCount;
             /**@private */
             this._globalParallelLightDir = new Vector3(0, -1, 0);
             /**@private */
             this._statesDirty = true;
             /**@private */
             this._shadowMapTextureSize = 1024;
             /**@private */
             this._scene = null;
             /**@private */
             this._boundingSphere = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1);
             /**@private */
             this._boundingBox = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1);
             /**@private */
             this._frustumPos = new Array((ParallelSplitShadowMap.MAX_PSSM_COUNT + 1) * 4);
             /**@private */
             this._uniformDistance = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1);
             /**@private */
             this._logDistance = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1);
             /**@private */
             this._dimension = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1);
             /** @private */
             this._PCFType = 0;
             /** @private */
             this._tempLookAt3 = new Vector3();
             /** @private */
             this._tempLookAt4 = new Vector4();
             /** @private */
             this._tempValue = new Vector4();
             /** @private */
             this._tempPos = new Vector3();
             /** @private */
             this._tempLightUp = new Vector3();
             /** @private */
             this._tempMin = new Vector4();
             /** @private */
             this._tempMax = new Vector4();
             /** @private */
             this._tempMatrix44 = new Matrix4x4;
             /**@private */
             this._splitFrustumCulling = new BoundFrustum(Matrix4x4.DEFAULT);
             /** @private */
             this._tempScaleMatrix44 = new Matrix4x4();
             /** @private */
             this._shadowPCFOffset = new Vector2(1.0 / 1024.0, 1.0 / 1024.0);
             /** @private */
             this._shaderValueDistance = new Vector4();
             /** @private */
             this._shaderValueLightVP = null;
             this.cameras = [];
             this._shaderValueVPs = [];
             var i;
             for (i = 0; i < this._spiltDistance.length; i++) {
                 this._spiltDistance[i] = 0.0;
             }
             for (i = 0; i < this._dimension.length; i++) {
                 this._dimension[i] = new Vector2();
             }
             for (i = 0; i < this._frustumPos.length; i++) {
                 this._frustumPos[i] = new Vector3();
             }
             for (i = 0; i < this._boundingBox.length; i++) {
                 this._boundingBox[i] = new BoundBox(new Vector3(), new Vector3());
             }
             for (i = 0; i < this._boundingSphere.length; i++) {
                 this._boundingSphere[i] = new BoundSphere(new Vector3(), 0.0);
             }
             Matrix4x4.createScaling(new Vector3(0.5, 0.5, 1.0), this._tempScaleMatrix44);
             this._tempScaleMatrix44.elements[12] = 0.5;
             this._tempScaleMatrix44.elements[13] = 0.5;
         }
         setInfo(scene, maxDistance, globalParallelDir, shadowMapTextureSize, numberOfPSSM, PCFType) {
             if (numberOfPSSM > ParallelSplitShadowMap.MAX_PSSM_COUNT) {
                 this._shadowMapCount = ParallelSplitShadowMap.MAX_PSSM_COUNT;
             }
             this._scene = scene;
             this._maxDistance = maxDistance;
             this.shadowMapCount = numberOfPSSM;
             this._globalParallelLightDir = globalParallelDir;
             this._ratioOfDistance = 1.0 / this._shadowMapCount;
             for (var i = 0; i < this._spiltDistance.length; i++) {
                 this._spiltDistance[i] = 0.0;
             }
             this._shadowMapTextureSize = shadowMapTextureSize;
             this._shadowPCFOffset.x = 1.0 / this._shadowMapTextureSize;
             this._shadowPCFOffset.y = 1.0 / this._shadowMapTextureSize;
             this.setPCFType(PCFType);
             this._statesDirty = true;
         }
         setPCFType(PCFtype) {
             this._PCFType = PCFtype;
             var defineData = this._scene._shaderValues;
             switch (this._PCFType) {
                 case 0:
                     defineData.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3);
                     break;
                 case 1:
                     defineData.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3);
                     break;
                 case 2:
                     defineData.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3);
                     break;
                 case 3:
                     defineData.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1);
                     defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2);
                     break;
             }
         }
         getPCFType() {
             return this._PCFType;
         }
         setFarDistance(value) {
             if (this._maxDistance != value) {
                 this._maxDistance = value;
                 this._statesDirty = true;
             }
         }
         getFarDistance() {
             return this._maxDistance;
         }
         set shadowMapCount(value) {
             value = value > 0 ? value : 1;
             value = value <= ParallelSplitShadowMap.MAX_PSSM_COUNT ? value : ParallelSplitShadowMap.MAX_PSSM_COUNT;
             if (this._shadowMapCount != value) {
                 this._shadowMapCount = value;
                 this._ratioOfDistance = 1.0 / this._shadowMapCount;
                 this._statesDirty = true;
                 this._shaderValueLightVP = new Float32Array(value * 16);
                 this._shaderValueVPs.length = value;
                 for (var i = 0; i < value; i++)
                     this._shaderValueVPs[i] = new Float32Array(this._shaderValueLightVP.buffer, i * 64);
             }
         }
         get shadowMapCount() {
             return this._shadowMapCount;
         }
         /**
          * @private
          */
         _beginSampler(index, sceneCamera) {
             if (index < 0 || index > this._shadowMapCount) //TODO:
                 throw new Error("ParallelSplitShadowMap: beginSample invalid index");
             this._currentPSSM = index;
             this._update(sceneCamera);
         }
         /**
          * @private
          */
         endSampler(sceneCamera) {
             this._currentPSSM = -1;
         }
         /**
          * @private
          */
         _calcAllLightCameraInfo(sceneCamera) {
             if (this._shadowMapCount === 1) {
                 this._beginSampler(0, sceneCamera);
                 this.endSampler(sceneCamera);
             }
             else {
                 for (var i = 0, n = this._shadowMapCount + 1; i < n; i++) {
                     this._beginSampler(i, sceneCamera);
                     this.endSampler(sceneCamera);
                 }
             }
         }
         /**
          * @private
          */
         _recalculate(nearPlane, fieldOfView, aspectRatio) {
             this._calcSplitDistance(nearPlane);
             this._calcBoundingBox(fieldOfView, aspectRatio);
             this._rebuildRenderInfo();
         }
         /**
          * @private
          */
         _update(sceneCamera) {
             var nearPlane = sceneCamera.nearPlane;
             var fieldOfView = sceneCamera.fieldOfView;
             var aspectRatio = sceneCamera.aspectRatio;
             if (this._statesDirty || this.lastNearPlane !== nearPlane || this.lastFieldOfView !== fieldOfView || this.lastAspectRatio !== aspectRatio) { //TODO:同一场景多摄像机频繁切换仍会重新计算,将包围矩阵存到摄像机自身可解决
                 this._recalculate(nearPlane, fieldOfView, aspectRatio);
                 this._uploadShaderValue();
                 this._statesDirty = false;
                 this.lastNearPlane = nearPlane;
                 this.lastFieldOfView = fieldOfView;
                 this.lastAspectRatio = aspectRatio;
             }
             //calcSplitFrustum(sceneCamera);
             this._calcLightViewProject(sceneCamera);
         }
         /**
          * @private
          */
         _uploadShaderValue() {
             var sceneSV = this._scene._shaderValues;
             switch (this._shadowMapCount) {
                 case 1:
                     sceneSV.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1);
                     sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2);
                     sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3);
                     break;
                 case 2:
                     sceneSV.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2);
                     sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1);
                     sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3);
                     break;
                 case 3:
                     sceneSV.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3);
                     sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1);
                     sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2);
                     break;
             }
             sceneSV.setVector(ILaya3D.Scene3D.SHADOWDISTANCE, this._shaderValueDistance);
             sceneSV.setBuffer(ILaya3D.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP);
             sceneSV.setVector2(ILaya3D.Scene3D.SHADOWMAPPCFOFFSET, this._shadowPCFOffset);
             switch (this._shadowMapCount) {
                 case 3:
                     sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget);
                     sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget);
                     sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE3, this.cameras[3].renderTarget);
                     break;
                 case 2:
                     sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget);
                     sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget);
                     break;
                 case 1:
                     sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget);
                     break;
             }
         }
         /**
          * @private
          */
         _calcSplitDistance(nearPlane) {
             var far = this._maxDistance;
             var invNumberOfPSSM = 1.0 / this._shadowMapCount;
             var i;
             for (i = 0; i <= this._shadowMapCount; i++) {
                 this._uniformDistance[i] = nearPlane + (far - nearPlane) * i * invNumberOfPSSM;
             }
             var farDivNear = far / nearPlane;
             for (i = 0; i <= this._shadowMapCount; i++) {
                 var n = Math.pow(farDivNear, i * invNumberOfPSSM);
                 this._logDistance[i] = nearPlane * n;
             }
             for (i = 0; i <= this._shadowMapCount; i++) {
                 this._spiltDistance[i] = this._uniformDistance[i] * this._ratioOfDistance + this._logDistance[i] * (1.0 - this._ratioOfDistance);
             }
             this._shaderValueDistance.x = this._spiltDistance[1];
             this._shaderValueDistance.y = this._spiltDistance[2];
             this._shaderValueDistance.z = this._spiltDistance[3];
             this._shaderValueDistance.w = 0.0; //_spiltDistance[4]为undefine 微信小游戏
         }
         /**
          * @private
          */
         _calcBoundingBox(fieldOfView, aspectRatio) {
             var fov = 3.1415926 * fieldOfView / 180.0;
             var halfTanValue = Math.tan(fov / 2.0);
             var height;
             var width;
             var distance;
             var i;
             for (i = 0; i <= this._shadowMapCount; i++) {
                 distance = this._spiltDistance[i];
                 height = distance * halfTanValue;
                 width = height * aspectRatio;
                 var temp = this._frustumPos[i * 4 + 0];
                 temp.x = -width; // distance * 0.0 - height * 0.0 + width * -1.0
                 temp.y = -height; //distance * 0.0 - height * 1.0 + width * 0.0
                 temp.z = -distance; // distance * -1.0 - height * 0.0 + width * 0.0
                 temp = this._frustumPos[i * 4 + 1];
                 temp.x = width; // distance * 0.0 - height * 0.0 - width * -1.0
                 temp.y = -height; // distance * 0.0 - height * 1.0 - width * 0.0
                 temp.z = -distance; //distance * -1.0 - height * 0.0 - width * 0.0
                 temp = this._frustumPos[i * 4 + 2];
                 temp.x = -width; // distance * 0.0 + width * -1 + height * 0.0
                 temp.y = height; // distance * 0.0 + width * 0.0 + height * 1.0
                 temp.z = -distance; // distance * -1.0 + width * 0.0 + height * 0.0
                 temp = this._frustumPos[i * 4 + 3];
                 temp.x = width; // distance * 0.0 - width * -1 + height * 0.0
                 temp.y = height; // distance * 0.0 - width * 0.0 + height * 1.0
                 temp.z = -distance; // distance * -1.0 - width * 0.0 + height * 0.0
                 temp = this._dimension[i];
                 temp.x = width;
                 temp.y = height;
             }
             var d;
             var min;
             var max;
             var center;
             for (i = 1; i <= this._shadowMapCount; i++) {
                 d = this._dimension[i];
                 min = this._boundingBox[i].min;
                 min.x = -d.x;
                 min.y = -d.y;
                 min.z = -this._spiltDistance[i];
                 max = this._boundingBox[i].max;
                 max.x = d.x;
                 max.y = d.y;
                 max.z = -this._spiltDistance[i - 1];
                 center = this._boundingSphere[i].center;
                 center.x = (min.x + max.x) * 0.5;
                 center.y = (min.y + max.y) * 0.5;
                 center.z = (min.z + max.z) * 0.5;
                 this._boundingSphere[i].radius = Math.sqrt(Math.pow(max.x - min.x, 2) + Math.pow(max.y - min.y, 2) + Math.pow(max.z - min.z, 2)) * 0.5;
             }
             min = this._boundingBox[0].min;
             d = this._dimension[this._shadowMapCount];
             min.x = -d.x;
             min.y = -d.y;
             min.z = -this._spiltDistance[this._shadowMapCount];
             max = this._boundingBox[0].max;
             max.x = d.x;
             max.y = d.y;
             max.z = -this._spiltDistance[0];
             center = this._boundingSphere[0].center;
             center.x = (min.x + max.x) * 0.5;
             center.y = (min.y + max.y) * 0.5;
             center.z = (min.z + max.z) * 0.5;
             this._boundingSphere[0].radius = Math.sqrt(Math.pow(max.x - min.x, 2) + Math.pow(max.y - min.y, 2) + Math.pow(max.z - min.z, 2)) * 0.5;
         }
         calcSplitFrustum(sceneCamera) {
             if (this._currentPSSM > 0) {
                 Matrix4x4.createPerspective(3.1416 * sceneCamera.fieldOfView / 180.0, sceneCamera.aspectRatio, this._spiltDistance[this._currentPSSM - 1], this._spiltDistance[this._currentPSSM], this._tempMatrix44);
             }
             else {
                 Matrix4x4.createPerspective(3.1416 * sceneCamera.fieldOfView / 180.0, sceneCamera.aspectRatio, this._spiltDistance[0], this._spiltDistance[this._shadowMapCount], this._tempMatrix44);
             }
             Matrix4x4.multiply(this._tempMatrix44, sceneCamera.viewMatrix, this._tempMatrix44);
             this._splitFrustumCulling.matrix = this._tempMatrix44;
         }
         /**
          * @private
          */
         _rebuildRenderInfo() {
             var nNum = this._shadowMapCount + 1;
             var i;
             this.cameras.length = nNum;
             for (i = 0; i < nNum; i++) {
                 if (!this.cameras[i]) {
                     var camera = new Camera();
                     camera.name = "lightCamera" + i;
                     camera.clearColor = new Vector4(1.0, 1.0, 1.0, 1.0);
                     this.cameras[i] = camera;
                 }
                 var shadowMap = this.cameras[i].renderTarget;
                 if (shadowMap == null || shadowMap.width != this._shadowMapTextureSize || shadowMap.height != this._shadowMapTextureSize) {
                     (shadowMap) && (shadowMap.destroy());
                     shadowMap = new RenderTexture(this._shadowMapTextureSize, this._shadowMapTextureSize, BaseTexture.FORMAT_R8G8B8A8, BaseTexture.FORMAT_DEPTH_16);
                     shadowMap.filterMode = BaseTexture.FILTERMODE_POINT;
                     this.cameras[i].renderTarget = shadowMap;
                 }
             }
         }
         /**
          * @private
          */
         _calcLightViewProject(sceneCamera) {
             var boundSphere = this._boundingSphere[this._currentPSSM];
             var cameraMatViewInv = sceneCamera.transform.worldMatrix;
             var radius = boundSphere.radius;
             boundSphere.center.cloneTo(this._tempLookAt3);
             Vector3.transformV3ToV4(this._tempLookAt3, cameraMatViewInv, this._tempLookAt4);
             var lookAt3Element = this._tempLookAt3;
             var lookAt4Element = this._tempLookAt4;
             lookAt3Element.x = lookAt4Element.x;
             lookAt3Element.y = lookAt4Element.y;
             lookAt3Element.z = lookAt4Element.z;
             var lightUpElement = this._tempLightUp;
             sceneCamera.transform.worldMatrix.getForward(ParallelSplitShadowMap._tempVector30);
             var sceneCameraDir = ParallelSplitShadowMap._tempVector30;
             lightUpElement.x = sceneCameraDir.x;
             lightUpElement.y = 1.0;
             lightUpElement.z = sceneCameraDir.z;
             Vector3.normalize(this._tempLightUp, this._tempLightUp);
             Vector3.scale(this._globalParallelLightDir, boundSphere.radius * 4, this._tempPos);
             Vector3.subtract(this._tempLookAt3, this._tempPos, this._tempPos);
             var curLightCamera = this.cameras[this._currentPSSM];
             curLightCamera.transform.position = this._tempPos;
             curLightCamera.transform.lookAt(this._tempLookAt3, this._tempLightUp, false);
             var tempMax = this._tempMax;
             var tempMin = this._tempMin;
             tempMax.x = tempMax.y = tempMax.z = -100000.0;
             tempMax.w = 1.0;
             tempMin.x = tempMin.y = tempMin.z = 100000.0;
             tempMin.w = 1.0;
             /*
                var offSet:int; var offSet1:int; var offSet2:int;
                if (_currentPSSM == 0) {
                offSet1 = 0;
                offSet2 = _numberOfPSSM * 3;
                }
                else {
                offSet1 = (_currentPSSM - 1) * 4;
                offSet2 = offSet1;
                }
                //Convert  matrix : from view space->world space->light view space
                Matrix4x4.multiply(_lightCamera.viewMatrix, cameraMatViewInv, _tempMatrix44);
                var tempValueElement:Float32Array = _tempValue.elements;
                for (var i:int= 0; i < 8 ; i++ ) {
                offSet = (i < 4) ? offSet1 : offSet2;
                var frustumPosElements:Float32Array = _frustumPos[offSet + i].elements;
                tempValueElement[0] = frustumPosElements[0];
                tempValueElement[1] = frustumPosElements[1];
                tempValueElement[2] = frustumPosElements[2];
                tempValueElement[3] = 1.0;
                Vector4.transformByM4x4(_tempValue, _tempMatrix44, _tempValue);
                tempMinElements[0] = (tempValueElement[0] < tempMinElements[0]) ? tempValueElement[0] : tempMinElements[0];
                tempMinElements[1] = (tempValueElement[1] < tempMinElements[1]) ? tempValueElement[1] : tempMinElements[1];
                tempMinElements[2] = (tempValueElement[2] < tempMinElements[2]) ? tempValueElement[2] : tempMinElements[2];
                tempMaxElements[0] = (tempValueElement[0] > tempMaxElements[0]) ? tempValueElement[0] : tempMaxElements[0];
                tempMaxElements[1] = (tempValueElement[1] > tempMaxElements[1]) ? tempValueElement[1] : tempMaxElements[1];
                tempMaxElements[2] = (tempValueElement[2] > tempMaxElements[2]) ? tempValueElement[2] : tempMaxElements[2];
                }
              */
             Matrix4x4.multiply(curLightCamera.viewMatrix, cameraMatViewInv, this._tempMatrix44);
             var tempValueElement = this._tempValue;
             var corners = [];
             corners.length = 8;
             this._boundingBox[this._currentPSSM].getCorners(corners);
             for (var i = 0; i < 8; i++) {
                 var frustumPosElements = corners[i];
                 tempValueElement.x = frustumPosElements.x;
                 tempValueElement.y = frustumPosElements.y;
                 tempValueElement.z = frustumPosElements.z;
                 tempValueElement.w = 1.0;
                 Vector4.transformByM4x4(this._tempValue, this._tempMatrix44, this._tempValue);
                 tempMin.x = (tempValueElement.x < tempMin.x) ? tempValueElement.x : tempMin.x;
                 tempMin.y = (tempValueElement.y < tempMin.y) ? tempValueElement.y : tempMin.y;
                 tempMin.z = (tempValueElement.z < tempMin.z) ? tempValueElement.z : tempMin.z;
                 tempMax.x = (tempValueElement.x > tempMax.x) ? tempValueElement.x : tempMax.x;
                 tempMax.y = (tempValueElement.y > tempMax.y) ? tempValueElement.y : tempMax.y;
                 tempMax.z = (tempValueElement.z > tempMax.z) ? tempValueElement.z : tempMax.z;
             }
             //现在tempValueElement变成了center
             Vector4.add(this._tempMax, this._tempMin, this._tempValue);
             tempValueElement.x *= 0.5;
             tempValueElement.y *= 0.5;
             tempValueElement.z *= 0.5;
             tempValueElement.w = 1;
             Vector4.transformByM4x4(this._tempValue, curLightCamera.transform.worldMatrix, this._tempValue);
             var distance = Math.abs(-this._tempMax.z);
             var farPlane = distance > this._maxDistance ? distance : this._maxDistance;
             //build light's view and project matrix
             Vector3.scale(this._globalParallelLightDir, farPlane, this._tempPos);
             var tempPosElement = this._tempPos;
             tempPosElement.x = tempValueElement.x - tempPosElement.x;
             tempPosElement.y = tempValueElement.y - tempPosElement.y;
             tempPosElement.z = tempValueElement.z - tempPosElement.z;
             curLightCamera.transform.position = this._tempPos;
             curLightCamera.transform.lookAt(this._tempLookAt3, this._tempLightUp, false);
             Matrix4x4.createOrthoOffCenter(tempMin.x, tempMax.x, tempMin.y, tempMax.y, 1.0, farPlane + 0.5 * (tempMax.z - tempMin.z), curLightCamera.projectionMatrix);
             //calc frustum
             var projectView = curLightCamera.projectionViewMatrix;
             ParallelSplitShadowMap.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44, projectView, this._shaderValueVPs[this._currentPSSM]);
             this._scene._shaderValues.setBuffer(ILaya3D.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP);
         }
         /**
          * 计算两个矩阵的乘法
          * @param	left left矩阵
          * @param	right  right矩阵
          * @param	out  输出矩阵
          */
         static multiplyMatrixOutFloat32Array(left, right, out) {
             var i, a, b, ai0, ai1, ai2, ai3;
             a = left.elements;
             b = right.elements;
             for (i = 0; i < 4; i++) {
                 ai0 = a[i];
                 ai1 = a[i + 4];
                 ai2 = a[i + 8];
                 ai3 = a[i + 12];
                 out[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
                 out[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
                 out[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
                 out[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
             }
         }
         setShadowMapTextureSize(size) {
             if (size !== this._shadowMapTextureSize) {
                 this._shadowMapTextureSize = size;
                 this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize;
                 this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize;
                 this._statesDirty = true;
             }
         }
         disposeAllRenderTarget() {
             for (var i = 0, n = this._shadowMapCount + 1; i < n; i++) {
                 if (this.cameras[i].renderTarget) {
                     this.cameras[i].renderTarget.destroy();
                     this.cameras[i].renderTarget = null;
                 }
             }
         }
     }
     /**@private */
     ParallelSplitShadowMap.MAX_PSSM_COUNT = 3;
     /**@private */
     ParallelSplitShadowMap._tempVector30 = new Vector3();

     /**
      * <code>LightSprite</code> 类用于创建灯光的父类。
      */
     class LightSprite extends Sprite3D {
         /**
          * 创建一个 <code>LightSprite</code> 实例。
          */
         constructor() {
             super();
             this._intensity = 1.0;
             this._intensityColor = new Vector3();
             this.color = new Vector3(1.0, 1.0, 1.0);
             this._shadow = false;
             this._shadowFarPlane = 8;
             this._shadowMapSize = 512;
             this._shadowMapCount = 1;
             this._shadowMapPCFType = 0;
             this._lightmapBakedType = LightSprite.LIGHTMAPBAKEDTYPE_REALTIME;
         }
         /**
          * 获取灯光强度。
          * @return 灯光强度
          */
         get intensity() {
             return this._intensity;
         }
         /**
          * 设置灯光强度。
          * @param value 灯光强度
          */
         set intensity(value) {
             this._intensity = value;
         }
         /**
          * 获取是否产生阴影。
          * @return 是否产生阴影。
          */
         get shadow() {
             return this._shadow;
         }
         /**
          * 设置是否产生阴影。
          * @param value 是否产生阴影。
          */
         set shadow(value) {
             throw new Error("LightSprite: must override it.");
         }
         /**
          * 获取阴影最远范围。
          * @return 阴影最远范围。
          */
         get shadowDistance() {
             return this._shadowFarPlane;
         }
         /**
          * 设置阴影最远范围。
          * @param value 阴影最远范围。
          */
         set shadowDistance(value) {
             this._shadowFarPlane = value;
             (this._parallelSplitShadowMap) && (this._parallelSplitShadowMap.setFarDistance(value));
         }
         /**
          * 获取阴影贴图尺寸。
          * @return 阴影贴图尺寸。
          */
         get shadowResolution() {
             return this._shadowMapSize;
         }
         /**
          * 设置阴影贴图尺寸。
          * @param value 阴影贴图尺寸。
          */
         set shadowResolution(value) {
             this._shadowMapSize = value;
             (this._parallelSplitShadowMap) && (this._parallelSplitShadowMap.setShadowMapTextureSize(value));
         }
         /**
          * 获取阴影分段数。
          * @return 阴影分段数。
          */
         get shadowPSSMCount() {
             return this._shadowMapCount;
         }
         /**
          * 设置阴影分段数。
          * @param value 阴影分段数。
          */
         set shadowPSSMCount(value) {
             this._shadowMapCount = value;
             (this._parallelSplitShadowMap) && (this._parallelSplitShadowMap.shadowMapCount = value);
         }
         /**
          * 获取阴影PCF类型。
          * @return PCF类型。
          */
         get shadowPCFType() {
             return this._shadowMapPCFType;
         }
         /**
          * 设置阴影PCF类型。
          * @param value PCF类型。
          */
         set shadowPCFType(value) {
             this._shadowMapPCFType = value;
             (this._parallelSplitShadowMap) && (this._parallelSplitShadowMap.setPCFType(value));
         }
         /**
          * 获取灯光烘培类型。
          */
         get lightmapBakedType() {
             return this._lightmapBakedType;
         }
         /**
          * 设置灯光烘培类型。
          */
         set lightmapBakedType(value) {
             if (this._lightmapBakedType !== value) {
                 this._lightmapBakedType = value;
                 if (this.activeInHierarchy) {
                     if (value !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED)
                         this._scene._addLight(this);
                     else
                         this._scene._removeLight(this);
                 }
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             super._parse(data, spriteMap);
             var colorData = data.color;
             this.color.fromArray(colorData);
             this.intensity = data.intensity;
             this.lightmapBakedType = data.lightmapBakedType;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onActive() {
             super._onActive();
             (this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED) && (this._scene._addLight(this));
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onInActive() {
             super._onInActive();
             (this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED) && (this._scene._removeLight(this));
         }
         /**
          * 更新灯光相关渲染状态参数。
          * @param state 渲染状态参数。
          */
         _prepareToScene() {
             return false;
         }
         /**
          * @private
          */
         _create() {
             return new LightSprite();
         }
         /**
          * 获取灯光的漫反射颜色。
          * @return 灯光的漫反射颜色。
          */
         get diffuseColor() {
             console.log("LightSprite: discard property,please use color property instead.");
             return this.color;
         }
         /**
          * 设置灯光的漫反射颜色。
          * @param value 灯光的漫反射颜色。
          */
         set diffuseColor(value) {
             console.log("LightSprite: discard property,please use color property instead.");
             this.color = value;
         }
     }
     /** 灯光烘培类型-实时。*/
     LightSprite.LIGHTMAPBAKEDTYPE_REALTIME = 0;
     /** 灯光烘培类型-混合。*/
     LightSprite.LIGHTMAPBAKEDTYPE_MIXED = 1;
     /** 灯光烘培类型-烘焙。*/
     LightSprite.LIGHTMAPBAKEDTYPE_BAKED = 2;

     /**
      * <code>DirectionLight</code> 类用于创建平行光。
      */
     class DirectionLight extends LightSprite {
         /**
          * @inheritDoc
          */
         /*override*/ set shadow(value) {
             if (this._shadow !== value) {
                 this._shadow = value;
                 (this.scene) && (this._initShadow());
             }
         }
         /**
          * 创建一个 <code>DirectionLight</code> 实例。
          */
         constructor() {
             super();
             this._direction = new Vector3();
         }
         /**
          * @private
          */
         _initShadow() {
             if (this._shadow) {
                 this._parallelSplitShadowMap = new ParallelSplitShadowMap();
                 this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap);
                 this.transform.worldMatrix.getForward(this._direction);
                 Vector3.normalize(this._direction, this._direction);
                 this._parallelSplitShadowMap.setInfo(this.scene, this._shadowFarPlane, this._direction, this._shadowMapSize, this._shadowMapCount, this._shadowMapPCFType);
             }
             else {
                 var defineDatas = this._scene._shaderValues;
                 var parallelSplitShadowMaps = this.scene.parallelSplitShadowMaps;
                 parallelSplitShadowMaps.splice(parallelSplitShadowMaps.indexOf(this._parallelSplitShadowMap), 1);
                 this._parallelSplitShadowMap.disposeAllRenderTarget();
                 this._parallelSplitShadowMap = null;
                 defineDatas.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1);
                 defineDatas.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2);
                 defineDatas.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onActive() {
             super._onActive();
             this._shadow && (this._initShadow());
             (this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED) && (this._scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT));
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onInActive() {
             super._onInActive();
             (this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED) && (this._scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT));
         }
         /**
          * 更新平行光相关渲染状态参数。
          * @param state 渲染状态参数。
          */
         /*override*/ _prepareToScene() {
             var scene = this._scene;
             if (scene.enableLight && this.activeInHierarchy) {
                 var shaderValue = scene._shaderValues;
                 Vector3.scale(this.color, this._intensity, this._intensityColor);
                 shaderValue.setVector3(ILaya3D.Scene3D.LIGHTDIRCOLOR, this._intensityColor);
                 this.transform.worldMatrix.getForward(this._direction);
                 Vector3.normalize(this._direction, this._direction);
                 shaderValue.setVector3(ILaya3D.Scene3D.LIGHTDIRECTION, this._direction);
                 return true;
             }
             else {
                 return false;
             }
         }
     }

     class MeshSprite3DShaderDeclaration {
     }

     /**
      * <code>MeshFilter</code> 类用于创建网格过滤器。
      */
     class MeshFilter {
         /**
          * 获取共享网格。
          * @return 共享网格。
          */
         get sharedMesh() {
             return this._sharedMesh;
         }
         /**
          * 设置共享网格。
          * @return  value 共享网格。
          */
         set sharedMesh(value) {
             if (this._sharedMesh !== value) {
                 var defineDatas = this._owner._render._shaderValues;
                 var lastValue = this._sharedMesh;
                 if (lastValue) {
                     lastValue._removeReference();
                     defineDatas.removeDefine(this._getMeshDefine(lastValue));
                 }
                 if (value) {
                     value._addReference();
                     defineDatas.addDefine(this._getMeshDefine(value));
                 }
                 this._owner._render._onMeshChange(value);
                 this._sharedMesh = value;
             }
         }
         /**
          * 创建一个新的 <code>MeshFilter</code> 实例。
          * @param owner 所属网格精灵。
          */
         constructor(owner) {
             this._owner = owner;
         }
         /**
          * @private
          */
         _getMeshDefine(mesh) {
             var define;
             for (var i = 0, n = mesh._subMeshCount; i < n; i++) {
                 var subMesh = mesh._getSubMesh(i);
                 var vertexElements = subMesh._vertexBuffer._vertexDeclaration.vertexElements;
                 for (var j = 0, m = vertexElements.length; j < m; j++) {
                     var vertexElement = vertexElements[j];
                     var name = vertexElement.elementUsage;
                     switch (name) {
                         case VertexMesh.MESH_COLOR0:
                             define |= MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR;
                             break;
                         case VertexMesh.MESH_TEXTURECOORDINATE0:
                             define |= MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0;
                             break;
                         case VertexMesh.MESH_TEXTURECOORDINATE1:
                             define |= MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1;
                             break;
                     }
                 }
             }
             return define;
         }
         /**
          * @inheritDoc
          */
         destroy() {
             this._owner = null;
             (this._sharedMesh) && (this._sharedMesh._removeReference(), this._sharedMesh = null);
         }
     }

     /**
      * @private
      */
     class BatchMark {
         constructor() {
             /**@private */
             this.updateMark = -1;
             /**@private */
             this.indexInList = -1;
             /**@private */
             this.batched = false;
         }
     }

     /**
      * @private
      * <code>GeometryElement</code> 类用于实现几何体元素,该类为抽象类。
      */
     class GeometryElement {
         /**
          * 创建一个 <code>GeometryElement</code> 实例。
          */
         constructor() {
             this._destroyed = false;
         }
         /**
          * 获取是否销毁。
          * @return 是否销毁。
          */
         get destroyed() {
             return this._destroyed;
         }
         /**
          * 获取几何体类型。
          */
         _getType() {
             throw "GeometryElement:must override it.";
         }
         /**
          * @private
          * @return  是否需要渲染。
          */
         _prepareRender(state) {
             return true;
         }
         /**
          * @private
          */
         _render(state) {
             throw "GeometryElement:must override it.";
         }
         /**
          * 销毁。
          */
         destroy() {
             if (this._destroyed)
                 return;
             this._destroyed = true;
         }
     }
     /**@private */
     GeometryElement._typeCounter = 0;

     /**
      * @private
      */
     class SubMeshInstanceBatch extends GeometryElement {
         /**
          * 创建一个 <code>InstanceSubMesh</code> 实例。
          */
         constructor() {
             super();
             /** @private */
             this.maxInstanceCount = 1024;
             /** @private */
             this.instanceWorldMatrixData = new Float32Array(this.maxInstanceCount * 16);
             /** @private */
             this.instanceMVPMatrixData = new Float32Array(this.maxInstanceCount * 16);
             /** @private */
             this.instanceWorldMatrixBuffer = new VertexBuffer3D(this.instanceWorldMatrixData.length * 4, WebGLContext.DYNAMIC_DRAW);
             /** @private */
             this.instanceMVPMatrixBuffer = new VertexBuffer3D(this.instanceMVPMatrixData.length * 4, WebGLContext.DYNAMIC_DRAW);
             this.instanceWorldMatrixBuffer.vertexDeclaration = VertexMesh.instanceWorldMatrixDeclaration;
             this.instanceMVPMatrixBuffer.vertexDeclaration = VertexMesh.instanceMVPMatrixDeclaration;
         }
         /**
          * @private
          */
         static __init__() {
             SubMeshInstanceBatch.instance = new SubMeshInstanceBatch();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _render(state) {
             var element = state.renderElement;
             var subMesh = element.instanceSubMesh;
             var count = element.instanceBatchElementList.length;
             var indexCount = subMesh._indexCount;
             subMesh._mesh._instanceBufferState.bind();
             LayaGL.layaGPUInstance.drawElementsInstanced(WebGLContext.TRIANGLES, indexCount, WebGLContext.UNSIGNED_SHORT, subMesh._indexStart * 2, count);
             Stat.renderBatches++;
             Stat.savedRenderBatches += count - 1;
             Stat.trianglesFaces += indexCount * count / 3;
         }
     }

     /**
      * @private
      * <code>RenderElement</code> 类用于实现渲染元素。
      */
     class RenderElement {
         /**
          * 创建一个 <code>RenderElement</code> 实例。
          */
         constructor() {
             /** @private */
             this.renderSubShader = null; //TODO：做缓存标记优化
             /** @private */
             this.renderType = RenderElement.RENDERTYPE_NORMAL;
         }
         /**
          * @private
          */
         getInvertFront() {
             return this._transform._isFrontFaceInvert;
         }
         /**
          * @private
          */
         setTransform(transform) {
             this._transform = transform;
         }
         /**
          * @private
          */
         setGeometry(geometry) {
             this._geometry = geometry;
         }
         /**
          * @private
          */
         addToOpaqueRenderQueue(context, queue) {
             queue.elements.push(this);
         }
         /**
          * @private
          */
         addToTransparentRenderQueue(context, queue) {
             queue.elements.push(this);
             queue.lastTransparentBatched = false;
             queue.lastTransparentRenderElement = this;
         }
         /**
          * @private
          */
         _update(scene, context, customShader, replacementTag) {
             if (this.material) { //材质可能为空
                 var subShader = this.material._shader.getSubShaderAt(0); //TODO:
                 this.renderSubShader = null;
                 if (customShader) {
                     if (replacementTag) {
                         var oriTag = subShader.getFlag(replacementTag);
                         if (oriTag) {
                             var customSubShaders = customShader._subShaders;
                             for (var k = 0, p = customSubShaders.length; k < p; k++) {
                                 var customSubShader = customSubShaders[k];
                                 if (oriTag === customSubShader.getFlag(replacementTag)) {
                                     this.renderSubShader = customSubShader;
                                     break;
                                 }
                             }
                             if (!this.renderSubShader)
                                 return;
                         }
                         else {
                             return;
                         }
                     }
                     else {
                         this.renderSubShader = customShader.getSubShaderAt(0); //TODO:
                     }
                 }
                 else {
                     this.renderSubShader = subShader;
                 }
                 var renderQueue = scene._getRenderQueue(this.material.renderQueue);
                 if (renderQueue.isTransparent)
                     this.addToTransparentRenderQueue(context, renderQueue);
                 else
                     this.addToOpaqueRenderQueue(context, renderQueue);
             }
         }
         /**
          * @private
          */
         _render(context, isTarget) {
             var lastStateMaterial, lastStateShaderInstance, lastStateRender;
             var updateMark = Camera._updateMark;
             var scene = context.scene;
             var camera = context.camera;
             var transform = this._transform;
             var geometry = this._geometry;
             context.renderElement = this;
             var updateRender = updateMark !== this.render._updateMark || this.renderType !== this.render._updateRenderType;
             if (updateRender) { //此处处理更新为裁剪和合并后的，可避免浪费
                 this.render._renderUpdate(context, transform);
                 this.render._renderUpdateWithCamera(context, transform);
                 this.render._updateMark = updateMark;
                 this.render._updateRenderType = this.renderType;
             }
             if (geometry._prepareRender(context)) {
                 var passes = this.renderSubShader._passes;
                 for (var j = 0, m = passes.length; j < m; j++) {
                     var shaderPass = context.shader = passes[j].withCompile((scene._shaderValues._defineDatas.value) & (~this.material._disablePublicDefineDatas.value), this.render._shaderValues._defineDatas.value, this.material._shaderValues._defineDatas.value);
                     var switchShader = shaderPass.bind(); //纹理需要切换shader时重新绑定 其他uniform不需要
                     var switchUpdateMark = (updateMark !== shaderPass._uploadMark);
                     var uploadScene = (shaderPass._uploadScene !== scene) || switchUpdateMark;
                     if (uploadScene || switchShader) {
                         shaderPass.uploadUniforms(shaderPass._sceneUniformParamsMap, scene._shaderValues, uploadScene);
                         shaderPass._uploadScene = scene;
                     }
                     var uploadSprite3D = (shaderPass._uploadRender !== this.render || shaderPass._uploadRenderType !== this.renderType) || switchUpdateMark;
                     if (uploadSprite3D || switchShader) {
                         shaderPass.uploadUniforms(shaderPass._spriteUniformParamsMap, this.render._shaderValues, uploadSprite3D);
                         shaderPass._uploadRender = this.render;
                         shaderPass._uploadRenderType = this.renderType;
                     }
                     var uploadCamera = shaderPass._uploadCamera !== camera || switchUpdateMark;
                     if (uploadCamera || switchShader) {
                         shaderPass.uploadUniforms(shaderPass._cameraUniformParamsMap, camera._shaderValues, uploadCamera);
                         shaderPass._uploadCamera = camera;
                     }
                     var uploadMaterial = (shaderPass._uploadMaterial !== this.material) || switchUpdateMark;
                     if (uploadMaterial || switchShader) {
                         shaderPass.uploadUniforms(shaderPass._materialUniformParamsMap, this.material._shaderValues, uploadMaterial);
                         shaderPass._uploadMaterial = this.material;
                     }
                     var matValues = this.material._shaderValues;
                     if (lastStateMaterial !== this.material || lastStateShaderInstance !== shaderPass) { //lastStateMaterial,lastStateShaderInstance存到全局，多摄像机还可优化
                         shaderPass.uploadRenderStateBlendDepth(matValues);
                         shaderPass.uploadRenderStateFrontFace(matValues, isTarget, this.getInvertFront());
                         lastStateMaterial = this.material;
                         lastStateShaderInstance = shaderPass;
                         lastStateRender = this.render;
                     }
                     else {
                         if (lastStateRender !== this.render) { //TODO:是否可以用transfrom
                             shaderPass.uploadRenderStateFrontFace(matValues, isTarget, this.getInvertFront());
                             lastStateRender = this.render;
                         }
                     }
                     geometry._render(context);
                     shaderPass._uploadMark = updateMark;
                 }
             }
             if (updateRender && this.renderType !== RenderElement.RENDERTYPE_NORMAL)
                 this.render._revertBatchRenderUpdate(context); //还原因合并导致的数据变化
             Camera._updateMark++;
         }
         /**
          * @private
          */
         destroy() {
             this._transform = null;
             this._geometry = null;
             this.material = null;
             this.render = null;
         }
     }
     /** @private */
     RenderElement.RENDERTYPE_NORMAL = 0;
     /** @private */
     RenderElement.RENDERTYPE_STATICBATCH = 1;
     /** @private */
     RenderElement.RENDERTYPE_INSTANCEBATCH = 2;
     /** @private */
     RenderElement.RENDERTYPE_VERTEXBATCH = 3;

     /**
      * @private
      */
     class SubMeshRenderElement extends RenderElement {
         /**
          * 创建一个 <code>SubMeshRenderElement</code> 实例。
          */
         constructor() {
             super();
             this._dynamicWorldPositionNormalNeedUpdate = true;
         }
         /**
          * @private
          */
         _onWorldMatrixChanged() {
             this._dynamicWorldPositionNormalNeedUpdate = true;
         }
         /**
          * @inheritDoc
          */
         _computeWorldPositionsAndNormals(positionOffset, normalOffset, multiSubMesh, vertexCount) {
             if (this._dynamicWorldPositionNormalNeedUpdate) {
                 var subMesh = this._geometry;
                 var vertexBuffer = subMesh._vertexBuffer;
                 var vertexFloatCount = vertexBuffer.vertexDeclaration.vertexStride / 4;
                 var oriVertexes = vertexBuffer.getData();
                 var worldMat = this._transform.worldMatrix;
                 var rotation = this._transform.rotation; //TODO:是否换成矩阵
                 var indices = subMesh._indices;
                 for (var i = 0; i < vertexCount; i++) {
                     var index = multiSubMesh ? indices[i] : i;
                     var oriOffset = index * vertexFloatCount;
                     var bakeOffset = i * 3;
                     Utils3D.transformVector3ArrayToVector3ArrayCoordinate(oriVertexes, oriOffset + positionOffset, worldMat, this._dynamicWorldPositions, bakeOffset);
                     (normalOffset !== -1) && (Utils3D.transformVector3ArrayByQuat(oriVertexes, oriOffset + normalOffset, rotation, this._dynamicWorldNormals, bakeOffset));
                 }
                 this._dynamicWorldPositionNormalNeedUpdate = false;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ setTransform(transform) {
             if (this._transform !== transform) {
                 (this._transform) && (this._transform.off(Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged));
                 (transform) && (transform.on(Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged));
                 this._dynamicWorldPositionNormalNeedUpdate = true;
                 this._transform = transform;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ setGeometry(geometry) {
             if (this._geometry !== geometry) {
                 var subMesh = geometry;
                 var mesh = subMesh._mesh;
                 if (mesh) { //TODO:可能是StaticSubMesh
                     var multiSubMesh = mesh._subMeshCount > 1;
                     var dynBatVerCount = multiSubMesh ? subMesh._indexCount : mesh._vertexCount;
                     if (dynBatVerCount <= ILaya3D.SubMeshDynamicBatch.maxAllowVertexCount) {
                         var length = dynBatVerCount * 3;
                         this._dynamicVertexBatch = true;
                         this._dynamicWorldPositions = new Float32Array(length);
                         this._dynamicWorldNormals = new Float32Array(length);
                         this._dynamicVertexCount = dynBatVerCount;
                         this._dynamicMultiSubMesh = multiSubMesh;
                     }
                     else {
                         this._dynamicVertexBatch = false;
                     }
                 }
                 this._geometry = geometry;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ addToOpaqueRenderQueue(context, queue) {
             var subMeshStaticBatch = this.staticBatch;
             var elements = queue.elements;
             if (subMeshStaticBatch) {
                 var staManager = ILaya3D.MeshRenderStaticBatchManager.instance;
                 var staBatchMarks = staManager.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, subMeshStaticBatch._batchID);
                 if (staManager._updateCountMark === staBatchMarks.updateMark) {
                     var staBatchIndex = staBatchMarks.indexInList;
                     if (staBatchMarks.batched) {
                         elements[staBatchIndex].staticBatchElementList.push(this);
                     }
                     else {
                         var staOriElement = elements[staBatchIndex];
                         var staOriRender = staOriElement.render;
                         var staBatchElement = staManager._getBatchRenderElementFromPool();
                         staBatchElement.renderType = RenderElement.RENDERTYPE_STATICBATCH;
                         staBatchElement.setGeometry(subMeshStaticBatch);
                         staBatchElement.material = staOriElement.material;
                         var staRootOwner = subMeshStaticBatch.batchOwner;
                         var staBatchTransform = staRootOwner ? staRootOwner._transform : null;
                         staBatchElement.setTransform(staBatchTransform);
                         staBatchElement.render = staOriRender;
                         staBatchElement.renderSubShader = staOriElement.renderSubShader;
                         var staBatchList = staBatchElement.staticBatchElementList;
                         staBatchList.length = 0;
                         staBatchList.push(staOriElement);
                         staBatchList.push(this);
                         elements[staBatchIndex] = staBatchElement;
                         staBatchMarks.batched = true;
                     }
                 }
                 else {
                     staBatchMarks.updateMark = staManager._updateCountMark;
                     staBatchMarks.indexInList = elements.length;
                     staBatchMarks.batched = false; //是否已有大于两个的元素可合并
                     elements.push(this);
                 }
             }
             else if (this.renderSubShader._owner._enableInstancing && LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) { //需要支持Instance渲染才可用,暂不支持光照贴图
                 var subMesh = this._geometry;
                 var insManager = ILaya3D.MeshRenderDynamicBatchManager.instance;
                 var insBatchMarks = insManager.getInstanceBatchOpaquaMark(this.render.receiveShadow, this.material.id, subMesh._id, this._transform._isFrontFaceInvert);
                 if (insManager._updateCountMark === insBatchMarks.updateMark) {
                     var insBatchIndex = insBatchMarks.indexInList;
                     if (insBatchMarks.batched) {
                         var instanceBatchElementList = elements[insBatchIndex].instanceBatchElementList;
                         if (instanceBatchElementList.length === SubMeshInstanceBatch.instance.maxInstanceCount) {
                             insBatchMarks.updateMark = insManager._updateCountMark;
                             insBatchMarks.indexInList = elements.length;
                             insBatchMarks.batched = false; //是否已有大于两个的元素可合并
                             elements.push(this);
                         }
                         else {
                             instanceBatchElementList.push(this);
                         }
                     }
                     else {
                         var insOriElement = elements[insBatchIndex];
                         var insOriRender = insOriElement.render;
                         var insBatchElement = insManager._getBatchRenderElementFromPool(); //TODO:是否动态和静态方法可合并
                         insBatchElement.renderType = RenderElement.RENDERTYPE_INSTANCEBATCH;
                         insBatchElement.setGeometry(SubMeshInstanceBatch.instance);
                         insBatchElement.material = insOriElement.material;
                         insBatchElement.setTransform(null);
                         insBatchElement.render = insOriRender;
                         insBatchElement.instanceSubMesh = subMesh;
                         insBatchElement.renderSubShader = insOriElement.renderSubShader;
                         var insBatchList = insBatchElement.instanceBatchElementList;
                         insBatchList.length = 0;
                         insBatchList.push(insOriElement);
                         insBatchList.push(this);
                         elements[insBatchIndex] = insBatchElement;
                         insBatchMarks.batched = true;
                     }
                 }
                 else {
                     insBatchMarks.updateMark = insManager._updateCountMark;
                     insBatchMarks.indexInList = elements.length;
                     insBatchMarks.batched = false; //是否已有大于两个的元素可合并
                     elements.push(this);
                 }
             }
             else if (this._dynamicVertexBatch) {
                 var verDec = this._geometry._vertexBuffer.vertexDeclaration;
                 var dynManager = ILaya3D.MeshRenderDynamicBatchManager.instance;
                 var dynBatchMarks = dynManager.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, verDec.id);
                 if (dynManager._updateCountMark === dynBatchMarks.updateMark) {
                     var dynBatchIndex = dynBatchMarks.indexInList;
                     if (dynBatchMarks.batched) {
                         elements[dynBatchIndex].vertexBatchElementList.push(this);
                     }
                     else {
                         var dynOriElement = elements[dynBatchIndex];
                         var dynOriRender = dynOriElement.render;
                         var dynBatchElement = dynManager._getBatchRenderElementFromPool(); //TODO:是否动态和静态方法可合并
                         dynBatchElement.renderType = RenderElement.RENDERTYPE_VERTEXBATCH;
                         dynBatchElement.setGeometry(ILaya3D.SubMeshDynamicBatch.instance);
                         dynBatchElement.material = dynOriElement.material;
                         dynBatchElement.setTransform(null);
                         dynBatchElement.render = dynOriRender;
                         dynBatchElement.vertexBatchVertexDeclaration = verDec;
                         dynBatchElement.renderSubShader = dynOriElement.renderSubShader;
                         var dynBatchList = dynBatchElement.vertexBatchElementList;
                         dynBatchList.length = 0;
                         dynBatchList.push(dynOriElement);
                         dynBatchList.push(this);
                         elements[dynBatchIndex] = dynBatchElement;
                         dynBatchMarks.batched = true;
                     }
                 }
                 else {
                     dynBatchMarks.updateMark = dynManager._updateCountMark;
                     dynBatchMarks.indexInList = elements.length;
                     dynBatchMarks.batched = false; //是否已有大于两个的元素可合并
                     elements.push(this);
                 }
             }
             else {
                 elements.push(this);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ addToTransparentRenderQueue(context, queue) {
             var subMeshStaticBatch = this.staticBatch;
             var elements = queue.elements;
             if (subMeshStaticBatch) {
                 var staManager = ILaya3D.MeshRenderStaticBatchManager.instance;
                 var staLastElement = queue.lastTransparentRenderElement;
                 if (staLastElement) {
                     var staLastRender = staLastElement.render;
                     if (staLastElement._geometry._getType() !== this._geometry._getType() || staLastElement.staticBatch !== subMeshStaticBatch || staLastElement.material !== this.material || staLastRender.receiveShadow !== this.render.receiveShadow || staLastRender.lightmapIndex !== this.render.lightmapIndex) {
                         elements.push(this);
                         queue.lastTransparentBatched = false;
                     }
                     else {
                         if (queue.lastTransparentBatched) {
                             elements[elements.length - 1].staticBatchElementList.push((this));
                         }
                         else {
                             var staBatchElement = staManager._getBatchRenderElementFromPool();
                             staBatchElement.renderType = RenderElement.RENDERTYPE_STATICBATCH;
                             staBatchElement.setGeometry(subMeshStaticBatch);
                             staBatchElement.material = staLastElement.material;
                             var staRootOwner = subMeshStaticBatch.batchOwner;
                             var staBatchTransform = staRootOwner ? staRootOwner._transform : null;
                             staBatchElement.setTransform(staBatchTransform);
                             staBatchElement.render = this.render;
                             staBatchElement.renderSubShader = staLastElement.renderSubShader;
                             var staBatchList = staBatchElement.staticBatchElementList;
                             staBatchList.length = 0;
                             staBatchList.push(staLastElement);
                             staBatchList.push(this);
                             elements[elements.length - 1] = staBatchElement;
                         }
                         queue.lastTransparentBatched = true;
                     }
                 }
                 else {
                     elements.push(this);
                     queue.lastTransparentBatched = false;
                 }
             }
             else if (this.renderSubShader._owner._enableInstancing && LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) { //需要支持Instance渲染才可用，暂不支持光照贴图
                 var subMesh = this._geometry;
                 var insManager = ILaya3D.MeshRenderDynamicBatchManager.instance;
                 var insLastElement = queue.lastTransparentRenderElement;
                 if (insLastElement) {
                     var insLastRender = insLastElement.render;
                     if (insLastElement._geometry._getType() !== this._geometry._getType() || insLastElement._geometry !== subMesh || insLastElement.material !== this.material || insLastRender.receiveShadow !== this.render.receiveShadow) {
                         elements.push(this);
                         queue.lastTransparentBatched = false;
                     }
                     else {
                         if (queue.lastTransparentBatched) {
                             elements[elements.length - 1].instanceBatchElementList.push((this));
                         }
                         else {
                             var insBatchElement = insManager._getBatchRenderElementFromPool();
                             insBatchElement.renderType = RenderElement.RENDERTYPE_INSTANCEBATCH;
                             insBatchElement.setGeometry(SubMeshInstanceBatch.instance);
                             insBatchElement.material = insLastElement.material;
                             insBatchElement.setTransform(null);
                             insBatchElement.render = this.render;
                             insBatchElement.instanceSubMesh = subMesh;
                             insBatchElement.renderSubShader = insLastElement.renderSubShader;
                             var insBatchList = insBatchElement.instanceBatchElementList;
                             insBatchList.length = 0;
                             insBatchList.push(insLastElement);
                             insBatchList.push(this);
                             elements[elements.length - 1] = insBatchElement;
                         }
                         queue.lastTransparentBatched = true;
                     }
                 }
                 else {
                     elements.push(this);
                     queue.lastTransparentBatched = false;
                 }
             }
             else if (this._dynamicVertexBatch) {
                 var verDec = this._geometry._vertexBuffer.vertexDeclaration;
                 var dynManager = ILaya3D.MeshRenderDynamicBatchManager.instance;
                 var dynLastElement = queue.lastTransparentRenderElement;
                 if (dynLastElement) {
                     var dynLastRender = dynLastElement.render;
                     if (dynLastElement._geometry._getType() !== this._geometry._getType() || dynLastElement._geometry._vertexBuffer._vertexDeclaration !== verDec || dynLastElement.material !== this.material || dynLastRender.receiveShadow !== this.render.receiveShadow || dynLastRender.lightmapIndex !== this.render.lightmapIndex) {
                         elements.push(this);
                         queue.lastTransparentBatched = false;
                     }
                     else {
                         if (queue.lastTransparentBatched) {
                             elements[elements.length - 1].vertexBatchElementList.push((this));
                         }
                         else {
                             var dynBatchElement = dynManager._getBatchRenderElementFromPool();
                             dynBatchElement.renderType = RenderElement.RENDERTYPE_VERTEXBATCH;
                             dynBatchElement.setGeometry(ILaya3D.SubMeshDynamicBatch.instance);
                             dynBatchElement.material = dynLastElement.material;
                             dynBatchElement.setTransform(null);
                             dynBatchElement.render = this.render;
                             dynBatchElement.vertexBatchVertexDeclaration = verDec;
                             dynBatchElement.renderSubShader = dynLastElement.renderSubShader;
                             var dynBatchList = dynBatchElement.vertexBatchElementList;
                             dynBatchList.length = 0;
                             dynBatchList.push(dynLastElement);
                             dynBatchList.push(this);
                             elements[elements.length - 1] = dynBatchElement;
                         }
                         queue.lastTransparentBatched = true;
                     }
                 }
                 else {
                     elements.push(this);
                     queue.lastTransparentBatched = false;
                 }
             }
             else {
                 elements.push(this);
             }
             queue.lastTransparentRenderElement = this;
         }
         getInvertFront() {
             switch (this.renderType) {
                 case RenderElement.RENDERTYPE_NORMAL:
                     return this._transform._isFrontFaceInvert;
                     break;
                 case RenderElement.RENDERTYPE_STATICBATCH:
                 case RenderElement.RENDERTYPE_VERTEXBATCH:
                     return false;
                     break;
                 case RenderElement.RENDERTYPE_INSTANCEBATCH:
                     return this.instanceBatchElementList[0]._transform._isFrontFaceInvert;
                     break;
                     throw "SubMeshRenderElement: unknown renderType";
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy() {
             super.destroy();
             this._dynamicWorldPositions = null;
             this._dynamicWorldNormals = null;
             this.staticBatch = null;
             this.staticBatchElementList = null;
             this.vertexBatchElementList = null;
             this.vertexBatchVertexDeclaration = null;
         }
     }

     /**
      * @private
      * <code>SubMeshStaticBatch</code> 类用于网格静态合并。
      */
     class SubMeshStaticBatch extends GeometryElement {
         /**
          * 创建一个 <code>SubMeshStaticBatch</code> 实例。
          */
         constructor(batchOwner, number, vertexDeclaration) {
             super();
             /** @private */
             this._bufferState = new BufferState();
             this._batchID = SubMeshStaticBatch._batchIDCounter++;
             this._batchElements = [];
             this._currentBatchVertexCount = 0;
             this._currentBatchIndexCount = 0;
             this._vertexDeclaration = vertexDeclaration;
             this.batchOwner = batchOwner;
             this.number = number;
         }
         /**
          * @private
          */
         _getStaticBatchBakedVertexs(batchVertices, batchOffset, batchOwnerTransform, transform, render, mesh) {
             var vertexBuffer = mesh._vertexBuffers[0];
             var vertexDeclaration = vertexBuffer.vertexDeclaration;
             var positionOffset = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_POSITION0).offset / 4;
             var normalElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_NORMAL0);
             var normalOffset = normalElement ? normalElement.offset / 4 : -1;
             var colorElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_COLOR0);
             var colorOffset = colorElement ? colorElement.offset / 4 : -1;
             var uv0Element = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE0);
             var uv0Offset = uv0Element ? uv0Element.offset / 4 : -1;
             var uv1Element = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE1);
             var uv1Offset = uv1Element ? uv1Element.offset / 4 : -1;
             var tangentElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TANGENT0);
             var sTangentOffset = tangentElement ? tangentElement.offset / 4 : -1;
             var bakeVertexFloatCount = 18;
             var oriVertexFloatCount = vertexDeclaration.vertexStride / 4;
             var oriVertexes = vertexBuffer.getData();
             var worldMat;
             if (batchOwnerTransform) {
                 var rootMat = batchOwnerTransform.worldMatrix;
                 rootMat.invert(SubMeshStaticBatch._tempMatrix4x40);
                 worldMat = SubMeshStaticBatch._tempMatrix4x41;
                 Matrix4x4.multiply(SubMeshStaticBatch._tempMatrix4x40, transform.worldMatrix, worldMat);
             }
             else {
                 worldMat = transform.worldMatrix;
             }
             var rotation = SubMeshStaticBatch._tempQuaternion0;
             worldMat.decomposeTransRotScale(SubMeshStaticBatch._tempVector30, rotation, SubMeshStaticBatch._tempVector31); //可不计算position和scale	
             var lightmapScaleOffset = render.lightmapScaleOffset;
             var vertexCount = mesh.vertexCount;
             for (var i = 0; i < vertexCount; i++) {
                 var oriOffset = i * oriVertexFloatCount;
                 var bakeOffset = (i + batchOffset) * bakeVertexFloatCount;
                 Utils3D.transformVector3ArrayToVector3ArrayCoordinate(oriVertexes, oriOffset + positionOffset, worldMat, batchVertices, bakeOffset + 0);
                 if (normalOffset !== -1)
                     Utils3D.transformVector3ArrayByQuat(oriVertexes, oriOffset + normalOffset, rotation, batchVertices, bakeOffset + 3);
                 var j, m;
                 var bakOff = bakeOffset + 6;
                 if (colorOffset !== -1) {
                     var oriOff = oriOffset + colorOffset;
                     for (j = 0, m = 4; j < m; j++)
                         batchVertices[bakOff + j] = oriVertexes[oriOff + j];
                 }
                 else {
                     for (j = 0, m = 4; j < m; j++)
                         batchVertices[bakOff + j] = 1.0;
                 }
                 if (uv0Offset !== -1) {
                     var absUv0Offset = oriOffset + uv0Offset;
                     batchVertices[bakeOffset + 10] = oriVertexes[absUv0Offset];
                     batchVertices[bakeOffset + 11] = oriVertexes[absUv0Offset + 1];
                 }
                 if (lightmapScaleOffset) {
                     if (uv1Offset !== -1)
                         Utils3D.transformLightingMapTexcoordArray(oriVertexes, oriOffset + uv1Offset, lightmapScaleOffset, batchVertices, bakeOffset + 12);
                     else
                         Utils3D.transformLightingMapTexcoordArray(oriVertexes, oriOffset + uv0Offset, lightmapScaleOffset, batchVertices, bakeOffset + 12);
                 }
                 if (sTangentOffset !== -1) {
                     var absSTanegntOffset = oriOffset + sTangentOffset;
                     batchVertices[bakeOffset + 14] = oriVertexes[absSTanegntOffset];
                     batchVertices[bakeOffset + 15] = oriVertexes[absSTanegntOffset + 1];
                     batchVertices[bakeOffset + 16] = oriVertexes[absSTanegntOffset + 2];
                     batchVertices[bakeOffset + 17] = oriVertexes[absSTanegntOffset + 3];
                 }
             }
             return vertexCount;
         }
         /**
          * @private
          */
         addTest(sprite) {
             var vertexCount;
             var subMeshVertexCount = sprite.meshFilter.sharedMesh.vertexCount;
             vertexCount = this._currentBatchVertexCount + subMeshVertexCount;
             if (vertexCount > SubMeshStaticBatch.maxBatchVertexCount)
                 return false;
             return true;
         }
         /**
          * @private
          */
         add(sprite) {
             var oldStaticBatch = sprite._render._staticBatch;
             (oldStaticBatch) && (oldStaticBatch.remove(sprite)); //重复合并需要从旧的staticBatch移除
             var mesh = sprite.meshFilter.sharedMesh;
             var subMeshVertexCount = mesh.vertexCount;
             this._batchElements.push(sprite);
             var render = sprite._render;
             render._isPartOfStaticBatch = true;
             render._staticBatch = this;
             var renderElements = render._renderElements;
             for (var i = 0, n = renderElements.length; i < n; i++)
                 renderElements[i].staticBatch = this;
             this._currentBatchIndexCount += mesh._indexBuffer.indexCount;
             this._currentBatchVertexCount += subMeshVertexCount;
         }
         /**
          * @private
          */
         remove(sprite) {
             var mesh = sprite.meshFilter.sharedMesh;
             var index = this._batchElements.indexOf(sprite);
             if (index !== -1) {
                 this._batchElements.splice(index, 1);
                 var render = sprite._render;
                 var renderElements = sprite._render._renderElements;
                 for (var i = 0, n = renderElements.length; i < n; i++)
                     renderElements[i].staticBatch = null;
                 var meshVertexCount = mesh.vertexCount;
                 this._currentBatchIndexCount = this._currentBatchIndexCount - mesh._indexBuffer.indexCount;
                 this._currentBatchVertexCount = this._currentBatchVertexCount - meshVertexCount;
                 sprite._render._isPartOfStaticBatch = false;
             }
         }
         /**
          * @private
          */
         finishInit() {
             if (this._vertexBuffer) {
                 this._vertexBuffer.destroy();
                 this._indexBuffer.destroy();
                 Resource._addGPUMemory(-(this._vertexBuffer._byteLength + this._indexBuffer._byteLength));
             }
             var batchVertexCount = 0;
             var batchIndexCount = 0;
             var rootOwner = this.batchOwner;
             var floatStride = this._vertexDeclaration.vertexStride / 4;
             var vertexDatas = new Float32Array(floatStride * this._currentBatchVertexCount);
             var indexDatas = new Uint16Array(this._currentBatchIndexCount);
             this._vertexBuffer = new VertexBuffer3D(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount, WebGLContext.STATIC_DRAW);
             this._vertexBuffer.vertexDeclaration = this._vertexDeclaration;
             this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, this._currentBatchIndexCount, WebGLContext.STATIC_DRAW);
             for (var i = 0, n = this._batchElements.length; i < n; i++) {
                 var sprite = this._batchElements[i];
                 var mesh = sprite.meshFilter.sharedMesh;
                 var meshVerCount = this._getStaticBatchBakedVertexs(vertexDatas, batchVertexCount, rootOwner ? rootOwner._transform : null, sprite._transform, sprite._render, mesh);
                 var indices = mesh._indexBuffer.getData();
                 var indexOffset = batchVertexCount;
                 var indexEnd = batchIndexCount + indices.length; //TODO:indexStartCount和Index
                 var elements = sprite._render._renderElements;
                 for (var j = 0, m = mesh.subMeshCount; j < m; j++) {
                     var subMesh = mesh._subMeshes[j];
                     var start = batchIndexCount + subMesh._indexStart;
                     var element = elements[j];
                     element.staticBatchIndexStart = start;
                     element.staticBatchIndexEnd = start + subMesh._indexCount;
                 }
                 indexDatas.set(indices, batchIndexCount); //TODO:换成函数和动态合并一样
                 var k;
                 var isInvert = rootOwner ? (sprite._transform._isFrontFaceInvert !== rootOwner.transform._isFrontFaceInvert) : sprite._transform._isFrontFaceInvert;
                 if (isInvert) {
                     for (k = batchIndexCount; k < indexEnd; k += 3) {
                         indexDatas[k] = indexOffset + indexDatas[k];
                         var index1 = indexDatas[k + 1];
                         var index2 = indexDatas[k + 2];
                         indexDatas[k + 1] = indexOffset + index2;
                         indexDatas[k + 2] = indexOffset + index1;
                     }
                 }
                 else {
                     for (k = batchIndexCount; k < indexEnd; k += 3) {
                         indexDatas[k] = indexOffset + indexDatas[k];
                         indexDatas[k + 1] = indexOffset + indexDatas[k + 1];
                         indexDatas[k + 2] = indexOffset + indexDatas[k + 2];
                     }
                 }
                 batchIndexCount += indices.length;
                 batchVertexCount += meshVerCount;
             }
             this._vertexBuffer.setData(vertexDatas);
             this._indexBuffer.setData(indexDatas);
             var memorySize = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
             Resource._addGPUMemory(memorySize);
             this._bufferState.bind();
             this._bufferState.applyVertexBuffer(this._vertexBuffer);
             this._bufferState.applyIndexBuffer(this._indexBuffer);
             this._bufferState.unBind();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _render(state) {
             this._bufferState.bind();
             var element = state.renderElement;
             var batchElementList = element.staticBatchElementList;
             /*合并drawcall版本:合并几率不大*/
             var from = 0;
             var end = 0;
             var count = batchElementList.length;
             for (var i = 1; i < count; i++) {
                 var lastElement = batchElementList[i - 1];
                 if (lastElement.staticBatchIndexEnd === batchElementList[i].staticBatchIndexStart) {
                     end++;
                     continue;
                 }
                 else {
                     var start = batchElementList[from].staticBatchIndexStart;
                     var indexCount = batchElementList[end].staticBatchIndexEnd - start;
                     LayaGL.instance.drawElements(WebGLContext.TRIANGLES, indexCount, WebGLContext.UNSIGNED_SHORT, start * 2);
                     from = ++end;
                     Stat.trianglesFaces += indexCount / 3;
                 }
             }
             start = batchElementList[from].staticBatchIndexStart;
             indexCount = batchElementList[end].staticBatchIndexEnd - start;
             LayaGL.instance.drawElements(WebGLContext.TRIANGLES, indexCount, WebGLContext.UNSIGNED_SHORT, start * 2);
             Stat.renderBatches++;
             Stat.savedRenderBatches += count - 1;
             Stat.trianglesFaces += indexCount / 3;
             /*暴力循环版本:drawcall调用次数有浪费
                //for (var i:int = 0, n:int = batchElementList.length; i < n; i++) {
                //var element:SubMeshRenderElement = batchElementList[i];
                //var start:int = element.staticBatchIndexStart;
                //var indexCount:int = element.staticBatchIndexEnd - start;
                //LayaGL.instance.drawElements(WebGLContext.TRIANGLES, indexCount, WebGLContext.UNSIGNED_SHORT, start * 2);
                //Stat.drawCall++;
                //Stat.trianglesFaces += indexCount / 3;
                //}
              */
         }
         /**
          * @private
          */
         dispose() {
             var memorySize = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
             Resource._addGPUMemory(-memorySize);
             this._batchElements = null;
             this.batchOwner = null;
             this._vertexDeclaration = null;
             this._bufferState.destroy();
             this._vertexBuffer.destroy();
             this._indexBuffer.destroy();
             this._vertexBuffer = null;
             this._indexBuffer = null;
             this._bufferState = null;
         }
     }
     /** @private */
     SubMeshStaticBatch._tempVector30 = new Vector3();
     /** @private */
     SubMeshStaticBatch._tempVector31 = new Vector3();
     /** @private */
     SubMeshStaticBatch._tempQuaternion0 = new Quaternion();
     /** @private */
     SubMeshStaticBatch._tempMatrix4x40 = new Matrix4x4();
     /** @private */
     SubMeshStaticBatch._tempMatrix4x41 = new Matrix4x4();
     /** @private */
     SubMeshStaticBatch.maxBatchVertexCount = 65535;
     /** @private */
     SubMeshStaticBatch._batchIDCounter = 0;

     /**
      * @private
      * <code>MeshSprite3DStaticBatchManager</code> 类用于网格精灵静态批处理管理。
      */
     class MeshRenderStaticBatchManager extends StaticBatchManager {
         /**
          * 创建一个 <code>MeshSprite3DStaticBatchManager</code> 实例。
          */
         constructor() {
             super();
             /**@private */
             this._opaqueBatchMarks = [];
             this._updateCountMark = 0;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _compare(left, right) {
             //按照合并条件排序，增加初始状态合并几率
             var lRender = left._render, rRender = right._render;
             var leftGeo = left.meshFilter.sharedMesh, rightGeo = right.meshFilter.sharedMesh;
             var lightOffset = lRender.lightmapIndex - rRender.lightmapIndex;
             if (lightOffset === 0) {
                 var receiveShadowOffset = (lRender.receiveShadow ? 1 : 0) - (rRender.receiveShadow ? 1 : 0);
                 if (receiveShadowOffset === 0) {
                     var materialOffset = lRender.sharedMaterial.id - rRender.sharedMaterial.id; //多维子材质以第一个材质排序
                     if (materialOffset === 0) {
                         var verDec = leftGeo._vertexBuffers[0].vertexDeclaration.id - rightGeo._vertexBuffers[0].vertexDeclaration.id; //TODO:以第一个Buffer为主,后期是否修改VB机制
                         if (verDec === 0) {
                             return rightGeo._indexBuffer.indexCount - leftGeo._indexBuffer.indexCount; //根据三角面排序
                         }
                         else {
                             return verDec;
                         }
                     }
                     else {
                         return materialOffset;
                     }
                 }
                 else {
                     return receiveShadowOffset;
                 }
             }
             else {
                 return lightOffset;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getBatchRenderElementFromPool() {
             var renderElement = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
             if (!renderElement) {
                 renderElement = new SubMeshRenderElement();
                 this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = renderElement;
                 renderElement.staticBatchElementList = [];
             }
             return renderElement;
         }
         /**
          * @private
          */
         _getStaticBatch(rootOwner, number) {
             var key = rootOwner ? rootOwner.id : 0;
             var batchOwner = this._staticBatches[key];
             (batchOwner) || (batchOwner = this._staticBatches[key] = []);
             return (batchOwner[number]) || (batchOwner[number] = new SubMeshStaticBatch(rootOwner, number, MeshRenderStaticBatchManager._verDec));
         }
         /**
          * @inheritDoc
          */
         /*override*/ _initStaticBatchs(rootOwner) {
             this._quickSort(this._initBatchSprites, 0, this._initBatchSprites.length - 1);
             var lastCanMerage = false;
             var curStaticBatch;
             var batchNumber = 0;
             for (var i = 0, n = this._initBatchSprites.length; i < n; i++) {
                 var sprite = this._initBatchSprites[i];
                 if (lastCanMerage) {
                     if (curStaticBatch.addTest(sprite)) {
                         curStaticBatch.add(sprite);
                     }
                     else {
                         lastCanMerage = false;
                         batchNumber++; //修改编号，区分批处理
                     }
                 }
                 else {
                     var lastIndex = n - 1;
                     if (i !== lastIndex) {
                         curStaticBatch = this._getStaticBatch(rootOwner, batchNumber);
                         curStaticBatch.add(sprite);
                         lastCanMerage = true;
                     }
                 }
             }
             for (var key in this._staticBatches) {
                 var batches = this._staticBatches[key];
                 for (i = 0, n = batches.length; i < n; i++)
                     batches[i].finishInit();
             }
             this._initBatchSprites.length = 0;
         }
         /**
          * @private
          */
         _destroyRenderSprite(sprite) {
             var staticBatch = sprite._render._staticBatch;
             staticBatch.remove(sprite);
             if (staticBatch._batchElements.length === 0) {
                 var owner = staticBatch.batchOwner;
                 var ownerID = owner ? owner.id : 0;
                 var batches = this._staticBatches[ownerID];
                 batches[staticBatch.number] = null;
                 staticBatch.dispose();
                 var empty = true;
                 for (var i = 0; i < batches.length; i++) {
                     if (batches[i])
                         empty = false;
                 }
                 if (empty) {
                     delete this._staticBatches[ownerID];
                 }
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _clear() {
             super._clear();
             this._updateCountMark++;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _garbageCollection() {
             for (var key in this._staticBatches) {
                 var batches = this._staticBatches[key];
                 for (var i = 0, n = batches.length; i < n; i++) {
                     var staticBatch = batches[i];
                     if (staticBatch._batchElements.length === 0) {
                         staticBatch.dispose();
                         batches.splice(i, 1);
                         i--, n--;
                         if (n === 0)
                             delete this._staticBatches[key];
                     }
                 }
             }
         }
         /**
          * @private
          */
         getBatchOpaquaMark(lightMapIndex, receiveShadow, materialID, staticBatchID) {
             var receiveShadowIndex = receiveShadow ? 1 : 0;
             var staLightMapMarks = (this._opaqueBatchMarks[lightMapIndex]) || (this._opaqueBatchMarks[lightMapIndex] = []);
             var staReceiveShadowMarks = (staLightMapMarks[receiveShadowIndex]) || (staLightMapMarks[receiveShadowIndex] = []);
             var staMaterialMarks = (staReceiveShadowMarks[materialID]) || (staReceiveShadowMarks[materialID] = []);
             return (staMaterialMarks[staticBatchID]) || (staMaterialMarks[staticBatchID] = new BatchMark);
         }
     }
     /** @private */
     MeshRenderStaticBatchManager._verDec = VertexMesh.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
     /** @private */
     MeshRenderStaticBatchManager.instance = new MeshRenderStaticBatchManager();

     /**
      * <code>BaseMaterial</code> 类用于创建材质。
      */
     class BaseMaterial extends Resource {
         /**
          * 创建一个 <code>BaseMaterial</code> 实例。
          */
         constructor() {
             super();
             /** @private */
             this._shaderValues = null; //TODO:剥离贴图ShaderValue
             this._disablePublicDefineDatas = new DefineDatas();
             this._shaderValues = new ShaderData(this);
             this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE;
             this._alphaTest = false;
         }
         /**
          * 加载材质。
          * @param url 材质地址。
          * @param complete 完成回掉。
          */
         static load(url, complete) {
             Laya.loader.create(url, complete, null, BaseMaterial.MATERIAL);
         }
         /**
          * @private
          */
         static __initDefine__() {
             BaseMaterial.shaderDefines = new ShaderDefines();
             BaseMaterial.SHADERDEFINE_ALPHATEST = BaseMaterial.shaderDefines.registerDefine("ALPHATEST");
         }
         /**
          * @inheritDoc
          */
         static _parse(data, propertyParams = null, constructParams = null) {
             var jsonData = data;
             var props = jsonData.props;
             var material;
             var classType = props.type;
             //var clasPaths: any[] = classType.split('.');
             //var clas: new () => any = Browser.window;
             //clasPaths.forEach(function (cls: any): void {
             //	clas = clas[cls];
             //});
             var clas = ClassUtils.getRegClass(classType);
             if (clas)
                 material = new clas();
             else
                 throw ('_getSprite3DHierarchyInnerUrls 错误: ' + data.type + ' 不是类');
             switch (jsonData.version) {
                 case "LAYAMATERIAL:01":
                 case "LAYAMATERIAL:02":
                     var i, n;
                     for (var key in props) {
                         switch (key) {
                             case "vectors":
                                 var vectors = props[key];
                                 for (i = 0, n = vectors.length; i < n; i++) {
                                     var vector = vectors[i];
                                     var vectorValue = vector.value;
                                     switch (vectorValue.length) {
                                         case 2:
                                             material[vector.name] = new Vector2(vectorValue[0], vectorValue[1]);
                                             break;
                                         case 3:
                                             material[vector.name] = new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]);
                                             break;
                                         case 4:
                                             material[vector.name] = new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                             break;
                                         default:
                                             throw new Error("BaseMaterial:unkonwn color length.");
                                     }
                                 }
                                 break;
                             case "textures":
                                 var textures = props[key];
                                 for (i = 0, n = textures.length; i < n; i++) {
                                     var texture = textures[i];
                                     var path = texture.path;
                                     (path) && (material[texture.name] = Loader.getRes(path));
                                 }
                                 break;
                             case "defines":
                                 var defineNames = props[key];
                                 for (i = 0, n = defineNames.length; i < n; i++) {
                                     var define = material._shader.getSubShaderAt(0).getMaterialDefineByName(defineNames[i]); //TODO:是否取消defines
                                     material._shaderValues.addDefine(define);
                                 }
                                 break;
                             case "renderStates": //"LAYAMATERIAL:02" 
                                 var renderStatesData = props[key];
                                 var renderStateData = renderStatesData[0];
                                 var mat = material; //TODO:临时兼容
                                 mat.blend = renderStateData.blend;
                                 mat.cull = renderStateData.cull;
                                 mat.depthTest = renderStateData.depthTest;
                                 mat.depthWrite = renderStateData.depthWrite;
                                 mat.blendSrc = renderStateData.srcBlend;
                                 mat.blendDst = renderStateData.dstBlend;
                                 break;
                             case "cull": //"LAYAMATERIAL:01"
                                 material.cull = props[key];
                                 break;
                             case "blend": //"LAYAMATERIAL:01"
                                 material.blend = props[key];
                                 break;
                             case "depthWrite": //"LAYAMATERIAL:01" 
                                 material.depthWrite = props[key];
                                 break;
                             case "srcBlend": //"LAYAMATERIAL:01" 
                                 material.blendSrc = props[key];
                                 break;
                             case "dstBlend": //"LAYAMATERIAL:01" 
                                 material.blendDst = props[key];
                                 break;
                             default:
                                 material[key] = props[key];
                         }
                     }
                     break;
                 default:
                     throw new Error("BaseMaterial:unkonwn version.");
             }
             return material;
         }
         /**
          * 获取透明测试模式裁剪值。
          * @return 透明测试模式裁剪值。
          */
         get alphaTestValue() {
             return this._shaderValues.getNumber(BaseMaterial.ALPHATESTVALUE);
         }
         /**
          * 设置透明测试模式裁剪值。
          * @param value 透明测试模式裁剪值。
          */
         set alphaTestValue(value) {
             this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE, value);
         }
         /**
          * 获取是否透明裁剪。
          * @return 是否透明裁剪。
          */
         get alphaTest() {
             return this._alphaTest;
         }
         /**
          * 设置是否透明裁剪。
          * @param value 是否透明裁剪。
          */
         set alphaTest(value) {
             this._alphaTest = value;
             if (value)
                 this._shaderValues.addDefine(BaseMaterial.SHADERDEFINE_ALPHATEST);
             else
                 this._shaderValues.removeDefine(BaseMaterial.SHADERDEFINE_ALPHATEST);
         }
         /**
          * @private
          */
         _removeTetxureReference() {
             var data = this._shaderValues.getData();
             for (var k in data) {
                 var value = data[k];
                 if (value && value instanceof BaseTexture) //TODO:需要优化,杜绝is判断，慢
                     value._removeReference();
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _addReference(count = 1) {
             super._addReference(count);
             var data = this._shaderValues.getData();
             for (var k in data) {
                 var value = data[k];
                 if (value && value instanceof BaseTexture) //TODO:需要优化,杜绝is判断，慢
                     value._addReference();
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _removeReference(count = 1) {
             super._removeReference(count);
             this._removeTetxureReference();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _disposeResource() {
             if (this._referenceCount > 0)
                 this._removeTetxureReference();
             this._shaderValues = null;
         }
         /**
          * 设置使用Shader名字。
          * @param name 名称。
          */
         setShaderName(name) {
             this._shader = Shader3D.find(name);
             if (!this._shader)
                 throw new Error("BaseMaterial: unknown shader name.");
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destBaseMaterial = destObject;
             destBaseMaterial.name = this.name;
             destBaseMaterial.renderQueue = this.renderQueue;
             this._disablePublicDefineDatas.cloneTo(destBaseMaterial._disablePublicDefineDatas);
             this._shaderValues.cloneTo(destBaseMaterial._shaderValues);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new BaseMaterial();
             this.cloneTo(dest);
             return dest;
         }
         //--------------------------------------------兼容-------------------------------------------------
         get _defineDatas() {
             return this._shaderValues._defineDatas;
         }
     }
     /**Material资源。*/
     BaseMaterial.MATERIAL = "MATERIAL";
     /** 渲染队列_不透明。*/
     BaseMaterial.RENDERQUEUE_OPAQUE = 2000;
     /** 渲染队列_阿尔法裁剪。*/
     BaseMaterial.RENDERQUEUE_ALPHATEST = 2450;
     /** 渲染队列_透明。*/
     BaseMaterial.RENDERQUEUE_TRANSPARENT = 3000;
     /**@private 着色器变量,透明测试值。*/
     BaseMaterial.ALPHATESTVALUE = Shader3D.propertyNameToID("u_AlphaTestValue");
     /**@private */
     BaseMaterial.shaderDefines = null;

     /**
      * <code>RenderState</code> 类用于控制渲染状态。
      */
     class RenderState {
         /**
          * 创建一个 <code>RenderState</code> 实例。
          */
         constructor() {
             this.cull = RenderState.CULL_BACK;
             this.blend = RenderState.BLEND_DISABLE;
             this.srcBlend = RenderState.BLENDPARAM_ONE;
             this.dstBlend = RenderState.BLENDPARAM_ZERO;
             this.srcBlendRGB = RenderState.BLENDPARAM_ONE;
             this.dstBlendRGB = RenderState.BLENDPARAM_ZERO;
             this.srcBlendAlpha = RenderState.BLENDPARAM_ONE;
             this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO;
             this.blendConstColor = new Vector4(1, 1, 1, 1);
             this.blendEquation = RenderState.BLENDEQUATION_ADD;
             this.blendEquationRGB = RenderState.BLENDEQUATION_ADD;
             this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD;
             this.depthTest = RenderState.DEPTHTEST_LEQUAL;
             this.depthWrite = true;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(dest) {
             var destState = dest;
             destState.cull = this.cull;
             destState.blend = this.blend;
             destState.srcBlend = this.srcBlend;
             destState.dstBlend = this.dstBlend;
             destState.srcBlendRGB = this.srcBlendRGB;
             destState.dstBlendRGB = this.dstBlendRGB;
             destState.srcBlendAlpha = this.srcBlendAlpha;
             destState.dstBlendAlpha = this.dstBlendAlpha;
             this.blendConstColor.cloneTo(destState.blendConstColor);
             destState.blendEquation = this.blendEquation;
             destState.blendEquationRGB = this.blendEquationRGB;
             destState.blendEquationAlpha = this.blendEquationAlpha;
             destState.depthTest = this.depthTest;
             destState.depthWrite = this.depthWrite;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new RenderState();
             this.cloneTo(dest);
             return dest;
         }
     }
     /**剔除枚举_不剔除。*/
     RenderState.CULL_NONE = 0;
     /**剔除枚举_剔除正面。*/
     RenderState.CULL_FRONT = 1;
     /**剔除枚举_剔除背面。*/
     RenderState.CULL_BACK = 2;
     /**混合枚举_禁用。*/
     RenderState.BLEND_DISABLE = 0;
     /**混合枚举_启用_RGB和Alpha统一混合。*/
     RenderState.BLEND_ENABLE_ALL = 1;
     /**混合枚举_启用_RGB和Alpha单独混合。*/
     RenderState.BLEND_ENABLE_SEPERATE = 2;
     /**混合参数枚举_零,例：RGB(0,0,0),Alpha:(1)。*/
     RenderState.BLENDPARAM_ZERO = 0;
     /**混合参数枚举_一,例：RGB(1,1,1),Alpha:(1)。*/
     RenderState.BLENDPARAM_ONE = 1;
     /**混合参数枚举_源颜色,例：RGB(Rs, Gs, Bs)，Alpha(As)。*/
     RenderState.BLENDPARAM_SRC_COLOR = 0x0300;
     /**混合参数枚举_一减源颜色,例：RGB(1-Rs, 1-Gs, 1-Bs)，Alpha(1-As)。*/
     RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR = 0x0301;
     /**混合参数枚举_目标颜色,例：RGB(Rd, Gd, Bd),Alpha(Ad)。*/
     RenderState.BLENDPARAM_DST_COLOR = 0x0306;
     /**混合参数枚举_一减目标颜色,例：RGB(1-Rd, 1-Gd, 1-Bd)，Alpha(1-Ad)。*/
     RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR = 0x0307;
     /**混合参数枚举_源透明,例:RGB(As, As, As),Alpha(1-As)。*/
     RenderState.BLENDPARAM_SRC_ALPHA = 0x0302;
     /**混合参数枚举_一减源阿尔法,例:RGB(1-As, 1-As, 1-As),Alpha(1-As)。*/
     RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 0x0303;
     /**混合参数枚举_目标阿尔法，例：RGB(Ad, Ad, Ad),Alpha(Ad)。*/
     RenderState.BLENDPARAM_DST_ALPHA = 0x0304;
     /**混合参数枚举_一减目标阿尔法,例：RGB(1-Ad, 1-Ad, 1-Ad),Alpha(Ad)。*/
     RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA = 0x0305;
     /**混合参数枚举_阿尔法饱和，例：RGB(min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad)),Alpha(1)。*/
     RenderState.BLENDPARAM_SRC_ALPHA_SATURATE = 0x0308;
     /**混合方程枚举_加法,例：source + destination*/
     RenderState.BLENDEQUATION_ADD = 0;
     /**混合方程枚举_减法，例：source - destination*/
     RenderState.BLENDEQUATION_SUBTRACT = 1;
     /**混合方程枚举_反序减法，例：destination - source*/
     RenderState.BLENDEQUATION_REVERSE_SUBTRACT = 2;
     /**深度测试函数枚举_关闭深度测试。*/
     RenderState.DEPTHTEST_OFF = 0 /*WebGLContext.NEVER*/; //TODO:什么鬼
     /**深度测试函数枚举_从不通过。*/
     RenderState.DEPTHTEST_NEVER = 0x0200 /*WebGLContext.NEVER*/;
     /**深度测试函数枚举_小于时通过。*/
     RenderState.DEPTHTEST_LESS = 0x0201 /*WebGLContext.LESS*/;
     /**深度测试函数枚举_等于时通过。*/
     RenderState.DEPTHTEST_EQUAL = 0x0202 /*WebGLContext.EQUAL*/;
     /**深度测试函数枚举_小于等于时通过。*/
     RenderState.DEPTHTEST_LEQUAL = 0x0203 /*WebGLContext.LEQUAL*/;
     /**深度测试函数枚举_大于时通过。*/
     RenderState.DEPTHTEST_GREATER = 0x0204 /*WebGLContext.GREATER*/;
     /**深度测试函数枚举_不等于时通过。*/
     RenderState.DEPTHTEST_NOTEQUAL = 0x0205 /*WebGLContext.NOTEQUAL*/;
     /**深度测试函数枚举_大于等于时通过。*/
     RenderState.DEPTHTEST_GEQUAL = 0x0206 /*WebGLContext.GEQUAL*/;
     /**深度测试函数枚举_总是通过。*/
     RenderState.DEPTHTEST_ALWAYS = 0x0207 /*WebGLContext.ALWAYS*/;

     /**
      * <code>BlinnPhongMaterial</code> 类用于实现Blinn-Phong材质。
      */
     class BlinnPhongMaterial extends BaseMaterial {
         /**
          * 创建一个 <code>BlinnPhongMaterial</code> 实例。
          */
         constructor() {
             super();
             /**@private */
             this._enableVertexColor = false;
             this.setShaderName("BLINNPHONG");
             this._albedoIntensity = 1.0;
             this._albedoColor = new Vector4(1.0, 1.0, 1.0, 1.0);
             var sv = this._shaderValues;
             sv.setVector(BlinnPhongMaterial.ALBEDOCOLOR, new Vector4(1.0, 1.0, 1.0, 1.0));
             sv.setVector(BlinnPhongMaterial.MATERIALSPECULAR, new Vector4(1.0, 1.0, 1.0, 1.0));
             sv.setNumber(BlinnPhongMaterial.SHININESS, 0.078125);
             sv.setNumber(BaseMaterial.ALPHATESTVALUE, 0.5);
             sv.setVector(BlinnPhongMaterial.TILINGOFFSET, new Vector4(1.0, 1.0, 0.0, 0.0));
             this._enableLighting = true;
             this.renderMode = BlinnPhongMaterial.RENDERMODE_OPAQUE;
         }
         /**
          * @private
          */
         static __initDefine__() {
             BlinnPhongMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = BlinnPhongMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
             BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = BlinnPhongMaterial.shaderDefines.registerDefine("NORMALMAP");
             BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = BlinnPhongMaterial.shaderDefines.registerDefine("SPECULARMAP");
             BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET = BlinnPhongMaterial.shaderDefines.registerDefine("TILINGOFFSET");
             BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = BlinnPhongMaterial.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
         }
         /**
          * @private
          */
         get _ColorR() {
             return this._albedoColor.x;
         }
         /**
          * @private
          */
         set _ColorR(value) {
             this._albedoColor.x = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorG() {
             return this._albedoColor.y;
         }
         /**
          * @private
          */
         set _ColorG(value) {
             this._albedoColor.y = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorB() {
             return this._albedoColor.z;
         }
         /**
          * @private
          */
         set _ColorB(value) {
             this._albedoColor.z = value;
             this.albedoColor = this._albedoColor;
         }
         /**@private */
         get _ColorA() {
             return this._albedoColor.w;
         }
         /**
          * @private
          */
         set _ColorA(value) {
             this._albedoColor.w = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _SpecColorR() {
             return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x;
         }
         /**
          * @private
          */
         set _SpecColorR(value) {
             this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x = value;
         }
         /**
          * @private
          */
         get _SpecColorG() {
             return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y;
         }
         /**
          * @private
          */
         set _SpecColorG(value) {
             this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y = value;
         }
         /**
          * @private
          */
         get _SpecColorB() {
             return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z;
         }
         /**
          * @private
          */
         set _SpecColorB(value) {
             this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z = value;
         }
         /**
          * @private
          */
         get _SpecColorA() {
             return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w;
         }
         /**
          * @private
          */
         set _SpecColorA(value) {
             this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w = value;
         }
         /**
          * @private
          */
         get _AlbedoIntensity() {
             return this._albedoIntensity;
         }
         /**
          * @private
          */
         set _AlbedoIntensity(value) {
             if (this._albedoIntensity !== value) {
                 var finalAlbedo = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                 Vector4.scale(this._albedoColor, value, finalAlbedo);
                 this._albedoIntensity = value;
                 this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, finalAlbedo); //修改值后必须调用此接口,否则NATIVE不生效
             }
         }
         /**
          * @private
          */
         get _Shininess() {
             return this._shaderValues.getNumber(BlinnPhongMaterial.SHININESS);
         }
         /**
          * @private
          */
         set _Shininess(value) {
             value = Math.max(0.0, Math.min(1.0, value));
             this._shaderValues.setNumber(BlinnPhongMaterial.SHININESS, value);
         }
         /**
          * @private
          */
         get _MainTex_STX() {
             return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).x;
         }
         /**
          * @private
          */
         set _MainTex_STX(x) {
             var tilOff = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
             tilOff.x = x;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STY() {
             return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).y;
         }
         /**
          * @private
          */
         set _MainTex_STY(y) {
             var tilOff = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
             tilOff.y = y;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STZ() {
             return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).z;
         }
         /**
          * @private
          */
         set _MainTex_STZ(z) {
             var tilOff = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
             tilOff.z = z;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STW() {
             return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).w;
         }
         /**
          * @private
          */
         set _MainTex_STW(w) {
             var tilOff = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
             tilOff.w = w;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _Cutoff() {
             return this.alphaTestValue;
         }
         /**
          * @private
          */
         set _Cutoff(value) {
             this.alphaTestValue = value;
         }
         /**
          * 设置渲染模式。
          * @return 渲染模式。
          */
         set renderMode(value) {
             switch (value) {
                 case BlinnPhongMaterial.RENDERMODE_OPAQUE:
                     this.alphaTest = false;
                     this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE;
                     this.depthWrite = true;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_DISABLE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     break;
                 case BlinnPhongMaterial.RENDERMODE_CUTOUT:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_ALPHATEST;
                     this.alphaTest = true;
                     this.depthWrite = true;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_DISABLE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     break;
                 case BlinnPhongMaterial.RENDERMODE_TRANSPARENT:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     break;
                 default:
                     throw new Error("Material:renderMode value error.");
             }
         }
         /**
          * 获取是否支持顶点色。
          * @return  是否支持顶点色。
          */
         get enableVertexColor() {
             return this._enableVertexColor;
         }
         /**
          * 设置是否支持顶点色。
          * @param value  是否支持顶点色。
          */
         set enableVertexColor(value) {
             this._enableVertexColor = value;
             if (value)
                 this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
             else
                 this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @return 纹理平铺和偏移X分量。
          */
         get tilingOffsetX() {
             return this._MainTex_STX;
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @param x 纹理平铺和偏移X分量。
          */
         set tilingOffsetX(x) {
             this._MainTex_STX = x;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @return 纹理平铺和偏移Y分量。
          */
         get tilingOffsetY() {
             return this._MainTex_STY;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @param y 纹理平铺和偏移Y分量。
          */
         set tilingOffsetY(y) {
             this._MainTex_STY = y;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @return 纹理平铺和偏移Z分量。
          */
         get tilingOffsetZ() {
             return this._MainTex_STZ;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @param z 纹理平铺和偏移Z分量。
          */
         set tilingOffsetZ(z) {
             this._MainTex_STZ = z;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @return 纹理平铺和偏移W分量。
          */
         get tilingOffsetW() {
             return this._MainTex_STW;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @param w 纹理平铺和偏移W分量。
          */
         set tilingOffsetW(w) {
             this._MainTex_STW = w;
         }
         /**
          * 获取纹理平铺和偏移。
          * @return 纹理平铺和偏移。
          */
         get tilingOffset() {
             return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
         }
         /**
          * 获取纹理平铺和偏移。
          * @param value 纹理平铺和偏移。
          */
         set tilingOffset(value) {
             if (value) {
                 if (value.x != 1 || value.y != 1 || value.z != 0 || value.w != 0)
                     this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
                 else
                     this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             else {
                 this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             this._shaderValues.setVector(BlinnPhongMaterial.TILINGOFFSET, value);
         }
         /**
          * 获取反照率颜色R分量。
          * @return 反照率颜色R分量。
          */
         get albedoColorR() {
             return this._ColorR;
         }
         /**
          * 设置反照率颜色R分量。
          * @param value 反照率颜色R分量。
          */
         set albedoColorR(value) {
             this._ColorR = value;
         }
         /**
          * 获取反照率颜色G分量。
          * @return 反照率颜色G分量。
          */
         get albedoColorG() {
             return this._ColorG;
         }
         /**
          * 设置反照率颜色G分量。
          * @param value 反照率颜色G分量。
          */
         set albedoColorG(value) {
             this._ColorG = value;
         }
         /**
          * 获取反照率颜色B分量。
          * @return 反照率颜色B分量。
          */
         get albedoColorB() {
             return this._ColorB;
         }
         /**
          * 设置反照率颜色B分量。
          * @param value 反照率颜色B分量。
          */
         set albedoColorB(value) {
             this._ColorB = value;
         }
         /**
          * 获取反照率颜色Z分量。
          * @return 反照率颜色Z分量。
          */
         get albedoColorA() {
             return this._ColorA;
         }
         /**
          * 设置反照率颜色alpha分量。
          * @param value 反照率颜色alpha分量。
          */
         set albedoColorA(value) {
             this._ColorA = value;
         }
         /**
          * 获取反照率颜色。
          * @return 反照率颜色。
          */
         get albedoColor() {
             return this._albedoColor;
         }
         /**
          * 设置反照率颜色。
          * @param value 反照率颜色。
          */
         set albedoColor(value) {
             var finalAlbedo = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
             Vector4.scale(value, this._albedoIntensity, finalAlbedo);
             this._albedoColor = value;
             this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, finalAlbedo); //修改值后必须调用此接口,否则NATIVE不生效
         }
         /**
          * 获取反照率强度。
          * @return 反照率强度。
          */
         get albedoIntensity() {
             return this._albedoIntensity;
         }
         /**
          * 设置反照率强度。
          * @param value 反照率强度。
          */
         set albedoIntensity(value) {
             this._AlbedoIntensity = value;
         }
         /**
          * 获取高光颜色R轴分量。
          * @return 高光颜色R轴分量。
          */
         get specularColorR() {
             return this._SpecColorR;
         }
         /**
          * 设置高光颜色R分量。
          * @param value 高光颜色R分量。
          */
         set specularColorR(value) {
             this._SpecColorR = value;
         }
         /**
          * 获取高光颜色G分量。
          * @return 高光颜色G分量。
          */
         get specularColorG() {
             return this._SpecColorG;
         }
         /**
          * 设置高光颜色G分量。
          * @param value 高光颜色G分量。
          */
         set specularColorG(value) {
             this._SpecColorG = value;
         }
         /**
          * 获取高光颜色B分量。
          * @return 高光颜色B分量。
          */
         get specularColorB() {
             return this._SpecColorB;
         }
         /**
          * 设置高光颜色B分量。
          * @param value 高光颜色B分量。
          */
         set specularColorB(value) {
             this._SpecColorB = value;
         }
         /**
          * 获取高光颜色A分量。
          * @return 高光颜色A分量。
          */
         get specularColorA() {
             return this._SpecColorA;
         }
         /**
          * 设置高光颜色A分量。
          * @param value 高光颜色A分量。
          */
         set specularColorA(value) {
             this._SpecColorA = value;
         }
         /**
          * 获取高光颜色。
          * @return 高光颜色。
          */
         get specularColor() {
             return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR);
         }
         /**
          * 设置高光颜色。
          * @param value 高光颜色。
          */
         set specularColor(value) {
             this._shaderValues.setVector(BlinnPhongMaterial.MATERIALSPECULAR, value);
         }
         /**
          * 获取高光强度,范围为0到1。
          * @return 高光强度。
          */
         get shininess() {
             return this._Shininess;
         }
         /**
          * 设置高光强度,范围为0到1。
          * @param value 高光强度。
          */
         set shininess(value) {
             this._Shininess = value;
         }
         /**
          * 获取反照率贴图。
          * @return 反照率贴图。
          */
         get albedoTexture() {
             return this._shaderValues.getTexture(BlinnPhongMaterial.ALBEDOTEXTURE);
         }
         /**
          * 设置反照率贴图。
          * @param value 反照率贴图。
          */
         set albedoTexture(value) {
             if (value)
                 this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
             else
                 this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
             this._shaderValues.setTexture(BlinnPhongMaterial.ALBEDOTEXTURE, value);
         }
         /**
          * 获取法线贴图。
          * @return 法线贴图。
          */
         get normalTexture() {
             return this._shaderValues.getTexture(BlinnPhongMaterial.NORMALTEXTURE);
         }
         /**
          * 设置法线贴图。
          * @param value 法线贴图。
          */
         set normalTexture(value) {
             if (value)
                 this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
             else
                 this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
             this._shaderValues.setTexture(BlinnPhongMaterial.NORMALTEXTURE, value);
         }
         /**
          * 获取高光贴图。
          * @return 高光贴图。
          */
         get specularTexture() {
             return this._shaderValues.getTexture(BlinnPhongMaterial.SPECULARTEXTURE);
         }
         /**
          * 设置高光贴图，高光强度则从该贴图RGB值中获取,如果该值为空则从漫反射贴图的Alpha通道获取。
          * @param value  高光贴图。
          */
         set specularTexture(value) {
             if (value)
                 this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
             else
                 this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
             this._shaderValues.setTexture(BlinnPhongMaterial.SPECULARTEXTURE, value);
         }
         /**
          * 获取是否启用光照。
          * @return 是否启用光照。
          */
         get enableLighting() {
             return this._enableLighting;
         }
         /**
          * 设置是否启用光照。
          * @param value 是否启用光照。
          */
         set enableLighting(value) {
             if (this._enableLighting !== value) {
                 if (value)
                     this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                 else
                     this._disablePublicDefineDatas.add(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                 this._enableLighting = value;
             }
         }
         /**
          * 设置是否写入深度。
          * @param value 是否写入深度。
          */
         set depthWrite(value) {
             this._shaderValues.setBool(BlinnPhongMaterial.DEPTH_WRITE, value);
         }
         /**
          * 获取是否写入深度。
          * @return 是否写入深度。
          */
         get depthWrite() {
             return this._shaderValues.getBool(BlinnPhongMaterial.DEPTH_WRITE);
         }
         /**
          * 设置剔除方式。
          * @param value 剔除方式。
          */
         set cull(value) {
             this._shaderValues.setInt(BlinnPhongMaterial.CULL, value);
         }
         /**
          * 获取剔除方式。
          * @return 剔除方式。
          */
         get cull() {
             return this._shaderValues.getInt(BlinnPhongMaterial.CULL);
         }
         /**
          * 设置混合方式。
          * @param value 混合方式。
          */
         set blend(value) {
             this._shaderValues.setInt(BlinnPhongMaterial.BLEND, value);
         }
         /**
          * 获取混合方式。
          * @return 混合方式。
          */
         get blend() {
             return this._shaderValues.getInt(BlinnPhongMaterial.BLEND);
         }
         /**
          * 设置混合源。
          * @param value 混合源
          */
         set blendSrc(value) {
             this._shaderValues.setInt(BlinnPhongMaterial.BLEND_SRC, value);
         }
         /**
          * 获取混合源。
          * @return 混合源。
          */
         get blendSrc() {
             return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_SRC);
         }
         /**
          * 设置混合目标。
          * @param value 混合目标
          */
         set blendDst(value) {
             this._shaderValues.setInt(BlinnPhongMaterial.BLEND_DST, value);
         }
         /**
          * 获取混合目标。
          * @return 混合目标。
          */
         get blendDst() {
             return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_DST);
         }
         /**
          * 设置深度测试方式。
          * @param value 深度测试方式
          */
         set depthTest(value) {
             this._shaderValues.setInt(BlinnPhongMaterial.DEPTH_TEST, value);
         }
         /**
          * 获取深度测试方式。
          * @return 深度测试方式。
          */
         get depthTest() {
             return this._shaderValues.getInt(BlinnPhongMaterial.DEPTH_TEST);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new BlinnPhongMaterial();
             this.cloneTo(dest);
             return dest;
         }
         /**
          * @inheritDoc
          */
         cloneTo(destObject) {
             super.cloneTo(destObject);
             var destMaterial = destObject;
             destMaterial._enableLighting = this._enableLighting;
             destMaterial._albedoIntensity = this._albedoIntensity;
             destMaterial._enableVertexColor = this._enableVertexColor;
             this._albedoColor.cloneTo(destMaterial._albedoColor);
         }
     }
     /**渲染状态_不透明。*/
     BlinnPhongMaterial.RENDERMODE_OPAQUE = 0;
     /**渲染状态_阿尔法测试。*/
     BlinnPhongMaterial.RENDERMODE_CUTOUT = 1;
     /**渲染状态_透明混合。*/
     BlinnPhongMaterial.RENDERMODE_TRANSPARENT = 2;
     BlinnPhongMaterial.ALBEDOTEXTURE = Shader3D.propertyNameToID("u_DiffuseTexture");
     BlinnPhongMaterial.NORMALTEXTURE = Shader3D.propertyNameToID("u_NormalTexture");
     BlinnPhongMaterial.SPECULARTEXTURE = Shader3D.propertyNameToID("u_SpecularTexture");
     BlinnPhongMaterial.ALBEDOCOLOR = Shader3D.propertyNameToID("u_DiffuseColor");
     BlinnPhongMaterial.MATERIALSPECULAR = Shader3D.propertyNameToID("u_MaterialSpecular");
     BlinnPhongMaterial.SHININESS = Shader3D.propertyNameToID("u_Shininess");
     BlinnPhongMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset");
     BlinnPhongMaterial.CULL = Shader3D.propertyNameToID("s_Cull");
     BlinnPhongMaterial.BLEND = Shader3D.propertyNameToID("s_Blend");
     BlinnPhongMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
     BlinnPhongMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
     BlinnPhongMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
     BlinnPhongMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
     /**@private */
     BlinnPhongMaterial.shaderDefines = null;

     /**
      * <code>Bounds</code> 类用于创建包围体。
      */
     class Bounds {
         /**
          * 创建一个 <code>Bounds</code> 实例。
          * @param	min  min 最小坐标
          * @param	max  max 最大坐标。
          */
         constructor(min, max) {
             /**@private */
             this._updateFlag = 0;
             /**@private	*/
             this._center = new Vector3();
             /**@private	*/
             this._extent = new Vector3();
             /**@private	*/
             this._boundBox = new BoundBox(new Vector3(), new Vector3());
             min.cloneTo(this._boundBox.min);
             max.cloneTo(this._boundBox.max);
             this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, true);
         }
         /**
          * 设置包围盒的最小点。
          * @param value	包围盒的最小点。
          */
         setMin(value) {
             var min = this._boundBox.min;
             if (value !== min)
                 value.cloneTo(min);
             this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, true);
             this._setUpdateFlag(Bounds._UPDATE_MIN, false);
         }
         /**
          * 获取包围盒的最小点。
          * @return	包围盒的最小点。
          */
         getMin() {
             var min = this._boundBox.min;
             if (this._getUpdateFlag(Bounds._UPDATE_MIN)) {
                 this._getMin(this.getCenter(), this.getExtent(), min);
                 this._setUpdateFlag(Bounds._UPDATE_MIN, false);
             }
             return min;
         }
         /**
          * 设置包围盒的最大点。
          * @param value	包围盒的最大点。
          */
         setMax(value) {
             var max = this._boundBox.max;
             if (value !== max)
                 value.cloneTo(max);
             this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, true);
             this._setUpdateFlag(Bounds._UPDATE_MAX, false);
         }
         /**
          * 获取包围盒的最大点。
          * @return	包围盒的最大点。
          */
         getMax() {
             var max = this._boundBox.max;
             if (this._getUpdateFlag(Bounds._UPDATE_MAX)) {
                 this._getMax(this.getCenter(), this.getExtent(), max);
                 this._setUpdateFlag(Bounds._UPDATE_MAX, false);
             }
             return max;
         }
         /**
          * 设置包围盒的中心点。
          * @param value	包围盒的中心点。
          */
         setCenter(value) {
             if (value !== this._center)
                 value.cloneTo(this._center);
             this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, true);
             this._setUpdateFlag(Bounds._UPDATE_CENTER, false);
         }
         /**
          * 获取包围盒的中心点。
          * @return	包围盒的中心点。
          */
         getCenter() {
             if (this._getUpdateFlag(Bounds._UPDATE_CENTER)) {
                 this._getCenter(this.getMin(), this.getMax(), this._center);
                 this._setUpdateFlag(Bounds._UPDATE_CENTER, false);
             }
             return this._center;
         }
         /**
          * 设置包围盒的范围。
          * @param value	包围盒的范围。
          */
         setExtent(value) {
             if (value !== this._extent)
                 value.cloneTo(this._extent);
             this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, true);
             this._setUpdateFlag(Bounds._UPDATE_EXTENT, false);
         }
         /**
          * 获取包围盒的范围。
          * @return	包围盒的范围。
          */
         getExtent() {
             if (this._getUpdateFlag(Bounds._UPDATE_EXTENT)) {
                 this._getExtent(this.getMin(), this.getMax(), this._extent);
                 this._setUpdateFlag(Bounds._UPDATE_EXTENT, false);
             }
             return this._extent;
         }
         /**
          * @private
          */
         _getUpdateFlag(type) {
             return (this._updateFlag & type) != 0;
         }
         /**
          * @private
          */
         _setUpdateFlag(type, value) {
             if (value)
                 this._updateFlag |= type;
             else
                 this._updateFlag &= ~type;
         }
         /**
          * @private
          */
         _getCenter(min, max, out) {
             Vector3.add(min, max, out);
             Vector3.scale(out, 0.5, out);
         }
         /**
          * @private
          */
         _getExtent(min, max, out) {
             Vector3.subtract(max, min, out);
             Vector3.scale(out, 0.5, out);
         }
         /**
          * @private
          */
         _getMin(center, extent, out) {
             Vector3.subtract(center, extent, out);
         }
         /**
          * @private
          */
         _getMax(center, extent, out) {
             Vector3.add(center, extent, out);
         }
         /**
          * @private
          */
         _rotateExtents(extents, rotation, out) {
             var extentsX = extents.x;
             var extentsY = extents.y;
             var extentsZ = extents.z;
             var matE = rotation.elements;
             out.x = Math.abs(matE[0] * extentsX) + Math.abs(matE[4] * extentsY) + Math.abs(matE[8] * extentsZ);
             out.y = Math.abs(matE[1] * extentsX) + Math.abs(matE[5] * extentsY) + Math.abs(matE[9] * extentsZ);
             out.z = Math.abs(matE[2] * extentsX) + Math.abs(matE[6] * extentsY) + Math.abs(matE[10] * extentsZ);
         }
         /**
          * @private
          */
         _tranform(matrix, out) {
             var outCen = out._center;
             var outExt = out._extent;
             Vector3.transformCoordinate(this.getCenter(), matrix, outCen);
             this._rotateExtents(this.getExtent(), matrix, outExt);
             out._boundBox.setCenterAndExtent(outCen, outExt);
             out._updateFlag = 0;
         }
         /**
          * @private
          */
         _getBoundBox() {
             var min = this._boundBox.min;
             if (this._getUpdateFlag(Bounds._UPDATE_MIN)) {
                 this._getMin(this.getCenter(), this.getExtent(), min);
                 this._setUpdateFlag(Bounds._UPDATE_MIN, false);
             }
             var max = this._boundBox.max;
             if (this._getUpdateFlag(Bounds._UPDATE_MAX)) {
                 this._getMax(this.getCenter(), this.getExtent(), max);
                 this._setUpdateFlag(Bounds._UPDATE_MAX, false);
             }
             return this._boundBox;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destBounds = destObject;
             this.getMin().cloneTo(destBounds._boundBox.min);
             this.getMax().cloneTo(destBounds._boundBox.max);
             this.getCenter().cloneTo(destBounds._center);
             this.getExtent().cloneTo(destBounds._extent);
             destBounds._updateFlag = 0;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new Bounds(new Vector3(), new Vector3());
             this.cloneTo(dest);
             return dest;
         }
     }
     /**@private */
     Bounds._UPDATE_MIN = 0x01;
     /**@private */
     Bounds._UPDATE_MAX = 0x02;
     /**@private */
     Bounds._UPDATE_CENTER = 0x04;
     /**@private */
     Bounds._UPDATE_EXTENT = 0x08;

     /**
      * <code>Render</code> 类用于渲染器的父类，抽象类不允许实例。
      */
     class BaseRender extends EventDispatcher {
         /**
          * @private
          * 创建一个新的 <code>BaseRender</code> 实例。
          */
         constructor(owner) {
             super();
             /** @private  [实现IListPool接口]*/
             this._indexInList = -1;
             /** @private */
             this._indexInCastShadowList = -1;
             /** @private */
             this._boundsChange = true;
             this._supportOctree = true;
             /** @private */
             this._sharedMaterials = [];
             /**@private */
             this._visible = true; //初始值为默认可见,否则会造成第一帧动画不更新等，TODO:还有个包围盒更新好像浪费了
             /** @private */
             this._indexInOctreeMotionList = -1;
             /** @private */
             this._updateMark = -1;
             /** @private */
             this._updateRenderType = -1;
             /** @private */
             this._isPartOfStaticBatch = false;
             /** @private */
             this._staticBatch = null;
             this._id = ++BaseRender._uniqueIDCounter;
             this._indexInCastShadowList = -1;
             this._bounds = new Bounds(Vector3._ZERO, Vector3._ZERO);
             if (Render.supportWebGLPlusCulling) { //[NATIVE]
                 var length = FrustumCulling._cullingBufferLength;
                 this._cullingBufferIndex = length;
                 var cullingBuffer = FrustumCulling._cullingBuffer;
                 var resizeLength = length + 7;
                 if (resizeLength >= cullingBuffer.length) {
                     var temp = cullingBuffer;
                     cullingBuffer = FrustumCulling._cullingBuffer = new Float32Array(cullingBuffer.length + 4096);
                     cullingBuffer.set(temp, 0);
                 }
                 cullingBuffer[length] = 2;
                 FrustumCulling._cullingBufferLength = resizeLength;
             }
             this._renderElements = [];
             this._owner = owner;
             this._enable = true;
             this._materialsInstance = [];
             this._shaderValues = new ShaderData(null);
             this.lightmapIndex = -1;
             this._castShadow = false;
             this.receiveShadow = false;
             this.sortingFudge = 0.0;
             (owner) && (this._owner.transform.on(Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange)); //如果为合并BaseRender,owner可能为空
         }
         /**
          * 获取唯一标识ID,通常用于识别。
          */
         get id() {
             return this._id;
         }
         /**
          * 获取光照贴图的索引。
          * @return 光照贴图的索引。
          */
         get lightmapIndex() {
             return this._lightmapIndex;
         }
         /**
          * 设置光照贴图的索引。
          * @param value 光照贴图的索引。
          */
         set lightmapIndex(value) {
             if (this._lightmapIndex !== value) {
                 this._lightmapIndex = value;
                 this._applyLightMapParams();
             }
         }
         /**
          * 获取光照贴图的缩放和偏移。
          * @return  光照贴图的缩放和偏移。
          */
         get lightmapScaleOffset() {
             return this._lightmapScaleOffset;
         }
         /**
          * 设置光照贴图的缩放和偏移。
          * @param  光照贴图的缩放和偏移。
          */
         set lightmapScaleOffset(value) {
             this._lightmapScaleOffset = value;
             this._shaderValues.setVector(RenderableSprite3D.LIGHTMAPSCALEOFFSET, value);
             this._shaderValues.addDefine(RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
         }
         /**
          * 获取是否可用。
          * @return 是否可用。
          */
         get enable() {
             return this._enable;
         }
         /**
          * 设置是否可用。
          * @param value 是否可用。
          */
         set enable(value) {
             this._enable = !!value;
         }
         /**
          * 返回第一个实例材质,第一次使用会拷贝实例对象。
          * @return 第一个实例材质。
          */
         get material() {
             var material = this._sharedMaterials[0];
             if (material && !this._materialsInstance[0]) {
                 var insMat = this._getInstanceMaterial(material, 0);
                 var renderElement = this._renderElements[0];
                 (renderElement) && (renderElement.material = insMat);
             }
             return this._sharedMaterials[0];
         }
         /**
          * 设置第一个实例材质。
          * @param value 第一个实例材质。
          */
         set material(value) {
             this.sharedMaterial = value;
         }
         /**
          * 获取潜拷贝实例材质列表,第一次使用会拷贝实例对象。
          * @return 浅拷贝实例材质列表。
          */
         get materials() {
             for (var i = 0, n = this._sharedMaterials.length; i < n; i++) {
                 if (!this._materialsInstance[i]) {
                     var insMat = this._getInstanceMaterial(this._sharedMaterials[i], i);
                     var renderElement = this._renderElements[i];
                     (renderElement) && (renderElement.material = insMat);
                 }
             }
             return this._sharedMaterials.slice();
         }
         /**
          * 设置实例材质列表。
          * @param value 实例材质列表。
          */
         set materials(value) {
             this.sharedMaterials = value;
         }
         /**
          * 返回第一个材质。
          * @return 第一个材质。
          */
         get sharedMaterial() {
             return this._sharedMaterials[0];
         }
         /**
          * 设置第一个材质。
          * @param value 第一个材质。
          */
         set sharedMaterial(value) {
             var lastValue = this._sharedMaterials[0];
             if (lastValue !== value) {
                 this._sharedMaterials[0] = value;
                 this._materialsInstance[0] = false;
                 this._changeMaterialReference(lastValue, value);
                 var renderElement = this._renderElements[0];
                 (renderElement) && (renderElement.material = value);
             }
         }
         /**
          * 获取浅拷贝材质列表。
          * @return 浅拷贝材质列表。
          */
         get sharedMaterials() {
             return this._sharedMaterials.slice();
         }
         /**
          * 设置材质列表。
          * @param value 材质列表。
          */
         set sharedMaterials(value) {
             var materialsInstance = this._materialsInstance;
             var sharedMats = this._sharedMaterials;
             for (var i = 0, n = sharedMats.length; i < n; i++) {
                 var lastMat = sharedMats[i];
                 (lastMat) && (lastMat._removeReference());
             }
             if (value) {
                 var count = value.length;
                 materialsInstance.length = count;
                 sharedMats.length = count;
                 for (i = 0; i < count; i++) {
                     lastMat = sharedMats[i];
                     var mat = value[i];
                     if (lastMat !== mat) {
                         materialsInstance[i] = false;
                         var renderElement = this._renderElements[i];
                         (renderElement) && (renderElement.material = mat);
                     }
                     if (mat) {
                         mat._addReference();
                     }
                     sharedMats[i] = mat;
                 }
             }
             else {
                 throw new Error("BaseRender: shadredMaterials value can't be null.");
             }
         }
         /**
          * 获取包围盒,只读,不允许修改其值。
          * @return 包围盒。
          */
         get bounds() {
             if (this._boundsChange) {
                 this._calculateBoundingBox();
                 this._boundsChange = false;
             }
             return this._bounds;
         }
         /**
          * 设置是否接收阴影属性
          */
         set receiveShadow(value) {
             if (this._receiveShadow !== value) {
                 this._receiveShadow = value;
                 if (value)
                     this._shaderValues.addDefine(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
                 else
                     this._shaderValues.removeDefine(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
             }
         }
         /**
          * 获得是否接收阴影属性
          */
         get receiveShadow() {
             return this._receiveShadow;
         }
         /**
          * 获取是否产生阴影。
          * @return 是否产生阴影。
          */
         get castShadow() {
             return this._castShadow;
         }
         /**
          *	设置是否产生阴影。
          * 	@param value 是否产生阴影。
          */
         set castShadow(value) {
             if (this._castShadow !== value) {
                 if (this._owner.activeInHierarchy) {
                     if (value)
                         this._scene._addShadowCastRenderObject(this);
                     else
                         this._scene._removeShadowCastRenderObject(this);
                 }
                 this._castShadow = value;
             }
         }
         /**
          * 是否是静态的一部分。
          */
         get isPartOfStaticBatch() {
             return this._isPartOfStaticBatch;
         }
         /**
          * @private
          */
         _getOctreeNode() {
             return this._octreeNode;
         }
         /**
          * @private
          */
         _setOctreeNode(value) {
             this._octreeNode = value;
         }
         /**
          * @private
          */
         _getIndexInMotionList() {
             return this._indexInOctreeMotionList;
         }
         /**
          * @private
          */
         _setIndexInMotionList(value) {
             this._indexInOctreeMotionList = value;
         }
         /**
          * @private
          */
         _changeMaterialReference(lastValue, value) {
             (lastValue) && (lastValue._removeReference());
             value._addReference(); //TODO:value可以为空
         }
         /**
          * @private
          */
         _getInstanceMaterial(material, index) {
             var insMat = material.clone(); //深拷贝
             insMat.name = insMat.name + "(Instance)";
             this._materialsInstance[index] = true;
             this._changeMaterialReference(this._sharedMaterials[index], insMat);
             this._sharedMaterials[index] = insMat;
             return insMat;
         }
         /**
          * @private
          */
         _applyLightMapParams() {
             if (this._scene && this._lightmapIndex >= 0) {
                 var lightMaps = this._scene.getlightmaps();
                 if (this._lightmapIndex < lightMaps.length) {
                     this._shaderValues.addDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
                     this._shaderValues.setTexture(RenderableSprite3D.LIGHTMAP, lightMaps[this._lightmapIndex]);
                 }
                 else {
                     this._shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
                 }
             }
             else {
                 this._shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
             }
         }
         /**
          * @private
          */
         _onWorldMatNeedChange(flag) {
             this._boundsChange = true;
             if (this._octreeNode) {
                 flag &= Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE; //过滤有用TRANSFORM标记
                 if (flag) {
                     if (this._indexInOctreeMotionList === -1) //_octreeNode表示在八叉树队列中
                         this._octreeNode._octree.addMotionObject(this);
                 }
             }
         }
         /**
          * @private
          */
         _calculateBoundingBox() {
             throw ("BaseRender: must override it.");
         }
         /**
          * @private [实现ISingletonElement接口]
          */
         _getIndexInList() {
             return this._indexInList;
         }
         /**
          * @private [实现ISingletonElement接口]
          */
         _setIndexInList(index) {
             this._indexInList = index;
         }
         /**
          * @private
          */
         _setBelongScene(scene) {
             if (this._scene !== scene) {
                 this._scene = scene;
                 this._applyLightMapParams();
             }
         }
         /**
          * @private
          * @param boundFrustum 如果boundFrustum为空则为摄像机不裁剪模式。
          */
         _needRender(boundFrustum) {
             return true;
         }
         /**
          * @private
          */
         _renderUpdate(context, transform) {
         }
         /**
          * @private
          */
         _renderUpdateWithCamera(context, transform) {
         }
         /**
          * @private
          */
         _revertBatchRenderUpdate(context) {
         }
         /**
          * @private
          */
         _destroy() {
             (this._indexInOctreeMotionList !== -1) && (this._octreeNode._octree.removeMotionObject(this));
             this.offAll();
             var i = 0, n = 0;
             for (i = 0, n = this._renderElements.length; i < n; i++)
                 this._renderElements[i].destroy();
             for (i = 0, n = this._sharedMaterials.length; i < n; i++)
                 (this._sharedMaterials[i].destroyed) || (this._sharedMaterials[i]._removeReference()); //TODO:材质可能为空
             this._renderElements = null;
             this._owner = null;
             this._sharedMaterials = null;
             this._bounds = null;
             this._lightmapScaleOffset = null;
         }
     }
     /**@private */
     BaseRender._tempBoundBoxCorners = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
     /**@private */
     BaseRender._uniqueIDCounter = 0;

     /**
      * <code>MeshRenderer</code> 类用于网格渲染器。
      */
     class MeshRenderer extends BaseRender {
         /**
          * 创建一个新的 <code>MeshRender</code> 实例。
          */
         constructor(owner) {
             super(owner);
             this._projectionViewWorldMatrix = new Matrix4x4();
         }
         /**
          * @private
          */
         _createRenderElement() {
             return new SubMeshRenderElement();
         }
         /**
          * @private
          */
         _onMeshChange(mesh) {
             if (mesh) {
                 var count = mesh.subMeshCount;
                 this._renderElements.length = count;
                 for (var i = 0; i < count; i++) {
                     var renderElement = this._renderElements[i];
                     if (!renderElement) {
                         var material = this.sharedMaterials[i];
                         renderElement = this._renderElements[i] = this._createRenderElement();
                         renderElement.setTransform(this._owner._transform);
                         renderElement.render = this;
                         renderElement.material = material ? material : BlinnPhongMaterial.defaultMaterial; //确保有材质,由默认材质代替。
                     }
                     renderElement.setGeometry(mesh._getSubMesh(i));
                 }
             }
             else {
                 this._renderElements.length = 0;
             }
             this._boundsChange = true;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _calculateBoundingBox() {
             var sharedMesh = this._owner.meshFilter.sharedMesh;
             if (sharedMesh) {
                 var worldMat = this._owner.transform.worldMatrix;
                 sharedMesh.bounds._tranform(worldMat, this._bounds);
             }
             if (Render.supportWebGLPlusCulling) { //[NATIVE]
                 var min = this._bounds.getMin();
                 var max = this._bounds.getMax();
                 var buffer = FrustumCulling._cullingBuffer;
                 buffer[this._cullingBufferIndex + 1] = min.x;
                 buffer[this._cullingBufferIndex + 2] = min.y;
                 buffer[this._cullingBufferIndex + 3] = min.z;
                 buffer[this._cullingBufferIndex + 4] = max.x;
                 buffer[this._cullingBufferIndex + 5] = max.y;
                 buffer[this._cullingBufferIndex + 6] = max.z;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _needRender(boundFrustum) {
             if (boundFrustum)
                 return boundFrustum.containsBoundBox(this.bounds._getBoundBox()) !== ContainmentType.Disjoint;
             else
                 return true;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _renderUpdate(context, transform) {
             var element = context.renderElement;
             switch (element.renderType) {
                 case RenderElement.RENDERTYPE_NORMAL:
                     this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, transform.worldMatrix);
                     break;
                 case RenderElement.RENDERTYPE_STATICBATCH:
                     this._oriDefineValue = this._shaderValues._defineDatas.value;
                     if (transform)
                         this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, transform.worldMatrix);
                     else
                         this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, Matrix4x4.DEFAULT);
                     this._shaderValues.addDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1);
                     this._shaderValues.removeDefine(RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
                     break;
                 case RenderElement.RENDERTYPE_VERTEXBATCH:
                     this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, Matrix4x4.DEFAULT);
                     break;
                 case RenderElement.RENDERTYPE_INSTANCEBATCH:
                     var worldMatrixData = SubMeshInstanceBatch.instance.instanceWorldMatrixData;
                     var insBatches = element.instanceBatchElementList;
                     var count = insBatches.length;
                     for (var i = 0; i < count; i++)
                         worldMatrixData.set(insBatches[i]._transform.worldMatrix.elements, i * 16);
                     SubMeshInstanceBatch.instance.instanceWorldMatrixBuffer.setData(worldMatrixData, 0, 0, count * 16);
                     this._shaderValues.addDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE);
                     break;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _renderUpdateWithCamera(context, transform) {
             var projectionView = context.projectionViewMatrix;
             var element = context.renderElement;
             switch (element.renderType) {
                 case RenderElement.RENDERTYPE_NORMAL:
                 case RenderElement.RENDERTYPE_STATICBATCH:
                 case RenderElement.RENDERTYPE_VERTEXBATCH:
                     if (transform) {
                         Matrix4x4.multiply(projectionView, transform.worldMatrix, this._projectionViewWorldMatrix);
                         this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix);
                     }
                     else {
                         this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView);
                     }
                     break;
                 case RenderElement.RENDERTYPE_INSTANCEBATCH:
                     var mvpMatrixData = SubMeshInstanceBatch.instance.instanceMVPMatrixData;
                     var insBatches = element.instanceBatchElementList;
                     var count = insBatches.length;
                     for (var i = 0; i < count; i++) {
                         var worldMat = insBatches[i]._transform.worldMatrix;
                         Utils3D.mulMatrixByArray(projectionView.elements, 0, worldMat.elements, 0, mvpMatrixData, i * 16);
                     }
                     SubMeshInstanceBatch.instance.instanceMVPMatrixBuffer.setData(mvpMatrixData, 0, 0, count * 16);
                     break;
             }
         }
         /**
          * @inheritDoc
          */
         _renderUpdateWithCameraForNative(context, transform) {
             var projectionView = context.projectionViewMatrix;
             var element = context.renderElement;
             switch (element.renderType) {
                 case RenderElement.RENDERTYPE_NORMAL:
                     if (transform) {
                         Matrix4x4.multiply(projectionView, transform.worldMatrix, this._projectionViewWorldMatrix);
                         this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix);
                     }
                     else {
                         this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView);
                     }
                     break;
                 case RenderElement.RENDERTYPE_STATICBATCH:
                 case RenderElement.RENDERTYPE_VERTEXBATCH:
                     var noteValue = ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                     ShaderData.setRuntimeValueMode(false); //[Native]
                     if (transform) {
                         Matrix4x4.multiply(projectionView, transform.worldMatrix, this._projectionViewWorldMatrix);
                         this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix);
                     }
                     else {
                         this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView);
                     }
                     ShaderData.setRuntimeValueMode(noteValue); //[Native]
                     break;
                 case RenderElement.RENDERTYPE_INSTANCEBATCH:
                     var mvpMatrixData = SubMeshInstanceBatch.instance.instanceMVPMatrixData;
                     var insBatches = element.instanceBatchElementList;
                     var count = insBatches.length;
                     for (var i = 0; i < count; i++) {
                         var worldMat = insBatches[i]._transform.worldMatrix;
                         Utils3D.mulMatrixByArray(projectionView.elements, 0, worldMat.elements, 0, mvpMatrixData, i * 16);
                     }
                     SubMeshInstanceBatch.instance.instanceMVPMatrixBuffer.setData(mvpMatrixData, 0, 0, count * 16);
                     break;
             }
         }
         /**
          * @private
          */
         /*override*/ _revertBatchRenderUpdate(context) {
             var element = context.renderElement;
             switch (element.renderType) {
                 case RenderElement.RENDERTYPE_STATICBATCH:
                     this._shaderValues._defineDatas.value = this._oriDefineValue;
                     break;
                 case RenderElement.RENDERTYPE_INSTANCEBATCH:
                     this._shaderValues.removeDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE);
                     break;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _destroy() {
             (this._isPartOfStaticBatch) && (MeshRenderStaticBatchManager.instance._destroyRenderSprite(this._owner));
             super._destroy();
         }
     }

     /**
      * @private
      * <code>SubMeshDynamicBatch</code> 类用于网格动态合并。
      */
     class SubMeshDynamicBatch extends GeometryElement {
         /**
          * 创建一个 <code>SubMeshDynamicBatch</code> 实例。
          */
         constructor() {
             super();
             /** @private */
             this._bufferState = new BufferState();
             var maxVerDec = VertexMesh.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
             var maxByteCount = maxVerDec.vertexStride * SubMeshDynamicBatch.maxIndicesCount;
             this._vertices = new Float32Array(maxByteCount / 4);
             this._vertexBuffer = new VertexBuffer3D(maxByteCount, WebGLContext.DYNAMIC_DRAW);
             this._indices = new Int16Array(SubMeshDynamicBatch.maxIndicesCount);
             this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, this._indices.length, WebGLContext.DYNAMIC_DRAW);
             var memorySize = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
             Resource._addMemory(memorySize, memorySize);
         }
         /**
         * @private
         */
         static __init__() {
             SubMeshDynamicBatch.instance = new SubMeshDynamicBatch();
         }
         /**
          * @private
          */
         _getBatchVertices(vertexDeclaration, batchVertices, batchOffset, transform, element, subMesh) {
             var vertexFloatCount = vertexDeclaration.vertexStride / 4;
             var oriVertexes = subMesh._vertexBuffer.getData();
             var lightmapScaleOffset = element.render.lightmapScaleOffset;
             var multiSubMesh = element._dynamicMultiSubMesh;
             var vertexCount = element._dynamicVertexCount;
             element._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, multiSubMesh, vertexCount);
             var worldPositions = element._dynamicWorldPositions;
             var worldNormals = element._dynamicWorldNormals;
             var indices = subMesh._indices;
             for (var i = 0; i < vertexCount; i++) {
                 var index = multiSubMesh ? indices[i] : i;
                 var oriOffset = index * vertexFloatCount;
                 var bakeOffset = (i + batchOffset) * vertexFloatCount;
                 var oriOff = i * 3;
                 var bakOff = bakeOffset + this._positionOffset;
                 batchVertices[bakOff] = worldPositions[oriOff];
                 batchVertices[bakOff + 1] = worldPositions[oriOff + 1];
                 batchVertices[bakOff + 2] = worldPositions[oriOff + 2];
                 if (this._normalOffset !== -1) {
                     bakOff = bakeOffset + this._normalOffset;
                     batchVertices[bakOff] = worldNormals[oriOff];
                     batchVertices[bakOff + 1] = worldNormals[oriOff + 1];
                     batchVertices[bakOff + 2] = worldNormals[oriOff + 2];
                 }
                 if (this._colorOffset !== -1) {
                     bakOff = bakeOffset + this._colorOffset;
                     oriOff = oriOffset + this._colorOffset;
                     batchVertices[bakOff] = oriVertexes[oriOff];
                     batchVertices[bakOff + 1] = oriVertexes[oriOff + 1];
                     batchVertices[bakOff + 2] = oriVertexes[oriOff + 2];
                     batchVertices[bakOff + 3] = oriVertexes[oriOff + 3];
                 }
                 if (this._uv0Offset !== -1) {
                     bakOff = bakeOffset + this._uv0Offset;
                     oriOff = oriOffset + this._uv0Offset;
                     batchVertices[bakOff] = oriVertexes[oriOff];
                     batchVertices[bakOff + 1] = oriVertexes[oriOff + 1];
                 }
                 //if (lightmapScaleOffset) {//TODO:动态合并光照贴图UV如何处理
                 //if (_uv1Offset !== -1)
                 //Utils3D.transformLightingMapTexcoordByUV1Array(oriVertexes, oriOffset + _uv1Offset, lightmapScaleOffset, batchVertices, bakeOffset + _uv1Offset);
                 //else
                 //Utils3D.transformLightingMapTexcoordByUV0Array(oriVertexes, oriOffset + _uv0Offset, lightmapScaleOffset, batchVertices, bakeOffset + _uv1Offset);
                 //}
                 if (this._sTangentOffset !== -1) {
                     bakOff = bakeOffset + this._sTangentOffset;
                     oriOff = oriOffset + this._sTangentOffset;
                     batchVertices[bakOff] = oriVertexes[oriOff];
                     batchVertices[bakOff + 1] = oriVertexes[oriOff + 1];
                     batchVertices[bakOff + 2] = oriVertexes[oriOff + 2];
                     batchVertices[bakOff + 3] = oriVertexes[oriOff + 3];
                     bakOff = bakeOffset + this._sTangentOffset;
                     oriOff = oriOffset + this._sTangentOffset;
                     batchVertices[bakOff] = oriVertexes[oriOff];
                     batchVertices[bakOff + 1] = oriVertexes[oriOff + 1];
                     batchVertices[bakOff + 2] = oriVertexes[oriOff + 2];
                     batchVertices[bakOff + 3] = oriVertexes[oriOff + 3];
                 }
             }
         }
         /**
          * @private
          */
         _getBatchIndices(batchIndices, batchIndexCount, batchVertexCount, transform, subMesh, multiSubMesh) {
             var subIndices = subMesh._indices;
             var k, m, batchOffset;
             var isInvert = transform._isFrontFaceInvert;
             if (multiSubMesh) {
                 if (isInvert) {
                     for (k = 0, m = subIndices.length; k < m; k += 3) {
                         batchOffset = batchIndexCount + k;
                         var index = batchVertexCount + k;
                         batchIndices[batchOffset] = index;
                         batchIndices[batchOffset + 1] = index + 2;
                         batchIndices[batchOffset + 2] = index + 1;
                     }
                 }
                 else {
                     for (k = m, m = subIndices.length; k < m; k += 3) {
                         batchOffset = batchIndexCount + k;
                         index = batchVertexCount + k;
                         batchIndices[batchOffset] = index;
                         batchIndices[batchOffset + 1] = index + 1;
                         batchIndices[batchOffset + 2] = index + 2;
                     }
                 }
             }
             else {
                 if (isInvert) {
                     for (k = 0, m = subIndices.length; k < m; k += 3) {
                         batchOffset = batchIndexCount + k;
                         batchIndices[batchOffset] = batchVertexCount + subIndices[k];
                         batchIndices[batchOffset + 1] = batchVertexCount + subIndices[k + 2];
                         batchIndices[batchOffset + 2] = batchVertexCount + subIndices[k + 1];
                     }
                 }
                 else {
                     for (k = m, m = subIndices.length; k < m; k += 3) {
                         batchOffset = batchIndexCount + k;
                         batchIndices[batchOffset] = batchVertexCount + subIndices[k];
                         batchIndices[batchOffset + 1] = batchVertexCount + subIndices[k + 1];
                         batchIndices[batchOffset + 2] = batchVertexCount + subIndices[k + 2];
                     }
                 }
             }
         }
         /**
          * @private
          */
         _flush(vertexCount, indexCount) {
             this._vertexBuffer.setData(this._vertices, 0, 0, vertexCount * (this._vertexBuffer.vertexDeclaration.vertexStride / 4));
             this._indexBuffer.setData(this._indices, 0, 0, indexCount);
             LayaGL.instance.drawElements(WebGLContext.TRIANGLES, indexCount, WebGLContext.UNSIGNED_SHORT, 0);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _prepareRender(state) {
             var element = state.renderElement;
             var vertexDeclaration = element.vertexBatchVertexDeclaration;
             this._bufferState = ILaya3D.MeshRenderDynamicBatchManager.instance._getBufferState(vertexDeclaration);
             this._positionOffset = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_POSITION0).offset / 4;
             var normalElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_NORMAL0);
             this._normalOffset = normalElement ? normalElement.offset / 4 : -1;
             var colorElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_COLOR0);
             this._colorOffset = colorElement ? colorElement.offset / 4 : -1;
             var uv0Element = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE0);
             this._uv0Offset = uv0Element ? uv0Element.offset / 4 : -1;
             var uv1Element = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE1);
             this._uv1Offset = uv1Element ? uv1Element.offset / 4 : -1;
             var tangentElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TANGENT0);
             this._sTangentOffset = tangentElement ? tangentElement.offset / 4 : -1;
             return true;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _render(context) {
             this._bufferState.bind();
             var element = context.renderElement;
             var vertexDeclaration = element.vertexBatchVertexDeclaration;
             var batchElements = element.vertexBatchElementList;
             var batchVertexCount = 0;
             var batchIndexCount = 0;
             var floatStride = vertexDeclaration.vertexStride / 4;
             var renderBatchCount = 0;
             var elementCount = batchElements.length;
             for (var i = 0; i < elementCount; i++) {
                 var subElement = batchElements[i];
                 var subMesh = subElement._geometry;
                 var indexCount = subMesh._indexCount;
                 if (batchIndexCount + indexCount > SubMeshDynamicBatch.maxIndicesCount) {
                     this._flush(batchVertexCount, batchIndexCount);
                     renderBatchCount++;
                     Stat.trianglesFaces += batchIndexCount / 3;
                     batchVertexCount = batchIndexCount = 0;
                 }
                 var transform = subElement._transform;
                 this._getBatchVertices(vertexDeclaration, this._vertices, batchVertexCount, transform, /*(element.render as MeshRender)*/ subElement, subMesh);
                 this._getBatchIndices(this._indices, batchIndexCount, batchVertexCount, transform, subMesh, subElement._dynamicMultiSubMesh);
                 batchVertexCount += subElement._dynamicVertexCount;
                 batchIndexCount += indexCount;
             }
             this._flush(batchVertexCount, batchIndexCount);
             renderBatchCount++;
             Stat.renderBatches += renderBatchCount;
             Stat.savedRenderBatches += elementCount - renderBatchCount;
             Stat.trianglesFaces += batchIndexCount / 3;
         }
     }
     /** @private
      * //MI6 (微信) 大于12个顶点微小提升
      * //MI6 (QQ浏览器8.2 X5内核038230GPU-UU) 大于12个顶点微小提升
      * //MI6 (chrome63) 大于10个顶点微小提升
      * //IPHONE7PLUS  IOS11 微信 大于12个顶点微小提升
      * //IPHONE5s  IOS8 微信 大于12仍有较大提升
      */
     SubMeshDynamicBatch.maxAllowVertexCount = 10;
     /** @private */
     SubMeshDynamicBatch.maxAllowAttribueCount = 900; //TODO:
     /** @private */
     SubMeshDynamicBatch.maxIndicesCount = 32000;

     /**
      * @private
      * <code>MeshSprite3DDynamicBatchManager</code> 类用于网格精灵动态批处理管理。
      */
     class MeshRenderDynamicBatchManager extends DynamicBatchManager {
         /**
          * 创建一个 <code>MeshSprite3DDynamicBatchManager</code> 实例。
          */
         constructor() {
             super();
             /**@private */
             this._instanceBatchOpaqueMarks = [];
             /**@private */
             this._vertexBatchOpaqueMarks = [];
             /**@private */
             this._cacheBufferStates = [];
             this._updateCountMark = 0;
         }
         /**
          * @private
          */
         getInstanceBatchOpaquaMark(receiveShadow, materialID, subMeshID, invertFace) {
             var instanceReceiveShadowMarks = (this._instanceBatchOpaqueMarks[receiveShadow ? 0 : 1]) || (this._instanceBatchOpaqueMarks[receiveShadow ? 0 : 1] = []);
             var instanceMaterialMarks = (instanceReceiveShadowMarks[materialID]) || (instanceReceiveShadowMarks[materialID] = []);
             var instancSubMeshMarks = (instanceMaterialMarks[subMeshID]) || (instanceMaterialMarks[subMeshID] = []);
             return instancSubMeshMarks[invertFace ? 1 : 0] || (instancSubMeshMarks[invertFace ? 1 : 0] = new BatchMark());
         }
         /**
          * @private
          */
         getVertexBatchOpaquaMark(lightMapIndex, receiveShadow, materialID, verDecID) {
             var dynLightMapMarks = (this._vertexBatchOpaqueMarks[lightMapIndex]) || (this._vertexBatchOpaqueMarks[lightMapIndex] = []);
             var dynReceiveShadowMarks = (dynLightMapMarks[receiveShadow ? 0 : 1]) || (dynLightMapMarks[receiveShadow ? 0 : 1] = []);
             var dynMaterialMarks = (dynReceiveShadowMarks[materialID]) || (dynReceiveShadowMarks[materialID] = []);
             return dynMaterialMarks[verDecID] || (dynMaterialMarks[verDecID] = new BatchMark());
         }
         /**
          * @private
          */
         _getBufferState(vertexDeclaration) {
             var bufferState = this._cacheBufferStates[vertexDeclaration.id];
             if (!bufferState) {
                 var instance = SubMeshDynamicBatch.instance;
                 bufferState = new BufferState();
                 bufferState.bind();
                 var vertexBuffer = instance._vertexBuffer;
                 vertexBuffer.vertexDeclaration = vertexDeclaration;
                 bufferState.applyVertexBuffer(vertexBuffer);
                 bufferState.applyIndexBuffer(instance._indexBuffer);
                 bufferState.unBind();
                 this._cacheBufferStates[vertexDeclaration.id] = bufferState;
             }
             return bufferState;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getBatchRenderElementFromPool() {
             var renderElement = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
             if (!renderElement) {
                 renderElement = new SubMeshRenderElement();
                 this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = renderElement;
                 renderElement.vertexBatchElementList = [];
                 renderElement.instanceBatchElementList = [];
             }
             return renderElement;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _clear() {
             super._clear();
             this._updateCountMark++;
         }
     }
     /** @private */
     MeshRenderDynamicBatchManager.instance = new MeshRenderDynamicBatchManager();

     /**
      * <code>MeshSprite3D</code> 类用于创建网格。
      */
     class MeshSprite3D extends RenderableSprite3D {
         /**
          * @private
          */
         static __init__() {
             MeshSprite3D.shaderDefines = new ShaderDefines(RenderableSprite3D.shaderDefines);
             MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0 = MeshSprite3D.shaderDefines.registerDefine("UV");
             MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR = MeshSprite3D.shaderDefines.registerDefine("COLOR");
             MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1 = MeshSprite3D.shaderDefines.registerDefine("UV1");
             MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE = MeshSprite3D.shaderDefines.registerDefine("GPU_INSTANCE");
             StaticBatchManager._registerManager(MeshRenderStaticBatchManager.instance);
             DynamicBatchManager._registerManager(MeshRenderDynamicBatchManager.instance);
         }
         /**
          * 获取网格过滤器。
          * @return  网格过滤器。
          */
         get meshFilter() {
             return this._meshFilter;
         }
         /**
          * 获取网格渲染器。
          * @return  网格渲染器。
          */
         get meshRenderer() {
             return this._render;
         }
         /**
          * 创建一个 <code>MeshSprite3D</code> 实例。
          * @param mesh 网格,同时会加载网格所用默认材质。
          * @param name 名字。
          */
         constructor(mesh = null, name = null) {
             super(name);
             this._meshFilter = new MeshFilter(this);
             this._render = new MeshRenderer(this);
             (mesh) && (this._meshFilter.sharedMesh = mesh);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             super._parse(data, spriteMap);
             var render = this.meshRenderer;
             var lightmapIndex = data.lightmapIndex;
             (lightmapIndex != null) && (render.lightmapIndex = lightmapIndex);
             var lightmapScaleOffsetArray = data.lightmapScaleOffset;
             (lightmapScaleOffsetArray) && (render.lightmapScaleOffset = new Vector4(lightmapScaleOffsetArray[0], lightmapScaleOffsetArray[1], lightmapScaleOffsetArray[2], lightmapScaleOffsetArray[3]));
             (data.meshPath != undefined) && (this.meshFilter.sharedMesh = Loader.getRes(data.meshPath));
             (data.enableRender != undefined) && (this.meshRenderer.enable = data.enableRender);
             var materials = data.materials;
             if (materials) {
                 var sharedMaterials = render.sharedMaterials;
                 var materialCount = materials.length;
                 sharedMaterials.length = materialCount;
                 for (var i = 0; i < materialCount; i++) {
                     sharedMaterials[i] = Loader.getRes(materials[i].path);
                 }
                 render.sharedMaterials = sharedMaterials;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _addToInitStaticBatchManager() {
             MeshRenderStaticBatchManager.instance._addBatchSprite(this);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _cloneTo(destObject, rootSprite, dstSprite) {
             var meshSprite3D = destObject;
             meshSprite3D._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
             var meshRender = this._render;
             var destMeshRender = meshSprite3D._render;
             destMeshRender.enable = meshRender.enable;
             destMeshRender.sharedMaterials = meshRender.sharedMaterials;
             destMeshRender.castShadow = meshRender.castShadow;
             var lightmapScaleOffset = meshRender.lightmapScaleOffset;
             lightmapScaleOffset && (destMeshRender.lightmapScaleOffset = lightmapScaleOffset.clone());
             destMeshRender.lightmapIndex = meshRender.lightmapIndex;
             destMeshRender.receiveShadow = meshRender.receiveShadow;
             destMeshRender.sortingFudge = meshRender.sortingFudge;
             super._cloneTo(destObject, rootSprite, dstSprite); //父类函数在最后,组件应该最后赋值，否则获取材质默认值等相关函数会有问题
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy(destroyChild = true) {
             if (this.destroyed)
                 return;
             super.destroy(destroyChild);
             this._meshFilter.destroy();
         }
         /**
          * @private
          */
         _create() {
             return new MeshSprite3D();
         }
     }

     /**
      * <code>SingletonList</code> 类用于实现单例队列。
      */
     class SingletonList {
         /**
          * 创建一个新的 <code>SingletonList</code> 实例。
          */
         constructor() {
             /**@private [只读]*/
             this.elements = [];
             /** @private [只读]*/
             this.length = 0;
         }
         /**
          * @private
          */
         _add(element) {
             if (this.length === this.elements.length)
                 this.elements.push(element);
             else
                 this.elements[this.length] = element;
         }
     }

     /**
         /**
          * <code>CastShadowList</code> 类用于实现产生阴影者队列。
          */
     class CastShadowList extends SingletonList {
         /**
          * 创建一个新的 <code>CastShadowList</code> 实例。
          */
         constructor() {
             super();
         }
         /**
          * @private
          */
         add(element) {
             var index = element._indexInCastShadowList;
             if (index !== -1)
                 throw "CastShadowList:element has  in  CastShadowList.";
             this._add(element);
             element._indexInCastShadowList = this.length++;
         }
         /**
          * @private
          */
         remove(element) {
             var index = element._indexInCastShadowList;
             this.length--;
             if (index !== this.length) {
                 var end = this.elements[this.length];
                 this.elements[index] = end;
                 end._indexInCastShadowList = index;
             }
             element._indexInCastShadowList = -1;
         }
     }

     /**
      * <code>SimpleSingletonList</code> 类用于实现单例队列。
      */
     class SimpleSingletonList extends SingletonList {
         /**
          * 创建一个新的 <code>SimpleSingletonList</code> 实例。
          */
         constructor() {
             super();
         }
         /**
          * @private
          */
         add(element) {
             var index = element._getIndexInList();
             if (index !== -1)
                 throw "SimpleSingletonList:" + element + " has  in  SingletonList.";
             this._add(element);
             element._setIndexInList(this.length++);
         }
         /**
          * @private
          */
         remove(element) {
             var index = element._getIndexInList();
             this.length--;
             if (index !== this.length) {
                 var end = this.elements[this.length];
                 this.elements[index] = end;
                 end._setIndexInList(index);
             }
             element._setIndexInList(-1);
         }
     }

     /**
      * @private
      */
     class MouseTouch {
         constructor() {
             /**@private */
             this._pressedSprite = null;
             /**@private */
             this._pressedLoopCount = -1;
             /**@private */
             this.sprite = null;
             /**@private */
             this.mousePositionX = 0;
             /**@private */
             this.mousePositionY = 0;
         }
     }

     /**
      * <code>Touch</code> 类用于实现触摸描述。
      */
     class Touch {
         /**
          * @private
          * 创建一个 <code>Touch</code> 实例。
          */
         constructor() {
             /** @private  [实现IListPool接口]*/
             this._indexInList = -1;
             /** @private */
             this._identifier = -1;
             /** @private */
             this._position = new Vector2();
         }
         /**
          * 获取唯一识别ID。
          * @return 唯一识别ID。
          */
         get identifier() {
             return this._identifier;
         }
         /**
          * 获取触摸点的像素坐标。
          * @return 触摸点的像素坐标 [只读]。
          */
         get position() {
             return this._position;
         }
         /**
          * @private [实现ISingletonElement接口]
          */
         _getIndexInList() {
             return this._indexInList;
         }
         /**
          * @private [实现ISingletonElement接口]
          */
         _setIndexInList(index) {
             this._indexInList = index;
         }
     }

     /**
      * <code>HitResult</code> 类用于实现射线检测或形状扫描的结果。
      */
     class HitResult {
         /**
          * 创建一个 <code>HitResult</code> 实例。
          */
         constructor() {
             /** 是否成功。 */
             this.succeeded = false;
             /** 发生碰撞的碰撞组件。*/
             this.collider = null;
             /** 碰撞点。*/
             this.point = new Vector3();
             /** 碰撞法线。*/
             this.normal = new Vector3();
             /** 碰撞分数。 */
             this.hitFraction = 0;
         }
     }

     /**
      * <code>Physics</code> 类用于简单物理检测。
      */
     class Physics3DUtils {
         /**
          * 创建一个 <code>Physics</code> 实例。
          */
         constructor() {
         }
         /**
          * 是否忽略两个碰撞器的碰撞检测。
          * @param	collider1 碰撞器一。
          * @param	collider2 碰撞器二。
          * @param	ignore 是否忽略。
          */
         static setColliderCollision(collider1, collider2, collsion) {
         }
         /**
          * 获取是否忽略两个碰撞器的碰撞检测。
          * @param	collider1 碰撞器一。
          * @param	collider2 碰撞器二。
          * @return	是否忽略。
          */
         static getIColliderCollision(collider1, collider2) {
             //return collider1._ignoreCollisonMap[collider2.id] ? true : false;
             return false;
         }
     }
     Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER = 0x1;
     Physics3DUtils.COLLISIONFILTERGROUP_STATICFILTER = 0x2;
     Physics3DUtils.COLLISIONFILTERGROUP_KINEMATICFILTER = 0x4;
     Physics3DUtils.COLLISIONFILTERGROUP_DEBRISFILTER = 0x8;
     Physics3DUtils.COLLISIONFILTERGROUP_SENSORTRIGGER = 0x10;
     Physics3DUtils.COLLISIONFILTERGROUP_CHARACTERFILTER = 0x20;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 0x40;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 0x80;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 0x100;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 0x200;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 0x400;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 0x800;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 0x1000;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 0x2000;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 0x4000;
     Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 0x8000;
     Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER = -1;
     /**重力值。*/
     Physics3DUtils.gravity = new Vector3(0, -9.81, 0);

     /**
      * <code>PhysicsUpdateList</code> 类用于实现物理更新队列。
      */
     class PhysicsUpdateList extends SingletonList {
         /**
          * 创建一个新的 <code>PhysicsUpdateList</code> 实例。
          */
         constructor() {
             super();
         }
         /**
          * @private
          */
         add(element) {
             var index = element._inPhysicUpdateListIndex;
             if (index !== -1)
                 throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
             this._add(element);
             element._inPhysicUpdateListIndex = this.length++;
         }
         /**
          * @private
          */
         remove(element) {
             var index = element._inPhysicUpdateListIndex;
             this.length--;
             if (index !== this.length) {
                 var end = this.elements[this.length];
                 this.elements[index] = end;
                 end._inPhysicUpdateListIndex = index;
             }
             element._inPhysicUpdateListIndex = -1;
         }
     }

     /**
      * <code>ContactPoint</code> 类用于创建物理碰撞信息。
      */
     class ContactPoint {
         /**
          * 创建一个 <code>ContactPoint</code> 实例。
          */
         constructor() {
             /**@private */
             this._idCounter = 0;
             /**碰撞器A。*/
             this.colliderA = null;
             /**碰撞器B。*/
             this.colliderB = null;
             /**距离。*/
             this.distance = 0;
             /**法线。*/
             this.normal = new Vector3();
             /**碰撞器A的碰撞点。*/
             this.positionOnA = new Vector3();
             /**碰撞器B的碰撞点。*/
             this.positionOnB = new Vector3();
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             this._id = ++this._idCounter;
         }
     }

     /**
      * <code>Collision</code> 类用于创建物理碰撞信息。
      */
     class Collision {
         /**
          * 创建一个 <code>Collision</code> 实例。
          */
         constructor() {
             /**@private */
             this._lastUpdateFrame = -2147483648 /*int.MIN_VALUE*/;
             /**@private */
             this._updateFrame = -2147483648 /*int.MIN_VALUE*/;
             /**@private */
             this._isTrigger = false;
             /**@private [只读]*/
             this.contacts = [];
         }
         /**
          * @private
          */
         _setUpdateFrame(farme) {
             this._lastUpdateFrame = this._updateFrame; //TODO:为啥整两个
             this._updateFrame = farme;
         }
     }

     /**
      * <code>CollisionMap</code> 类用于实现碰撞组合实例图。
      */
     class CollisionTool {
         /**
          * 创建一个 <code>CollisionMap</code> 实例。
          */
         constructor() {
             /**@private	*/
             this._hitResultsPoolIndex = 0;
             /**@private	*/
             this._hitResultsPool = [];
             /**@private	*/
             this._contactPonintsPoolIndex = 0;
             /**@private	*/
             this._contactPointsPool = [];
             /**@private */
             this._collisionsPool = [];
             /**@private */
             this._collisions = {};
         }
         /**
          * @private
          */
         getHitResult() {
             var hitResult = this._hitResultsPool[this._hitResultsPoolIndex++];
             if (!hitResult) {
                 hitResult = new HitResult();
                 this._hitResultsPool.push(hitResult);
             }
             return hitResult;
         }
         /**
          * @private
          */
         recoverAllHitResultsPool() {
             this._hitResultsPoolIndex = 0;
         }
         /**
          * @private
          */
         getContactPoints() {
             var contactPoint = this._contactPointsPool[this._contactPonintsPoolIndex++];
             if (!contactPoint) {
                 contactPoint = new ContactPoint();
                 this._contactPointsPool.push(contactPoint);
             }
             return contactPoint;
         }
         /**
          * @private
          */
         recoverAllContactPointsPool() {
             this._contactPonintsPoolIndex = 0;
         }
         /**
          * @private
          */
         getCollision(physicComponentA, physicComponentB) {
             var collision;
             var idA = physicComponentA.id;
             var idB = physicComponentB.id;
             var subCollisionFirst = this._collisions[idA];
             if (subCollisionFirst)
                 collision = subCollisionFirst[idB];
             if (!collision) {
                 if (!subCollisionFirst) {
                     subCollisionFirst = {};
                     this._collisions[idA] = subCollisionFirst;
                 }
                 collision = this._collisionsPool.length === 0 ? new Collision() : this._collisionsPool.pop();
                 collision._colliderA = physicComponentA;
                 collision._colliderB = physicComponentB;
                 subCollisionFirst[idB] = collision;
             }
             return collision;
         }
         /**
          * @private
          */
         recoverCollision(collision) {
             var idA = collision._colliderA.id;
             var idB = collision._colliderB.id;
             this._collisions[idA][idB] = null;
             this._collisionsPool.push(collision);
         }
         /**
          * @private
          */
         garbageCollection() {
             this._hitResultsPoolIndex = 0;
             this._hitResultsPool.length = 0;
             this._contactPonintsPoolIndex = 0;
             this._contactPointsPool.length = 0;
             this._collisionsPool.length = 0;
             for (var subCollisionsKey in this._collisionsPool) {
                 var subCollisions = this._collisionsPool[subCollisionsKey];
                 var wholeDelete = true;
                 for (var collisionKey in subCollisions) {
                     if (subCollisions[collisionKey])
                         wholeDelete = false;
                     else
                         delete subCollisions[collisionKey];
                 }
                 if (wholeDelete)
                     delete this._collisionsPool[subCollisionsKey];
             }
         }
     }

     class Physics {
     }
     /**@private */
     Physics._physics3D = null;
     /**@private */
     Physics._enbalePhysics = false;

     /**
      * <code>ColliderShape</code> 类用于创建形状碰撞器的父类，该类为抽象类。
      */
     class ColliderShape {
         /**
          * 创建一个新的 <code>ColliderShape</code> 实例。
          */
         constructor() {
             /**@private */
             this._scale = new Vector3(1, 1, 1);
             /**@private */
             this._centerMatrix = new Matrix4x4();
             /**@private */
             this._attatched = false;
             /**@private */
             this._indexInCompound = -1;
             /**@private */
             this._compoundParent = null;
             /**@private */
             this._attatchedCollisionObject = null;
             /**@private */
             this._referenceCount = 0;
             /**@private */
             this._localOffset = new Vector3(0, 0, 0);
             /**@private */
             this._localRotation = new Quaternion(0, 0, 0, 1);
             this.needsCustomCollisionCallback = false; //TODO:默认值,TODO:::::::::::::::::::::::::::::::
         }
         /**
          * @private
          */
         static __init__() {
             ColliderShape._nativeScale = new Physics._physics3D.btVector3(1, 1, 1);
             ColliderShape._nativeVector30 = new Physics._physics3D.btVector3(0, 0, 0);
             ColliderShape._nativQuaternion0 = new Physics._physics3D.btQuaternion(0, 0, 0, 1);
             ColliderShape._nativeTransform0 = new Physics._physics3D.btTransform();
         }
         /**
          * @private
          */
         static _createAffineTransformation(trans, rot, outE) {
             var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
             var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
             var wx = w * x2, wy = w * y2, wz = w * z2;
             outE[0] = (1 - (yy + zz));
             outE[1] = (xy + wz);
             outE[2] = (xz - wy);
             outE[3] = 0;
             outE[4] = (xy - wz);
             outE[5] = (1 - (xx + zz));
             outE[6] = (yz + wx);
             outE[7] = 0;
             outE[8] = (xz + wy);
             outE[9] = (yz - wx);
             outE[10] = (1 - (xx + yy));
             outE[11] = 0;
             outE[12] = trans.x;
             outE[13] = trans.y;
             outE[14] = trans.z;
             outE[15] = 1;
         }
         /**
          * 获取碰撞类型。
          * @return 碰撞类型。
          */
         get type() {
             return this._type;
         }
         /**
          * 获取Shape的本地偏移。
          * @return Shape的本地偏移。
          */
         get localOffset() {
             return this._localOffset;
         }
         /**
          * 设置Shape的本地偏移。
          * @param Shape的本地偏移。
          */
         set localOffset(value) {
             this._localOffset = value;
             if (this._compoundParent)
                 this._compoundParent._updateChildTransform(this);
         }
         /**
          * 获取Shape的本地旋转。
          * @return Shape的本地旋转。
          */
         get localRotation() {
             return this._localRotation;
         }
         /**
          * 设置Shape的本地旋转。
          * @param Shape的本地旋转。
          */
         set localRotation(value) {
             this._localRotation = value;
             if (this._compoundParent)
                 this._compoundParent._updateChildTransform(this);
         }
         /**
          * @private
          */
         _setScale(value) {
             if (this._compoundParent) { //TODO:待查,这里有问题
                 this.updateLocalTransformations();
             }
             else {
                 ColliderShape._nativeScale.setValue(value.x, value.y, value.z);
                 this._nativeShape.setLocalScaling(ColliderShape._nativeScale);
             }
         }
         /**
          * @private
          */
         _addReference() {
             this._referenceCount++;
         }
         /**
          * @private
          */
         _removeReference() {
             this._referenceCount--;
         }
         /**
          * 更新本地偏移,如果修改LocalOffset或LocalRotation需要调用。
          */
         updateLocalTransformations() {
             if (this._compoundParent) {
                 var offset = ColliderShape._tempVector30;
                 Vector3.multiply(this.localOffset, this._scale, offset);
                 ColliderShape._createAffineTransformation(offset, this.localRotation, this._centerMatrix.elements);
             }
             else {
                 ColliderShape._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
             }
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destColliderShape = destObject;
             this._localOffset.cloneTo(destColliderShape.localOffset);
             this._localRotation.cloneTo(destColliderShape.localRotation);
             destColliderShape.localOffset = destColliderShape.localOffset;
             destColliderShape.localRotation = destColliderShape.localRotation;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             return null;
         }
         /**
          * @private
          */
         destroy() {
             if (this._nativeShape) {
                 Physics._physics3D.destroy(this._nativeShape);
                 this._nativeShape = null;
             }
         }
     }
     /** @private */
     ColliderShape.SHAPEORIENTATION_UPX = 0;
     /** @private */
     ColliderShape.SHAPEORIENTATION_UPY = 1;
     /** @private */
     ColliderShape.SHAPEORIENTATION_UPZ = 2;
     /** @private */
     ColliderShape.SHAPETYPES_BOX = 0;
     /** @private */
     ColliderShape.SHAPETYPES_SPHERE = 1;
     /** @private */
     ColliderShape.SHAPETYPES_CYLINDER = 2;
     /** @private */
     ColliderShape.SHAPETYPES_CAPSULE = 3;
     /** @private */
     ColliderShape.SHAPETYPES_CONVEXHULL = 4;
     /** @private */
     ColliderShape.SHAPETYPES_COMPOUND = 5;
     /** @private */
     ColliderShape.SHAPETYPES_STATICPLANE = 6;
     /** @private */
     ColliderShape.SHAPETYPES_CONE = 7;
     /** @private */
     ColliderShape._tempVector30 = new Vector3();

     /**
      * <code>BoxColliderShape</code> 类用于创建盒子形状碰撞器。
      */
     class BoxColliderShape extends ColliderShape {
         /**
         * @private
         */
         static __init__() {
             BoxColliderShape._nativeSize = new Physics._physics3D.btVector3(0, 0, 0);
         }
         /**
          * 获取X轴尺寸。
          */
         get sizeX() {
             return this._sizeX;
         }
         /**
          * 获取Y轴尺寸。
          */
         get sizeY() {
             return this._sizeY;
         }
         /**
          * 获取Z轴尺寸。
          */
         get sizeZ() {
             return this._sizeZ;
         }
         /**
          * 创建一个新的 <code>BoxColliderShape</code> 实例。
          * @param sizeX 盒子X轴尺寸。
          * @param sizeY 盒子Y轴尺寸。
          * @param sizeZ 盒子Z轴尺寸。
          */
         constructor(sizeX = 1.0, sizeY = 1.0, sizeZ = 1.0) {
             super();
             this._sizeX = sizeX;
             this._sizeY = sizeY;
             this._sizeZ = sizeZ;
             this._type = ColliderShape.SHAPETYPES_BOX;
             BoxColliderShape._nativeSize.setValue(sizeX / 2, sizeY / 2, sizeZ / 2);
             this._nativeShape = new Physics._physics3D.btBoxShape(BoxColliderShape._nativeSize);
         }
         /**
          * @inheritDoc
          */
         clone() {
             var dest = new BoxColliderShape(this._sizeX, this._sizeY, this._sizeZ);
             this.cloneTo(dest);
             return dest;
         }
     }

     /**
      * <code>CapsuleColliderShape</code> 类用于创建胶囊形状碰撞器。
      */
     class CapsuleColliderShape extends ColliderShape {
         /**
          * 创建一个新的 <code>CapsuleColliderShape</code> 实例。
          * @param 半径。
          * @param 高(包含半径)。
          * @param orientation 胶囊体方向。
          */
         constructor(radius = 0.5, length = 1.25, orientation = ColliderShape.SHAPEORIENTATION_UPY) {
             super();
             this._radius = radius;
             this._length = length;
             this._orientation = orientation;
             this._type = ColliderShape.SHAPETYPES_CAPSULE;
             switch (orientation) {
                 case ColliderShape.SHAPEORIENTATION_UPX:
                     this._nativeShape = new Physics._physics3D.btCapsuleShapeX(radius, length - radius * 2);
                     break;
                 case ColliderShape.SHAPEORIENTATION_UPY:
                     this._nativeShape = new Physics._physics3D.btCapsuleShape(radius, length - radius * 2);
                     break;
                 case ColliderShape.SHAPEORIENTATION_UPZ:
                     this._nativeShape = new Physics._physics3D.btCapsuleShapeZ(radius, length - radius * 2);
                     break;
                 default:
                     throw "CapsuleColliderShape:unknown orientation.";
             }
         }
         /**
          * 获取半径。
          */
         get radius() {
             return this._radius;
         }
         /**
          * 获取长度。
          */
         get length() {
             return this._length;
         }
         /**
          * 获取方向。
          */
         get orientation() {
             return this._orientation;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _setScale(value) {
             var fixScale = CapsuleColliderShape._tempVector30;
             switch (this.orientation) {
                 case ColliderShape.SHAPEORIENTATION_UPX:
                     fixScale.x = value.x;
                     fixScale.y = fixScale.z = Math.max(value.y, value.z);
                     break;
                 case ColliderShape.SHAPEORIENTATION_UPY:
                     fixScale.y = value.y;
                     fixScale.x = fixScale.z = Math.max(value.x, value.z);
                     break;
                 case ColliderShape.SHAPEORIENTATION_UPZ:
                     fixScale.z = value.z;
                     fixScale.x = fixScale.y = Math.max(value.x, value.y);
                     break;
                 default:
                     throw "CapsuleColliderShape:unknown orientation.";
             }
             super._setScale(fixScale);
         }
         /**
          * @inheritDoc
          */
         /*override*/ clone() {
             var dest = new CapsuleColliderShape(this._radius, this._length, this._orientation);
             this.cloneTo(dest);
             return dest;
         }
     }
     /** @private */
     CapsuleColliderShape._tempVector30 = new Vector3();

     /**
      * <code>CompoundColliderShape</code> 类用于创建盒子形状碰撞器。
      */
     class CompoundColliderShape extends ColliderShape {
         /**
          * 创建一个新的 <code>CompoundColliderShape</code> 实例。
          */
         constructor() {
             super();
             /**@private */
             this._childColliderShapes = [];
             this._type = ColliderShape.SHAPETYPES_COMPOUND;
             this._nativeShape = new Physics._physics3D.btCompoundShape();
         }
         /**
          * @private
          */
         static __init__() {
             CompoundColliderShape._nativeVector3One = new Physics._physics3D.btVector3(1, 1, 1);
             CompoundColliderShape._nativeTransform = new Physics._physics3D.btTransform();
             CompoundColliderShape._nativeOffset = new Physics._physics3D.btVector3(0, 0, 0);
             CompoundColliderShape._nativRotation = new Physics._physics3D.btQuaternion(0, 0, 0, 1);
         }
         /**
          * @private
          */
         _clearChildShape(shape) {
             shape._attatched = false;
             shape._compoundParent = null;
             shape._indexInCompound = -1;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _addReference() {
             //TODO:
         }
         /**
          * @inheritDoc
          */
         /*override*/ _removeReference() {
             //TODO:
         }
         /**
          * @private
          */
         _updateChildTransform(shape) {
             var offset = shape.localOffset;
             var rotation = shape.localRotation;
             var nativeOffset = ColliderShape._nativeVector30;
             var nativeQuaternion = ColliderShape._nativQuaternion0;
             var nativeTransform = ColliderShape._nativeTransform0;
             nativeOffset.setValue(-offset.x, offset.y, offset.z);
             nativeQuaternion.setValue(-rotation.x, rotation.y, rotation.z, -rotation.w);
             nativeTransform.setOrigin(nativeOffset);
             nativeTransform.setRotation(nativeQuaternion);
             this._nativeShape.updateChildTransform(shape._indexInCompound, nativeTransform, true);
         }
         /**
          * 添加子碰撞器形状。
          * @param	shape 子碰撞器形状。
          */
         addChildShape(shape) {
             if (shape._attatched)
                 throw "CompoundColliderShape: this shape has attatched to other entity.";
             shape._attatched = true;
             shape._compoundParent = this;
             shape._indexInCompound = this._childColliderShapes.length;
             this._childColliderShapes.push(shape);
             var offset = shape.localOffset;
             var rotation = shape.localRotation;
             CompoundColliderShape._nativeOffset.setValue(-offset.x, offset.y, offset.z);
             CompoundColliderShape._nativRotation.setValue(-rotation.x, rotation.y, rotation.z, -rotation.w);
             CompoundColliderShape._nativeTransform.setOrigin(CompoundColliderShape._nativeOffset);
             CompoundColliderShape._nativeTransform.setRotation(CompoundColliderShape._nativRotation);
             var nativeScale = this._nativeShape.getLocalScaling();
             this._nativeShape.setLocalScaling(CompoundColliderShape._nativeVector3One);
             this._nativeShape.addChildShape(CompoundColliderShape._nativeTransform, shape._nativeShape);
             this._nativeShape.setLocalScaling(nativeScale);
             (this._attatchedCollisionObject) && (this._attatchedCollisionObject.colliderShape = this); //修改子Shape需要重新赋值父Shape以及将物理精灵重新加入物理世界等操作
         }
         /**
          * 移除子碰撞器形状。
          * @param	shape 子碰撞器形状。
          */
         removeChildShape(shape) {
             if (shape._compoundParent === this) {
                 var index = shape._indexInCompound;
                 this._clearChildShape(shape);
                 var endShape = this._childColliderShapes[this._childColliderShapes.length - 1];
                 endShape._indexInCompound = index;
                 this._childColliderShapes[index] = endShape;
                 this._childColliderShapes.pop();
                 this._nativeShape.removeChildShapeByIndex(index);
             }
         }
         /**
          * 清空子碰撞器形状。
          */
         clearChildShape() {
             for (var i = 0, n = this._childColliderShapes.length; i < n; i++) {
                 this._clearChildShape(this._childColliderShapes[i]);
                 this._nativeShape.removeChildShapeByIndex(0);
             }
             this._childColliderShapes.length = 0;
         }
         /**
          * 获取子形状数量。
          * @return
          */
         getChildShapeCount() {
             return this._childColliderShapes.length;
         }
         /**
          * @inheritDoc
          */
         /*override*/ cloneTo(destObject) {
             var destCompoundColliderShape = destObject;
             destCompoundColliderShape.clearChildShape();
             for (var i = 0, n = this._childColliderShapes.length; i < n; i++)
                 destCompoundColliderShape.addChildShape(this._childColliderShapes[i].clone());
         }
         /**
          * @inheritDoc
          */
         /*override*/ clone() {
             var dest = new CompoundColliderShape();
             this.cloneTo(dest);
             return dest;
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy() {
             super.destroy();
             for (var i = 0, n = this._childColliderShapes.length; i < n; i++) {
                 var childShape = this._childColliderShapes[i];
                 if (childShape._referenceCount === 0)
                     childShape.destroy();
             }
         }
     }

     /**
      * <code>ConeColliderShape</code> 类用于创建圆柱碰撞器。
      */
     class ConeColliderShape extends ColliderShape {
         /**
          * 创建一个新的 <code>ConeColliderShape</code> 实例。
          * @param height 高。
          * @param radius 半径。
          */
         constructor(radius = 0.5, height = 1.0, orientation = ColliderShape.SHAPEORIENTATION_UPY) {
             super();
             /**@private */
             this._radius = 1;
             /**@private */
             this._height = 0.5;
             this._radius = radius;
             this._height = height;
             this._orientation = orientation;
             this._type = ColliderShape.SHAPETYPES_CYLINDER;
             switch (orientation) {
                 case ColliderShape.SHAPEORIENTATION_UPX:
                     this._nativeShape = new Physics._physics3D.btConeShapeX(radius, height);
                     break;
                 case ColliderShape.SHAPEORIENTATION_UPY:
                     this._nativeShape = new Physics._physics3D.btConeShape(radius, height);
                     break;
                 case ColliderShape.SHAPEORIENTATION_UPZ:
                     this._nativeShape = new Physics._physics3D.btConeShapeZ(radius, height);
                     break;
                 default:
                     throw "ConeColliderShape:unknown orientation.";
             }
         }
         /**
          * 获取半径。
          */
         get radius() {
             return this._radius;
         }
         /**
          * 获取高度。
          */
         get height() {
             return this._height;
         }
         /**
          * 获取方向。
          */
         get orientation() {
             return this._orientation;
         }
         /**
          * @inheritDoc
          */
         /*override*/ clone() {
             var dest = new ConeColliderShape(this._radius, this._height, this._orientation);
             this.cloneTo(dest);
             return dest;
         }
     }

     /**
      * <code>CylinderColliderShape</code> 类用于创建圆柱碰撞器。
      */
     class CylinderColliderShape extends ColliderShape {
         /**
          * 创建一个新的 <code>CylinderColliderShape</code> 实例。
          * @param height 高。
          * @param radius 半径。
          */
         constructor(radius = 0.5, height = 1.0, orientation = ColliderShape.SHAPEORIENTATION_UPY) {
             super();
             /**@private */
             this._radius = 1;
             /**@private */
             this._height = 0.5;
             this._radius = radius;
             this._height = height;
             this._orientation = orientation;
             this._type = ColliderShape.SHAPETYPES_CYLINDER;
             switch (orientation) {
                 case ColliderShape.SHAPEORIENTATION_UPX:
                     CylinderColliderShape._nativeSize.setValue(height / 2, radius, radius);
                     this._nativeShape = new Physics._physics3D.btCylinderShapeX(CylinderColliderShape._nativeSize);
                     break;
                 case ColliderShape.SHAPEORIENTATION_UPY:
                     CylinderColliderShape._nativeSize.setValue(radius, height / 2, radius);
                     this._nativeShape = new Physics._physics3D.btCylinderShape(CylinderColliderShape._nativeSize);
                     break;
                 case ColliderShape.SHAPEORIENTATION_UPZ:
                     CylinderColliderShape._nativeSize.setValue(radius, radius, height / 2);
                     this._nativeShape = new Physics._physics3D.btCylinderShapeZ(CylinderColliderShape._nativeSize);
                     break;
                 default:
                     throw "CapsuleColliderShape:unknown orientation.";
             }
         }
         /**
     * @private
     */
         static __init__() {
             CylinderColliderShape._nativeSize = new Physics._physics3D.btVector3(0, 0, 0);
         }
         /**
          * 获取半径。
          */
         get radius() {
             return this._radius;
         }
         /**
          * 获取高度。
          */
         get height() {
             return this._height;
         }
         /**
          * 获取方向。
          */
         get orientation() {
             return this._orientation;
         }
         /**
          * @inheritDoc
          */
         /*override*/ clone() {
             var dest = new CylinderColliderShape(this._radius, this._height, this._orientation);
             this.cloneTo(dest);
             return dest;
         }
     }

     /**
      * <code>MeshColliderShape</code> 类用于创建网格碰撞器。
      */
     class MeshColliderShape extends ColliderShape {
         /**
          * 创建一个新的 <code>MeshColliderShape</code> 实例。
          */
         constructor() {
             super();
             /**@private */
             this._mesh = null;
             /**@private */
             this._convex = false;
         }
         /**
          * 获取网格。
          * @return 网格。
          */
         get mesh() {
             return this._mesh;
         }
         /**
          * 设置网格。
          * @param 网格。
          */
         set mesh(value) {
             if (this._mesh !== value) {
                 var physics3D = Physics._physics3D;
                 if (this._mesh) {
                     physics3D.destroy(this._nativeShape);
                 }
                 if (value) {
                     this._nativeShape = new Physics._physics3D.btGImpactMeshShape(value._getPhysicMesh());
                     this._nativeShape.updateBound();
                 }
                 this._mesh = value;
             }
         }
         /**
          * 获取是否使用凸多边形。
          * @return 是否使用凸多边形。
          */
         get convex() {
             return this._convex;
         }
         /**
          * 设置是否使用凸多边形。
          * @param value 是否使用凸多边形。
          */
         set convex(value) {
             this._convex = value;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _setScale(value) {
             if (this._compoundParent) { //TODO:待查,这里有问题
                 this.updateLocalTransformations(); //TODO:
             }
             else {
                 ColliderShape._nativeScale.setValue(value.x, value.y, value.z);
                 this._nativeShape.setLocalScaling(ColliderShape._nativeScale);
                 this._nativeShape.updateBound(); //更新缩放后需要更新包围体,有性能损耗
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ cloneTo(destObject) {
             var destMeshCollider = destObject;
             destMeshCollider.convex = this._convex;
             destMeshCollider.mesh = this._mesh;
             super.cloneTo(destObject);
         }
         /**
          * @inheritDoc
          */
         /*override*/ clone() {
             var dest = new MeshColliderShape();
             this.cloneTo(dest);
             return dest;
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy() {
             if (this._nativeShape) {
                 var physics3D = Physics._physics3D;
                 physics3D.destroy(this._nativeShape);
                 this._nativeShape = null;
             }
         }
     }

     /**
      * <code>SphereColliderShape</code> 类用于创建球形碰撞器。
      */
     class SphereColliderShape extends ColliderShape {
         /**
          * 获取半径。
          */
         get radius() {
             return this._radius;
         }
         /**
          * 创建一个新的 <code>SphereColliderShape</code> 实例。
          * @param radius 半径。
          */
         constructor(radius = 0.5) {
             super();
             this._radius = radius;
             this._type = ColliderShape.SHAPETYPES_SPHERE;
             this._nativeShape = new Physics._physics3D.btSphereShape(radius);
         }
         /**
          * @inheritDoc
          */
         /*override*/ clone() {
             var dest = new SphereColliderShape(this._radius);
             this.cloneTo(dest);
             return dest;
         }
     }

     /**
      * <code>PhysicsComponent</code> 类用于创建物理组件的父类。
      */
     class PhysicsComponent extends Component {
         /**
          * 创建一个 <code>PhysicsComponent</code> 实例。
          * @param collisionGroup 所属碰撞组。
          * @param canCollideWith 可产生碰撞的碰撞组。
          */
         constructor(collisionGroup, canCollideWith) {
             super();
             /** @private */
             this._restitution = 0.0;
             /** @private */
             this._friction = 0.5;
             /** @private */
             this._rollingFriction = 0.0;
             /** @private */
             this._ccdMotionThreshold = 0.0;
             /** @private */
             this._ccdSweptSphereRadius = 0.0;
             /** @private */
             this._collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER;
             /** @private */
             this._canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER;
             /** @private */
             this._colliderShape = null;
             /** @private */
             this._transformFlag = 2147483647 /*int.MAX_VALUE*/;
             /** @private */
             this._enableProcessCollisions = true;
             /** @private */
             this._inPhysicUpdateListIndex = -1;
             /** 是否可以缩放Shape。 */
             this.canScaleShape = true;
             this._collisionGroup = collisionGroup;
             this._canCollideWith = canCollideWith;
             PhysicsComponent._physicObjectsMap[this.id] = this;
         }
         /**
         * @private
         */
         static __init__() {
             PhysicsComponent._nativeVector30 = new Physics._physics3D.btVector3(0, 0, 0);
             PhysicsComponent._nativeQuaternion0 = new Physics._physics3D.btQuaternion(0, 0, 0, 1);
         }
         /**
          * @private
          */
         static _createAffineTransformationArray(tranX, tranY, tranZ, rotX, rotY, rotZ, rotW, scale, outE) {
             var x2 = rotX + rotX, y2 = rotY + rotY, z2 = rotZ + rotZ;
             var xx = rotX * x2, xy = rotX * y2, xz = rotX * z2, yy = rotY * y2, yz = rotY * z2, zz = rotZ * z2;
             var wx = rotW * x2, wy = rotW * y2, wz = rotW * z2, sx = scale[0], sy = scale[1], sz = scale[2];
             outE[0] = (1 - (yy + zz)) * sx;
             outE[1] = (xy + wz) * sx;
             outE[2] = (xz - wy) * sx;
             outE[3] = 0;
             outE[4] = (xy - wz) * sy;
             outE[5] = (1 - (xx + zz)) * sy;
             outE[6] = (yz + wx) * sy;
             outE[7] = 0;
             outE[8] = (xz + wy) * sz;
             outE[9] = (yz - wx) * sz;
             outE[10] = (1 - (xx + yy)) * sz;
             outE[11] = 0;
             outE[12] = tranX;
             outE[13] = tranY;
             outE[14] = tranZ;
             outE[15] = 1;
         }
         /**
     * @private
     */
         static _creatShape(shapeData) {
             var colliderShape;
             switch (shapeData.type) {
                 case "BoxColliderShape":
                     var sizeData = shapeData.size;
                     colliderShape = sizeData ? new BoxColliderShape(sizeData[0], sizeData[1], sizeData[2]) : new BoxColliderShape();
                     break;
                 case "SphereColliderShape":
                     colliderShape = new SphereColliderShape(shapeData.radius);
                     break;
                 case "CapsuleColliderShape":
                     colliderShape = new CapsuleColliderShape(shapeData.radius, shapeData.height, shapeData.orientation);
                     break;
                 case "MeshColliderShape":
                     var meshCollider = new MeshColliderShape();
                     shapeData.mesh && (meshCollider.mesh = Loader.getRes(shapeData.mesh));
                     colliderShape = meshCollider;
                     break;
                 case "ConeColliderShape":
                     colliderShape = new ConeColliderShape(shapeData.radius, shapeData.height, shapeData.orientation);
                     break;
                 case "CylinderColliderShape":
                     colliderShape = new CylinderColliderShape(shapeData.radius, shapeData.height, shapeData.orientation);
                     break;
                 default:
                     throw "unknown shape type.";
             }
             if (shapeData.center) {
                 var localOffset = colliderShape.localOffset;
                 localOffset.fromArray(shapeData.center);
                 colliderShape.localOffset = localOffset;
             }
             return colliderShape;
         }
         /**
          * @private
          */
         static physicVector3TransformQuat(source, qx, qy, qz, qw, out) {
             var x = source.x, y = source.y, z = source.z, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
             out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
             out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
             out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
         }
         /**
          * @private
          */
         static physicQuaternionMultiply(lx, ly, lz, lw, right, out) {
             var rx = right.x;
             var ry = right.y;
             var rz = right.z;
             var rw = right.w;
             var a = (ly * rz - lz * ry);
             var b = (lz * rx - lx * rz);
             var c = (lx * ry - ly * rx);
             var d = (lx * rx + ly * ry + lz * rz);
             out.x = (lx * rw + rx * lw) + a;
             out.y = (ly * rw + ry * lw) + b;
             out.z = (lz * rw + rz * lw) + c;
             out.w = lw * rw - d;
         }
         /**
          * 获取弹力。
          * @return 弹力。
          */
         get restitution() {
             return this._restitution;
         }
         /**
          * 设置弹力。
          * @param 弹力。
          */
         set restitution(value) {
             this._restitution = value;
             this._nativeColliderObject && this._nativeColliderObject.setRestitution(value);
         }
         /**
          * 获取摩擦力。
          * @return 摩擦力。
          */
         get friction() {
             return this._friction;
         }
         /**
          * 设置摩擦力。
          * @param value 摩擦力。
          */
         set friction(value) {
             this._friction = value;
             this._nativeColliderObject && this._nativeColliderObject.setFriction(value);
         }
         /**
          * 获取滚动摩擦力。
          * @return 滚动摩擦力。
          */
         get rollingFriction() {
             return this._nativeColliderObject.getRollingFriction();
         }
         /**
          * 设置滚动摩擦力。
          * @param 滚动摩擦力。
          */
         set rollingFriction(value) {
             this._rollingFriction = value;
             this._nativeColliderObject && this._nativeColliderObject.setRollingFriction(value);
         }
         /**
          *获取用于连续碰撞检测(CCD)的速度阈值,当物体移动速度小于该值时不进行CCD检测,防止快速移动物体(例如:子弹)错误的穿过其它物体,0表示禁止。
          * @return 连续碰撞检测(CCD)的速度阈值。
          */
         get ccdMotionThreshold() {
             return this._ccdMotionThreshold;
         }
         /**
          *设置用于连续碰撞检测(CCD)的速度阈值，当物体移动速度小于该值时不进行CCD检测,防止快速移动物体(例如:子弹)错误的穿过其它物体,0表示禁止。
          * @param value 连续碰撞检测(CCD)的速度阈值。
          */
         set ccdMotionThreshold(value) {
             this._ccdMotionThreshold = value;
             this._nativeColliderObject && this._nativeColliderObject.setCcdMotionThreshold(value);
         }
         /**
          *获取用于进入连续碰撞检测(CCD)范围的球半径。
          * @return 球半径。
          */
         get ccdSweptSphereRadius() {
             return this._ccdSweptSphereRadius;
         }
         /**
          *设置用于进入连续碰撞检测(CCD)范围的球半径。
          * @param 球半径。
          */
         set ccdSweptSphereRadius(value) {
             this._ccdSweptSphereRadius = value;
             this._nativeColliderObject && this._nativeColliderObject.setCcdSweptSphereRadius(value);
         }
         /**
          * 获取是否激活。
          */
         get isActive() {
             return this._nativeColliderObject ? this._nativeColliderObject.isActive() : false;
         }
         /**
          * @inheritDoc
          */
         /*override*/ set enabled(value) {
             if (this._simulation && this._colliderShape) {
                 if (value) {
                     this._derivePhysicsTransformation(true);
                     this._addToSimulation();
                 }
                 else {
                     this._removeFromSimulation();
                 }
             }
             super.enabled = value;
         }
         /**
          * 获取碰撞形状。
          */
         get colliderShape() {
             return this._colliderShape;
         }
         /**
          * 设置碰撞形状。
          */
         set colliderShape(value) {
             var lastColliderShape = this._colliderShape;
             if (lastColliderShape) {
                 lastColliderShape._attatched = false;
                 lastColliderShape._attatchedCollisionObject = null;
             }
             this._colliderShape = value;
             if (value) {
                 if (value._attatched) {
                     throw "PhysicsComponent: this shape has attatched to other entity.";
                 }
                 else {
                     value._attatched = true;
                     value._attatchedCollisionObject = this;
                 }
                 if (this._nativeColliderObject) {
                     this._nativeColliderObject.setCollisionShape(value._nativeShape);
                     var canInSimulation = this._simulation && this._enabled;
                     (canInSimulation && lastColliderShape) && (this._removeFromSimulation()); //修改shape必须把Collison从物理世界中移除再重新添加
                     this._onShapeChange(value); //修改shape会计算惯性
                     if (canInSimulation) {
                         this._derivePhysicsTransformation(true);
                         this._addToSimulation();
                     }
                 }
             }
             else {
                 if (this._simulation && this._enabled)
                     lastColliderShape && this._removeFromSimulation();
             }
         }
         /**
          * 获取模拟器。
          * @return 模拟器。
          */
         get simulation() {
             return this._simulation;
         }
         /**
          * 获取所属碰撞组。
          * @return 所属碰撞组。
          */
         get collisionGroup() {
             return this._collisionGroup;
         }
         /**
          * 设置所属碰撞组。
          * @param 所属碰撞组。
          */
         set collisionGroup(value) {
             if (this._collisionGroup !== value) {
                 this._collisionGroup = value;
                 if (this._simulation && this._colliderShape && this._enabled) {
                     this._removeFromSimulation();
                     this._addToSimulation();
                 }
             }
         }
         /**
          * 获取可碰撞的碰撞组。
          * @return 可碰撞组。
          */
         get canCollideWith() {
             return this._canCollideWith;
         }
         /**
          * 设置可碰撞的碰撞组。
          * @param 可碰撞组。
          */
         set canCollideWith(value) {
             if (this._canCollideWith !== value) {
                 this._canCollideWith = value;
                 if (this._simulation && this._colliderShape && this._enabled) {
                     this._removeFromSimulation();
                     this._addToSimulation();
                 }
             }
         }
         /**
          * @private
          */
         _isValid() {
             return this._simulation && this._colliderShape && this._enabled;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data) {
             (data.collisionGroup != null) && (this.collisionGroup = data.collisionGroup);
             (data.canCollideWith != null) && (this.canCollideWith = data.canCollideWith);
             (data.ccdMotionThreshold != null) && (this.ccdMotionThreshold = data.ccdMotionThreshold);
             (data.ccdSweptSphereRadius != null) && (this.ccdSweptSphereRadius = data.ccdSweptSphereRadius);
         }
         /**
          * @private
          */
         _parseShape(shapesData) {
             var shapeCount = shapesData.length;
             if (shapeCount === 1) {
                 var shape = PhysicsComponent._creatShape(shapesData[0]);
                 this.colliderShape = shape;
             }
             else {
                 var compoundShape = new CompoundColliderShape();
                 for (var i = 0; i < shapeCount; i++) {
                     shape = PhysicsComponent._creatShape(shapesData[i]);
                     compoundShape.addChildShape(shape);
                 }
                 this.colliderShape = compoundShape;
             }
         }
         /**
          * @private
          */
         _onScaleChange(scale) {
             this._colliderShape._setScale(scale);
         }
         /**
          * @private
          */
         _setTransformFlag(type, value) {
             if (value)
                 this._transformFlag |= type;
             else
                 this._transformFlag &= ~type;
         }
         /**
          * @private
          */
         _getTransformFlag(type) {
             return (this._transformFlag & type) != 0;
         }
         /**
          * @private
          */
         _addToSimulation() {
         }
         /**
          * @private
          */
         _removeFromSimulation() {
         }
         /**
          * 	@private
          */
         _derivePhysicsTransformation(force) {
             this._innerDerivePhysicsTransformation(this._nativeColliderObject.getWorldTransform(), force);
         }
         /**
          * 	@private
          *	通过渲染矩阵更新物理矩阵。
          */
         _innerDerivePhysicsTransformation(physicTransformOut, force) {
             var transform = this.owner._transform;
             var rotation = transform.rotation;
             if (force || this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                 var shapeOffset = this._colliderShape.localOffset;
                 var position = transform.position;
                 var nativePosition = PhysicsComponent._nativeVector30;
                 if (shapeOffset.x !== 0 || shapeOffset.y !== 0 || shapeOffset.z !== 0) {
                     var physicPosition = PhysicsComponent._tempVector30;
                     PhysicsComponent.physicVector3TransformQuat(shapeOffset, rotation.x, rotation.y, rotation.z, rotation.w, physicPosition);
                     Vector3.add(position, physicPosition, physicPosition);
                     nativePosition.setValue(-physicPosition.x, physicPosition.y, physicPosition.z);
                 }
                 else {
                     nativePosition.setValue(-position.x, position.y, position.z);
                 }
                 physicTransformOut.setOrigin(nativePosition);
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, false);
             }
             if (force || this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION)) {
                 var shapeRotation = this._colliderShape.localRotation;
                 var nativeRotation = PhysicsComponent._nativeQuaternion0;
                 if (shapeRotation.x !== 0 || shapeRotation.y !== 0 || shapeRotation.z !== 0 || shapeRotation.w !== 1) {
                     var physicRotation = PhysicsComponent._tempQuaternion0;
                     PhysicsComponent.physicQuaternionMultiply(rotation.x, rotation.y, rotation.z, rotation.w, shapeRotation, physicRotation);
                     nativeRotation.setValue(-physicRotation.x, physicRotation.y, physicRotation.z, -physicRotation.w);
                 }
                 else {
                     nativeRotation.setValue(-rotation.x, rotation.y, rotation.z, -rotation.w);
                 }
                 physicTransformOut.setRotation(nativeRotation);
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, false);
             }
             if (force || this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                 this._onScaleChange(transform.scale);
                 this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, false);
             }
         }
         /**
          * @private
          * 通过物理矩阵更新渲染矩阵。
          */
         _updateTransformComponent(physicsTransform) {
             var localOffset = this._colliderShape.localOffset;
             var localRotation = this._colliderShape.localRotation;
             var transform = this.owner._transform;
             var position = transform.position;
             var rotation = transform.rotation;
             var nativePosition = physicsTransform.getOrigin();
             var nativeRotation = physicsTransform.getRotation();
             var nativeRotX = -nativeRotation.x();
             var nativeRotY = nativeRotation.y();
             var nativeRotZ = nativeRotation.z();
             var nativeRotW = -nativeRotation.w();
             if (localOffset.x !== 0 || localOffset.y !== 0 || localOffset.z !== 0) {
                 var rotShapePosition = PhysicsComponent._tempVector30;
                 PhysicsComponent.physicVector3TransformQuat(localOffset, nativeRotX, nativeRotY, nativeRotZ, nativeRotW, rotShapePosition);
                 position.x = -nativePosition.x() - rotShapePosition.x;
                 position.y = nativePosition.y() - rotShapePosition.y;
                 position.z = nativePosition.z() - rotShapePosition.z;
             }
             else {
                 position.x = -nativePosition.x();
                 position.y = nativePosition.y();
                 position.z = nativePosition.z();
             }
             transform.position = position;
             if (localRotation.x !== 0 || localRotation.y !== 0 || localRotation.z !== 0 || localRotation.w !== 1) {
                 var invertShapeRotaion = PhysicsComponent._tempQuaternion0;
                 localRotation.invert(invertShapeRotaion);
                 PhysicsComponent.physicQuaternionMultiply(nativeRotX, nativeRotY, nativeRotZ, nativeRotW, invertShapeRotaion, rotation);
             }
             else {
                 rotation.x = nativeRotX;
                 rotation.y = nativeRotY;
                 rotation.z = nativeRotZ;
                 rotation.w = nativeRotW;
             }
             transform.rotation = rotation;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onEnable() {
             this._simulation = this.owner._scene.physicsSimulation;
             this._nativeColliderObject.setContactProcessingThreshold(1e30);
             if (this._colliderShape && this._enabled) {
                 this._derivePhysicsTransformation(true);
                 this._addToSimulation();
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onDisable() {
             if (this._colliderShape && this._enabled) {
                 this._removeFromSimulation();
                 (this._inPhysicUpdateListIndex !== -1) && (this._simulation._physicsUpdateList.remove(this)); //销毁前一定会调用 _onDisable()
             }
             this._simulation = null;
         }
         /**
          * @private
          */
         _onShapeChange(colShape) {
             var btColObj = this._nativeColliderObject;
             var flags = btColObj.getCollisionFlags();
             if (colShape.needsCustomCollisionCallback) {
                 if ((flags & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) === 0)
                     btColObj.setCollisionFlags(flags | PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
             }
             else {
                 if ((flags & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0)
                     btColObj.setCollisionFlags(flags ^ PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onAdded() {
             this.enabled = this._enabled;
             this.restitution = this._restitution;
             this.friction = this._friction;
             this.rollingFriction = this._rollingFriction;
             this.ccdMotionThreshold = this._ccdMotionThreshold;
             this.ccdSweptSphereRadius = this._ccdSweptSphereRadius;
             this.owner.transform.on(Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onDestroy() {
             var physics3D = Physics._physics3D;
             delete PhysicsComponent._physicObjectsMap[this.id];
             physics3D.destroy(this._nativeColliderObject);
             this._colliderShape.destroy();
             super._onDestroy();
             this._nativeColliderObject = null;
             this._colliderShape = null;
             this._simulation = null;
             this.owner.transform.off(Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
         }
         /**
          * @private
          */
         _onTransformChanged(flag) {
             if (PhysicsComponent._addUpdateList) {
                 flag &= Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE; //过滤有用TRANSFORM标记
                 if (flag) {
                     this._transformFlag |= flag;
                     if (this._isValid() && this._inPhysicUpdateListIndex === -1) //_isValid()表示可使用
                         this._simulation._physicsUpdateList.add(this);
                 }
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _cloneTo(dest) {
             var destPhysicsComponent = dest;
             destPhysicsComponent.restitution = this._restitution;
             destPhysicsComponent.friction = this._friction;
             destPhysicsComponent.rollingFriction = this._rollingFriction;
             destPhysicsComponent.ccdMotionThreshold = this._ccdMotionThreshold;
             destPhysicsComponent.ccdSweptSphereRadius = this._ccdSweptSphereRadius;
             destPhysicsComponent.collisionGroup = this._collisionGroup;
             destPhysicsComponent.canCollideWith = this._canCollideWith;
             destPhysicsComponent.canScaleShape = this.canScaleShape;
             (this._colliderShape) && (destPhysicsComponent.colliderShape = this._colliderShape.clone());
         }
     }
     /** @private */
     PhysicsComponent.ACTIVATIONSTATE_ACTIVE_TAG = 1;
     /** @private */
     PhysicsComponent.ACTIVATIONSTATE_ISLAND_SLEEPING = 2;
     /** @private */
     PhysicsComponent.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3;
     /** @private */
     PhysicsComponent.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4;
     /** @private */
     PhysicsComponent.ACTIVATIONSTATE_DISABLE_SIMULATION = 5;
     /** @private */
     PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT = 1;
     /** @private */
     PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT = 2;
     /** @private */
     PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4;
     /** @private */
     PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8; //this allows per-triangle material (friction/restitution)
     /** @private */
     PhysicsComponent.COLLISIONFLAGS_CHARACTER_OBJECT = 16;
     /** @private */
     PhysicsComponent.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32; //disable debug drawing
     /** @private */
     PhysicsComponent.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64; //disable parallel/SPU processing
     /**@private */
     PhysicsComponent._tempVector30 = new Vector3();
     /**@private */
     PhysicsComponent._tempQuaternion0 = new Quaternion();
     /**@private */
     PhysicsComponent._tempQuaternion1 = new Quaternion();
     /**@private */
     PhysicsComponent._tempMatrix4x40 = new Matrix4x4();
     /**@private */
     PhysicsComponent._physicObjectsMap = {};
     /** @private */
     PhysicsComponent._addUpdateList = true;

     /**
      * <code>Simulation</code> 类用于创建物理模拟器。
      */
     class PhysicsSimulation {
         /**
          * @private
          * 创建一个 <code>Simulation</code> 实例。
          */
         constructor(configuration, flags = 0) {
             /**@private	*/
             this._gravity = new Vector3(0, -10, 0);
             /** @private */
             this._nativeVector3Zero = new Physics._physics3D.btVector3(0, 0, 0);
             /** @private */
             this._nativeDefaultQuaternion = new Physics._physics3D.btQuaternion(0, 0, 0, -1);
             /**@private	*/
             this._collisionsUtils = new CollisionTool();
             /**@private	*/
             this._previousFrameCollisions = [];
             /**@private	*/
             this._currentFrameCollisions = [];
             /**@private	*/
             this._physicsUpdateList = new PhysicsUpdateList();
             /**@private	*/
             this._characters = [];
             /**@private	*/
             this._updatedRigidbodies = 0;
             /**物理引擎在一帧中用于补偿减速的最大次数：模拟器每帧允许的最大模拟次数，如果引擎运行缓慢,可能需要增加该次数，否则模拟器会丢失“时间",引擎间隔时间小于maxSubSteps*fixedTimeStep非常重要。*/
             this.maxSubSteps = 1;
             /**物理模拟器帧的间隔时间:通过减少fixedTimeStep可增加模拟精度，默认是1.0 / 60.0。*/
             this.fixedTimeStep = 1.0 / 60.0;
             this.maxSubSteps = configuration.maxSubSteps;
             this.fixedTimeStep = configuration.fixedTimeStep;
             var physics3D = Physics._physics3D;
             this._nativeCollisionConfiguration = new physics3D.btDefaultCollisionConfiguration();
             this._nativeDispatcher = new physics3D.btCollisionDispatcher(this._nativeCollisionConfiguration);
             this._nativeBroadphase = new physics3D.btDbvtBroadphase();
             this._nativeBroadphase.getOverlappingPairCache().setInternalGhostPairCallback(new physics3D.btGhostPairCallback()); //this allows characters to have proper physics behavior
             var conFlags = configuration.flags;
             if (conFlags & PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY) {
                 this._nativeCollisionWorld = new physics3D.btCollisionWorld(this._nativeDispatcher, this._nativeBroadphase, this._nativeCollisionConfiguration);
             }
             else if (conFlags & PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT) {
                 throw "PhysicsSimulation:SoftBody processing is not yet available";
             }
             else {
                 var solver = new physics3D.btSequentialImpulseConstraintSolver();
                 this._nativeDiscreteDynamicsWorld = new physics3D.btDiscreteDynamicsWorld(this._nativeDispatcher, this._nativeBroadphase, solver, this._nativeCollisionConfiguration);
                 this._nativeCollisionWorld = this._nativeDiscreteDynamicsWorld;
             }
             if (this._nativeDiscreteDynamicsWorld) {
                 this._nativeSolverInfo = this._nativeDiscreteDynamicsWorld.getSolverInfo(); //we are required to keep this reference, or the GC will mess up
                 this._nativeDispatchInfo = this._nativeDiscreteDynamicsWorld.getDispatchInfo();
             }
             this._nativeClosestRayResultCallback = new physics3D.ClosestRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero);
             this._nativeAllHitsRayResultCallback = new physics3D.AllHitsRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero);
             this._nativeClosestConvexResultCallback = new physics3D.ClosestConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero);
             this._nativeAllConvexResultCallback = new physics3D.AllConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero); //是否TODO:优化C++
             physics3D._btGImpactCollisionAlgorithm_RegisterAlgorithm(this._nativeDispatcher.a); //注册算法
         }
         /**
         * @private
         */
         static __init__() {
             PhysicsSimulation._nativeTempVector30 = new Physics._physics3D.btVector3(0, 0, 0);
             PhysicsSimulation._nativeTempVector31 = new Physics._physics3D.btVector3(0, 0, 0);
             PhysicsSimulation._nativeTempQuaternion0 = new Physics._physics3D.btQuaternion(0, 0, 0, 1);
             PhysicsSimulation._nativeTempQuaternion1 = new Physics._physics3D.btQuaternion(0, 0, 0, 1);
             PhysicsSimulation._nativeTempTransform0 = new Physics._physics3D.btTransform();
             PhysicsSimulation._nativeTempTransform1 = new Physics._physics3D.btTransform();
         }
         /**
          * 创建限制刚体运动的约束条件。
          */
         static createConstraint() {
             //TODO:
         }
         /**
          * 获取是否进行连续碰撞检测。
          * @return  是否进行连续碰撞检测。
          */
         get continuousCollisionDetection() {
             return this._nativeDispatchInfo.get_m_useContinuous();
         }
         /**
          * 设置是否进行连续碰撞检测。
          * @param value 是否进行连续碰撞检测。
          */
         set continuousCollisionDetection(value) {
             this._nativeDispatchInfo.set_m_useContinuous(value);
         }
         /**
          * 获取重力。
          */
         get gravity() {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
             return this._gravity;
         }
         /**
          * 设置重力。
          */
         set gravity(value) {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
             this._gravity = value;
             var nativeGravity = PhysicsSimulation._nativeTempVector30;
             nativeGravity.setValue(-value.x, value.y, value.z); //TODO:是否先get省一个变量
             this._nativeDiscreteDynamicsWorld.setGravity(nativeGravity);
         }
         /**
          * @private
          */
         get speculativeContactRestitution() {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
             return this._nativeDiscreteDynamicsWorld.getApplySpeculativeContactRestitution();
         }
         /**
          * @private
          */
         set speculativeContactRestitution(value) {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
             this._nativeDiscreteDynamicsWorld.setApplySpeculativeContactRestitution(value);
         }
         /**
          * @private
          */
         _simulate(deltaTime) {
             this._updatedRigidbodies = 0;
             if (this._nativeDiscreteDynamicsWorld)
                 this._nativeDiscreteDynamicsWorld.stepSimulation(deltaTime, this.maxSubSteps, this.fixedTimeStep);
             else
                 this._nativeCollisionWorld.PerformDiscreteCollisionDetection();
         }
         /**
          * @private
          */
         _destroy() {
             var physics3D = Physics._physics3D;
             if (this._nativeDiscreteDynamicsWorld) {
                 physics3D.destroy(this._nativeDiscreteDynamicsWorld);
                 this._nativeDiscreteDynamicsWorld = null;
             }
             else {
                 physics3D.destroy(this._nativeCollisionWorld);
                 this._nativeCollisionWorld = null;
             }
             physics3D.destroy(this._nativeBroadphase);
             this._nativeBroadphase = null;
             physics3D.destroy(this._nativeDispatcher);
             this._nativeDispatcher = null;
             physics3D.destroy(this._nativeCollisionConfiguration);
             this._nativeCollisionConfiguration = null;
         }
         /**
          * @private
          */
         _addPhysicsCollider(component, group, mask) {
             this._nativeCollisionWorld.addCollisionObject(component._nativeColliderObject, group, mask);
         }
         /**
          * @private
          */
         _removePhysicsCollider(component) {
             this._nativeCollisionWorld.removeCollisionObject(component._nativeColliderObject);
         }
         /**
          * @private
          */
         _addRigidBody(rigidBody, group, mask) {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
             this._nativeCollisionWorld.addRigidBody(rigidBody._nativeColliderObject, group, mask);
         }
         /**
          * @private
          */
         _removeRigidBody(rigidBody) {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
             this._nativeCollisionWorld.removeRigidBody(rigidBody._nativeColliderObject);
         }
         /**
          * @private
          */
         _addCharacter(character, group, mask) {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
             this._nativeCollisionWorld.addCollisionObject(character._nativeColliderObject, group, mask);
             this._nativeCollisionWorld.addAction(character._nativeKinematicCharacter);
         }
         /**
          * @private
          */
         _removeCharacter(character) {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
             this._nativeCollisionWorld.removeCollisionObject(character._nativeColliderObject);
             this._nativeCollisionWorld.removeAction(character._nativeKinematicCharacter);
         }
         /**
          * 射线检测第一个碰撞物体。
          * @param	from 起始位置。
          * @param	to 结束位置。
          * @param	out 碰撞结果。
          * @param   collisonGroup 射线所属碰撞组。
          * @param   collisionMask 与射线可产生碰撞的组。
          * @return 	是否成功。
          */
         raycastFromTo(from, to, out = null, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
             var rayResultCall = this._nativeClosestRayResultCallback;
             var rayFrom = PhysicsSimulation._nativeTempVector30;
             var rayTo = PhysicsSimulation._nativeTempVector31;
             rayFrom.setValue(-from.x, from.y, from.z);
             rayTo.setValue(-to.x, to.y, to.z);
             rayResultCall.set_m_rayFromWorld(rayFrom);
             rayResultCall.set_m_rayToWorld(rayTo);
             rayResultCall.set_m_collisionFilterGroup(collisonGroup);
             rayResultCall.set_m_collisionFilterMask(collisionMask);
             rayResultCall.set_m_collisionObject(null); //还原默认值
             rayResultCall.set_m_closestHitFraction(1); //还原默认值
             this._nativeCollisionWorld.rayTest(rayFrom, rayTo, rayResultCall); //TODO:out为空可优化,bullet内
             if (rayResultCall.hasHit()) {
                 if (out) {
                     out.succeeded = true;
                     out.collider = PhysicsComponent._physicObjectsMap[rayResultCall.get_m_collisionObject().getUserIndex()];
                     out.hitFraction = rayResultCall.get_m_closestHitFraction();
                     var nativePoint = rayResultCall.get_m_hitPointWorld();
                     var point = out.point;
                     point.x = -nativePoint.x();
                     point.y = nativePoint.y();
                     point.z = nativePoint.z();
                     var nativeNormal = rayResultCall.get_m_hitNormalWorld();
                     var normal = out.normal;
                     normal.x = -nativeNormal.x();
                     normal.y = nativeNormal.y();
                     normal.z = nativeNormal.z();
                 }
                 return true;
             }
             else {
                 if (out)
                     out.succeeded = false;
                 return false;
             }
         }
         /**
          * 射线检测所有碰撞的物体。
          * @param	from 起始位置。
          * @param	to 结束位置。
          * @param	out 碰撞结果[数组元素会被回收]。
          * @param   collisonGroup 射线所属碰撞组。
          * @param   collisionMask 与射线可产生碰撞的组。
          * @return 	是否成功。
          */
         raycastAllFromTo(from, to, out, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
             var rayResultCall = this._nativeAllHitsRayResultCallback;
             var rayFrom = PhysicsSimulation._nativeTempVector30;
             var rayTo = PhysicsSimulation._nativeTempVector31;
             out.length = 0;
             rayFrom.setValue(-from.x, from.y, from.z);
             rayTo.setValue(-to.x, to.y, to.z);
             rayResultCall.set_m_rayFromWorld(rayFrom);
             rayResultCall.set_m_rayToWorld(rayTo);
             rayResultCall.set_m_collisionFilterGroup(collisonGroup);
             rayResultCall.set_m_collisionFilterMask(collisionMask);
             //rayResultCall.set_m_collisionObject(null);//还原默认值
             //rayResultCall.set_m_closestHitFraction(1);//还原默认值
             var collisionObjects = rayResultCall.get_m_collisionObjects();
             var nativePoints = rayResultCall.get_m_hitPointWorld();
             var nativeNormals = rayResultCall.get_m_hitNormalWorld();
             var nativeFractions = rayResultCall.get_m_hitFractions();
             collisionObjects.clear(); //清空检测队列
             nativePoints.clear();
             nativeNormals.clear();
             nativeFractions.clear();
             this._nativeCollisionWorld.rayTest(rayFrom, rayTo, rayResultCall);
             var count = collisionObjects.size();
             if (count > 0) {
                 this._collisionsUtils.recoverAllHitResultsPool();
                 for (var i = 0; i < count; i++) {
                     var hitResult = this._collisionsUtils.getHitResult();
                     out.push(hitResult);
                     hitResult.succeeded = true;
                     hitResult.collider = PhysicsComponent._physicObjectsMap[collisionObjects.at(i).getUserIndex()];
                     hitResult.hitFraction = nativeFractions.at(i);
                     var nativePoint = nativePoints.at(i); //取出后需要立即赋值,防止取出法线时被覆盖
                     var pointE = hitResult.point;
                     pointE.x = -nativePoint.x();
                     pointE.y = nativePoint.y();
                     pointE.z = nativePoint.z();
                     var nativeNormal = nativeNormals.at(i);
                     var normalE = hitResult.normal;
                     normalE.x = -nativeNormal.x();
                     normalE.y = nativeNormal.y();
                     normalE.z = nativeNormal.z();
                 }
                 return true;
             }
             else {
                 return false;
             }
         }
         /**
          *  射线检测第一个碰撞物体。
          * @param  	ray        射线
          * @param  	outHitInfo 与该射线发生碰撞的第一个碰撞器的碰撞信息
          * @param  	distance   射线长度,默认为最大值
          * @param   collisonGroup 射线所属碰撞组。
          * @param   collisionMask 与射线可产生碰撞的组。
          * @return 	是否检测成功。
          */
         rayCast(ray, outHitResult = null, distance = 2147483647 /*Int.MAX_VALUE*/, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
             var from = ray.origin;
             var to = PhysicsSimulation._tempVector30;
             Vector3.normalize(ray.direction, to);
             Vector3.scale(to, distance, to);
             Vector3.add(from, to, to);
             return this.raycastFromTo(from, to, outHitResult, collisonGroup, collisionMask);
         }
         /**
          * 射线检测所有碰撞的物体。
          * @param  	ray        射线
          * @param  	out 碰撞结果[数组元素会被回收]。
          * @param  	distance   射线长度,默认为最大值
          * @param   collisonGroup 射线所属碰撞组。
          * @param   collisionMask 与射线可产生碰撞的组。
          * @return 	是否检测成功。
          */
         rayCastAll(ray, out, distance = 2147483647 /*Int.MAX_VALUE*/, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
             var from = ray.origin;
             var to = PhysicsSimulation._tempVector30;
             Vector3.normalize(ray.direction, to);
             Vector3.scale(to, distance, to);
             Vector3.add(from, to, to);
             return this.raycastAllFromTo(from, to, out, collisonGroup, collisionMask);
         }
         /**
          * 形状检测第一个碰撞的物体。
          * @param   shape 形状。
          * @param	fromPosition 世界空间起始位置。
          * @param	toPosition 世界空间结束位置。
          * @param	out 碰撞结果。
          * @param	fromRotation 起始旋转。
          * @param	toRotation 结束旋转。
          * @param   collisonGroup 射线所属碰撞组。
          * @param   collisionMask 与射线可产生碰撞的组。
          * @return 	是否成功。
          */
         shapeCast(shape, fromPosition, toPosition, out = null, fromRotation = null, toRotation = null, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, allowedCcdPenetration = 0.0) {
             var convexResultCall = this._nativeClosestConvexResultCallback;
             var convexPosFrom = PhysicsSimulation._nativeTempVector30;
             var convexPosTo = PhysicsSimulation._nativeTempVector31;
             var convexRotFrom = PhysicsSimulation._nativeTempQuaternion0;
             var convexRotTo = PhysicsSimulation._nativeTempQuaternion1;
             var convexTransform = PhysicsSimulation._nativeTempTransform0;
             var convexTransTo = PhysicsSimulation._nativeTempTransform1;
             var sweepShape = shape._nativeShape;
             convexPosFrom.setValue(-fromPosition.x, fromPosition.y, fromPosition.z);
             convexPosTo.setValue(-toPosition.x, toPosition.y, toPosition.z);
             //convexResultCall.set_m_convexFromWorld(convexPosFrom);
             //convexResultCall.set_m_convexToWorld(convexPosTo);
             convexResultCall.set_m_collisionFilterGroup(collisonGroup);
             convexResultCall.set_m_collisionFilterMask(collisionMask);
             convexTransform.setOrigin(convexPosFrom);
             convexTransTo.setOrigin(convexPosTo);
             if (fromRotation) {
                 convexRotFrom.setValue(-fromRotation.x, fromRotation.y, fromRotation.z, -fromRotation.w);
                 convexTransform.setRotation(convexRotFrom);
             }
             else {
                 convexTransform.setRotation(this._nativeDefaultQuaternion);
             }
             if (toRotation) {
                 convexRotTo.setValue(-toRotation.x, toRotation.y, toRotation.z, -toRotation.w);
                 convexTransTo.setRotation(convexRotTo);
             }
             else {
                 convexTransTo.setRotation(this._nativeDefaultQuaternion);
             }
             convexResultCall.set_m_hitCollisionObject(null); //还原默认值
             convexResultCall.set_m_closestHitFraction(1); //还原默认值
             this._nativeCollisionWorld.convexSweepTest(sweepShape, convexTransform, convexTransTo, convexResultCall, allowedCcdPenetration);
             if (convexResultCall.hasHit()) {
                 if (out) {
                     out.succeeded = true;
                     out.collider = PhysicsComponent._physicObjectsMap[convexResultCall.get_m_hitCollisionObject().getUserIndex()];
                     out.hitFraction = convexResultCall.get_m_closestHitFraction();
                     var nativePoint = convexResultCall.get_m_hitPointWorld();
                     var nativeNormal = convexResultCall.get_m_hitNormalWorld();
                     var point = out.point;
                     var normal = out.normal;
                     point.x = -nativePoint.x();
                     point.y = nativePoint.y();
                     point.z = nativePoint.z();
                     normal.x = -nativeNormal.x();
                     normal.y = nativeNormal.y();
                     normal.z = nativeNormal.z();
                 }
                 return true;
             }
             else {
                 if (out)
                     out.succeeded = false;
                 return false;
             }
         }
         /**
          * 形状检测所有碰撞的物体。
          * @param   shape 形状。
          * @param	fromPosition 世界空间起始位置。
          * @param	toPosition 世界空间结束位置。
          * @param	out 碰撞结果[数组元素会被回收]。
          * @param	fromRotation 起始旋转。
          * @param	toRotation 结束旋转。
          * @param   collisonGroup 射线所属碰撞组。
          * @param   collisionMask 与射线可产生碰撞的组。
          * @return 	是否成功。
          */
         shapeCastAll(shape, fromPosition, toPosition, out, fromRotation = null, toRotation = null, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, allowedCcdPenetration = 0.0) {
             var convexResultCall = this._nativeAllConvexResultCallback;
             var convexPosFrom = PhysicsSimulation._nativeTempVector30;
             var convexPosTo = PhysicsSimulation._nativeTempVector31;
             var convexRotFrom = PhysicsSimulation._nativeTempQuaternion0;
             var convexRotTo = PhysicsSimulation._nativeTempQuaternion1;
             var convexTransform = PhysicsSimulation._nativeTempTransform0;
             var convexTransTo = PhysicsSimulation._nativeTempTransform1;
             var sweepShape = shape._nativeShape;
             out.length = 0;
             convexPosFrom.setValue(-fromPosition.x, fromPosition.y, fromPosition.z);
             convexPosTo.setValue(-toPosition.x, toPosition.y, toPosition.z);
             //convexResultCall.set_m_convexFromWorld(convexPosFrom);
             //convexResultCall.set_m_convexToWorld(convexPosTo);
             convexResultCall.set_m_collisionFilterGroup(collisonGroup);
             convexResultCall.set_m_collisionFilterMask(collisionMask);
             convexTransform.setOrigin(convexPosFrom);
             convexTransTo.setOrigin(convexPosTo);
             if (fromRotation) {
                 convexRotFrom.setValue(-fromRotation.x, fromRotation.y, fromRotation.z, -fromRotation.w);
                 convexTransform.setRotation(convexRotFrom);
             }
             else {
                 convexTransform.setRotation(this._nativeDefaultQuaternion);
             }
             if (toRotation) {
                 convexRotTo.setValue(-toRotation.x, toRotation.y, toRotation.z, -toRotation.w);
                 convexTransTo.setRotation(convexRotTo);
             }
             else {
                 convexTransTo.setRotation(this._nativeDefaultQuaternion);
             }
             var collisionObjects = convexResultCall.get_m_collisionObjects();
             collisionObjects.clear(); //清空检测队列
             this._nativeCollisionWorld.convexSweepTest(sweepShape, convexTransform, convexTransTo, convexResultCall, allowedCcdPenetration);
             var count = collisionObjects.size();
             if (count > 0) {
                 var nativePoints = convexResultCall.get_m_hitPointWorld();
                 var nativeNormals = convexResultCall.get_m_hitNormalWorld();
                 var nativeFractions = convexResultCall.get_m_hitFractions();
                 for (var i = 0; i < count; i++) {
                     var hitResult = this._collisionsUtils.getHitResult();
                     out.push(hitResult);
                     hitResult.succeeded = true;
                     hitResult.collider = PhysicsComponent._physicObjectsMap[collisionObjects.at(i).getUserIndex()];
                     hitResult.hitFraction = nativeFractions.at(i);
                     var nativePoint = nativePoints.at(i);
                     var point = hitResult.point;
                     point.x = -nativePoint.x();
                     point.y = nativePoint.y();
                     point.z = nativePoint.z();
                     var nativeNormal = nativeNormals.at(i);
                     var normal = hitResult.normal;
                     normal.x = -nativeNormal.x();
                     normal.y = nativeNormal.y();
                     normal.z = nativeNormal.z();
                 }
                 return true;
             }
             else {
                 return false;
             }
         }
         /**
          * 添加刚体运动的约束条件。
          * @param constraint 约束。
          * @param disableCollisionsBetweenLinkedBodies 是否禁用
          */
         addConstraint(constraint, disableCollisionsBetweenLinkedBodies = false) {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
             this._nativeDiscreteDynamicsWorld.addConstraint(constraint._nativeConstraint, disableCollisionsBetweenLinkedBodies);
             constraint._simulation = this;
         }
         /**
          * 移除刚体运动的约束条件。
          */
         removeConstraint(constraint) {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
             this._nativeDiscreteDynamicsWorld.removeConstraint(constraint._nativeConstraint);
         }
         /**
          * @private
          */
         _updatePhysicsTransformFromRender() {
             var elements = this._physicsUpdateList.elements;
             for (var i = 0, n = this._physicsUpdateList.length; i < n; i++) {
                 var physicCollider = elements[i];
                 physicCollider._derivePhysicsTransformation(false);
                 physicCollider._inPhysicUpdateListIndex = -1; //置空索引
             }
             this._physicsUpdateList.length = 0; //清空物理更新队列
         }
         /**
          * @private
          */
         _updateCharacters() {
             for (var i = 0, n = this._characters.length; i < n; i++) {
                 var character = this._characters[i];
                 character._updateTransformComponent(character._nativeColliderObject.getWorldTransform());
             }
         }
         /**
          * @private
          */
         _updateCollisions() {
             this._collisionsUtils.recoverAllContactPointsPool();
             var previous = this._currentFrameCollisions;
             this._currentFrameCollisions = this._previousFrameCollisions;
             this._currentFrameCollisions.length = 0;
             this._previousFrameCollisions = previous;
             var loopCount = Stat.loopCount;
             var numManifolds = this._nativeDispatcher.getNumManifolds();
             for (var i = 0; i < numManifolds; i++) {
                 var contactManifold = this._nativeDispatcher.getManifoldByIndexInternal(i); //1.可能同时返回A和B、B和A 2.可能同时返回A和B多次(可能和CCD有关)
                 var componentA = PhysicsComponent._physicObjectsMap[contactManifold.getBody0().getUserIndex()];
                 var componentB = PhysicsComponent._physicObjectsMap[contactManifold.getBody1().getUserIndex()];
                 var collision = null;
                 var isFirstCollision; //可能同时返回A和B多次,需要过滤
                 var contacts = null;
                 var isTrigger = componentA.isTrigger || componentB.isTrigger;
                 if (isTrigger && (componentA.owner._needProcessTriggers || componentB.owner._needProcessTriggers)) {
                     var numContacts = contactManifold.getNumContacts();
                     for (var j = 0; j < numContacts; j++) {
                         var pt = contactManifold.getContactPoint(j);
                         var distance = pt.getDistance();
                         if (distance <= 0) {
                             collision = this._collisionsUtils.getCollision(componentA, componentB);
                             contacts = collision.contacts;
                             isFirstCollision = collision._updateFrame !== loopCount;
                             if (isFirstCollision) {
                                 collision._isTrigger = true;
                                 contacts.length = 0;
                             }
                             break;
                         }
                     }
                 }
                 else if (componentA.owner._needProcessCollisions || componentB.owner._needProcessCollisions) {
                     if (componentA._enableProcessCollisions || componentB._enableProcessCollisions) { //例：运动刚体需跳过
                         numContacts = contactManifold.getNumContacts();
                         for (j = 0; j < numContacts; j++) {
                             pt = contactManifold.getContactPoint(j);
                             distance = pt.getDistance();
                             if (distance <= 0) {
                                 var contactPoint = this._collisionsUtils.getContactPoints();
                                 contactPoint.colliderA = componentA;
                                 contactPoint.colliderB = componentB;
                                 contactPoint.distance = distance;
                                 var nativeNormal = pt.get_m_normalWorldOnB();
                                 var normal = contactPoint.normal;
                                 normal.x = -nativeNormal.x();
                                 normal.y = nativeNormal.y();
                                 normal.z = nativeNormal.z();
                                 var nativePostionA = pt.get_m_positionWorldOnA();
                                 var positionOnA = contactPoint.positionOnA;
                                 positionOnA.x = -nativePostionA.x();
                                 positionOnA.y = nativePostionA.y();
                                 positionOnA.z = nativePostionA.z();
                                 var nativePostionB = pt.get_m_positionWorldOnB();
                                 var positionOnB = contactPoint.positionOnB;
                                 positionOnB.x = -nativePostionB.x();
                                 positionOnB.y = nativePostionB.y();
                                 positionOnB.z = nativePostionB.z();
                                 if (!collision) {
                                     collision = this._collisionsUtils.getCollision(componentA, componentB);
                                     contacts = collision.contacts;
                                     isFirstCollision = collision._updateFrame !== loopCount;
                                     if (isFirstCollision) {
                                         collision._isTrigger = false;
                                         contacts.length = 0;
                                     }
                                 }
                                 contacts.push(contactPoint);
                             }
                         }
                     }
                 }
                 if (collision && isFirstCollision) {
                     this._currentFrameCollisions.push(collision);
                     collision._setUpdateFrame(loopCount);
                 }
             }
         }
         /**
          * @private
          */
         _eventScripts() {
             var loopCount = Stat.loopCount;
             for (var i = 0, n = this._currentFrameCollisions.length; i < n; i++) {
                 var curFrameCol = this._currentFrameCollisions[i];
                 var colliderA = curFrameCol._colliderA;
                 var colliderB = curFrameCol._colliderB;
                 if (colliderA.destroyed || colliderB.destroyed) //前一个循环可能会销毁后面循环的同一物理组件
                     continue;
                 if (loopCount - curFrameCol._lastUpdateFrame === 1) {
                     var ownerA = colliderA.owner;
                     var scriptsA = ownerA._scripts;
                     if (scriptsA) {
                         if (curFrameCol._isTrigger) {
                             if (ownerA._needProcessTriggers) {
                                 for (var j = 0, m = scriptsA.length; j < m; j++)
                                     scriptsA[j].onTriggerStay(colliderB);
                             }
                         }
                         else {
                             if (ownerA._needProcessCollisions) {
                                 for (j = 0, m = scriptsA.length; j < m; j++) {
                                     curFrameCol.other = colliderB;
                                     scriptsA[j].onCollisionStay(curFrameCol);
                                 }
                             }
                         }
                     }
                     var ownerB = colliderB.owner;
                     var scriptsB = ownerB._scripts;
                     if (scriptsB) {
                         if (curFrameCol._isTrigger) {
                             if (ownerB._needProcessTriggers) {
                                 for (j = 0, m = scriptsB.length; j < m; j++)
                                     scriptsB[j].onTriggerStay(colliderA);
                             }
                         }
                         else {
                             if (ownerB._needProcessCollisions) {
                                 for (j = 0, m = scriptsB.length; j < m; j++) {
                                     curFrameCol.other = colliderA;
                                     scriptsB[j].onCollisionStay(curFrameCol);
                                 }
                             }
                         }
                     }
                 }
                 else {
                     ownerA = colliderA.owner;
                     scriptsA = ownerA._scripts;
                     if (scriptsA) {
                         if (curFrameCol._isTrigger) {
                             if (ownerA._needProcessTriggers) {
                                 for (j = 0, m = scriptsA.length; j < m; j++)
                                     scriptsA[j].onTriggerEnter(colliderB);
                             }
                         }
                         else {
                             if (ownerA._needProcessCollisions) {
                                 for (j = 0, m = scriptsA.length; j < m; j++) {
                                     curFrameCol.other = colliderB;
                                     scriptsA[j].onCollisionEnter(curFrameCol);
                                 }
                             }
                         }
                     }
                     ownerB = colliderB.owner;
                     scriptsB = ownerB._scripts;
                     if (scriptsB) {
                         if (curFrameCol._isTrigger) {
                             if (ownerB._needProcessTriggers) {
                                 for (j = 0, m = scriptsB.length; j < m; j++)
                                     scriptsB[j].onTriggerEnter(colliderA);
                             }
                         }
                         else {
                             if (ownerB._needProcessCollisions) {
                                 for (j = 0, m = scriptsB.length; j < m; j++) {
                                     curFrameCol.other = colliderA;
                                     scriptsB[j].onCollisionEnter(curFrameCol);
                                 }
                             }
                         }
                     }
                 }
             }
             for (i = 0, n = this._previousFrameCollisions.length; i < n; i++) {
                 var preFrameCol = this._previousFrameCollisions[i];
                 var preColliderA = preFrameCol._colliderA;
                 var preColliderB = preFrameCol._colliderB;
                 if (preColliderA.destroyed || preColliderB.destroyed)
                     continue;
                 if (loopCount - preFrameCol._updateFrame === 1) {
                     this._collisionsUtils.recoverCollision(preFrameCol); //回收collision对象
                     ownerA = preColliderA.owner;
                     scriptsA = ownerA._scripts;
                     if (scriptsA) {
                         if (preFrameCol._isTrigger) {
                             if (ownerA._needProcessTriggers) {
                                 for (j = 0, m = scriptsA.length; j < m; j++)
                                     scriptsA[j].onTriggerExit(preColliderB);
                             }
                         }
                         else {
                             if (ownerA._needProcessCollisions) {
                                 for (j = 0, m = scriptsA.length; j < m; j++) {
                                     preFrameCol.other = preColliderB;
                                     scriptsA[j].onCollisionExit(preFrameCol);
                                 }
                             }
                         }
                     }
                     ownerB = preColliderB.owner;
                     scriptsB = ownerB._scripts;
                     if (scriptsB) {
                         if (preFrameCol._isTrigger) {
                             if (ownerB._needProcessTriggers) {
                                 for (j = 0, m = scriptsB.length; j < m; j++)
                                     scriptsB[j].onTriggerExit(preColliderA);
                             }
                         }
                         else {
                             if (ownerB._needProcessCollisions) {
                                 for (j = 0, m = scriptsB.length; j < m; j++) {
                                     preFrameCol.other = preColliderA;
                                     scriptsB[j].onCollisionExit(preFrameCol);
                                 }
                             }
                         }
                     }
                 }
             }
         }
         /**
          * 清除力。
          */
         clearForces() {
             if (!this._nativeDiscreteDynamicsWorld)
                 throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
             this._nativeDiscreteDynamicsWorld.clearForces();
         }
     }
     /** @private */
     PhysicsSimulation.PHYSICSENGINEFLAGS_NONE = 0x0;
     /** @private */
     PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY = 0x1;
     /** @private */
     PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 0x2;
     /** @private */
     PhysicsSimulation.PHYSICSENGINEFLAGS_MULTITHREADED = 0x4;
     /** @private */
     PhysicsSimulation.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 0x8;
     /** @private */
     PhysicsSimulation.SOLVERMODE_RANDMIZE_ORDER = 1;
     /** @private */
     PhysicsSimulation.SOLVERMODE_FRICTION_SEPARATE = 2;
     /** @private */
     PhysicsSimulation.SOLVERMODE_USE_WARMSTARTING = 4;
     /** @private */
     PhysicsSimulation.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16;
     /** @private */
     PhysicsSimulation.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32;
     /** @private */
     PhysicsSimulation.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64;
     /** @private */
     PhysicsSimulation.SOLVERMODE_CACHE_FRIENDLY = 128;
     /** @private */
     PhysicsSimulation.SOLVERMODE_SIMD = 256;
     /** @private */
     PhysicsSimulation.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512;
     /** @private */
     PhysicsSimulation.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024;
     /**@private */
     PhysicsSimulation._tempVector30 = new Vector3();
     /*是否禁用所有模拟器。*/
     PhysicsSimulation.disableSimulation = false;

     /**
      * <code>Input3D</code> 类用于实现3D输入。
      */
     class Input3D {
         /**
          * @private
          * 创建一个 <code>Input3D</code> 实例。
          */
         constructor() {
             /**@private */
             this._eventList = [];
             /**@private */
             this._mouseTouch = new MouseTouch();
             /**@private */
             this._touchPool = [];
             /**@private */
             this._touches = new SimpleSingletonList();
             /**@private */
             this._multiTouchEnabled = true;
         }
         /**
          *@private
          */
         __init__(canvas, scene) {
             this._scene = scene;
             var list = this._eventList;
             canvas.oncontextmenu = function (e) {
                 return false;
             };
             canvas.addEventListener('mousedown', function (e) {
                 e.preventDefault();
                 list.push(e);
             });
             canvas.addEventListener('mouseup', function (e) {
                 e.preventDefault();
                 list.push(e);
             }, true);
             canvas.addEventListener('mousemove', function (e) {
                 e.preventDefault();
                 list.push(e);
             }, true);
             canvas.addEventListener("touchstart", function (e) {
                 e.preventDefault();
                 list.push(e);
             });
             canvas.addEventListener("touchend", function (e) {
                 e.preventDefault();
                 list.push(e);
             }, true);
             canvas.addEventListener("touchmove", function (e) {
                 e.preventDefault();
                 list.push(e);
             }, true);
             canvas.addEventListener("touchcancel", function (e) {
                 //e.preventDefault()会导致debugger中断后touchcancel无法执行,抛异常
                 list.push(e);
             }, true);
         }
         /**
          * 获取触摸点个数。
          * @return 触摸点个数。
          */
         touchCount() {
             return this._touches.length;
         }
         /**
          * 获取是否可以使用多点触摸。
          * @return 是否可以使用多点触摸。
          */
         get multiTouchEnabled() {
             return this._multiTouchEnabled;
         }
         /**
          * 设置是否可以使用多点触摸。
          * @param 是否可以使用多点触摸。
          */
         set multiTouchEnabled(value) {
             this._multiTouchEnabled = value;
         }
         /**
          * @private
          */
         _getTouch(touchID) {
             var touch = this._touchPool[touchID];
             if (!touch) {
                 touch = new Touch();
                 this._touchPool[touchID] = touch;
                 touch._identifier = touchID;
             }
             return touch;
         }
         /**
          * @private
          */
         _mouseTouchDown() {
             var touch = this._mouseTouch;
             var sprite = touch.sprite;
             touch._pressedSprite = sprite;
             touch._pressedLoopCount = Stat.loopCount;
             if (sprite) {
                 var scripts = sprite._scripts;
                 if (scripts) {
                     for (var i = 0, n = scripts.length; i < n; i++)
                         scripts[i].onMouseDown(); //onMouseDown
                 }
             }
         }
         /**
          * @private
          */
         _mouseTouchUp() {
             var i, n;
             var touch = this._mouseTouch;
             var lastPressedSprite = touch._pressedSprite;
             touch._pressedSprite = null; //表示鼠标弹起
             touch._pressedLoopCount = -1;
             var sprite = touch.sprite;
             if (sprite) {
                 if (sprite === lastPressedSprite) {
                     var scripts = sprite._scripts;
                     if (scripts) {
                         for (i = 0, n = scripts.length; i < n; i++)
                             scripts[i].onMouseClick(); //onMouseClifck
                     }
                 }
             }
             if (lastPressedSprite) {
                 var lastScripts = lastPressedSprite._scripts;
                 if (lastScripts) {
                     for (i = 0, n = lastScripts.length; i < n; i++)
                         lastScripts[i].onMouseUp(); //onMouseUp
                 }
             }
         }
         /**
          * @private
          */
         _mouseTouchRayCast(cameras) {
             var touchHitResult = Input3D._tempHitResult0;
             var touchPos = Input3D._tempVector20;
             var touchRay = Input3D._tempRay0;
             touchHitResult.succeeded = false;
             var x = this._mouseTouch.mousePositionX;
             var y = this._mouseTouch.mousePositionY;
             touchPos.x = x;
             touchPos.y = y;
             for (var i = cameras.length - 1; i >= 0; i--) {
                 var camera = cameras[i];
                 var viewport = camera.viewport;
                 if (touchPos.x >= viewport.x && touchPos.y >= viewport.y && touchPos.x <= viewport.width && touchPos.y <= viewport.height) {
                     camera.viewportPointToRay(touchPos, touchRay);
                     var sucess = this._scene._physicsSimulation.rayCast(touchRay, touchHitResult);
                     if (sucess || (camera.clearFlag === BaseCamera.CLEARFLAG_SOLIDCOLOR || camera.clearFlag === BaseCamera.CLEARFLAG_SKY))
                         break;
                 }
             }
             var touch = this._mouseTouch;
             var lastSprite = touch.sprite;
             if (touchHitResult.succeeded) {
                 var touchSprite = touchHitResult.collider.owner;
                 touch.sprite = touchSprite;
                 var scripts = touchSprite._scripts;
                 if (lastSprite !== touchSprite) {
                     if (scripts) {
                         for (var j = 0, m = scripts.length; j < m; j++)
                             scripts[j].onMouseEnter(); //onMouseEnter
                     }
                 }
             }
             else {
                 touch.sprite = null;
             }
             if (lastSprite && (lastSprite !== touchSprite)) {
                 var outScripts = lastSprite._scripts;
                 if (outScripts) {
                     for (j = 0, m = outScripts.length; j < m; j++)
                         outScripts[j].onMouseOut(); //onMouseOut
                 }
             }
         }
         /**
          * @private
          * @param flag 0:add、1:remove、2:change
          */
         _changeTouches(changedTouches, flag) {
             var offsetX = 0, offsetY = 0;
             var lastCount = this._touches.length;
             for (var j = 0, m = changedTouches.length; j < m; j++) {
                 var nativeTouch = changedTouches[j];
                 var identifier = nativeTouch.identifier;
                 if (!this._multiTouchEnabled && identifier !== 0)
                     continue;
                 var touch = this._getTouch(identifier);
                 var pos = touch._position;
                 var mousePoint = Input3D._tempPoint;
                 mousePoint.setTo(nativeTouch.pageX, nativeTouch.pageY);
                 Laya.stage._canvasTransform.invertTransformPoint(mousePoint); //考虑画布缩放	
                 var posX = mousePoint.x;
                 var posY = mousePoint.y;
                 switch (flag) {
                     case 0: //add 
                         this._touches.add(touch);
                         offsetX += posX;
                         offsetY += posY;
                         break;
                     case 1: //remove 
                         this._touches.remove(touch);
                         offsetX -= posX;
                         offsetY -= posY;
                         break;
                     case 2: //change 
                         offsetX = posX - pos.x;
                         offsetY = posY - pos.y;
                         break;
                 }
                 pos.x = posX;
                 pos.y = posY;
             }
             var touchCount = this._touches.length;
             if (touchCount === 0) { //无触摸点需要归零
                 this._mouseTouch.mousePositionX = 0;
                 this._mouseTouch.mousePositionY = 0;
             }
             else {
                 this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * lastCount + offsetX) / touchCount;
                 this._mouseTouch.mousePositionY = (this._mouseTouch.mousePositionY * lastCount + offsetY) / touchCount;
             }
         }
         /**
          * @private
          */
         _update() {
             var enablePhysics = Physics._enbalePhysics && !PhysicsSimulation.disableSimulation;
             var i, n, j, m;
             n = this._eventList.length;
             var cameras = this._scene._cameraPool;
             if (n > 0) {
                 for (i = 0; i < n; i++) {
                     var e = this._eventList[i];
                     switch (e.type) {
                         case "mousedown":
                             (enablePhysics) && (this._mouseTouchDown());
                             break;
                         case "mouseup":
                             (enablePhysics) && (this._mouseTouchUp());
                             break;
                         case "mousemove":
                             var mousePoint = Input3D._tempPoint;
                             mousePoint.setTo(e.pageX, e.pageY);
                             Laya.stage._canvasTransform.invertTransformPoint(mousePoint); //考虑画布缩放
                             this._mouseTouch.mousePositionX = mousePoint.x;
                             this._mouseTouch.mousePositionY = mousePoint.y;
                             (enablePhysics) && (this._mouseTouchRayCast(cameras));
                             break;
                         case "touchstart":
                             var lastLength = this._touches.length; //需要在_changeTouches()之前获取
                             this._changeTouches(e.changedTouches, 0);
                             if (enablePhysics) {
                                 this._mouseTouchRayCast(cameras); //触摸点击时touchMove不会触发,需要调用_touchRayCast()函数
                                 (lastLength === 0) && (this._mouseTouchDown());
                             }
                             break;
                         case "touchend":
                         case "touchcancel":
                             this._changeTouches(e.changedTouches, 1);
                             (enablePhysics && this._touches.length === 0) && (this._mouseTouchUp());
                             break;
                         case "touchmove":
                             this._changeTouches(e.changedTouches, 2);
                             (enablePhysics) && (this._mouseTouchRayCast(cameras));
                             break;
                         default:
                             throw "Input3D:unkonwn event type.";
                     }
                 }
                 this._eventList.length = 0;
             }
             if (enablePhysics) {
                 var mouseTouch = this._mouseTouch;
                 var pressedSprite = mouseTouch._pressedSprite;
                 if (pressedSprite && (Stat.loopCount > mouseTouch._pressedLoopCount)) {
                     var pressedScripts = pressedSprite._scripts;
                     if (pressedScripts) {
                         for (j = 0, m = pressedScripts.length; j < m; j++)
                             pressedScripts[j].onMouseDrag(); //onMouseDrag
                     }
                 }
                 var touchSprite = mouseTouch.sprite;
                 if (touchSprite) {
                     var scripts = touchSprite._scripts;
                     if (scripts) {
                         for (j = 0, m = scripts.length; j < m; j++)
                             scripts[j].onMouseOver(); //onMouseOver
                     }
                 }
             }
         }
         /**
          *	获取触摸点。
          * 	@param	index 索引。
          * 	@return 触摸点。
          */
         getTouch(index) {
             if (index < this._touches.length) {
                 return this._touches.elements[index];
             }
             else {
                 return null;
             }
         }
     }
     /**@private */
     Input3D._tempPoint = new Point();
     /**@private */
     Input3D._tempVector20 = new Vector2();
     /**@private */
     Input3D._tempRay0 = new Ray(new Vector3(), new Vector3());
     /**@private */
     Input3D._tempHitResult0 = new HitResult();

     /**
          * <code>PhysicsSettings</code> 类用于创建物理配置信息。
          */
     class PhysicsSettings {
         /**
          * 创建一个 <code>PhysicsSettings</code> 实例。
          */
         constructor() {
             /**标志集合。*/
             this.flags = 0;
             /**物理引擎在一帧中用于补偿减速的最大次数。*/
             this.maxSubSteps = 1;
             /**物理模拟器帧的间隔时间。*/
             this.fixedTimeStep = 1.0 / 60.0;
         }
     }

     /**
      * <code>VertexPositionNormalTexture</code> 类用于创建位置、纹理顶点结构。
      */
     class VertexPositionTexture0 {
         constructor(position, textureCoordinate0) {
             this._position = position;
             this._textureCoordinate0 = textureCoordinate0;
         }
         static get vertexDeclaration() {
             return VertexPositionTexture0._vertexDeclaration;
         }
         get position() {
             return this._position;
         }
         get textureCoordinate0() {
             return this._textureCoordinate0;
         }
         get vertexDeclaration() {
             return VertexPositionTexture0._vertexDeclaration;
         }
     }
     VertexPositionTexture0._vertexDeclaration = new VertexDeclaration(20, [new VertexElement(0, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0),
         new VertexElement(12, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0)]);

     /**
      * <code>SkyDome</code> 类用于创建天空盒。
      */
     class SkyDome extends SkyMesh {
         /**
          * 创建一个 <code>SkyDome</code> 实例。
          * @param stacks 堆数。
          * @param slices 层数。
          */
         constructor(stacks = 48, slices = 48) {
             super();
             this._stacks = stacks;
             this._slices = slices;
             var vertexDeclaration = VertexPositionTexture0.vertexDeclaration;
             var vertexFloatCount = vertexDeclaration.vertexStride / 4;
             var numberVertices = (this._stacks + 1) * (this._slices + 1);
             var numberIndices = (3 * this._stacks * (this._slices + 1)) * 2;
             var vertices = new Float32Array(numberVertices * vertexFloatCount);
             var indices = new Uint16Array(numberIndices);
             var stackAngle = Math.PI / this._stacks;
             var sliceAngle = (Math.PI * 2.0) / this._slices;
             // Generate the group of Stacks for the sphere  
             var vertexIndex = 0;
             var vertexCount = 0;
             var indexCount = 0;
             for (var stack = 0; stack < (this._stacks + 1); stack++) {
                 var r = Math.sin(stack * stackAngle);
                 var y = Math.cos(stack * stackAngle);
                 // Generate the group of segments for the current Stack  
                 for (var slice = 0; slice < (this._slices + 1); slice++) {
                     var x = r * Math.sin(slice * sliceAngle);
                     var z = r * Math.cos(slice * sliceAngle);
                     vertices[vertexCount + 0] = x * SkyDome._radius;
                     vertices[vertexCount + 1] = y * SkyDome._radius;
                     vertices[vertexCount + 2] = z * SkyDome._radius;
                     vertices[vertexCount + 3] = -(slice / this._slices) + 0.75; //gzk 改成我喜欢的坐标系 原来是 slice/_slices
                     vertices[vertexCount + 4] = stack / this._stacks;
                     vertexCount += vertexFloatCount;
                     if (stack != (this._stacks - 1)) {
                         // First Face
                         indices[indexCount++] = vertexIndex + 1;
                         indices[indexCount++] = vertexIndex;
                         indices[indexCount++] = vertexIndex + (this._slices + 1);
                         // Second 
                         indices[indexCount++] = vertexIndex + (this._slices + 1);
                         indices[indexCount++] = vertexIndex;
                         indices[indexCount++] = vertexIndex + (this._slices);
                         vertexIndex++;
                     }
                 }
             }
             this._vertexBuffer = new VertexBuffer3D(vertices.length * 4, WebGLContext.STATIC_DRAW, false);
             this._vertexBuffer.vertexDeclaration = vertexDeclaration;
             this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, indices.length, WebGLContext.STATIC_DRAW, false);
             this._vertexBuffer.setData(vertices);
             this._indexBuffer.setData(indices);
             var bufferState = new BufferState();
             bufferState.bind();
             bufferState.applyVertexBuffer(this._vertexBuffer);
             bufferState.applyIndexBuffer(this._indexBuffer);
             bufferState.unBind();
             this._bufferState = bufferState;
         }
         /**
          * @private
          */
         static __init__() {
             SkyDome.instance = new SkyDome(); //TODO:移植为标准Mesh后需要加锁
         }
         /**
          * 获取堆数。
          */
         get stacks() {
             return this._stacks;
         }
         /**
          * 获取层数。
          */
         get slices() {
             return this._slices;
         }
         /*override*/ _render(state) {
             var indexCount = this._indexBuffer.indexCount;
             LayaGL.instance.drawElements(WebGLContext.TRIANGLES, indexCount, WebGLContext.UNSIGNED_SHORT, 0);
             Stat.trianglesFaces += indexCount / 3;
             Stat.renderBatches++;
         }
     }
     /**@private */
     SkyDome._radius = 1;

     /**
      * * <code>PostProcessRenderContext</code> 类用于创建后期处理渲染上下文。
      */
     class PostProcessRenderContext {
         constructor() {
             /** 源纹理。*/
             this.source = null;
             /** 输出纹理。*/
             this.destination = null;
             /** 渲染相机。*/
             this.camera = null;
             /** 合成着色器数据。*/
             this.compositeShaderData = null;
             /** 后期处理指令流。*/
             this.command = null;
             /** 临时纹理数组。*/
             this.deferredReleaseTextures = [];
         }
     }

     /**
      * <code>PostProcess</code> 类用于创建后期处理组件。
      */
     class PostProcess {
         /**
          * 创建一个 <code>PostProcess</code> 实例。
          */
         constructor() {
             /**@private */
             this._compositeShader = Shader3D.find("PostProcessComposite");
             /**@private */
             this._compositeShaderData = new ShaderData();
             /**@private */
             this._context = null;
             /**@private */
             this._effects = [];
             this._context = new PostProcessRenderContext();
             this._context.compositeShaderData = this._compositeShaderData;
         }
         /**
          * @private
          */
         static __init__() {
             PostProcess.SHADERDEFINE_BLOOM_LOW = PostProcess.shaderDefines.registerDefine("BLOOM_LOW");
             PostProcess.SHADERDEFINE_BLOOM = PostProcess.shaderDefines.registerDefine("BLOOM");
             PostProcess.SHADERDEFINE_FINALPASS = PostProcess.shaderDefines.registerDefine("FINALPASS");
         }
         /**
          *@private
          */
         _init(camera, command) {
             this._context.camera = camera;
             this._context.command = command;
         }
         /**
          * @private
          */
         _render() {
             var camera = this._context.camera;
             var screenTexture = RenderTexture.createFromPool(RenderContext3D.clientWidth, RenderContext3D.clientHeight, camera._getRenderTextureFormat(), BaseTexture.FORMAT_DEPTHSTENCIL_NONE);
             var cameraTarget = camera._renderTexture;
             this._context.command.clear();
             this._context.source = screenTexture;
             this._context.destination = cameraTarget;
             this._context.compositeShaderData.clearDefine();
             this._context.command.blitScreenTriangle(cameraTarget, screenTexture);
             this._context.compositeShaderData.setTexture(PostProcess.SHADERVALUE_AUTOEXPOSURETEX, Texture2D.whiteTexture); //TODO:
             for (var i = 0, n = this._effects.length; i < n; i++)
                 this._effects[i].render(this._context);
             this._compositeShaderData.addDefine(PostProcess.SHADERDEFINE_FINALPASS);
             //dithering.Render(context);
             var offScreenTexture = camera.renderTarget;
             var dest = offScreenTexture ? offScreenTexture : null; //TODO:如果不画到RenderTarget上,最后一次为null直接画到屏幕上
             this._context.destination = dest;
             this._context.command.blitScreenTriangle(this._context.source, dest, this._compositeShader, this._compositeShaderData);
             //context.source = context.destination;
             //context.destination = finalDestination;
             //释放临时纹理
             RenderTexture.recoverToPool(screenTexture);
             var tempRenderTextures = this._context.deferredReleaseTextures;
             for (i = 0, n = tempRenderTextures.length; i < n; i++)
                 RenderTexture.recoverToPool(tempRenderTextures[i]);
             tempRenderTextures.length = 0;
         }
         /**
          * 添加后期处理效果。
          */
         addEffect(effect) {
             this._effects.push(effect);
         }
         /**
          * 移除后期处理效果。
          */
         removeEffect(effect) {
             var index = this._effects.indexOf(effect);
             if (index !== -1)
                 this._effects.splice(index, 1);
         }
     }
     /**@private */
     PostProcess.SHADERVALUE_MAINTEX = Shader3D.propertyNameToID("u_MainTex");
     /**@private */
     PostProcess.SHADERVALUE_BLOOMTEX = Shader3D.propertyNameToID("u_BloomTex");
     /**@private */
     PostProcess.SHADERVALUE_AUTOEXPOSURETEX = Shader3D.propertyNameToID("u_AutoExposureTex");
     /**@private */
     PostProcess.SHADERVALUE_BLOOM_DIRTTEX = Shader3D.propertyNameToID("u_Bloom_DirtTex");
     /**@private */
     PostProcess.SHADERVALUE_BLOOMTEX_TEXELSIZE = Shader3D.propertyNameToID("u_BloomTex_TexelSize");
     /**@private */
     PostProcess.SHADERVALUE_BLOOM_DIRTTILEOFFSET = Shader3D.propertyNameToID("u_Bloom_DirtTileOffset");
     /**@private */
     PostProcess.SHADERVALUE_BLOOM_SETTINGS = Shader3D.propertyNameToID("u_Bloom_Settings");
     /**@private */
     PostProcess.SHADERVALUE_BLOOM_COLOR = Shader3D.propertyNameToID("u_Bloom_Color");
     /**@private */
     PostProcess.shaderDefines = new ShaderDefines();

     /**
      * <code>EffectMaterial</code> 类用于实现Mesh特效材质。
      */
     class EffectMaterial extends BaseMaterial {
         constructor() {
             super();
             this.setShaderName("Effect");
             this._color = new Vector4(1.0, 1.0, 1.0, 1.0);
             this._shaderValues.setVector(EffectMaterial.TINTCOLOR, new Vector4(1.0, 1.0, 1.0, 1.0));
             this.renderMode = EffectMaterial.RENDERMODE_ADDTIVE;
         }
         /**
          * @private
          */
         static __initDefine__() {
             EffectMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             EffectMaterial.SHADERDEFINE_MAINTEXTURE = EffectMaterial.shaderDefines.registerDefine("MAINTEXTURE");
             EffectMaterial.SHADERDEFINE_TILINGOFFSET = EffectMaterial.shaderDefines.registerDefine("TILINGOFFSET");
             EffectMaterial.SHADERDEFINE_ADDTIVEFOG = EffectMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
         }
         /**
          * @private
          */
         get _TintColorR() {
             return this._color.x;
         }
         /**
          * @private
          */
         set _TintColorR(value) {
             this._color.x = value;
             this.color = this._color;
         }
         /**
          * @private
          */
         get _TintColorG() {
             return this._color.y;
         }
         /**
          * @private
          */
         set _TintColorG(value) {
             this._color.y = value;
             this.color = this._color;
         }
         /**
          * @private
          */
         get _TintColorB() {
             return this._color.z;
         }
         /**
          * @private
          */
         set _TintColorB(value) {
             this._color.z = value;
             this.color = this._color;
         }
         /**@private */
         get _TintColorA() {
             return this._color.w;
         }
         /**
          * @private
          */
         set _TintColorA(value) {
             this._color.w = value;
             this.color = this._color;
         }
         /**
          * @private
          */
         get _MainTex_STX() {
             return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).x;
         }
         /**
          * @private
          */
         set _MainTex_STX(x) {
             var tilOff = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
             tilOff.x = x;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STY() {
             return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).y;
         }
         /**
          * @private
          */
         set _MainTex_STY(y) {
             var tilOff = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
             tilOff.y = y;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STZ() {
             return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).z;
         }
         /**
          * @private
          */
         set _MainTex_STZ(z) {
             var tilOff = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
             tilOff.z = z;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STW() {
             return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).w;
         }
         /**
          * @private
          */
         set _MainTex_STW(w) {
             var tilOff = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
             tilOff.w = w;
             this.tilingOffset = tilOff;
         }
         /**
          * 设置渲染模式。
          * @return 渲染模式。
          */
         set renderMode(value) {
             switch (value) {
                 case EffectMaterial.RENDERMODE_ADDTIVE:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_NONE;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                     break;
                 case EffectMaterial.RENDERMODE_ALPHABLENDED:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_NONE;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                     break;
                 default:
                     throw new Error("MeshEffectMaterial : renderMode value error.");
             }
         }
         /**
          * 获取颜色R分量。
          * @return 颜色R分量。
          */
         get colorR() {
             return this._TintColorR;
         }
         /**
          * 设置颜色R分量。
          * @param value 颜色R分量。
          */
         set colorR(value) {
             this._TintColorR = value;
         }
         /**
          * 获取颜色G分量。
          * @return 颜色G分量。
          */
         get colorG() {
             return this._TintColorG;
         }
         /**
          * 设置颜色G分量。
          * @param value 颜色G分量。
          */
         set colorG(value) {
             this._TintColorG = value;
         }
         /**
          * 获取颜色B分量。
          * @return 颜色B分量。
          */
         get colorB() {
             return this._TintColorB;
         }
         /**
          * 设置颜色B分量。
          * @param value 颜色B分量。
          */
         set colorB(value) {
             this._TintColorB = value;
         }
         /**
          * 获取颜色Z分量。
          * @return 颜色Z分量。
          */
         get colorA() {
             return this._TintColorA;
         }
         /**
          * 设置颜色alpha分量。
          * @param value 颜色alpha分量。
          */
         set colorA(value) {
             this._TintColorA = value;
         }
         /**
          * 获取颜色。
          * @return 颜色。
          */
         get color() {
             return this._shaderValues.getVector(EffectMaterial.TINTCOLOR);
         }
         /**
          * 设置颜色。
          * @param value 颜色。
          */
         set color(value) {
             this._shaderValues.setVector(EffectMaterial.TINTCOLOR, value);
         }
         /**
          * 获取贴图。
          * @return 贴图。
          */
         get texture() {
             return this._shaderValues.getTexture(EffectMaterial.MAINTEXTURE);
         }
         /**
          * 设置贴图。
          * @param value 贴图。
          */
         set texture(value) {
             if (value)
                 this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE);
             else
                 this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE);
             this._shaderValues.setTexture(EffectMaterial.MAINTEXTURE, value);
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @return 纹理平铺和偏移X分量。
          */
         get tilingOffsetX() {
             return this._MainTex_STX;
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @param x 纹理平铺和偏移X分量。
          */
         set tilingOffsetX(x) {
             this._MainTex_STX = x;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @return 纹理平铺和偏移Y分量。
          */
         get tilingOffsetY() {
             return this._MainTex_STY;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @param y 纹理平铺和偏移Y分量。
          */
         set tilingOffsetY(y) {
             this._MainTex_STY = y;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @return 纹理平铺和偏移Z分量。
          */
         get tilingOffsetZ() {
             return this._MainTex_STZ;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @param z 纹理平铺和偏移Z分量。
          */
         set tilingOffsetZ(z) {
             this._MainTex_STZ = z;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @return 纹理平铺和偏移W分量。
          */
         get tilingOffsetW() {
             return this._MainTex_STW;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @param w 纹理平铺和偏移W分量。
          */
         set tilingOffsetW(w) {
             this._MainTex_STW = w;
         }
         /**
          * 获取纹理平铺和偏移。
          * @return 纹理平铺和偏移。
          */
         get tilingOffset() {
             return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
         }
         /**
          * 设置纹理平铺和偏移。
          * @param value 纹理平铺和偏移。
          */
         set tilingOffset(value) {
             if (value) {
                 if (value.x != 1 || value.y != 1 || value.z != 0 || value.w != 0)
                     this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET);
                 else
                     this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             else {
                 this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             this._shaderValues.setVector(EffectMaterial.TILINGOFFSET, value);
         }
         /**
          * 设置是否写入深度。
          * @param value 是否写入深度。
          */
         set depthWrite(value) {
             this._shaderValues.setBool(EffectMaterial.DEPTH_WRITE, value);
         }
         /**
          * 获取是否写入深度。
          * @return 是否写入深度。
          */
         get depthWrite() {
             return this._shaderValues.getBool(EffectMaterial.DEPTH_WRITE);
         }
         /**
          * 设置剔除方式。
          * @param value 剔除方式。
          */
         set cull(value) {
             this._shaderValues.setInt(EffectMaterial.CULL, value);
         }
         /**
          * 获取剔除方式。
          * @return 剔除方式。
          */
         get cull() {
             return this._shaderValues.getInt(EffectMaterial.CULL);
         }
         /**
          * 设置混合方式。
          * @param value 混合方式。
          */
         set blend(value) {
             this._shaderValues.setInt(EffectMaterial.BLEND, value);
         }
         /**
          * 获取混合方式。
          * @return 混合方式。
          */
         get blend() {
             return this._shaderValues.getInt(EffectMaterial.BLEND);
         }
         /**
          * 设置混合源。
          * @param value 混合源
          */
         set blendSrc(value) {
             this._shaderValues.setInt(EffectMaterial.BLEND_SRC, value);
         }
         /**
          * 获取混合源。
          * @return 混合源。
          */
         get blendSrc() {
             return this._shaderValues.getInt(EffectMaterial.BLEND_SRC);
         }
         /**
          * 设置混合目标。
          * @param value 混合目标
          */
         set blendDst(value) {
             this._shaderValues.setInt(EffectMaterial.BLEND_DST, value);
         }
         /**
          * 获取混合目标。
          * @return 混合目标。
          */
         get blendDst() {
             return this._shaderValues.getInt(EffectMaterial.BLEND_DST);
         }
         /**
          * 设置深度测试方式。
          * @param value 深度测试方式
          */
         set depthTest(value) {
             this._shaderValues.setInt(EffectMaterial.DEPTH_TEST, value);
         }
         /**
          * 获取深度测试方式。
          * @return 深度测试方式。
          */
         get depthTest() {
             return this._shaderValues.getInt(EffectMaterial.DEPTH_TEST);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new EffectMaterial();
             this.cloneTo(dest);
             return dest;
         }
     }
     /**渲染状态_加色法混合。*/
     EffectMaterial.RENDERMODE_ADDTIVE = 0;
     /**渲染状态_透明混合。*/
     EffectMaterial.RENDERMODE_ALPHABLENDED = 1;
     EffectMaterial.MAINTEXTURE = Shader3D.propertyNameToID("u_AlbedoTexture");
     EffectMaterial.TINTCOLOR = Shader3D.propertyNameToID("u_AlbedoColor");
     EffectMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset");
     EffectMaterial.CULL = Shader3D.propertyNameToID("s_Cull");
     EffectMaterial.BLEND = Shader3D.propertyNameToID("s_Blend");
     EffectMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
     EffectMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
     EffectMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
     EffectMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
     /**@private */
     EffectMaterial.shaderDefines = null;

     /**
      * ...
      * @author ...
      */
     class ExtendTerrainMaterial extends BaseMaterial {
         constructor() {
             super();
             /**@private */
             this._enableLighting = true;
             this.setShaderName("ExtendTerrain");
             this.renderMode = ExtendTerrainMaterial.RENDERMODE_OPAQUE;
         }
         /**
          * @private
          */
         static __initDefine__() {
             ExtendTerrainMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM1");
             ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM2");
             ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM3");
             ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM4");
             ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM5");
         }
         /**
          * 获取splatAlpha贴图。
          * @return splatAlpha贴图。
          */
         get splatAlphaTexture() {
             return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE);
         }
         /**
          * 设置splatAlpha贴图。
          * @param value splatAlpha贴图。
          */
         set splatAlphaTexture(value) {
             this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE, value);
         }
         /**
          * 设置第一层贴图。
          * @param value 第一层贴图。
          */
         set diffuseTexture1(value) {
             this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1, value);
             this._setDetailNum(1);
         }
         /**
          * 获取第二层贴图。
          * @return 第二层贴图。
          */
         get diffuseTexture2() {
             return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2);
         }
         /**
          * 设置第二层贴图。
          * @param value 第二层贴图。
          */
         set diffuseTexture2(value) {
             this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2, value);
             this._setDetailNum(2);
         }
         /**
          * 获取第三层贴图。
          * @return 第三层贴图。
          */
         get diffuseTexture3() {
             return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3);
         }
         /**
          * 设置第三层贴图。
          * @param value 第三层贴图。
          */
         set diffuseTexture3(value) {
             this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3, value);
             this._setDetailNum(3);
         }
         /**
          * 获取第四层贴图。
          * @return 第四层贴图。
          */
         get diffuseTexture4() {
             return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4);
         }
         /**
          * 设置第四层贴图。
          * @param value 第四层贴图。
          */
         set diffuseTexture4(value) {
             this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4, value);
             this._setDetailNum(4);
         }
         /**
          * 获取第五层贴图。
          * @return 第五层贴图。
          */
         get diffuseTexture5() {
             return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5);
         }
         /**
          * 设置第五层贴图。
          * @param value 第五层贴图。
          */
         set diffuseTexture5(value) {
             this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5, value);
             this._setDetailNum(5);
         }
         _setDetailNum(value) {
             switch (value) {
                 case 1:
                     this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                     break;
                 case 2:
                     this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                     break;
                 case 3:
                     this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                     break;
                 case 4:
                     this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                     break;
                 case 5:
                     this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                     this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                     break;
             }
         }
         set diffuseScaleOffset1(scaleOffset1) {
             this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1, scaleOffset1);
         }
         set diffuseScaleOffset2(scaleOffset2) {
             this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2, scaleOffset2);
         }
         set diffuseScaleOffset3(scaleOffset3) {
             this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3, scaleOffset3);
         }
         set diffuseScaleOffset4(scaleOffset4) {
             this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4, scaleOffset4);
         }
         set diffuseScaleOffset5(scaleOffset5) {
             this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5, scaleOffset5);
         }
         /**
          * 获取是否启用光照。
          * @return 是否启用光照。
          */
         get enableLighting() {
             return this._enableLighting;
         }
         /**
          * 设置是否启用光照。
          * @param value 是否启用光照。
          */
         set enableLighting(value) {
             if (this._enableLighting !== value) {
                 if (value)
                     this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                 else
                     this._disablePublicDefineDatas.add(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                 this._enableLighting = value;
             }
         }
         /**
          * 设置渲染模式。
          * @return 渲染模式。
          */
         set renderMode(value) {
             switch (value) {
                 case ExtendTerrainMaterial.RENDERMODE_OPAQUE:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE;
                     this.depthWrite = true;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_DISABLE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     break;
                 case ExtendTerrainMaterial.RENDERMODE_TRANSPARENT:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.depthTest = RenderState.DEPTHTEST_LEQUAL;
                     break;
                 default:
                     throw new Error("ExtendTerrainMaterial:renderMode value error.");
             }
         }
         /**
          * 设置是否写入深度。
          * @param value 是否写入深度。
          */
         set depthWrite(value) {
             this._shaderValues.setBool(ExtendTerrainMaterial.DEPTH_WRITE, value);
         }
         /**
          * 获取是否写入深度。
          * @return 是否写入深度。
          */
         get depthWrite() {
             return this._shaderValues.getBool(ExtendTerrainMaterial.DEPTH_WRITE);
         }
         /**
          * 设置剔除方式。
          * @param value 剔除方式。
          */
         set cull(value) {
             this._shaderValues.setInt(ExtendTerrainMaterial.CULL, value);
         }
         /**
          * 获取剔除方式。
          * @return 剔除方式。
          */
         get cull() {
             return this._shaderValues.getInt(ExtendTerrainMaterial.CULL);
         }
         /**
          * 设置混合方式。
          * @param value 混合方式。
          */
         set blend(value) {
             this._shaderValues.setInt(ExtendTerrainMaterial.BLEND, value);
         }
         /**
          * 获取混合方式。
          * @return 混合方式。
          */
         get blend() {
             return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND);
         }
         /**
          * 设置混合源。
          * @param value 混合源
          */
         set blendSrc(value) {
             this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_SRC, value);
         }
         /**
          * 获取混合源。
          * @return 混合源。
          */
         get blendSrc() {
             return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_SRC);
         }
         /**
          * 设置混合目标。
          * @param value 混合目标
          */
         set blendDst(value) {
             this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_DST, value);
         }
         /**
          * 获取混合目标。
          * @return 混合目标。
          */
         get blendDst() {
             return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_DST);
         }
         /**
          * 设置深度测试方式。
          * @param value 深度测试方式
          */
         set depthTest(value) {
             this._shaderValues.setInt(ExtendTerrainMaterial.DEPTH_TEST, value);
         }
         /**
          * 获取深度测试方式。
          * @return 深度测试方式。
          */
         get depthTest() {
             return this._shaderValues.getInt(ExtendTerrainMaterial.DEPTH_TEST);
         }
         /**
     * 克隆。
     * @return	 克隆副本。
     */
         clone() {
             var dest = new ExtendTerrainMaterial();
             this.cloneTo(dest);
             return dest;
         }
     }
     /**渲染状态_不透明。*/
     ExtendTerrainMaterial.RENDERMODE_OPAQUE = 1;
     /**渲染状态_透明混合。*/
     ExtendTerrainMaterial.RENDERMODE_TRANSPARENT = 2;
     /**渲染状态_透明混合。*/
     ExtendTerrainMaterial.SPLATALPHATEXTURE = Shader3D.propertyNameToID("u_SplatAlphaTexture");
     ExtendTerrainMaterial.DIFFUSETEXTURE1 = Shader3D.propertyNameToID("u_DiffuseTexture1");
     ExtendTerrainMaterial.DIFFUSETEXTURE2 = Shader3D.propertyNameToID("u_DiffuseTexture2");
     ExtendTerrainMaterial.DIFFUSETEXTURE3 = Shader3D.propertyNameToID("u_DiffuseTexture3");
     ExtendTerrainMaterial.DIFFUSETEXTURE4 = Shader3D.propertyNameToID("u_DiffuseTexture4");
     ExtendTerrainMaterial.DIFFUSETEXTURE5 = Shader3D.propertyNameToID("u_DiffuseTexture5");
     ExtendTerrainMaterial.DIFFUSESCALEOFFSET1 = Shader3D.propertyNameToID("u_DiffuseScaleOffset1");
     ExtendTerrainMaterial.DIFFUSESCALEOFFSET2 = Shader3D.propertyNameToID("u_DiffuseScaleOffset2");
     ExtendTerrainMaterial.DIFFUSESCALEOFFSET3 = Shader3D.propertyNameToID("u_DiffuseScaleOffset3");
     ExtendTerrainMaterial.DIFFUSESCALEOFFSET4 = Shader3D.propertyNameToID("u_DiffuseScaleOffset4");
     ExtendTerrainMaterial.DIFFUSESCALEOFFSET5 = Shader3D.propertyNameToID("u_DiffuseScaleOffset5");
     ExtendTerrainMaterial.CULL = Shader3D.propertyNameToID("s_Cull");
     ExtendTerrainMaterial.BLEND = Shader3D.propertyNameToID("s_Blend");
     ExtendTerrainMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
     ExtendTerrainMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
     ExtendTerrainMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
     ExtendTerrainMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
     /**@private */
     ExtendTerrainMaterial.shaderDefines = null;

     /**
      * <code>PBRSpecularMaterial</code> 类用于实现PBR(Specular)材质。
      */
     class PBRSpecularMaterial extends BaseMaterial {
         /**
          * 创建一个 <code>PBRSpecularMaterial</code> 实例。
          */
         constructor() {
             super();
             this.setShaderName("PBRSpecular");
             this._albedoColor = new Vector4(1.0, 1.0, 1.0, 1.0);
             this._shaderValues.setVector(PBRSpecularMaterial.ALBEDOCOLOR, new Vector4(1.0, 1.0, 1.0, 1.0));
             this._emissionColor = new Vector4(0.0, 0.0, 0.0, 0.0);
             this._shaderValues.setVector(PBRSpecularMaterial.EMISSIONCOLOR, new Vector4(0.0, 0.0, 0.0, 0.0));
             this._specularColor = new Vector4(0.2, 0.2, 0.2, 0.2);
             this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, new Vector4(0.2, 0.2, 0.2, 0.2));
             this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESS, 0.5);
             this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSCALE, 1.0);
             this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSOURCE, 0);
             this._shaderValues.setNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH, 1.0);
             this._shaderValues.setNumber(PBRSpecularMaterial.NORMALSCALE, 1.0);
             this._shaderValues.setNumber(PBRSpecularMaterial.PARALLAXSCALE, 0.001);
             this._shaderValues.setBool(PBRSpecularMaterial.ENABLEEMISSION, false);
             this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE, 0.5);
             this.renderMode = PBRSpecularMaterial.RENDERMODE_OPAQUE;
         }
         /**
          * @private
          */
         static __initDefine__() {
             PBRSpecularMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE");
             PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("SPECULARTEXTURE");
             PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = PBRSpecularMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
             PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
             PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE");
             PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE");
             PBRSpecularMaterial.SHADERDEFINE_EMISSION = PBRSpecularMaterial.shaderDefines.registerDefine("EMISSION");
             PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE");
             PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET = PBRSpecularMaterial.shaderDefines.registerDefine("TILINGOFFSET");
             PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY = PBRSpecularMaterial.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
         }
         /**
          * @private
          */
         get _ColorR() {
             return this._albedoColor.x;
         }
         /**
          * @private
          */
         set _ColorR(value) {
             this._albedoColor.x = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorG() {
             return this._albedoColor.y;
         }
         /**
          * @private
          */
         set _ColorG(value) {
             this._albedoColor.y = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorB() {
             return this._albedoColor.z;
         }
         /**
          * @private
          */
         set _ColorB(value) {
             this._albedoColor.z = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorA() {
             return this._albedoColor.w;
         }
         /**
          * @private
          */
         set _ColorA(value) {
             this._albedoColor.w = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _SpecColorR() {
             return this._specularColor.x;
         }
         /**
          * @private
          */
         set _SpecColorR(value) {
             this._specularColor.x = value;
             this.specularColor = this._specularColor;
         }
         /**
          * @private
          */
         get _SpecColorG() {
             return this._specularColor.y;
         }
         /**
          * @private
          */
         set _SpecColorG(value) {
             this._specularColor.y = value;
             this.specularColor = this._specularColor;
         }
         /**
          * @private
          */
         get _SpecColorB() {
             return this._specularColor.z;
         }
         /**
          * @private
          */
         set _SpecColorB(value) {
             this._specularColor.z = value;
             this.specularColor = this._specularColor;
         }
         /**
          * @private
          */
         get _SpecColorA() {
             return this._specularColor.w;
         }
         /**
          * @private
          */
         set _SpecColorA(value) {
             this._specularColor.w = value;
             this.specularColor = this._specularColor;
         }
         /**
          * @private
          */
         get _Glossiness() {
             return this._shaderValues.getNumber(PBRSpecularMaterial.SMOOTHNESS);
         }
         /**
          * @private
          */
         set _Glossiness(value) {
             this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESS, value);
         }
         /**
          * @private
          */
         get _GlossMapScale() {
             return this._shaderValues.getNumber(PBRSpecularMaterial.SMOOTHNESSSCALE);
         }
         /**
          * @private
          */
         set _GlossMapScale(value) {
             this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSCALE, value);
         }
         /**
          * @private
          */
         get _BumpScale() {
             return this._shaderValues.getNumber(PBRSpecularMaterial.NORMALSCALE);
         }
         /**
          * @private
          */
         set _BumpScale(value) {
             this._shaderValues.setNumber(PBRSpecularMaterial.NORMALSCALE, value);
         }
         /**@private */
         get _Parallax() {
             return this._shaderValues.getNumber(PBRSpecularMaterial.PARALLAXSCALE);
         }
         /**
          * @private
          */
         set _Parallax(value) {
             this._shaderValues.setNumber(PBRSpecularMaterial.PARALLAXSCALE, value);
         }
         /**@private */
         get _OcclusionStrength() {
             return this._shaderValues.getNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH);
         }
         /**
          * @private
          */
         set _OcclusionStrength(value) {
             this._shaderValues.setNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH, value);
         }
         /**
          * @private
          */
         get _EmissionColorR() {
             return this._emissionColor.x;
         }
         /**
          * @private
          */
         set _EmissionColorR(value) {
             this._emissionColor.x = value;
             this.emissionColor = this._emissionColor;
         }
         /**
          * @private
          */
         get _EmissionColorG() {
             return this._emissionColor.y;
         }
         /**
          * @private
          */
         set _EmissionColorG(value) {
             this._emissionColor.y = value;
             this.emissionColor = this._emissionColor;
         }
         /**
          * @private
          */
         get _EmissionColorB() {
             return this._emissionColor.z;
         }
         /**
          * @private
          */
         set _EmissionColorB(value) {
             this._emissionColor.z = value;
             this.emissionColor = this._emissionColor;
         }
         /**
          * @private
          */
         get _EmissionColorA() {
             return this._emissionColor.w;
         }
         /**
          * @private
          */
         set _EmissionColorA(value) {
             this._emissionColor.w = value;
             this.emissionColor = this._emissionColor;
         }
         /**
          * @private
          */
         get _MainTex_STX() {
             return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).x;
         }
         /**
          * @private
          */
         set _MainTex_STX(x) {
             var tilOff = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
             tilOff.x = x;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STY() {
             return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).y;
         }
         /**
          * @private
          */
         set _MainTex_STY(y) {
             var tilOff = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
             tilOff.y = y;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STZ() {
             return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).z;
         }
         /**
          * @private
          */
         set _MainTex_STZ(z) {
             var tilOff = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
             tilOff.z = z;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STW() {
             return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).w;
         }
         /**
          * @private
          */
         set _MainTex_STW(w) {
             var tilOff = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
             tilOff.w = w;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _Cutoff() {
             return this.alphaTestValue;
         }
         /**
          * @private
          */
         set _Cutoff(value) {
             this.alphaTestValue = value;
         }
         /**
          * 获取反射率颜色R分量。
          * @return 反射率颜色R分量。
          */
         get albedoColorR() {
             return this._ColorR;
         }
         /**
          * 设置反射率颜色R分量。
          * @param value 反射率颜色R分量。
          */
         set albedoColorR(value) {
             this._ColorR = value;
         }
         /**
          * 获取反射率颜色G分量。
          * @return 反射率颜色G分量。
          */
         get albedoColorG() {
             return this._ColorG;
         }
         /**
          * 设置反射率颜色G分量。
          * @param value 反射率颜色G分量。
          */
         set albedoColorG(value) {
             this._ColorG = value;
         }
         /**
          * 获取反射率颜色B分量。
          * @return 反射率颜色B分量。
          */
         get albedoColorB() {
             return this._ColorB;
         }
         /**
          * 设置反射率颜色B分量。
          * @param value 反射率颜色B分量。
          */
         set albedoColorB(value) {
             this._ColorB = value;
         }
         /**
          * 获取反射率颜色A分量。
          * @return 反射率颜色A分量。
          */
         get albedoColorA() {
             return this._ColorA;
         }
         /**
          * 设置反射率颜色A分量。
          * @param value 反射率颜色A分量。
          */
         set albedoColorA(value) {
             this._ColorA = value;
         }
         /**
          * 获取反射率颜色。
          * @return 反射率颜色。
          */
         get albedoColor() {
             return this._albedoColor;
         }
         /**
          * 设置反射率颜色。
          * @param value 反射率颜色。
          */
         set albedoColor(value) {
             this._albedoColor = value;
             this._shaderValues.setVector(PBRSpecularMaterial.ALBEDOCOLOR, value);
         }
         /**
          * 获取漫反射贴图。
          * @return 漫反射贴图。
          */
         get albedoTexture() {
             return this._shaderValues.getTexture(PBRSpecularMaterial.ALBEDOTEXTURE);
         }
         /**
          * 设置漫反射贴图。
          * @param value 漫反射贴图。
          */
         set albedoTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE);
             }
             this._shaderValues.setTexture(PBRSpecularMaterial.ALBEDOTEXTURE, value);
         }
         /**
          * 获取法线贴图。
          * @return 法线贴图。
          */
         get normalTexture() {
             return this._shaderValues.getTexture(PBRSpecularMaterial.NORMALTEXTURE);
         }
         /**
          * 设置法线贴图。
          * @param value 法线贴图。
          */
         set normalTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE);
             }
             this._shaderValues.setTexture(PBRSpecularMaterial.NORMALTEXTURE, value);
         }
         /**
          * 获取法线贴图缩放系数。
          * @return 法线贴图缩放系数。
          */
         get normalTextureScale() {
             return this._BumpScale;
         }
         /**
          * 设置法线贴图缩放系数。
          * @param value 法线贴图缩放系数。
          */
         set normalTextureScale(value) {
             this._BumpScale = value;
         }
         /**
          * 获取视差贴图。
          * @return 视察贴图。
          */
         get parallaxTexture() {
             return this._shaderValues.getTexture(PBRSpecularMaterial.PARALLAXTEXTURE);
         }
         /**
          * 设置视差贴图。
          * @param value 视察贴图。
          */
         set parallaxTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE);
             }
             this._shaderValues.setTexture(PBRSpecularMaterial.PARALLAXTEXTURE, value);
         }
         /**
          * 获取视差贴图缩放系数。
          * @return 视差缩放系数。
          */
         get parallaxTextureScale() {
             return this._Parallax;
         }
         /**
          * 设置视差贴图缩放系数。
          * @param value 视差缩放系数。
          */
         set parallaxTextureScale(value) {
             this._Parallax = Math.max(0.005, Math.min(0.08, value));
         }
         /**
          * 获取遮挡贴图。
          * @return 遮挡贴图。
          */
         get occlusionTexture() {
             return this._shaderValues.getTexture(PBRSpecularMaterial.OCCLUSIONTEXTURE);
         }
         /**
          * 设置遮挡贴图。
          * @param value 遮挡贴图。
          */
         set occlusionTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
             }
             this._shaderValues.setTexture(PBRSpecularMaterial.OCCLUSIONTEXTURE, value);
         }
         /**
          * 获取遮挡贴图强度。
          * @return 遮挡贴图强度,范围为0到1。
          */
         get occlusionTextureStrength() {
             return this._OcclusionStrength;
         }
         /**
          * 设置遮挡贴图强度。
          * @param value 遮挡贴图强度,范围为0到1。
          */
         set occlusionTextureStrength(value) {
             this._OcclusionStrength = Math.max(0.0, Math.min(1.0, value));
         }
         /**
          * 获取高光贴图。
          * @return 高光贴图。
          */
         get specularTexture() {
             return this._shaderValues.getTexture(PBRSpecularMaterial.SPECULARTEXTURE);
         }
         /**
          * 设置高光贴图。
          * @param value 高光贴图。
          */
         set specularTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE);
             }
             this._shaderValues.setTexture(PBRSpecularMaterial.SPECULARTEXTURE, value);
         }
         /**
          * 获取高光颜色R分量。
          * @return 高光颜色R分量。
          */
         get specularColorR() {
             return this._SpecColorR;
         }
         /**
          * 设置高光颜色R分量。
          * @param value 高光颜色R分量。
          */
         set specularColorR(value) {
             this._SpecColorR = value;
         }
         /**
          * 获取高光颜色G分量。
          * @return 高光颜色G分量。
          */
         get specularColorG() {
             return this._SpecColorG;
         }
         /**
          * 设置高光颜色G分量。
          * @param value 高光颜色G分量。
          */
         set specularColorG(value) {
             this._SpecColorG = value;
         }
         /**
          * 获取高光颜色B分量。
          * @return 高光颜色B分量。
          */
         get specularColorB() {
             return this._SpecColorB;
         }
         /**
          * 设置高光颜色B分量。
          * @param value 高光颜色B分量。
          */
         set specularColorB(value) {
             this._SpecColorB = value;
         }
         /**
          * 获取高光颜色A分量。
          * @return 高光颜色A分量。
          */
         get specularColorA() {
             return this._SpecColorA;
         }
         /**
          * 设置高光颜色A分量。
          * @param value 高光颜色A分量。
          */
         set specularColorA(value) {
             this._SpecColorA = value;
         }
         /**
          * 获取高光颜色。
          * @return 高光颜色。
          */
         get specularColor() {
             return this._shaderValues.getVector(PBRSpecularMaterial.SPECULARCOLOR);
         }
         /**
          * 设置高光颜色。
          * @param value 高光颜色。
          */
         set specularColor(value) {
             this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, value);
         }
         /**
          * 获取光滑度。
          * @return 光滑度,范围为0到1。
          */
         get smoothness() {
             return this._Glossiness;
         }
         /**
          * 设置光滑度。
          * @param value 光滑度,范围为0到1。
          */
         set smoothness(value) {
             this._Glossiness = Math.max(0.0, Math.min(1.0, value));
         }
         /**
          * 获取光滑度缩放系数。
          * @return 光滑度缩放系数,范围为0到1。
          */
         get smoothnessTextureScale() {
             return this._GlossMapScale;
         }
         /**
          * 设置光滑度缩放系数。
          * @param value 光滑度缩放系数,范围为0到1。
          */
         set smoothnessTextureScale(value) {
             this._GlossMapScale = Math.max(0.0, Math.min(1.0, value));
         }
         /**
          * 获取光滑度数据源
          * @return 光滑滑度数据源,0或1。
          */
         get smoothnessSource() {
             return this._shaderValues.getInt(PBRSpecularMaterial.SMOOTHNESSSOURCE);
         }
         /**
          * 设置光滑度数据源。
          * @param value 光滑滑度数据源,0或1。
          */
         set smoothnessSource(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
                 this._shaderValues.setInt(PBRSpecularMaterial.SMOOTHNESSSOURCE, 1);
             }
             else {
                 this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
                 this._shaderValues.setInt(PBRSpecularMaterial.SMOOTHNESSSOURCE, 0);
             }
         }
         /**
          * 获取是否激活放射属性。
          * @return 是否激活放射属性。
          */
         get enableEmission() {
             return this._shaderValues.getBool(PBRSpecularMaterial.ENABLEEMISSION);
         }
         /**
          * 设置是否激活放射属性。
          * @param value 是否激活放射属性
          */
         set enableEmission(value) {
             if (value)
                 this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_EMISSION);
             else {
                 this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_EMISSION);
             }
             this._shaderValues.setBool(PBRSpecularMaterial.ENABLEEMISSION, value);
         }
         /**
          * 获取放射颜色。
          * @return 放射颜色。
          */
         get emissionColor() {
             return this._shaderValues.getVector(PBRSpecularMaterial.EMISSIONCOLOR);
         }
         /**
          * 设置放射颜色。
          * @param value 放射颜色。
          */
         set emissionColor(value) {
             this._shaderValues.setVector(PBRSpecularMaterial.EMISSIONCOLOR, value);
         }
         /**
          * 获取放射贴图。
          * @return 放射贴图。
          */
         get emissionTexture() {
             return this._shaderValues.getTexture(PBRSpecularMaterial.EMISSIONTEXTURE);
         }
         /**
          * 设置放射贴图。
          * @param value 放射贴图。
          */
         set emissionTexture(value) {
             if (value)
                 this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE);
             else
                 this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE);
             this._shaderValues.setTexture(PBRSpecularMaterial.EMISSIONTEXTURE, value);
         }
         /**
          * 获取是否开启反射。
          * @return 是否开启反射。
          */
         get enableReflection() {
             return this._shaderValues.getBool(PBRSpecularMaterial.ENABLEREFLECT);
         }
         /**
          * 设置是否开启反射。
          * @param value 是否开启反射。
          */
         set enableReflection(value) {
             this._shaderValues.setBool(PBRSpecularMaterial.ENABLEREFLECT, true);
             if (value)
                 this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP);
             else
                 this._disablePublicDefineDatas.add(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP);
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @return 纹理平铺和偏移X分量。
          */
         get tilingOffsetX() {
             return this._MainTex_STX;
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @param x 纹理平铺和偏移X分量。
          */
         set tilingOffsetX(x) {
             this._MainTex_STX = x;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @return 纹理平铺和偏移Y分量。
          */
         get tilingOffsetY() {
             return this._MainTex_STY;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @param y 纹理平铺和偏移Y分量。
          */
         set tilingOffsetY(y) {
             this._MainTex_STY = y;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @return 纹理平铺和偏移Z分量。
          */
         get tilingOffsetZ() {
             return this._MainTex_STZ;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @param z 纹理平铺和偏移Z分量。
          */
         set tilingOffsetZ(z) {
             this._MainTex_STZ = z;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @return 纹理平铺和偏移W分量。
          */
         get tilingOffsetW() {
             return this._MainTex_STW;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @param w 纹理平铺和偏移W分量。
          */
         set tilingOffsetW(w) {
             this._MainTex_STW = w;
         }
         /**
          * 获取纹理平铺和偏移。
          * @return 纹理平铺和偏移。
          */
         get tilingOffset() {
             return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
         }
         /**
          * 获取纹理平铺和偏移。
          * @param value 纹理平铺和偏移。
          */
         set tilingOffset(value) {
             if (value) {
                 if (value.x != 1 || value.y != 1 || value.z != 0 || value.w != 0)
                     this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
                 else
                     this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             else {
                 this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             this._shaderValues.setVector(PBRSpecularMaterial.TILINGOFFSET, value);
         }
         /**
          * 设置渲染模式。
          * @return 渲染模式。
          */
         set renderMode(value) {
             switch (value) {
                 case PBRSpecularMaterial.RENDERMODE_OPAQUE:
                     this.alphaTest = false;
                     this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE;
                     this.depthWrite = true;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_DISABLE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                     break;
                 case PBRSpecularMaterial.RENDERMODE_CUTOUT:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_ALPHATEST;
                     this.alphaTest = true;
                     this.depthWrite = true;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_DISABLE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                     break;
                 case PBRSpecularMaterial.RENDERMODE_FADE:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                     break;
                 case PBRSpecularMaterial.RENDERMODE_TRANSPARENT:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_ONE;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                     break;
                 default:
                     throw new Error("PBRSpecularMaterial : renderMode value error.");
             }
         }
         /**
          * 设置是否写入深度。
          * @param value 是否写入深度。
          */
         set depthWrite(value) {
             this._shaderValues.setBool(PBRSpecularMaterial.DEPTH_WRITE, value);
         }
         /**
          * 获取是否写入深度。
          * @return 是否写入深度。
          */
         get depthWrite() {
             return this._shaderValues.getBool(PBRSpecularMaterial.DEPTH_WRITE);
         }
         /**
          * 设置剔除方式。
          * @param value 剔除方式。
          */
         set cull(value) {
             this._shaderValues.setInt(PBRSpecularMaterial.CULL, value);
         }
         /**
          * 获取剔除方式。
          * @return 剔除方式。
          */
         get cull() {
             return this._shaderValues.getInt(PBRSpecularMaterial.CULL);
         }
         /**
          * 设置混合方式。
          * @param value 混合方式。
          */
         set blend(value) {
             this._shaderValues.setInt(PBRSpecularMaterial.BLEND, value);
         }
         /**
          * 获取混合方式。
          * @return 混合方式。
          */
         get blend() {
             return this._shaderValues.getInt(PBRSpecularMaterial.BLEND);
         }
         /**
          * 设置混合源。
          * @param value 混合源
          */
         set blendSrc(value) {
             this._shaderValues.setInt(PBRSpecularMaterial.BLEND_SRC, value);
         }
         /**
          * 获取混合源。
          * @return 混合源。
          */
         get blendSrc() {
             return this._shaderValues.getInt(PBRSpecularMaterial.BLEND_SRC);
         }
         /**
          * 设置混合目标。
          * @param value 混合目标
          */
         set blendDst(value) {
             this._shaderValues.setInt(PBRSpecularMaterial.BLEND_DST, value);
         }
         /**
          * 获取混合目标。
          * @return 混合目标。
          */
         get blendDst() {
             return this._shaderValues.getInt(PBRSpecularMaterial.BLEND_DST);
         }
         /**
          * 设置深度测试方式。
          * @param value 深度测试方式
          */
         set depthTest(value) {
             this._shaderValues.setInt(PBRSpecularMaterial.DEPTH_TEST, value);
         }
         /**
          * 获取深度测试方式。
          * @return 深度测试方式。
          */
         get depthTest() {
             return this._shaderValues.getInt(PBRSpecularMaterial.DEPTH_TEST);
         }
         /**
      * 克隆。
      * @return	 克隆副本。
      */
         clone() {
             var dest = new PBRSpecularMaterial();
             this.cloneTo(dest);
             return dest;
         }
         /**
          * @inheritDoc
          */
         /*override*/ cloneTo(destObject) {
             super.cloneTo(destObject);
             var destMaterial = destObject;
             this._albedoColor.cloneTo(destMaterial._albedoColor);
             this._specularColor.cloneTo(destMaterial._specularColor);
             this._emissionColor.cloneTo(destMaterial._emissionColor);
         }
     }
     /**光滑度数据源_高光贴图的Alpha通道。*/
     PBRSpecularMaterial.SmoothnessSource_SpecularTexture_Alpha = 0;
     /**光滑度数据源_反射率贴图的Alpha通道。*/
     PBRSpecularMaterial.SmoothnessSource_AlbedoTexture_Alpha = 1;
     /**渲染状态_不透明。*/
     PBRSpecularMaterial.RENDERMODE_OPAQUE = 0;
     /**渲染状态_透明测试。*/
     PBRSpecularMaterial.RENDERMODE_CUTOUT = 1;
     /**渲染状态_透明混合_游戏中经常使用的透明。*/
     PBRSpecularMaterial.RENDERMODE_FADE = 2;
     /**渲染状态_透明混合_物理上看似合理的透明。*/
     PBRSpecularMaterial.RENDERMODE_TRANSPARENT = 3;
     PBRSpecularMaterial.ALBEDOTEXTURE = Shader3D.propertyNameToID("u_AlbedoTexture");
     PBRSpecularMaterial.SPECULARTEXTURE = Shader3D.propertyNameToID("u_SpecularTexture");
     PBRSpecularMaterial.NORMALTEXTURE = Shader3D.propertyNameToID("u_NormalTexture");
     PBRSpecularMaterial.PARALLAXTEXTURE = Shader3D.propertyNameToID("u_ParallaxTexture");
     PBRSpecularMaterial.OCCLUSIONTEXTURE = Shader3D.propertyNameToID("u_OcclusionTexture");
     PBRSpecularMaterial.EMISSIONTEXTURE = Shader3D.propertyNameToID("u_EmissionTexture");
     PBRSpecularMaterial.ALBEDOCOLOR = Shader3D.propertyNameToID("u_AlbedoColor");
     PBRSpecularMaterial.SPECULARCOLOR = Shader3D.propertyNameToID("u_SpecularColor");
     PBRSpecularMaterial.EMISSIONCOLOR = Shader3D.propertyNameToID("u_EmissionColor");
     PBRSpecularMaterial.SMOOTHNESS = Shader3D.propertyNameToID("u_smoothness");
     PBRSpecularMaterial.SMOOTHNESSSCALE = Shader3D.propertyNameToID("u_smoothnessScale");
     PBRSpecularMaterial.SMOOTHNESSSOURCE = -1; //TODO:
     PBRSpecularMaterial.OCCLUSIONSTRENGTH = Shader3D.propertyNameToID("u_occlusionStrength");
     PBRSpecularMaterial.NORMALSCALE = Shader3D.propertyNameToID("u_normalScale");
     PBRSpecularMaterial.PARALLAXSCALE = Shader3D.propertyNameToID("u_parallaxScale");
     PBRSpecularMaterial.ENABLEEMISSION = -1; //TODO:
     PBRSpecularMaterial.ENABLEREFLECT = -1; //TODO:
     PBRSpecularMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset");
     PBRSpecularMaterial.CULL = Shader3D.propertyNameToID("s_Cull");
     PBRSpecularMaterial.BLEND = Shader3D.propertyNameToID("s_Blend");
     PBRSpecularMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
     PBRSpecularMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
     PBRSpecularMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
     PBRSpecularMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
     /**@private */
     PBRSpecularMaterial.shaderDefines = null;

     /**
      * <code>PBRStandardMaterial</code> 类用于实现PBR(Standard)材质。
      */
     class PBRStandardMaterial extends BaseMaterial {
         /**
          * 创建一个 <code>PBRStandardMaterial</code> 实例。
          */
         constructor() {
             super();
             this.setShaderName("PBRStandard");
             this._albedoColor = new Vector4(1.0, 1.0, 1.0, 1.0);
             this._shaderValues.setVector(PBRStandardMaterial.ALBEDOCOLOR, new Vector4(1.0, 1.0, 1.0, 1.0));
             this._emissionColor = new Vector4(0.0, 0.0, 0.0, 0.0);
             this._shaderValues.setVector(PBRStandardMaterial.EMISSIONCOLOR, new Vector4(0.0, 0.0, 0.0, 0.0));
             this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, 0.0);
             this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESS, 0.5);
             this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSCALE, 1.0);
             this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSOURCE, 0);
             this._shaderValues.setNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH, 1.0);
             this._shaderValues.setNumber(PBRStandardMaterial.NORMALSCALE, 1.0);
             this._shaderValues.setNumber(PBRStandardMaterial.PARALLAXSCALE, 0.001);
             this._shaderValues.setBool(PBRStandardMaterial.ENABLEEMISSION, false);
             this._shaderValues.setBool(PBRStandardMaterial.ENABLEREFLECT, true);
             this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE, 0.5);
             this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP);
             this.renderMode = PBRStandardMaterial.RENDERMODE_OPAQUE;
         }
         /**
          * @private
          */
         static __initDefine__() {
             PBRStandardMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE");
             PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("METALLICGLOSSTEXTURE");
             PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = PBRStandardMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
             PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
             PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE");
             PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE");
             PBRStandardMaterial.SHADERDEFINE_EMISSION = PBRStandardMaterial.shaderDefines.registerDefine("EMISSION");
             PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE");
             PBRStandardMaterial.SHADERDEFINE_REFLECTMAP = PBRStandardMaterial.shaderDefines.registerDefine("REFLECTMAP");
             PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET = PBRStandardMaterial.shaderDefines.registerDefine("TILINGOFFSET");
             PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY = PBRStandardMaterial.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
         }
         /**
          * @private
          */
         get _ColorR() {
             return this._albedoColor.x;
         }
         /**
          * @private
          */
         set _ColorR(value) {
             this._albedoColor.x = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorG() {
             return this._albedoColor.y;
         }
         /**
          * @private
          */
         set _ColorG(value) {
             this._albedoColor.y = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorB() {
             return this._albedoColor.z;
         }
         /**
          * @private
          */
         set _ColorB(value) {
             this._albedoColor.z = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorA() {
             return this._albedoColor.w;
         }
         /**
          * @private
          */
         set _ColorA(value) {
             this._albedoColor.w = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _Metallic() {
             return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC);
         }
         /**
          * @private
          */
         set _Metallic(value) {
             this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, value);
         }
         /**
          * @private
          */
         get _Glossiness() {
             return this._shaderValues.getNumber(PBRStandardMaterial.SMOOTHNESS);
         }
         /**
          * @private
          */
         set _Glossiness(value) {
             this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESS, value);
         }
         /**
          * @private
          */
         get _GlossMapScale() {
             return this._shaderValues.getNumber(PBRStandardMaterial.SMOOTHNESSSCALE);
         }
         /**
          * @private
          */
         set _GlossMapScale(value) {
             this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSCALE, value);
         }
         /**
          * @private
          */
         get _BumpScale() {
             return this._shaderValues.getNumber(PBRStandardMaterial.NORMALSCALE);
         }
         /**
          * @private
          */
         set _BumpScale(value) {
             this._shaderValues.setNumber(PBRStandardMaterial.NORMALSCALE, value);
         }
         /**@private */
         get _Parallax() {
             return this._shaderValues.getNumber(PBRStandardMaterial.PARALLAXSCALE);
         }
         /**
          * @private
          */
         set _Parallax(value) {
             this._shaderValues.setNumber(PBRStandardMaterial.PARALLAXSCALE, value);
         }
         /**@private */
         get _OcclusionStrength() {
             return this._shaderValues.getNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH);
         }
         /**
          * @private
          */
         set _OcclusionStrength(value) {
             this._shaderValues.setNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH, value);
         }
         /**
          * @private
          */
         get _EmissionColorR() {
             return this._emissionColor.x;
         }
         /**
          * @private
          */
         set _EmissionColorR(value) {
             this._emissionColor.x = value;
             this.emissionColor = this._emissionColor;
         }
         /**
          * @private
          */
         get _EmissionColorG() {
             return this._emissionColor.y;
         }
         /**
          * @private
          */
         set _EmissionColorG(value) {
             this._emissionColor.y = value;
             this.emissionColor = this._emissionColor;
         }
         /**
          * @private
          */
         get _EmissionColorB() {
             return this._emissionColor.z;
         }
         /**
          * @private
          */
         set _EmissionColorB(value) {
             this._emissionColor.z = value;
             this.emissionColor = this._emissionColor;
         }
         /**
          * @private
          */
         get _EmissionColorA() {
             return this._emissionColor.w;
         }
         /**
          * @private
          */
         set _EmissionColorA(value) {
             this._emissionColor.w = value;
             this.emissionColor = this._emissionColor;
         }
         /**
          * @private
          */
         get _MainTex_STX() {
             return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).x;
         }
         /**
          * @private
          */
         set _MainTex_STX(x) {
             var tilOff = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
             tilOff.x = x;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STY() {
             return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).y;
         }
         /**
          * @private
          */
         set _MainTex_STY(y) {
             var tilOff = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
             tilOff.y = y;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STZ() {
             return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).z;
         }
         /**
          * @private
          */
         set _MainTex_STZ(z) {
             var tilOff = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
             tilOff.z = z;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STW() {
             return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).w;
         }
         /**
          * @private
          */
         set _MainTex_STW(w) {
             var tilOff = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
             tilOff.w = w;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _Cutoff() {
             return this.alphaTestValue;
         }
         /**
          * @private
          */
         set _Cutoff(value) {
             this.alphaTestValue = value;
         }
         /**
          * 获取反射率颜色R分量。
          * @return 反射率颜色R分量。
          */
         get albedoColorR() {
             return this._ColorR;
         }
         /**
          * 设置反射率颜色R分量。
          * @param value 反射率颜色R分量。
          */
         set albedoColorR(value) {
             this._ColorR = value;
         }
         /**
          * 获取反射率颜色G分量。
          * @return 反射率颜色G分量。
          */
         get albedoColorG() {
             return this._ColorG;
         }
         /**
          * 设置反射率颜色G分量。
          * @param value 反射率颜色G分量。
          */
         set albedoColorG(value) {
             this._ColorG = value;
         }
         /**
          * 获取反射率颜色B分量。
          * @return 反射率颜色B分量。
          */
         get albedoColorB() {
             return this._ColorB;
         }
         /**
          * 设置反射率颜色B分量。
          * @param value 反射率颜色B分量。
          */
         set albedoColorB(value) {
             this._ColorB = value;
         }
         /**
          * 获取反射率颜色Z分量。
          * @return 反射率颜色Z分量。
          */
         get albedoColorA() {
             return this._ColorA;
         }
         /**
          * 设置反射率颜色alpha分量。
          * @param value 反射率颜色alpha分量。
          */
         set albedoColorA(value) {
             this._ColorA = value;
         }
         /**
          * 获取漫反射颜色。
          * @return 漫反射颜色。
          */
         get albedoColor() {
             return this._albedoColor;
         }
         /**
          * 设置漫反射颜色。
          * @param value 漫反射颜色。
          */
         set albedoColor(value) {
             this._albedoColor = value;
             this._shaderValues.setVector(PBRStandardMaterial.ALBEDOCOLOR, value);
         }
         /**
          * 获取漫反射贴图。
          * @return 漫反射贴图。
          */
         get albedoTexture() {
             return this._shaderValues.getTexture(PBRStandardMaterial.ALBEDOTEXTURE);
         }
         /**
          * 设置漫反射贴图。
          * @param value 漫反射贴图。
          */
         set albedoTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE);
             }
             this._shaderValues.setTexture(PBRStandardMaterial.ALBEDOTEXTURE, value);
         }
         /**
          * 获取法线贴图。
          * @return 法线贴图。
          */
         get normalTexture() {
             return this._shaderValues.getTexture(PBRStandardMaterial.NORMALTEXTURE);
         }
         /**
          * 设置法线贴图。
          * @param value 法线贴图。
          */
         set normalTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE);
             }
             this._shaderValues.setTexture(PBRStandardMaterial.NORMALTEXTURE, value);
         }
         /**
          * 获取法线贴图缩放系数。
          * @return 法线贴图缩放系数。
          */
         get normalTextureScale() {
             return this._BumpScale;
         }
         /**
          * 设置法线贴图缩放系数。
          * @param value 法线贴图缩放系数。
          */
         set normalTextureScale(value) {
             this._BumpScale = value;
         }
         /**
          * 获取视差贴图。
          * @return 视察贴图。
          */
         get parallaxTexture() {
             return this._shaderValues.getTexture(PBRStandardMaterial.PARALLAXTEXTURE);
         }
         /**
          * 设置视差贴图。
          * @param value 视察贴图。
          */
         set parallaxTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE);
             }
             this._shaderValues.setTexture(PBRStandardMaterial.PARALLAXTEXTURE, value);
         }
         /**
          * 获取视差贴图缩放系数。
          * @return 视差缩放系数。
          */
         get parallaxTextureScale() {
             return this._Parallax;
         }
         /**
          * 设置视差贴图缩放系数。
          * @param value 视差缩放系数。
          */
         set parallaxTextureScale(value) {
             this._Parallax = Math.max(0.005, Math.min(0.08, value));
         }
         /**
          * 获取遮挡贴图。
          * @return 遮挡贴图。
          */
         get occlusionTexture() {
             return this._shaderValues.getTexture(PBRStandardMaterial.OCCLUSIONTEXTURE);
         }
         /**
          * 设置遮挡贴图。
          * @param value 遮挡贴图。
          */
         set occlusionTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
             }
             this._shaderValues.setTexture(PBRStandardMaterial.OCCLUSIONTEXTURE, value);
         }
         /**
          * 获取遮挡贴图强度。
          * @return 遮挡贴图强度,范围为0到1。
          */
         get occlusionTextureStrength() {
             return this._OcclusionStrength;
         }
         /**
          * 设置遮挡贴图强度。
          * @param value 遮挡贴图强度,范围为0到1。
          */
         set occlusionTextureStrength(value) {
             this._OcclusionStrength = Math.max(0.0, Math.min(1.0, value));
         }
         /**
          * 获取金属光滑度贴图。
          * @return 金属光滑度贴图。
          */
         get metallicGlossTexture() {
             return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE);
         }
         /**
          * 设置金属光滑度贴图。
          * @param value 金属光滑度贴图。
          */
         set metallicGlossTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
             }
             this._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE, value);
         }
         /**
          * 获取金属度。
          * @return 金属度,范围为0到1。
          */
         get metallic() {
             return this._Metallic;
         }
         /**
          * 设置金属度。
          * @param value 金属度,范围为0到1。
          */
         set metallic(value) {
             this._Metallic = Math.max(0.0, Math.min(1.0, value));
         }
         /**
          * 获取光滑度。
          * @return 光滑度,范围为0到1。
          */
         get smoothness() {
             return this._Glossiness;
         }
         /**
          * 设置光滑度。
          * @param value 光滑度,范围为0到1。
          */
         set smoothness(value) {
             this._Glossiness = Math.max(0.0, Math.min(1.0, value));
         }
         /**
          * 获取光滑度缩放系数。
          * @return 光滑度缩放系数,范围为0到1。
          */
         get smoothnessTextureScale() {
             return this._GlossMapScale;
         }
         /**
          * 设置光滑度缩放系数。
          * @param value 光滑度缩放系数,范围为0到1。
          */
         set smoothnessTextureScale(value) {
             this._GlossMapScale = Math.max(0.0, Math.min(1.0, value));
         }
         /**
          * 获取光滑度数据源
          * @return 光滑滑度数据源,0或1。
          */
         get smoothnessSource() {
             return this._shaderValues.getInt(PBRStandardMaterial.SMOOTHNESSSOURCE);
         }
         /**
          * 设置光滑度数据源。
          * @param value 光滑滑度数据源,0或1。
          */
         set smoothnessSource(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
                 this._shaderValues.setInt(PBRStandardMaterial.SMOOTHNESSSOURCE, 1);
             }
             else {
                 this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
                 this._shaderValues.setInt(PBRStandardMaterial.SMOOTHNESSSOURCE, 0);
             }
         }
         /**
          * 获取是否激活放射属性。
          * @return 是否激活放射属性。
          */
         get enableEmission() {
             return this._shaderValues.getBool(PBRStandardMaterial.ENABLEEMISSION);
         }
         /**
          * 设置是否激活放射属性。
          * @param value 是否激活放射属性
          */
         set enableEmission(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_EMISSION);
             }
             else {
                 this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_EMISSION);
             }
             this._shaderValues.setBool(PBRStandardMaterial.ENABLEEMISSION, value);
         }
         /**
          * 获取放射颜色R分量。
          * @return 放射颜色R分量。
          */
         get emissionColorR() {
             return this._EmissionColorR;
         }
         /**
          * 设置放射颜色R分量。
          * @param value 放射颜色R分量。
          */
         set emissionColorR(value) {
             this._EmissionColorR = value;
         }
         /**
          * 获取放射颜色G分量。
          * @return 放射颜色G分量。
          */
         get emissionColorG() {
             return this._EmissionColorG;
         }
         /**
          * 设置放射颜色G分量。
          * @param value 放射颜色G分量。
          */
         set emissionColorG(value) {
             this._EmissionColorG = value;
         }
         /**
          * 获取放射颜色B分量。
          * @return 放射颜色B分量。
          */
         get emissionColorB() {
             return this._EmissionColorB;
         }
         /**
          * 设置放射颜色B分量。
          * @param value 放射颜色B分量。
          */
         set emissionColorB(value) {
             this._EmissionColorB = value;
         }
         /**
          * 获取放射颜色A分量。
          * @return 放射颜色A分量。
          */
         get emissionColorA() {
             return this._EmissionColorA;
         }
         /**
          * 设置放射颜色A分量。
          * @param value 放射颜色A分量。
          */
         set emissionColorA(value) {
             this._EmissionColorA = value;
         }
         /**
          * 获取放射颜色。
          * @return 放射颜色。
          */
         get emissionColor() {
             return this._shaderValues.getVector(PBRStandardMaterial.EMISSIONCOLOR);
         }
         /**
          * 设置放射颜色。
          * @param value 放射颜色。
          */
         set emissionColor(value) {
             this._shaderValues.setVector(PBRStandardMaterial.EMISSIONCOLOR, value);
         }
         /**
          * 获取放射贴图。
          * @return 放射贴图。
          */
         get emissionTexture() {
             return this._shaderValues.getTexture(PBRStandardMaterial.EMISSIONTEXTURE);
         }
         /**
          * 设置放射贴图。
          * @param value 放射贴图。
          */
         set emissionTexture(value) {
             if (value) {
                 this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE);
             }
             else {
                 this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE);
             }
             this._shaderValues.setTexture(PBRStandardMaterial.EMISSIONTEXTURE, value);
         }
         /**
          * 获取是否开启反射。
          * @return 是否开启反射。
          */
         get enableReflection() {
             return this._shaderValues.getBool(PBRStandardMaterial.ENABLEREFLECT);
         }
         /**
          * 设置是否开启反射。
          * @param value 是否开启反射。
          */
         set enableReflection(value) {
             this._shaderValues.setBool(PBRStandardMaterial.ENABLEREFLECT, true);
             if (value) {
                 this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP);
             }
             else {
                 this._disablePublicDefineDatas.add(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP);
             }
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @return 纹理平铺和偏移X分量。
          */
         get tilingOffsetX() {
             return this._MainTex_STX;
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @param x 纹理平铺和偏移X分量。
          */
         set tilingOffsetX(x) {
             this._MainTex_STX = x;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @return 纹理平铺和偏移Y分量。
          */
         get tilingOffsetY() {
             return this._MainTex_STY;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @param y 纹理平铺和偏移Y分量。
          */
         set tilingOffsetY(y) {
             this._MainTex_STY = y;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @return 纹理平铺和偏移Z分量。
          */
         get tilingOffsetZ() {
             return this._MainTex_STZ;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @param z 纹理平铺和偏移Z分量。
          */
         set tilingOffsetZ(z) {
             this._MainTex_STZ = z;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @return 纹理平铺和偏移W分量。
          */
         get tilingOffsetW() {
             return this._MainTex_STW;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @param w 纹理平铺和偏移W分量。
          */
         set tilingOffsetW(w) {
             this._MainTex_STW = w;
         }
         /**
          * 获取纹理平铺和偏移。
          * @return 纹理平铺和偏移。
          */
         get tilingOffset() {
             return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
         }
         /**
          * 获取纹理平铺和偏移。
          * @param value 纹理平铺和偏移。
          */
         set tilingOffset(value) {
             if (value) {
                 if (value.x != 1 || value.y != 1 || value.z != 0 || value.w != 0) {
                     this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
                 }
                 else {
                     this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
                 }
             }
             else {
                 this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             this._shaderValues.setVector(PBRStandardMaterial.TILINGOFFSET, value);
         }
         /**
          * 设置渲染模式。
          * @return 渲染模式。
          */
         set renderMode(value) {
             switch (value) {
                 case PBRStandardMaterial.RENDERMODE_OPAQUE:
                     this.alphaTest = false;
                     this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE;
                     this.depthWrite = true;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_DISABLE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                     break;
                 case PBRStandardMaterial.RENDERMODE_CUTOUT:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_ALPHATEST;
                     this.alphaTest = true;
                     this.depthWrite = true;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_DISABLE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                     break;
                 case PBRStandardMaterial.RENDERMODE_FADE:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                     break;
                     break;
                 case PBRStandardMaterial.RENDERMODE_TRANSPARENT:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_ONE;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                     break;
                 default:
                     throw new Error("PBRSpecularMaterial : renderMode value error.");
             }
         }
         /**
          * 设置是否写入深度。
          * @param value 是否写入深度。
          */
         set depthWrite(value) {
             this._shaderValues.setBool(PBRStandardMaterial.DEPTH_WRITE, value);
         }
         /**
          * 获取是否写入深度。
          * @return 是否写入深度。
          */
         get depthWrite() {
             return this._shaderValues.getBool(PBRStandardMaterial.DEPTH_WRITE);
         }
         /**
          * 设置剔除方式。
          * @param value 剔除方式。
          */
         set cull(value) {
             this._shaderValues.setInt(PBRStandardMaterial.CULL, value);
         }
         /**
          * 获取剔除方式。
          * @return 剔除方式。
          */
         get cull() {
             return this._shaderValues.getInt(PBRStandardMaterial.CULL);
         }
         /**
          * 设置混合方式。
          * @param value 混合方式。
          */
         set blend(value) {
             this._shaderValues.setInt(PBRStandardMaterial.BLEND, value);
         }
         /**
          * 获取混合方式。
          * @return 混合方式。
          */
         get blend() {
             return this._shaderValues.getInt(PBRStandardMaterial.BLEND);
         }
         /**
          * 设置混合源。
          * @param value 混合源
          */
         set blendSrc(value) {
             this._shaderValues.setInt(PBRStandardMaterial.BLEND_SRC, value);
         }
         /**
          * 获取混合源。
          * @return 混合源。
          */
         get blendSrc() {
             return this._shaderValues.getInt(PBRStandardMaterial.BLEND_SRC);
         }
         /**
          * 设置混合目标。
          * @param value 混合目标
          */
         set blendDst(value) {
             this._shaderValues.setInt(PBRStandardMaterial.BLEND_DST, value);
         }
         /**
          * 获取混合目标。
          * @return 混合目标。
          */
         get blendDst() {
             return this._shaderValues.getInt(PBRStandardMaterial.BLEND_DST);
         }
         /**
          * 设置深度测试方式。
          * @param value 深度测试方式
          */
         set depthTest(value) {
             this._shaderValues.setInt(PBRStandardMaterial.DEPTH_TEST, value);
         }
         /**
          * 获取深度测试方式。
          * @return 深度测试方式。
          */
         get depthTest() {
             return this._shaderValues.getInt(PBRStandardMaterial.DEPTH_TEST);
         }
         /**
      * 克隆。
      * @return	 克隆副本。
      */
         clone() {
             var dest = new PBRStandardMaterial();
             this.cloneTo(dest);
             return dest;
         }
         /**
          * @inheritDoc
          */
         /*override*/ cloneTo(destObject) {
             super.cloneTo(destObject);
             var destMaterial = destObject;
             this._albedoColor.cloneTo(destMaterial._albedoColor);
             this._emissionColor.cloneTo(destMaterial._emissionColor);
         }
     }
     /**光滑度数据源_金属度贴图的Alpha通道。*/
     PBRStandardMaterial.SmoothnessSource_MetallicGlossTexture_Alpha = 0;
     /**光滑度数据源_反射率贴图的Alpha通道。*/
     PBRStandardMaterial.SmoothnessSource_AlbedoTexture_Alpha = 1;
     /**渲染状态_不透明。*/
     PBRStandardMaterial.RENDERMODE_OPAQUE = 0;
     /**渲染状态_透明测试。*/
     PBRStandardMaterial.RENDERMODE_CUTOUT = 1;
     /**渲染状态_透明混合_游戏中经常使用的透明。*/
     PBRStandardMaterial.RENDERMODE_FADE = 2;
     /**渲染状态_透明混合_物理上看似合理的透明。*/
     PBRStandardMaterial.RENDERMODE_TRANSPARENT = 3;
     PBRStandardMaterial.ALBEDOTEXTURE = Shader3D.propertyNameToID("u_AlbedoTexture");
     PBRStandardMaterial.METALLICGLOSSTEXTURE = Shader3D.propertyNameToID("u_MetallicGlossTexture");
     PBRStandardMaterial.NORMALTEXTURE = Shader3D.propertyNameToID("u_NormalTexture");
     PBRStandardMaterial.PARALLAXTEXTURE = Shader3D.propertyNameToID("u_ParallaxTexture");
     PBRStandardMaterial.OCCLUSIONTEXTURE = Shader3D.propertyNameToID("u_OcclusionTexture");
     PBRStandardMaterial.EMISSIONTEXTURE = Shader3D.propertyNameToID("u_EmissionTexture");
     PBRStandardMaterial.ALBEDOCOLOR = Shader3D.propertyNameToID("u_AlbedoColor");
     PBRStandardMaterial.EMISSIONCOLOR = Shader3D.propertyNameToID("u_EmissionColor");
     PBRStandardMaterial.METALLIC = Shader3D.propertyNameToID("u_metallic");
     PBRStandardMaterial.SMOOTHNESS = Shader3D.propertyNameToID("u_smoothness");
     PBRStandardMaterial.SMOOTHNESSSCALE = Shader3D.propertyNameToID("u_smoothnessScale");
     PBRStandardMaterial.SMOOTHNESSSOURCE = -1; //TODO:
     PBRStandardMaterial.OCCLUSIONSTRENGTH = Shader3D.propertyNameToID("u_occlusionStrength");
     PBRStandardMaterial.NORMALSCALE = Shader3D.propertyNameToID("u_normalScale");
     PBRStandardMaterial.PARALLAXSCALE = Shader3D.propertyNameToID("u_parallaxScale");
     PBRStandardMaterial.ENABLEEMISSION = -1; //TODO:
     PBRStandardMaterial.ENABLEREFLECT = -1; //TODO:
     PBRStandardMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset");
     PBRStandardMaterial.CULL = Shader3D.propertyNameToID("s_Cull");
     PBRStandardMaterial.BLEND = Shader3D.propertyNameToID("s_Blend");
     PBRStandardMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
     PBRStandardMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
     PBRStandardMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
     PBRStandardMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
     /**@private */
     PBRStandardMaterial.shaderDefines = null;

     /**
      * <code>SkyProceduralMaterial</code> 类用于实现SkyProceduralMaterial材质。
      */
     class SkyProceduralMaterial extends BaseMaterial {
         /**
          * 创建一个 <code>SkyProceduralMaterial</code> 实例。
          */
         constructor() {
             super();
             this.setShaderName("SkyBoxProcedural");
             this.sunDisk = SkyProceduralMaterial.SUN_HIGH_QUALITY;
             this.sunSize = 0.04;
             this.sunSizeConvergence = 5;
             this.atmosphereThickness = 1.0;
             this.skyTint = new Vector4(0.5, 0.5, 0.5, 1.0);
             this.groundTint = new Vector4(0.369, 0.349, 0.341, 1.0);
             this.exposure = 1.3;
         }
         /**
          * @private
          */
         static __initDefine__() {
             SkyProceduralMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = SkyProceduralMaterial.shaderDefines.registerDefine("SUN_HIGH_QUALITY");
             SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = SkyProceduralMaterial.shaderDefines.registerDefine("SUN_SIMPLE");
         }
         /**
          * 获取太阳状态。
          * @return  太阳状态。
          */
         get sunDisk() {
             return this._sunDisk;
         }
         /**
          * 设置太阳状态。
          * @param value 太阳状态。
          */
         set sunDisk(value) {
             switch (value) {
                 case SkyProceduralMaterial.SUN_HIGH_QUALITY:
                     this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                     this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                     break;
                 case SkyProceduralMaterial.SUN_SIMPLE:
                     this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                     this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                     break;
                 case SkyProceduralMaterial.SUN_NODE:
                     this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                     this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                     break;
                 default:
                     throw "SkyBoxProceduralMaterial: unknown sun value.";
             }
             this._sunDisk = value;
         }
         /**
          * 获取太阳尺寸,范围是0到1。
          * @return  太阳尺寸。
          */
         get sunSize() {
             return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE);
         }
         /**
          * 设置太阳尺寸,范围是0到1。
          * @param value 太阳尺寸。
          */
         set sunSize(value) {
             value = Math.min(Math.max(0.0, value), 1.0);
             this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZE, value);
         }
         /**
          * 获取太阳尺寸收缩,范围是0到20。
          * @return  太阳尺寸收缩。
          */
         get sunSizeConvergence() {
             return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE);
         }
         /**
          * 设置太阳尺寸收缩,范围是0到20。
          * @param value 太阳尺寸收缩。
          */
         set sunSizeConvergence(value) {
             value = Math.min(Math.max(0.0, value), 20.0);
             this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE, value);
         }
         /**
          * 获取大气厚度,范围是0到5。
          * @return  大气厚度。
          */
         get atmosphereThickness() {
             return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS);
         }
         /**
          * 设置大气厚度,范围是0到5。
          * @param value 大气厚度。
          */
         set atmosphereThickness(value) {
             value = Math.min(Math.max(0.0, value), 5.0);
             this._shaderValues.setNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS, value);
         }
         /**
          * 获取天空颜色。
          * @return  天空颜色。
          */
         get skyTint() {
             return this._shaderValues.getVector(SkyProceduralMaterial.SKYTINT);
         }
         /**
          * 设置天空颜色。
          * @param value 天空颜色。
          */
         set skyTint(value) {
             this._shaderValues.setVector(SkyProceduralMaterial.SKYTINT, value);
         }
         /**
          * 获取地面颜色。
          * @return  地面颜色。
          */
         get groundTint() {
             return this._shaderValues.getVector(SkyProceduralMaterial.GROUNDTINT);
         }
         /**
          * 设置地面颜色。
          * @param value 地面颜色。
          */
         set groundTint(value) {
             this._shaderValues.setVector(SkyProceduralMaterial.GROUNDTINT, value);
         }
         /**
          * 获取曝光强度,范围是0到8。
          * @return 曝光强度。
          */
         get exposure() {
             return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE);
         }
         /**
          * 设置曝光强度,范围是0到8。
          * @param value 曝光强度。
          */
         set exposure(value) {
             value = Math.min(Math.max(0.0, value), 8.0);
             this._shaderValues.setNumber(SkyProceduralMaterial.EXPOSURE, value);
         }
         /**
      * 克隆。
      * @return	 克隆副本。
      */
         clone() {
             var dest = new SkyProceduralMaterial();
             this.cloneTo(dest);
             return dest;
         }
     }
     /** 太阳_无*/
     SkyProceduralMaterial.SUN_NODE = 0;
     /** 太阳_精简*/
     SkyProceduralMaterial.SUN_SIMPLE = 1;
     /** 太阳_高质量*/
     SkyProceduralMaterial.SUN_HIGH_QUALITY = 2;
     /**@private */
     SkyProceduralMaterial.SUNSIZE = Shader3D.propertyNameToID("u_SunSize");
     /**@private */
     SkyProceduralMaterial.SUNSIZECONVERGENCE = Shader3D.propertyNameToID("u_SunSizeConvergence");
     /**@private */
     SkyProceduralMaterial.ATMOSPHERETHICKNESS = Shader3D.propertyNameToID("u_AtmosphereThickness");
     /**@private */
     SkyProceduralMaterial.SKYTINT = Shader3D.propertyNameToID("u_SkyTint");
     /**@private */
     SkyProceduralMaterial.GROUNDTINT = Shader3D.propertyNameToID("u_GroundTint");
     /**@private */
     SkyProceduralMaterial.EXPOSURE = Shader3D.propertyNameToID("u_Exposure");
     /**@private */
     SkyProceduralMaterial.shaderDefines = null;

     /**
      * <code>UnlitMaterial</code> 类用于实现不受光照影响的材质。
      */
     class UnlitMaterial extends BaseMaterial {
         constructor() {
             super();
             /**@private */
             this._albedoColor = new Vector4(1.0, 1.0, 1.0, 1.0);
             /**@private */
             this._albedoIntensity = 1.0;
             /**@private */
             this._enableVertexColor = false;
             this.setShaderName("Unlit");
             this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, new Vector4(1.0, 1.0, 1.0, 1.0));
             this.renderMode = UnlitMaterial.RENDERMODE_OPAQUE;
         }
         /**
          * @private
          */
         static __initDefine__() {
             UnlitMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = UnlitMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE");
             UnlitMaterial.SHADERDEFINE_TILINGOFFSET = UnlitMaterial.shaderDefines.registerDefine("TILINGOFFSET");
             UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = UnlitMaterial.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
         }
         /**
          * @private
          */
         get _ColorR() {
             return this._albedoColor.x;
         }
         /**
          * @private
          */
         set _ColorR(value) {
             this._albedoColor.x = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorG() {
             return this._albedoColor.y;
         }
         /**
          * @private
          */
         set _ColorG(value) {
             this._albedoColor.y = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _ColorB() {
             return this._albedoColor.z;
         }
         /**
          * @private
          */
         set _ColorB(value) {
             this._albedoColor.z = value;
             this.albedoColor = this._albedoColor;
         }
         /**@private */
         get _ColorA() {
             return this._albedoColor.w;
         }
         /**
          * @private
          */
         set _ColorA(value) {
             this._albedoColor.w = value;
             this.albedoColor = this._albedoColor;
         }
         /**
          * @private
          */
         get _AlbedoIntensity() {
             return this._albedoIntensity;
         }
         /**
          * @private
          */
         set _AlbedoIntensity(value) {
             if (this._albedoIntensity !== value) {
                 var finalAlbedo = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                 Vector4.scale(this._albedoColor, value, finalAlbedo);
                 this._albedoIntensity = value;
                 this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, finalAlbedo);
             }
         }
         /**
          * @private
          */
         get _MainTex_STX() {
             return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).x;
         }
         /**
          * @private
          */
         set _MainTex_STX(x) {
             var tilOff = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
             tilOff.x = x;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STY() {
             return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).y;
         }
         /**
          * @private
          */
         set _MainTex_STY(y) {
             var tilOff = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
             tilOff.y = y;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STZ() {
             return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).z;
         }
         /**
          * @private
          */
         set _MainTex_STZ(z) {
             var tilOff = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
             tilOff.z = z;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STW() {
             return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).w;
         }
         /**
          * @private
          */
         set _MainTex_STW(w) {
             var tilOff = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
             tilOff.w = w;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _Cutoff() {
             return this.alphaTestValue;
         }
         /**
          * @private
          */
         set _Cutoff(value) {
             this.alphaTestValue = value;
         }
         /**
          * 获取反照率颜色R分量。
          * @return 反照率颜色R分量。
          */
         get albedoColorR() {
             return this._ColorR;
         }
         /**
          * 设置反照率颜色R分量。
          * @param value 反照率颜色R分量。
          */
         set albedoColorR(value) {
             this._ColorR = value;
         }
         /**
          * 获取反照率颜色G分量。
          * @return 反照率颜色G分量。
          */
         get albedoColorG() {
             return this._ColorG;
         }
         /**
          * 设置反照率颜色G分量。
          * @param value 反照率颜色G分量。
          */
         set albedoColorG(value) {
             this._ColorG = value;
         }
         /**
          * 获取反照率颜色B分量。
          * @return 反照率颜色B分量。
          */
         get albedoColorB() {
             return this._ColorB;
         }
         /**
          * 设置反照率颜色B分量。
          * @param value 反照率颜色B分量。
          */
         set albedoColorB(value) {
             this._ColorB = value;
         }
         /**
          * 获取反照率颜色Z分量。
          * @return 反照率颜色Z分量。
          */
         get albedoColorA() {
             return this._ColorA;
         }
         /**
          * 设置反照率颜色alpha分量。
          * @param value 反照率颜色alpha分量。
          */
         set albedoColorA(value) {
             this._ColorA = value;
         }
         /**
          * 获取反照率颜色。
          * @return 反照率颜色。
          */
         get albedoColor() {
             return this._albedoColor;
         }
         /**
          * 设置反照率颜色。
          * @param value 反照率颜色。
          */
         set albedoColor(value) {
             var finalAlbedo = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
             Vector4.scale(value, this._albedoIntensity, finalAlbedo);
             this._albedoColor = value;
             this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, finalAlbedo);
         }
         /**
          * 获取反照率强度。
          * @return 反照率强度。
          */
         get albedoIntensity() {
             return this._albedoIntensity;
         }
         /**
          * 设置反照率强度。
          * @param value 反照率强度。
          */
         set albedoIntensity(value) {
             this._AlbedoIntensity = value;
         }
         /**
          * 获取反照率贴图。
          * @return 反照率贴图。
          */
         get albedoTexture() {
             return this._shaderValues.getTexture(UnlitMaterial.ALBEDOTEXTURE);
         }
         /**
          * 设置反照率贴图。
          * @param value 反照率贴图。
          */
         set albedoTexture(value) {
             if (value)
                 this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
             else
                 this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
             this._shaderValues.setTexture(UnlitMaterial.ALBEDOTEXTURE, value);
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @return 纹理平铺和偏移X分量。
          */
         get tilingOffsetX() {
             return this._MainTex_STX;
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @param x 纹理平铺和偏移X分量。
          */
         set tilingOffsetX(x) {
             this._MainTex_STX = x;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @return 纹理平铺和偏移Y分量。
          */
         get tilingOffsetY() {
             return this._MainTex_STY;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @param y 纹理平铺和偏移Y分量。
          */
         set tilingOffsetY(y) {
             this._MainTex_STY = y;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @return 纹理平铺和偏移Z分量。
          */
         get tilingOffsetZ() {
             return this._MainTex_STZ;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @param z 纹理平铺和偏移Z分量。
          */
         set tilingOffsetZ(z) {
             this._MainTex_STZ = z;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @return 纹理平铺和偏移W分量。
          */
         get tilingOffsetW() {
             return this._MainTex_STW;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @param w 纹理平铺和偏移W分量。
          */
         set tilingOffsetW(w) {
             this._MainTex_STW = w;
         }
         /**
          * 获取纹理平铺和偏移。
          * @return 纹理平铺和偏移。
          */
         get tilingOffset() {
             return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
         }
         /**
          * 获取纹理平铺和偏移。
          * @param value 纹理平铺和偏移。
          */
         set tilingOffset(value) {
             if (value) {
                 if (value.x != 1 || value.y != 1 || value.z != 0 || value.w != 0)
                     this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET);
                 else
                     this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             else {
                 this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             this._shaderValues.setVector(UnlitMaterial.TILINGOFFSET, value);
         }
         /**
          * 获取是否支持顶点色。
          * @return  是否支持顶点色。
          */
         get enableVertexColor() {
             return this._enableVertexColor;
         }
         /**
          * 设置是否支持顶点色。
          * @param value  是否支持顶点色。
          */
         set enableVertexColor(value) {
             this._enableVertexColor = value;
             if (value)
                 this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
             else
                 this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
         }
         /**
          * 设置渲染模式。
          * @return 渲染模式。
          */
         set renderMode(value) {
             switch (value) {
                 case UnlitMaterial.RENDERMODE_OPAQUE:
                     this.alphaTest = false;
                     this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE;
                     this.depthWrite = true;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_DISABLE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     break;
                 case UnlitMaterial.RENDERMODE_CUTOUT:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_ALPHATEST;
                     this.alphaTest = true;
                     this.depthWrite = true;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_DISABLE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     break;
                 case UnlitMaterial.RENDERMODE_TRANSPARENT:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_BACK;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     break;
                 default:
                     throw new Error("UnlitMaterial : renderMode value error.");
             }
         }
         /**
          * 设置是否写入深度。
          * @param value 是否写入深度。
          */
         set depthWrite(value) {
             this._shaderValues.setBool(UnlitMaterial.DEPTH_WRITE, value);
         }
         /**
          * 获取是否写入深度。
          * @return 是否写入深度。
          */
         get depthWrite() {
             return this._shaderValues.getBool(UnlitMaterial.DEPTH_WRITE);
         }
         /**
          * 设置剔除方式。
          * @param value 剔除方式。
          */
         set cull(value) {
             this._shaderValues.setInt(UnlitMaterial.CULL, value);
         }
         /**
          * 获取剔除方式。
          * @return 剔除方式。
          */
         get cull() {
             return this._shaderValues.getInt(UnlitMaterial.CULL);
         }
         /**
          * 设置混合方式。
          * @param value 混合方式。
          */
         set blend(value) {
             this._shaderValues.setInt(UnlitMaterial.BLEND, value);
         }
         /**
          * 获取混合方式。
          * @return 混合方式。
          */
         get blend() {
             return this._shaderValues.getInt(UnlitMaterial.BLEND);
         }
         /**
          * 设置混合源。
          * @param value 混合源
          */
         set blendSrc(value) {
             this._shaderValues.setInt(UnlitMaterial.BLEND_SRC, value);
         }
         /**
          * 获取混合源。
          * @return 混合源。
          */
         get blendSrc() {
             return this._shaderValues.getInt(UnlitMaterial.BLEND_SRC);
         }
         /**
          * 设置混合目标。
          * @param value 混合目标
          */
         set blendDst(value) {
             this._shaderValues.setInt(UnlitMaterial.BLEND_DST, value);
         }
         /**
          * 获取混合目标。
          * @return 混合目标。
          */
         get blendDst() {
             return this._shaderValues.getInt(UnlitMaterial.BLEND_DST);
         }
         /**
          * 设置深度测试方式。
          * @param value 深度测试方式
          */
         set depthTest(value) {
             this._shaderValues.setInt(UnlitMaterial.DEPTH_TEST, value);
         }
         /**
          * 获取深度测试方式。
          * @return 深度测试方式。
          */
         get depthTest() {
             return this._shaderValues.getInt(UnlitMaterial.DEPTH_TEST);
         }
         /**
      * 克隆。
      * @return	 克隆副本。
      */
         clone() {
             var dest = new UnlitMaterial();
             this.cloneTo(dest);
             return dest;
         }
     }
     /**渲染状态_不透明。*/
     UnlitMaterial.RENDERMODE_OPAQUE = 0;
     /**渲染状态_阿尔法测试。*/
     UnlitMaterial.RENDERMODE_CUTOUT = 1;
     /**渲染状态__透明混合。*/
     UnlitMaterial.RENDERMODE_TRANSPARENT = 2;
     /**渲染状态__加色法混合。*/
     UnlitMaterial.RENDERMODE_ADDTIVE = 3;
     UnlitMaterial.ALBEDOTEXTURE = Shader3D.propertyNameToID("u_AlbedoTexture");
     UnlitMaterial.ALBEDOCOLOR = Shader3D.propertyNameToID("u_AlbedoColor");
     UnlitMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset");
     UnlitMaterial.CULL = Shader3D.propertyNameToID("s_Cull");
     UnlitMaterial.BLEND = Shader3D.propertyNameToID("s_Blend");
     UnlitMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
     UnlitMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
     UnlitMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
     UnlitMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
     /**@private */
     UnlitMaterial.shaderDefines = null;

     /**
      * <code>WaterPrimaryMaterial</code> 类用于实现水材质。
      */
     class WaterPrimaryMaterial extends BaseMaterial {
         constructor() {
             super();
             this.setShaderName("WaterPrimary");
             this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, new Vector4(0.172, 0.463, 0.435, 0));
             this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, 0.15);
             this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, new Vector4(19, 9, -16, -7));
         }
         /**
          * @private
          */
         static __initDefine__() {
             WaterPrimaryMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE = WaterPrimaryMaterial.shaderDefines.registerDefine("MAINTEXTURE");
             WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE = WaterPrimaryMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
         }
         /**
          * 获取地平线颜色。
          * @return 地平线颜色。
          */
         get horizonColor() {
             return this._shaderValues.getVector(WaterPrimaryMaterial.HORIZONCOLOR);
         }
         /**
          * 设置地平线颜色。
          * @param value 地平线颜色。
          */
         set horizonColor(value) {
             this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, value);
         }
         /**
          * 获取主贴图。
          * @return 主贴图。
          */
         get mainTexture() {
             return this._shaderValues.getTexture(WaterPrimaryMaterial.MAINTEXTURE);
         }
         /**
          * 设置主贴图。
          * @param value 主贴图。
          */
         set mainTexture(value) {
             if (value)
                 this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE);
             else
                 this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE);
             this._shaderValues.setTexture(WaterPrimaryMaterial.MAINTEXTURE, value);
         }
         /**
          * 获取法线贴图。
          * @return 法线贴图。
          */
         get normalTexture() {
             return this._shaderValues.getTexture(WaterPrimaryMaterial.NORMALTEXTURE);
         }
         /**
          * 设置法线贴图。
          * @param value 法线贴图。
          */
         set normalTexture(value) {
             if (value)
                 this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE);
             else
                 this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE);
             this._shaderValues.setTexture(WaterPrimaryMaterial.NORMALTEXTURE, value);
         }
         /**
          * 获取波动缩放系数。
          * @return 波动缩放系数。
          */
         get waveScale() {
             return this._shaderValues.getNumber(WaterPrimaryMaterial.WAVESCALE);
         }
         /**
          * 设置波动缩放系数。
          * @param value 波动缩放系数。
          */
         set waveScale(value) {
             this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, value);
         }
         /**
          * 获取波动速率。
          * @return 波动速率。
          */
         get waveSpeed() {
             return this._shaderValues.getVector(WaterPrimaryMaterial.WAVESPEED);
         }
         /**
          * 设置波动速率。
          * @param value 波动速率。
          */
         set waveSpeed(value) {
             this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, value);
         }
         /**
      * 克隆。
      * @return	 克隆副本。
      */
         clone() {
             var dest = new WaterPrimaryMaterial();
             this.cloneTo(dest);
             return dest;
         }
     }
     WaterPrimaryMaterial.HORIZONCOLOR = Shader3D.propertyNameToID("u_HorizonColor");
     WaterPrimaryMaterial.MAINTEXTURE = Shader3D.propertyNameToID("u_MainTexture");
     WaterPrimaryMaterial.NORMALTEXTURE = Shader3D.propertyNameToID("u_NormalTexture");
     WaterPrimaryMaterial.WAVESCALE = Shader3D.propertyNameToID("u_WaveScale");
     WaterPrimaryMaterial.WAVESPEED = Shader3D.propertyNameToID("u_WaveSpeed");
     /**@private */
     WaterPrimaryMaterial.shaderDefines = null;

     /**
          * ...
          * @author ...
          */
     class GradientMode {
     }
     /**
      * 找到与请求的评估时间相邻的两个键,并线性插值在他们之间,以获得一种混合的颜色。
      */
     GradientMode.Blend = 0;
     /**
      * 返回一个固定的颜色，通过查找第一个键的时间值大于所请求的评估时间。
      */
     GradientMode.Fixed = 1;

     /**
      * <code>Gradient</code> 类用于创建颜色渐变。
      */
     class Gradient {
         /**
          * 创建一个 <code>Gradient</code> 实例。
          * @param maxColorRGBKeyCount 最大RGB帧个数。
          * @param maxColorAlphaKeyCount 最大Alpha帧个数。
          */
         constructor(maxColorRGBKeyCount, maxColorAlphaKeyCount) {
             /**@private */
             this._mode = 0;
             /**@private */
             this._maxColorRGBKeysCount = 0;
             /**@private */
             this._maxColorAlphaKeysCount = 0;
             /**@private */
             this._colorRGBKeysCount = 0;
             /**@private */
             this._colorAlphaKeysCount = 0;
             /**@private */
             this._alphaElements = null;
             /**@private */
             this._rgbElements = null;
             this._maxColorRGBKeysCount = maxColorRGBKeyCount;
             this._maxColorAlphaKeysCount = maxColorAlphaKeyCount;
             this._rgbElements = new Float32Array(maxColorRGBKeyCount * 4);
             this._alphaElements = new Float32Array(maxColorAlphaKeyCount * 2);
         }
         /**
          * 获取梯度模式。
          * @return  梯度模式。
          */
         get mode() {
             return this._mode;
         }
         /**
          * 设置梯度模式。
          * @param value 梯度模式。
          */
         set mode(value) {
             this._mode = value;
         }
         /**
          * 获取颜色RGB数量。
          * @return 颜色RGB数量。
          */
         get colorRGBKeysCount() {
             return this._colorRGBKeysCount;
         }
         /**
          * 获取颜色Alpha数量。
          * @return 颜色Alpha数量。
          */
         get colorAlphaKeysCount() {
             return this._colorAlphaKeysCount;
         }
         /**
          * 获取最大颜色RGB帧数量。
          * @return 最大RGB帧数量。
          */
         get maxColorRGBKeysCount() {
             return this._maxColorRGBKeysCount;
         }
         /**
          * 获取最大颜色Alpha帧数量。
          * @return 最大Alpha帧数量。
          */
         get maxColorAlphaKeysCount() {
             return this._maxColorAlphaKeysCount;
         }
         /**
          * 增加颜色RGB帧。
          * @param	key 生命周期，范围为0到1。
          * @param	value RGB值。
          */
         addColorRGB(key, value) {
             if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                 var offset = this._colorRGBKeysCount * 4;
                 this._rgbElements[offset] = key;
                 this._rgbElements[offset + 1] = value.r;
                 this._rgbElements[offset + 2] = value.g;
                 this._rgbElements[offset + 3] = value.b;
                 this._colorRGBKeysCount++;
             }
             else {
                 console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
             }
         }
         /**
          * 增加颜色Alpha帧。
          * @param	key 生命周期，范围为0到1。
          * @param	value Alpha值。
          */
         addColorAlpha(key, value) {
             if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                 var offset = this._colorAlphaKeysCount * 2;
                 this._alphaElements[offset] = key;
                 this._alphaElements[offset + 1] = value;
                 this._colorAlphaKeysCount++;
             }
             else {
                 console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
             }
         }
         /**
          * 更新颜色RGB帧。
          * @param   index 索引。
          * @param	key 生命周期，范围为0到1。
          * @param	value RGB值。
          */
         updateColorRGB(index, key, value) {
             if (index < this._colorRGBKeysCount) {
                 var offset = index * 4;
                 this._rgbElements[offset] = key;
                 this._rgbElements[offset + 1] = value.r;
                 this._rgbElements[offset + 2] = value.g;
                 this._rgbElements[offset + 3] = value.b;
             }
             else {
                 console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
             }
         }
         /**
          * 更新颜色Alpha帧。
          * @param   index 索引。
          * @param	key 生命周期，范围为0到1。
          * @param	value Alpha值。
          */
         updateColorAlpha(index, key, value) {
             if (index < this._colorAlphaKeysCount) {
                 var offset = index * 2;
                 this._alphaElements[offset] = key;
                 this._alphaElements[offset + 1] = value;
             }
             else {
                 console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
             }
         }
         /**
          * 通过插值获取RGB颜色。
          * @param  lerpFactor 插值因子。
          * @param  out 颜色结果。
          * @param  开始查找索引。
          * @return 结果索引。
          */
         evaluateColorRGB(lerpFactor, out, startSearchIndex = 0, reverseSearch = false) {
             lerpFactor = Math.min(Math.max(lerpFactor, 0.0), 1.0);
             var rgbElements = this._rgbElements;
             var curIndex = startSearchIndex;
             if (reverseSearch) {
                 for (var i = curIndex; i >= 0; i--) {
                     var offset = i * 4;
                     var left = rgbElements[offset];
                     if (lerpFactor === left) {
                         out.r = rgbElements[offset + 1];
                         out.g = rgbElements[offset + 2];
                         out.b = rgbElements[offset + 3];
                         return curIndex;
                     }
                     switch (this._mode) {
                         case GradientMode.Blend:
                             if (lerpFactor > left) {
                                 var right = rgbElements[offset + 4];
                                 if (lerpFactor > right)
                                     throw "Gradient:wrong startSearchIndex.";
                                 var diff = right - left;
                                 var y1 = right - lerpFactor;
                                 var y2 = lerpFactor - left;
                                 out.r = (y1 * rgbElements[offset + 1] + y2 * rgbElements[offset + 5]) / diff;
                                 out.g = (y1 * rgbElements[offset + 2] + y2 * rgbElements[offset + 6]) / diff;
                                 out.b = (y1 * rgbElements[offset + 3] + y2 * rgbElements[offset + 7]) / diff;
                                 return curIndex;
                             }
                             else {
                                 curIndex--;
                                 continue;
                             }
                         case GradientMode.Fixed:
                             if (lerpFactor > left) {
                                 if (lerpFactor > rgbElements[offset + 4])
                                     throw "Gradient:wrong startSearchIndex.";
                                 out.r = rgbElements[offset + 5];
                                 out.g = rgbElements[offset + 6];
                                 out.b = rgbElements[offset + 7];
                                 return curIndex;
                             }
                             else {
                                 curIndex--;
                                 continue;
                             }
                         default:
                             throw "Gradient:unknown mode.";
                     }
                 }
             }
             else {
                 for (var i = 0, n = this._rgbElements.length; i < n; i++) {
                     offset = i * 4;
                     var right = rgbElements[offset];
                     if (lerpFactor === right) {
                         out.r = rgbElements[offset + 1];
                         out.g = rgbElements[offset + 2];
                         out.b = rgbElements[offset + 3];
                         return curIndex;
                     }
                     switch (this._mode) {
                         case GradientMode.Blend:
                             if (lerpFactor < right) {
                                 var left = rgbElements[offset - 4];
                                 if (lerpFactor < left)
                                     throw "Gradient:wrong startSearchIndex.";
                                 var diff = right - left;
                                 var y1 = right - lerpFactor;
                                 var y2 = lerpFactor - left;
                                 out.r = (y1 * rgbElements[offset - 3] + y2 * rgbElements[offset + 1]) / diff;
                                 out.g = (y1 * rgbElements[offset - 2] + y2 * rgbElements[offset + 2]) / diff;
                                 out.b = (y1 * rgbElements[offset - 1] + y2 * rgbElements[offset + 3]) / diff;
                                 return curIndex;
                             }
                             else {
                                 curIndex++;
                                 continue;
                             }
                         case GradientMode.Fixed:
                             if (lerpFactor < right) {
                                 if (lerpFactor < rgbElements[offset - 4])
                                     throw "Gradient:wrong startSearchIndex.";
                                 out.r = rgbElements[offset + 1];
                                 out.g = rgbElements[offset + 2];
                                 out.b = rgbElements[offset + 3];
                                 return curIndex;
                             }
                             else {
                                 curIndex++;
                                 continue;
                             }
                         default:
                             throw "Gradient:unknown mode.";
                     }
                 }
             }
             return curIndex;
         }
         /**
          * 通过插值获取透明值。
          * @param  lerpFactor 插值因子。
          * @param  out 颜色结果。
          * @param  开始查找索引。
          * @return 结果索引 。
          */
         evaluateColorAlpha(lerpFactor, outColor, startSearchIndex = 0, reverseSearch = false) {
             lerpFactor = Math.min(Math.max(lerpFactor, 0.0), 1.0);
             var alphaElements = this._alphaElements;
             var curIndex = startSearchIndex;
             if (reverseSearch) {
                 for (var i = curIndex; i >= 0; i--) {
                     var offset = i * 2;
                     var left = alphaElements[offset];
                     if (lerpFactor === left) {
                         outColor.a = alphaElements[offset + 1];
                         return curIndex;
                     }
                     switch (this._mode) {
                         case GradientMode.Blend:
                             if (lerpFactor > left) {
                                 var right = alphaElements[offset + 2];
                                 if (lerpFactor > right)
                                     throw "Gradient:wrong startSearchIndex.";
                                 var diff = right - left;
                                 var x1 = right - lerpFactor;
                                 var x2 = lerpFactor - left;
                                 outColor.a = (x1 * alphaElements[offset + 1] + x2 * alphaElements[offset + 3]) / diff;
                                 return curIndex;
                             }
                             else {
                                 curIndex--;
                                 continue;
                             }
                         case GradientMode.Fixed:
                             if (lerpFactor > left) {
                                 if (lerpFactor > alphaElements[offset + 2])
                                     throw "Gradient:wrong startSearchIndex.";
                                 outColor.a = alphaElements[offset + 3];
                                 return curIndex;
                             }
                             else {
                                 curIndex--;
                                 continue;
                             }
                         default:
                             throw "Gradient:unknown mode.";
                     }
                 }
             }
             else {
                 for (var i = curIndex, n = this._alphaElements.length; i < n; i++) {
                     var offset = i * 2;
                     var right = alphaElements[offset];
                     if (lerpFactor === right) {
                         outColor.a = alphaElements[offset + 1];
                         return curIndex;
                     }
                     switch (this._mode) {
                         case GradientMode.Blend:
                             if (lerpFactor < right) {
                                 var left = alphaElements[offset - 2];
                                 if (lerpFactor < left)
                                     throw "Gradient:wrong startSearchIndex.";
                                 var diff = right - left;
                                 var x1 = right - lerpFactor;
                                 var x2 = lerpFactor - left;
                                 outColor.a = (x1 * alphaElements[offset - 1] + x2 * alphaElements[offset + 1]) / diff;
                                 return curIndex;
                             }
                             else {
                                 curIndex++;
                                 continue;
                             }
                         case GradientMode.Fixed:
                             if (lerpFactor < right) {
                                 if (lerpFactor < alphaElements[offset - 2])
                                     throw "Gradient:wrong startSearchIndex.";
                                 outColor.a = alphaElements[offset + 1];
                                 return curIndex;
                             }
                             else {
                                 curIndex++;
                                 continue;
                             }
                         default:
                             throw "Gradient:unknown mode.";
                     }
                 }
             }
             return curIndex;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destGradientDataColor = destObject;
             var i, n;
             destGradientDataColor._colorAlphaKeysCount = this._colorAlphaKeysCount;
             var destAlphaElements = destGradientDataColor._alphaElements;
             for (i = 0, n = this._alphaElements.length; i < n; i++)
                 destAlphaElements[i] = this._alphaElements[i];
             destGradientDataColor._colorRGBKeysCount = this._colorRGBKeysCount;
             var destRGBElements = destGradientDataColor._rgbElements;
             for (i = 0, n = this._rgbElements.length; i < n; i++)
                 destRGBElements[i] = this._rgbElements[i];
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destGradientDataColor = new Gradient(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
             this.cloneTo(destGradientDataColor);
             return destGradientDataColor;
         }
     }

     /**
      * <code>ShurikenParticleMaterial</code> 类用于实现粒子材质。
      */
     class ShurikenParticleMaterial extends BaseMaterial {
         constructor() {
             super();
             this.setShaderName("PARTICLESHURIKEN");
             this._color = new Vector4(1.0, 1.0, 1.0, 1.0);
             this.renderMode = ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED; //默认加色法会自动加上雾化宏定义，导致非加色法从材质读取完后未移除宏定义。
         }
         /**
          * @private
          */
         static __initDefine__() {
             ShurikenParticleMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP = ShurikenParticleMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
             ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR = ShurikenParticleMaterial.shaderDefines.registerDefine("TINTCOLOR");
             ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG = ShurikenParticleMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
             ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET = ShurikenParticleMaterial.shaderDefines.registerDefine("TILINGOFFSET");
         }
         /**
          * @private
          */
         get _TintColorR() {
             return this._color.x;
         }
         /**
          * @private
          */
         set _TintColorR(value) {
             this._color.x = value;
             this.color = this._color;
         }
         /**
          * @private
          */
         get _TintColorG() {
             return this._color.y;
         }
         /**
          * @private
          */
         set _TintColorG(value) {
             this._color.y = value;
             this.color = this._color;
         }
         /**
          * @private
          */
         get _TintColorB() {
             return this._color.z;
         }
         /**
          * @private
          */
         set _TintColorB(value) {
             this._color.z = value;
             this.color = this._color;
         }
         /**@private */
         get _TintColorA() {
             return this._color.w;
         }
         /**
          * @private
          */
         set _TintColorA(value) {
             this._color.w = value;
             this.color = this._color;
         }
         /**
          * @private
          */
         get _MainTex_STX() {
             return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).x;
         }
         /**
          * @private
          */
         set _MainTex_STX(x) {
             var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
             tilOff.x = x;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STY() {
             return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).y;
         }
         /**
          * @private
          */
         set _MainTex_STY(y) {
             var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
             tilOff.y = y;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STZ() {
             return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).z;
         }
         /**
          * @private
          */
         set _MainTex_STZ(z) {
             var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
             tilOff.z = z;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STW() {
             return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).w;
         }
         /**
          * @private
          */
         set _MainTex_STW(w) {
             var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
             tilOff.w = w;
             this.tilingOffset = tilOff;
         }
         /**
          * 设置渲染模式。
          * @return 渲染模式。
          */
         set renderMode(value) {
             switch (value) {
                 case ShurikenParticleMaterial.RENDERMODE_ADDTIVE:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_NONE;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE;
                     this.alphaTest = false;
                     this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                     break;
                 case ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_NONE;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.alphaTest = false;
                     this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                     break;
                 default:
                     throw new Error("ShurikenParticleMaterial : renderMode value error.");
             }
         }
         /**
          * 获取颜色R分量。
          * @return 颜色R分量。
          */
         get colorR() {
             return this._TintColorR;
         }
         /**
          * 设置颜色R分量。
          * @param value 颜色R分量。
          */
         set colorR(value) {
             this._TintColorR = value;
         }
         /**
          * 获取颜色G分量。
          * @return 颜色G分量。
          */
         get colorG() {
             return this._TintColorG;
         }
         /**
          * 设置颜色G分量。
          * @param value 颜色G分量。
          */
         set colorG(value) {
             this._TintColorG = value;
         }
         /**
          * 获取颜色B分量。
          * @return 颜色B分量。
          */
         get colorB() {
             return this._TintColorB;
         }
         /**
          * 设置颜色B分量。
          * @param value 颜色B分量。
          */
         set colorB(value) {
             this._TintColorB = value;
         }
         /**
          * 获取颜色Z分量。
          * @return 颜色Z分量。
          */
         get colorA() {
             return this._TintColorA;
         }
         /**
          * 设置颜色alpha分量。
          * @param value 颜色alpha分量。
          */
         set colorA(value) {
             this._TintColorA = value;
         }
         /**
          * 获取颜色。
          * @return  颜色。
          */
         get color() {
             return this._shaderValues.getVector(ShurikenParticleMaterial.TINTCOLOR);
         }
         /**
          * 设置颜色。
          * @param value 颜色。
          */
         set color(value) {
             if (value)
                 this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
             else
                 this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
             this._shaderValues.setVector(ShurikenParticleMaterial.TINTCOLOR, value);
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @return 纹理平铺和偏移X分量。
          */
         get tilingOffsetX() {
             return this._MainTex_STX;
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @param x 纹理平铺和偏移X分量。
          */
         set tilingOffsetX(x) {
             this._MainTex_STX = x;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @return 纹理平铺和偏移Y分量。
          */
         get tilingOffsetY() {
             return this._MainTex_STY;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @param y 纹理平铺和偏移Y分量。
          */
         set tilingOffsetY(y) {
             this._MainTex_STY = y;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @return 纹理平铺和偏移Z分量。
          */
         get tilingOffsetZ() {
             return this._MainTex_STZ;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @param z 纹理平铺和偏移Z分量。
          */
         set tilingOffsetZ(z) {
             this._MainTex_STZ = z;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @return 纹理平铺和偏移W分量。
          */
         get tilingOffsetW() {
             return this._MainTex_STW;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @param w 纹理平铺和偏移W分量。
          */
         set tilingOffsetW(w) {
             this._MainTex_STW = w;
         }
         /**
          * 获取纹理平铺和偏移。
          * @return 纹理平铺和偏移。
          */
         get tilingOffset() {
             return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
         }
         /**
          * 获取纹理平铺和偏移。
          * @param value 纹理平铺和偏移。
          */
         set tilingOffset(value) {
             if (value) {
                 if (value.x != 1 || value.y != 1 || value.z != 0 || value.w != 0)
                     this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
                 else
                     this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             else {
                 this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             this._shaderValues.setVector(ShurikenParticleMaterial.TILINGOFFSET, value);
         }
         /**
          * 获取漫反射贴图。
          * @return 漫反射贴图。
          */
         get texture() {
             return this._shaderValues.getTexture(ShurikenParticleMaterial.DIFFUSETEXTURE);
         }
         /**
          * 设置漫反射贴图。
          * @param value 漫反射贴图。
          */
         set texture(value) {
             if (value)
                 this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
             else
                 this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
             this._shaderValues.setTexture(ShurikenParticleMaterial.DIFFUSETEXTURE, value);
         }
         /**
          * 设置是否写入深度。
          * @param value 是否写入深度。
          */
         set depthWrite(value) {
             this._shaderValues.setBool(ShurikenParticleMaterial.DEPTH_WRITE, value);
         }
         /**
          * 获取是否写入深度。
          * @return 是否写入深度。
          */
         get depthWrite() {
             return this._shaderValues.getBool(ShurikenParticleMaterial.DEPTH_WRITE);
         }
         /**
          * 设置剔除方式。
          * @param value 剔除方式。
          */
         set cull(value) {
             this._shaderValues.setInt(ShurikenParticleMaterial.CULL, value);
         }
         /**
          * 获取剔除方式。
          * @return 剔除方式。
          */
         get cull() {
             return this._shaderValues.getInt(ShurikenParticleMaterial.CULL);
         }
         /**
          * 设置混合方式。
          * @param value 混合方式。
          */
         set blend(value) {
             this._shaderValues.setInt(ShurikenParticleMaterial.BLEND, value);
         }
         /**
          * 获取混合方式。
          * @return 混合方式。
          */
         get blend() {
             return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND);
         }
         /**
          * 设置混合源。
          * @param value 混合源
          */
         set blendSrc(value) {
             this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_SRC, value);
         }
         /**
          * 获取混合源。
          * @return 混合源。
          */
         get blendSrc() {
             return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_SRC);
         }
         /**
          * 设置混合目标。
          * @param value 混合目标
          */
         set blendDst(value) {
             this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_DST, value);
         }
         /**
          * 获取混合目标。
          * @return 混合目标。
          */
         get blendDst() {
             return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_DST);
         }
         /**
          * 设置深度测试方式。
          * @param value 深度测试方式
          */
         set depthTest(value) {
             this._shaderValues.setInt(ShurikenParticleMaterial.DEPTH_TEST, value);
         }
         /**
          * 获取深度测试方式。
          * @return 深度测试方式。
          */
         get depthTest() {
             return this._shaderValues.getInt(ShurikenParticleMaterial.DEPTH_TEST);
         }
         /**
     * 克隆。
     * @return	 克隆副本。
     */
         clone() {
             var dest = new ShurikenParticleMaterial();
             this.cloneTo(dest);
             return dest;
         }
     }
     /**渲染状态_透明混合。*/
     ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED = 0;
     /**渲染状态_加色法混合。*/
     ShurikenParticleMaterial.RENDERMODE_ADDTIVE = 1;
     ShurikenParticleMaterial.DIFFUSETEXTURE = Shader3D.propertyNameToID("u_texture");
     ShurikenParticleMaterial.TINTCOLOR = Shader3D.propertyNameToID("u_Tintcolor");
     ShurikenParticleMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset");
     ShurikenParticleMaterial.CULL = Shader3D.propertyNameToID("s_Cull");
     ShurikenParticleMaterial.BLEND = Shader3D.propertyNameToID("s_Blend");
     ShurikenParticleMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
     ShurikenParticleMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
     ShurikenParticleMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
     ShurikenParticleMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
     /**@private */
     ShurikenParticleMaterial.shaderDefines = null;

     class ShuriKenParticle3DShaderDeclaration {
     }
     //Base
     ShuriKenParticle3DShaderDeclaration.WORLDPOSITION = Shader3D.propertyNameToID("u_WorldPosition");
     ShuriKenParticle3DShaderDeclaration.WORLDROTATION = Shader3D.propertyNameToID("u_WorldRotation");
     ShuriKenParticle3DShaderDeclaration.POSITIONSCALE = Shader3D.propertyNameToID("u_PositionScale");
     ShuriKenParticle3DShaderDeclaration.SIZESCALE = Shader3D.propertyNameToID("u_SizeScale");
     ShuriKenParticle3DShaderDeclaration.SCALINGMODE = Shader3D.propertyNameToID("u_ScalingMode");
     ShuriKenParticle3DShaderDeclaration.GRAVITY = Shader3D.propertyNameToID("u_Gravity");
     ShuriKenParticle3DShaderDeclaration.THREEDSTARTROTATION = Shader3D.propertyNameToID("u_ThreeDStartRotation");
     ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDLENGTHSCALE = Shader3D.propertyNameToID("u_StretchedBillboardLengthScale");
     ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDSPEEDSCALE = Shader3D.propertyNameToID("u_StretchedBillboardSpeedScale");
     ShuriKenParticle3DShaderDeclaration.SIMULATIONSPACE = Shader3D.propertyNameToID("u_SimulationSpace");
     ShuriKenParticle3DShaderDeclaration.CURRENTTIME = Shader3D.propertyNameToID("u_CurrentTime");
     //VelocityOverLifetime
     ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST = Shader3D.propertyNameToID("u_VOLVelocityConst");
     ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX = Shader3D.propertyNameToID("u_VOLVelocityGradientX");
     ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY = Shader3D.propertyNameToID("u_VOLVelocityGradientY");
     ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ = Shader3D.propertyNameToID("u_VOLVelocityGradientZ");
     ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONSTMAX = Shader3D.propertyNameToID("u_VOLVelocityConstMax");
     ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTXMAX = Shader3D.propertyNameToID("u_VOLVelocityGradientMaxX");
     ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTYMAX = Shader3D.propertyNameToID("u_VOLVelocityGradientMaxY");
     ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZMAX = Shader3D.propertyNameToID("u_VOLVelocityGradientMaxZ");
     ShuriKenParticle3DShaderDeclaration.VOLSPACETYPE = Shader3D.propertyNameToID("u_VOLSpaceType");
     //ColorOverLifetime
     ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS = Shader3D.propertyNameToID("u_ColorOverLifeGradientAlphas");
     ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS = Shader3D.propertyNameToID("u_ColorOverLifeGradientColors");
     ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS = Shader3D.propertyNameToID("u_MaxColorOverLifeGradientAlphas");
     ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS = Shader3D.propertyNameToID("u_MaxColorOverLifeGradientColors");
     //SizeOverLifetime
     ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT = Shader3D.propertyNameToID("u_SOLSizeGradient");
     ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX = Shader3D.propertyNameToID("u_SOLSizeGradientX");
     ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY = Shader3D.propertyNameToID("u_SOLSizeGradientY");
     ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ = Shader3D.propertyNameToID("u_SOLSizeGradientZ");
     ShuriKenParticle3DShaderDeclaration.SOLSizeGradientMax = Shader3D.propertyNameToID("u_SOLSizeGradientMax");
     ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTXMAX = Shader3D.propertyNameToID("u_SOLSizeGradientMaxX");
     ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTYMAX = Shader3D.propertyNameToID("u_SOLSizeGradientMaxY");
     ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZMAX = Shader3D.propertyNameToID("u_SOLSizeGradientMaxZ");
     //RotationOverLifetime
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST = Shader3D.propertyNameToID("u_ROLAngularVelocityConst");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE = Shader3D.propertyNameToID("u_ROLAngularVelocityConstSeprarate");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT = Shader3D.propertyNameToID("u_ROLAngularVelocityGradient");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientX");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientY");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientZ");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityConstMax");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAXSEPRARATE = Shader3D.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMax");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTXMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxX");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTYMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxY");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxZ");
     ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTWMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxW");
     //TextureSheetAnimation
     ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONCYCLES = Shader3D.propertyNameToID("u_TSACycles");
     ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONSUBUVLENGTH = Shader3D.propertyNameToID("u_TSASubUVLength");
     ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS = Shader3D.propertyNameToID("u_TSAGradientUVs");
     ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTMAXUVS = Shader3D.propertyNameToID("u_TSAMaxGradientUVs");

     /**
      * <code>ShurikenParticleRender</code> 类用于创建3D粒子渲染器。
      */
     class ShurikenParticleRenderer extends BaseRender {
         /**
          * 创建一个 <code>ShurikenParticleRender</code> 实例。
          */
         constructor(owner) {
             super(owner);
             /** @private */
             this._finalGravity = new Vector3();
             /** @private */
             this._tempRotationMatrix = new Matrix4x4();
             ///**排序模式,无。*/
             //public const SORTINGMODE_NONE:int = 0;
             ///**排序模式,通过摄像机距离排序,暂不支持。*/
             //public const SORTINGMODE_BYDISTANCE:int = 1;
             ///**排序模式,年长的在前绘制,暂不支持。*/
             //public const SORTINGMODE_OLDESTINFRONT:int = 2;
             ///**排序模式,年轻的在前绘制,暂不支持*/
             //public const SORTINGMODE_YOUNGESTINFRONT:int = 3;
             /**@private */
             this._renderMode = 0;
             /**@private */
             this._mesh = null;
             /**拉伸广告牌模式摄像机速度缩放,暂不支持。*/
             this.stretchedBillboardCameraSpeedScale = 0;
             /**拉伸广告牌模式速度缩放。*/
             this.stretchedBillboardSpeedScale = 0;
             /**拉伸广告牌模式长度缩放。*/
             this.stretchedBillboardLengthScale = 0;
             this._defaultBoundBox = new BoundBox(new Vector3(), new Vector3());
             this._renderMode = -1;
             this.stretchedBillboardCameraSpeedScale = 0.0;
             this.stretchedBillboardSpeedScale = 0.0;
             this.stretchedBillboardLengthScale = 1.0;
             //sortingMode = SORTINGMODE_NONE;
             this._supportOctree = false;
         }
         ///**排序模式。*/
         //public var sortingMode:int;
         /**
          * 获取渲染模式。
          * @return 渲染模式。
          */
         get renderMode() {
             return this._renderMode;
         }
         /**
          * 获取网格渲染模式所使用的Mesh,rendderMode为4时生效。
          * @return 网格模式所使用Mesh。
          */
         get mesh() {
             return this._mesh;
         }
         /**
          * 设置网格渲染模式所使用的Mesh,rendderMode为4时生效。
          * @param value 网格模式所使用Mesh。
          */
         set mesh(value) {
             if (this._mesh !== value) {
                 (this._mesh) && (this._mesh._removeReference());
                 this._mesh = value;
                 (value) && (value._addReference());
                 this._owner.particleSystem._initBufferDatas();
             }
         }
         /**
          * 设置渲染模式,0为BILLBOARD、1为STRETCHEDBILLBOARD、2为HORIZONTALBILLBOARD、3为VERTICALBILLBOARD、4为MESH。
          * @param value 渲染模式。
          */
         set renderMode(value) {
             if (this._renderMode !== value) {
                 var defineDatas = this._shaderValues;
                 switch (this._renderMode) {
                     case 0:
                         defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_BILLBOARD);
                         break;
                     case 1:
                         defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                         break;
                     case 2:
                         defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                         break;
                     case 3:
                         defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                         break;
                     case 4:
                         defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_MESH);
                         break;
                 }
                 this._renderMode = value;
                 switch (value) {
                     case 0:
                         defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_BILLBOARD);
                         break;
                     case 1:
                         defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                         break;
                     case 2:
                         defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                         break;
                     case 3:
                         defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                         break;
                     case 4:
                         defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_MESH);
                         break;
                     default:
                         throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                 }
                 this._owner.particleSystem._initBufferDatas();
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _calculateBoundingBox() {
             //var particleSystem:ShurikenParticleSystem = (_owner as ShuriKenParticle3D).particleSystem;
             //particleSystem._generateBoundingBox();
             //var rotation:Quaternion = _owner.transform.rotation;
             //var corners:Vector.<Vector3> = particleSystem._boundingBoxCorners;
             //for (var i:int = 0; i < 8; i++)
             //	Vector3.transformQuat(corners[i], rotation, _tempBoudingBoxCorners[i]);
             //BoundBox.createfromPoints(_tempBoudingBoxCorners, _boundingBox);
             var min = this._bounds.getMin();
             min.x = -Number.MAX_VALUE;
             min.y = -Number.MAX_VALUE;
             min.z = -Number.MAX_VALUE;
             this._bounds.setMin(min);
             var max = this._bounds.getMax();
             max.x = Number.MAX_VALUE;
             max.y = Number.MAX_VALUE;
             max.z = Number.MAX_VALUE;
             this._bounds.setMax(max);
             if (Render.supportWebGLPlusCulling) { //[NATIVE]
                 var min = this._bounds.getMin();
                 var max = this._bounds.getMax();
                 var buffer = FrustumCulling._cullingBuffer;
                 buffer[this._cullingBufferIndex + 1] = min.x;
                 buffer[this._cullingBufferIndex + 2] = min.y;
                 buffer[this._cullingBufferIndex + 3] = min.z;
                 buffer[this._cullingBufferIndex + 4] = max.x;
                 buffer[this._cullingBufferIndex + 5] = max.y;
                 buffer[this._cullingBufferIndex + 6] = max.z;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _needRender(boundFrustum) {
             if (boundFrustum) {
                 if (boundFrustum.containsBoundBox(this.bounds._getBoundBox()) !== ContainmentType.Disjoint) {
                     if (this._owner.particleSystem.isAlive)
                         return true;
                     else
                         return false;
                 }
                 else {
                     return false;
                 }
             }
             else {
                 return true;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _renderUpdate(context, transfrom) {
             var particleSystem = this._owner.particleSystem;
             var sv = this._shaderValues;
             var transform = this._owner.transform;
             switch (particleSystem.simulationSpace) {
                 case 0: //World
                     break;
                 case 1: //Local
                     sv.setVector3(ShuriKenParticle3DShaderDeclaration.WORLDPOSITION, transform.position);
                     sv.setQuaternion(ShuriKenParticle3DShaderDeclaration.WORLDROTATION, transform.rotation);
                     break;
                 default:
                     throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
             }
             switch (particleSystem.scaleMode) {
                 case 0:
                     var scale = transform.scale;
                     sv.setVector3(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, scale);
                     sv.setVector3(ShuriKenParticle3DShaderDeclaration.SIZESCALE, scale);
                     break;
                 case 1:
                     var localScale = transform.localScale;
                     sv.setVector3(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, localScale);
                     sv.setVector3(ShuriKenParticle3DShaderDeclaration.SIZESCALE, localScale);
                     break;
                 case 2:
                     sv.setVector3(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, transform.scale);
                     sv.setVector3(ShuriKenParticle3DShaderDeclaration.SIZESCALE, Vector3._ONE);
                     break;
             }
             Vector3.scale(Physics3DUtils.gravity, particleSystem.gravityModifier, this._finalGravity);
             sv.setVector3(ShuriKenParticle3DShaderDeclaration.GRAVITY, this._finalGravity);
             sv.setInt(ShuriKenParticle3DShaderDeclaration.SIMULATIONSPACE, particleSystem.simulationSpace);
             sv.setBool(ShuriKenParticle3DShaderDeclaration.THREEDSTARTROTATION, particleSystem.threeDStartRotation);
             sv.setInt(ShuriKenParticle3DShaderDeclaration.SCALINGMODE, particleSystem.scaleMode);
             sv.setNumber(ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale);
             sv.setNumber(ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale);
             sv.setNumber(ShuriKenParticle3DShaderDeclaration.CURRENTTIME, particleSystem._currentTime);
         }
         /**
          * @inheritDoc
          */
         /*override*/ get bounds() {
             //if (!(_owner as ShuriKenParticle3DShaderDeclaration).particleSystem.isAlive) {
             //return _defaultBoundBox;
             //} else {
             if (this._boundsChange) {
                 this._calculateBoundingBox();
                 this._boundsChange = false;
             }
             return this._bounds;
             //}
         }
         /**
          * @inheritDoc
          */
         /*override*/ _destroy() {
             super._destroy();
             (this._mesh) && (this._mesh._removeReference(), this._mesh = null);
         }
     }

     /**
      *  @private
      */
     class ShurikenParticleData {
         constructor() {
         }
         /**
          * @private
          */
         static _getStartLifetimeFromGradient(startLifeTimeGradient, emissionTime) {
             for (var i = 1, n = startLifeTimeGradient.gradientCount; i < n; i++) {
                 var key = startLifeTimeGradient.getKeyByIndex(i);
                 if (key >= emissionTime) {
                     var lastKey = startLifeTimeGradient.getKeyByIndex(i - 1);
                     var age = (emissionTime - lastKey) / (key - lastKey);
                     return MathUtil.lerp(startLifeTimeGradient.getValueByIndex(i - 1), startLifeTimeGradient.getValueByIndex(i), age);
                 }
             }
             throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
         }
         /**
          * @private
          */
         static _randomInvertRoationArray(rotatonE, outE, randomizeRotationDirection, rand, randomSeeds) {
             var randDic;
             if (rand) {
                 rand.seed = randomSeeds[6];
                 randDic = rand.getFloat();
                 randomSeeds[6] = rand.seed;
             }
             else {
                 randDic = Math.random();
             }
             if (randDic < randomizeRotationDirection) {
                 outE.x = -rotatonE.x;
                 outE.y = -rotatonE.y;
                 outE.z = -rotatonE.z;
             }
             else {
                 outE.x = rotatonE.x;
                 outE.y = rotatonE.y;
                 outE.z = rotatonE.z;
             }
         }
         /**
          * @private
          */
         static _randomInvertRoation(rotaton, randomizeRotationDirection, rand, randomSeeds) {
             var randDic;
             if (rand) {
                 rand.seed = randomSeeds[6];
                 randDic = rand.getFloat();
                 randomSeeds[6] = rand.seed;
             }
             else {
                 randDic = Math.random();
             }
             if (randDic < randomizeRotationDirection)
                 rotaton = -rotaton;
             return rotaton;
         }
         /**
          * @private
          */
         static create(particleSystem, particleRender, transform) {
             var autoRandomSeed = particleSystem.autoRandomSeed;
             var rand = particleSystem._rand;
             var randomSeeds = particleSystem._randomSeeds;
             //StartColor
             switch (particleSystem.startColorType) {
                 case 0:
                     var constantStartColor = particleSystem.startColorConstant;
                     ShurikenParticleData.startColor.x = constantStartColor.x;
                     ShurikenParticleData.startColor.y = constantStartColor.y;
                     ShurikenParticleData.startColor.z = constantStartColor.z;
                     ShurikenParticleData.startColor.w = constantStartColor.w;
                     break;
                 case 2:
                     if (autoRandomSeed) {
                         Vector4.lerp(particleSystem.startColorConstantMin, particleSystem.startColorConstantMax, Math.random(), ShurikenParticleData.startColor);
                     }
                     else {
                         rand.seed = randomSeeds[3];
                         Vector4.lerp(particleSystem.startColorConstantMin, particleSystem.startColorConstantMax, rand.getFloat(), ShurikenParticleData.startColor);
                         randomSeeds[3] = rand.seed;
                     }
                     break;
             }
             var colorOverLifetime = particleSystem.colorOverLifetime;
             if (colorOverLifetime && colorOverLifetime.enbale) {
                 var color = colorOverLifetime.color;
                 switch (color.type) {
                     case 0:
                         ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * color.constant.x;
                         ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * color.constant.y;
                         ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * color.constant.z;
                         ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * color.constant.w;
                         break;
                     case 2:
                         var colorRandom;
                         if (autoRandomSeed) {
                             colorRandom = Math.random();
                         }
                         else {
                             rand.seed = randomSeeds[10];
                             colorRandom = rand.getFloat();
                             randomSeeds[10] = rand.seed;
                         }
                         var minConstantColor = color.constantMin;
                         var maxConstantColor = color.constantMax;
                         ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * MathUtil.lerp(minConstantColor.x, maxConstantColor.x, colorRandom);
                         ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * MathUtil.lerp(minConstantColor.y, maxConstantColor.y, colorRandom);
                         ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * MathUtil.lerp(minConstantColor.z, maxConstantColor.z, colorRandom);
                         ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * MathUtil.lerp(minConstantColor.w, maxConstantColor.w, colorRandom);
                         break;
                 }
             }
             //StartSize
             var particleSize = ShurikenParticleData.startSize;
             switch (particleSystem.startSizeType) {
                 case 0:
                     if (particleSystem.threeDStartSize) {
                         var startSizeConstantSeparate = particleSystem.startSizeConstantSeparate;
                         particleSize[0] = startSizeConstantSeparate.x;
                         particleSize[1] = startSizeConstantSeparate.y;
                         particleSize[2] = startSizeConstantSeparate.z;
                     }
                     else {
                         particleSize[0] = particleSize[1] = particleSize[2] = particleSystem.startSizeConstant;
                     }
                     break;
                 case 2:
                     if (particleSystem.threeDStartSize) {
                         var startSizeConstantMinSeparate = particleSystem.startSizeConstantMinSeparate;
                         var startSizeConstantMaxSeparate = particleSystem.startSizeConstantMaxSeparate;
                         if (autoRandomSeed) {
                             particleSize[0] = MathUtil.lerp(startSizeConstantMinSeparate.x, startSizeConstantMaxSeparate.x, Math.random());
                             particleSize[1] = MathUtil.lerp(startSizeConstantMinSeparate.y, startSizeConstantMaxSeparate.y, Math.random());
                             particleSize[2] = MathUtil.lerp(startSizeConstantMinSeparate.z, startSizeConstantMaxSeparate.z, Math.random());
                         }
                         else {
                             rand.seed = randomSeeds[4];
                             particleSize[0] = MathUtil.lerp(startSizeConstantMinSeparate.x, startSizeConstantMaxSeparate.x, rand.getFloat());
                             particleSize[1] = MathUtil.lerp(startSizeConstantMinSeparate.y, startSizeConstantMaxSeparate.y, rand.getFloat());
                             particleSize[2] = MathUtil.lerp(startSizeConstantMinSeparate.z, startSizeConstantMaxSeparate.z, rand.getFloat());
                             randomSeeds[4] = rand.seed;
                         }
                     }
                     else {
                         if (autoRandomSeed) {
                             particleSize[0] = particleSize[1] = particleSize[2] = MathUtil.lerp(particleSystem.startSizeConstantMin, particleSystem.startSizeConstantMax, Math.random());
                         }
                         else {
                             rand.seed = randomSeeds[4];
                             particleSize[0] = particleSize[1] = particleSize[2] = MathUtil.lerp(particleSystem.startSizeConstantMin, particleSystem.startSizeConstantMax, rand.getFloat());
                             randomSeeds[4] = rand.seed;
                         }
                     }
                     break;
             }
             var sizeOverLifetime = particleSystem.sizeOverLifetime;
             if (sizeOverLifetime && sizeOverLifetime.enbale && sizeOverLifetime.size.type === 1) {
                 var size = sizeOverLifetime.size;
                 if (size.separateAxes) {
                     if (autoRandomSeed) {
                         particleSize[0] = particleSize[0] * MathUtil.lerp(size.constantMinSeparate.x, size.constantMaxSeparate.x, Math.random());
                         particleSize[1] = particleSize[1] * MathUtil.lerp(size.constantMinSeparate.y, size.constantMaxSeparate.y, Math.random());
                         particleSize[2] = particleSize[2] * MathUtil.lerp(size.constantMinSeparate.z, size.constantMaxSeparate.z, Math.random());
                     }
                     else {
                         rand.seed = randomSeeds[11];
                         particleSize[0] = particleSize[0] * MathUtil.lerp(size.constantMinSeparate.x, size.constantMaxSeparate.x, rand.getFloat());
                         particleSize[1] = particleSize[1] * MathUtil.lerp(size.constantMinSeparate.y, size.constantMaxSeparate.y, rand.getFloat());
                         particleSize[2] = particleSize[2] * MathUtil.lerp(size.constantMinSeparate.z, size.constantMaxSeparate.z, rand.getFloat());
                         randomSeeds[11] = rand.seed;
                     }
                 }
                 else {
                     var randomSize;
                     if (autoRandomSeed) {
                         randomSize = MathUtil.lerp(size.constantMin, size.constantMax, Math.random());
                     }
                     else {
                         rand.seed = randomSeeds[11];
                         randomSize = MathUtil.lerp(size.constantMin, size.constantMax, rand.getFloat());
                         randomSeeds[11] = rand.seed;
                     }
                     particleSize[0] = particleSize[0] * randomSize;
                     particleSize[1] = particleSize[1] * randomSize;
                     particleSize[2] = particleSize[2] * randomSize;
                 }
             }
             //StartRotation//TODO:renderMode2、3模式都不需要旋转，是否移除。
             var renderMode = particleRender.renderMode;
             if (renderMode !== 1) {
                 switch (particleSystem.startRotationType) {
                     case 0:
                         if (particleSystem.threeDStartRotation) {
                             var startRotationConstantSeparate = particleSystem.startRotationConstantSeparate;
                             var randomRotationE = ShurikenParticleData._tempVector30;
                             ShurikenParticleData._randomInvertRoationArray(startRotationConstantSeparate, randomRotationE, particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                             ShurikenParticleData.startRotation[0] = randomRotationE.x;
                             ShurikenParticleData.startRotation[1] = randomRotationE.y;
                             if (renderMode !== 4)
                                 ShurikenParticleData.startRotation[2] = -randomRotationE.z;
                             else
                                 ShurikenParticleData.startRotation[2] = randomRotationE.z;
                         }
                         else {
                             ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(particleSystem.startRotationConstant, particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                             ShurikenParticleData.startRotation[1] = 0;
                             ShurikenParticleData.startRotation[2] = 0; //需要置0,否则上次缓存影响数据。TODO:mesh模式下使用Z,但是这里为什么是X
                         }
                         break;
                     case 2:
                         if (particleSystem.threeDStartRotation) {
                             var startRotationConstantMinSeparate = particleSystem.startRotationConstantMinSeparate;
                             var startRotationConstantMaxSeparate = particleSystem.startRotationConstantMaxSeparate;
                             var lerpRoationE = ShurikenParticleData._tempVector30;
                             if (autoRandomSeed) {
                                 lerpRoationE.x = MathUtil.lerp(startRotationConstantMinSeparate.x, startRotationConstantMaxSeparate.x, Math.random());
                                 lerpRoationE.y = MathUtil.lerp(startRotationConstantMinSeparate.y, startRotationConstantMaxSeparate.y, Math.random());
                                 lerpRoationE.z = MathUtil.lerp(startRotationConstantMinSeparate.z, startRotationConstantMaxSeparate.z, Math.random());
                             }
                             else {
                                 rand.seed = randomSeeds[5];
                                 lerpRoationE.x = MathUtil.lerp(startRotationConstantMinSeparate.x, startRotationConstantMaxSeparate.x, rand.getFloat());
                                 lerpRoationE.y = MathUtil.lerp(startRotationConstantMinSeparate.y, startRotationConstantMaxSeparate.y, rand.getFloat());
                                 lerpRoationE.z = MathUtil.lerp(startRotationConstantMinSeparate.z, startRotationConstantMaxSeparate.z, rand.getFloat());
                                 randomSeeds[5] = rand.seed;
                             }
                             ShurikenParticleData._randomInvertRoationArray(lerpRoationE, lerpRoationE, particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                             ShurikenParticleData.startRotation[0] = lerpRoationE.x;
                             ShurikenParticleData.startRotation[1] = lerpRoationE.y;
                             if (renderMode !== 4)
                                 ShurikenParticleData.startRotation[2] = -lerpRoationE.z;
                             else
                                 ShurikenParticleData.startRotation[2] = lerpRoationE.z;
                         }
                         else {
                             if (autoRandomSeed) {
                                 ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(MathUtil.lerp(particleSystem.startRotationConstantMin, particleSystem.startRotationConstantMax, Math.random()), particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                             }
                             else {
                                 rand.seed = randomSeeds[5];
                                 ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(MathUtil.lerp(particleSystem.startRotationConstantMin, particleSystem.startRotationConstantMax, rand.getFloat()), particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                                 randomSeeds[5] = rand.seed;
                             }
                         }
                         break;
                 }
             }
             //StartLifetime
             switch (particleSystem.startLifetimeType) {
                 case 0:
                     ShurikenParticleData.startLifeTime = particleSystem.startLifetimeConstant;
                     break;
                 case 1:
                     ShurikenParticleData.startLifeTime = ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradient, particleSystem.emissionTime);
                     break;
                 case 2:
                     if (autoRandomSeed) {
                         ShurikenParticleData.startLifeTime = MathUtil.lerp(particleSystem.startLifetimeConstantMin, particleSystem.startLifetimeConstantMax, Math.random());
                     }
                     else {
                         rand.seed = randomSeeds[7];
                         ShurikenParticleData.startLifeTime = MathUtil.lerp(particleSystem.startLifetimeConstantMin, particleSystem.startLifetimeConstantMax, rand.getFloat());
                         randomSeeds[7] = rand.seed;
                     }
                     break;
                 case 3:
                     var emissionTime = particleSystem.emissionTime;
                     if (autoRandomSeed) {
                         ShurikenParticleData.startLifeTime = MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin, emissionTime), ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax, emissionTime), Math.random());
                     }
                     else {
                         rand.seed = randomSeeds[7];
                         ShurikenParticleData.startLifeTime = MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin, emissionTime), ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax, emissionTime), rand.getFloat());
                         randomSeeds[7] = rand.seed;
                     }
                     break;
             }
             //StartSpeed
             switch (particleSystem.startSpeedType) {
                 case 0:
                     ShurikenParticleData.startSpeed = particleSystem.startSpeedConstant;
                     break;
                 case 2:
                     if (autoRandomSeed) {
                         ShurikenParticleData.startSpeed = MathUtil.lerp(particleSystem.startSpeedConstantMin, particleSystem.startSpeedConstantMax, Math.random());
                     }
                     else {
                         rand.seed = randomSeeds[8];
                         ShurikenParticleData.startSpeed = MathUtil.lerp(particleSystem.startSpeedConstantMin, particleSystem.startSpeedConstantMax, rand.getFloat());
                         randomSeeds[8] = rand.seed;
                     }
                     break;
             }
             //StartUV
             var textureSheetAnimation = particleSystem.textureSheetAnimation;
             var enableSheetAnimation = textureSheetAnimation && textureSheetAnimation.enable;
             if (enableSheetAnimation) {
                 var title = textureSheetAnimation.tiles;
                 var titleX = title.x, titleY = title.y;
                 var subU = 1.0 / titleX, subV = 1.0 / titleY;
                 var startFrameCount;
                 var startFrame = textureSheetAnimation.startFrame;
                 switch (startFrame.type) {
                     case 0: //常量模式
                         startFrameCount = startFrame.constant;
                         break;
                     case 1: //随机双常量模式
                         if (autoRandomSeed) {
                             startFrameCount = MathUtil.lerp(startFrame.constantMin, startFrame.constantMax, Math.random());
                         }
                         else {
                             rand.seed = randomSeeds[14];
                             startFrameCount = MathUtil.lerp(startFrame.constantMin, startFrame.constantMax, rand.getFloat());
                             randomSeeds[14] = rand.seed;
                         }
                         break;
                 }
                 var frame = textureSheetAnimation.frame;
                 switch (frame.type) {
                     case 0:
                         startFrameCount += frame.constant;
                         break;
                     case 2:
                         if (autoRandomSeed) {
                             startFrameCount += MathUtil.lerp(frame.constantMin, frame.constantMax, Math.random());
                         }
                         else {
                             rand.seed = randomSeeds[15];
                             startFrameCount += MathUtil.lerp(frame.constantMin, frame.constantMax, rand.getFloat());
                             randomSeeds[15] = rand.seed;
                         }
                         break;
                 }
                 var startRow = 0; //TODO:case 2 没处理
                 switch (textureSheetAnimation.type) {
                     case 0: //Whole Sheet
                         startRow = Math.floor(startFrameCount / titleX);
                         break;
                     case 1: //Singal Row
                         if (textureSheetAnimation.randomRow) {
                             if (autoRandomSeed) {
                                 startRow = Math.floor(Math.random() * titleY);
                             }
                             else {
                                 rand.seed = randomSeeds[13];
                                 startRow = Math.floor(rand.getFloat() * titleY);
                                 randomSeeds[13] = rand.seed;
                             }
                         }
                         else {
                             startRow = textureSheetAnimation.rowIndex;
                         }
                         break;
                 }
                 var startCol = Math.floor(startFrameCount % titleX);
                 ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo;
                 ShurikenParticleData.startUVInfo[0] = subU;
                 ShurikenParticleData.startUVInfo[1] = subV;
                 ShurikenParticleData.startUVInfo[2] = startCol * subU;
                 ShurikenParticleData.startUVInfo[3] = startRow * subV;
             }
             else {
                 ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo;
                 ShurikenParticleData.startUVInfo[0] = 1.0;
                 ShurikenParticleData.startUVInfo[1] = 1.0;
                 ShurikenParticleData.startUVInfo[2] = 0.0;
                 ShurikenParticleData.startUVInfo[3] = 0.0;
             }
             switch (particleSystem.simulationSpace) {
                 case 0:
                     var position = transform.position;
                     ShurikenParticleData.simulationWorldPostion[0] = position.x;
                     ShurikenParticleData.simulationWorldPostion[1] = position.y;
                     ShurikenParticleData.simulationWorldPostion[2] = position.z;
                     var rotation = transform.rotation;
                     ShurikenParticleData.simulationWorldRotation[0] = rotation.x;
                     ShurikenParticleData.simulationWorldRotation[1] = rotation.y;
                     ShurikenParticleData.simulationWorldRotation[2] = rotation.z;
                     ShurikenParticleData.simulationWorldRotation[3] = rotation.w;
                     break;
                 case 1:
                     break;
                 default:
                     throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                     break;
             }
         }
     }
     /**@private */
     ShurikenParticleData._tempVector30 = new Vector3();
     /**@private */
     ShurikenParticleData._tempQuaternion = new Quaternion();
     ShurikenParticleData.startColor = new Vector4();
     ShurikenParticleData.startSize = new Float32Array(3);
     ShurikenParticleData.startRotation = new Float32Array(3);
     ShurikenParticleData.startUVInfo = new Float32Array(4);
     ShurikenParticleData.simulationWorldPostion = new Float32Array(3);
     ShurikenParticleData.simulationWorldRotation = new Float32Array(4);

     /**
      * <code>Emission</code> 类用于粒子发射器。
      */
     class Emission {
         /**
          * 设置粒子发射速率。
          * @param emissionRate 粒子发射速率 (个/秒)。
          */
         set emissionRate(value) {
             if (value < 0)
                 throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
             this._emissionRate = value;
         }
         /**
          * 获取粒子发射速率。
          * @return 粒子发射速率 (个/秒)。
          */
         get emissionRate() {
             return this._emissionRate;
         }
         /**
          * 获取是否已销毁。
          * @return 是否已销毁。
          */
         get destroyed() {
             return this._destroyed;
         }
         /**
          * 创建一个 <code>Emission</code> 实例。
          */
         constructor() {
             this._destroyed = false;
             this.emissionRate = 10;
             this._bursts = [];
         }
         /**
          * @private
          */
         destroy() {
             this._bursts = null;
             this._destroyed = true;
         }
         /**
          * 获取粒子爆裂个数。
          * @return 粒子爆裂个数。
          */
         getBurstsCount() {
             return this._bursts.length;
         }
         /**
          * 通过索引获取粒子爆裂。
          * @param index 爆裂索引。
          * @return 粒子爆裂。
          */
         getBurstByIndex(index) {
             return this._bursts[index];
         }
         /**
          * 增加粒子爆裂。
          * @param burst 爆裂。
          */
         addBurst(burst) {
             var burstsCount = this._bursts.length;
             if (burstsCount > 0)
                 for (var i = 0; i < burstsCount; i++) {
                     if (this._bursts[i].time > burst.time)
                         this._bursts.splice(i, 0, burst);
                 }
             this._bursts.push(burst);
         }
         /**
          * 移除粒子爆裂。
          * @param burst 爆裂。
          */
         removeBurst(burst) {
             var index = this._bursts.indexOf(burst);
             if (index !== -1) {
                 this._bursts.splice(index, 1);
             }
         }
         /**
          * 通过索引移除粒子爆裂。
          * @param index 爆裂索引。
          */
         removeBurstByIndex(index) {
             this._bursts.splice(index, 1);
         }
         /**
          * 清空粒子爆裂。
          */
         clearBurst() {
             this._bursts.length = 0;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destEmission = destObject;
             var destBursts = destEmission._bursts;
             destBursts.length = this._bursts.length;
             for (var i = 0, n = this._bursts.length; i < n; i++) {
                 var destBurst = destBursts[i];
                 if (destBurst)
                     this._bursts[i].cloneTo(destBurst);
                 else
                     destBursts[i] = this._bursts[i].clone();
             }
             destEmission._emissionRate = this._emissionRate;
             destEmission.enbale = this.enbale;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destEmission = new Vector3();
             this.cloneTo(destEmission);
             return destEmission;
         }
     }

     /**
      * <code>GradientDataNumber</code> 类用于创建浮点渐变。
      */
     class GradientDataNumber {
         /**
          * 创建一个 <code>GradientDataNumber</code> 实例。
          */
         constructor() {
             /**@private */
             this._currentLength = 0;
             this._elements = new Float32Array(8);
         }
         /**渐变浮点数量。*/
         get gradientCount() {
             return this._currentLength / 2;
         }
         /**
          * 增加浮点渐变。
          * @param	key 生命周期，范围为0到1。
          * @param	value 浮点值。
          */
         add(key, value) {
             if (this._currentLength < 8) {
                 if ((this._currentLength === 6) && ((key !== 1))) {
                     key = 1;
                     console.log("GradientDataNumber warning:the forth key is  be force set to 1.");
                 }
                 this._elements[this._currentLength++] = key;
                 this._elements[this._currentLength++] = value;
             }
             else {
                 console.log("GradientDataNumber warning:data count must lessEqual than 4");
             }
         }
         /**
          * 通过索引获取键。
          * @param	index 索引。
          * @return	value 键。
          */
         getKeyByIndex(index) {
             return this._elements[index * 2];
         }
         /**
          * 通过索引获取值。
          * @param	index 索引。
          * @return	value 值。
          */
         getValueByIndex(index) {
             return this._elements[index * 2 + 1];
         }
         /**
          * 获取平均值。
          */
         getAverageValue() {
             var total = 0;
             for (var i = 0, n = this._currentLength - 2; i < n; i += 2) {
                 var subValue = this._elements[i + 1];
                 subValue += this._elements[i + 3];
                 subValue = subValue * (this._elements[i + 2] - this._elements[i]);
             }
             return total / 2;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destGradientDataNumber = destObject;
             destGradientDataNumber._currentLength = this._currentLength;
             var destElements = destGradientDataNumber._elements;
             for (var i = 0, n = this._elements.length; i < n; i++)
                 destElements[i] = this._elements[i];
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destGradientDataNumber = new GradientDataNumber();
             this.cloneTo(destGradientDataNumber);
             return destGradientDataNumber;
         }
     }

     /**
      * ...
      * @author ...
      */
     class VertexShuriKenParticle {
         constructor() {
         }
     }
     VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0 = 0;
     VertexShuriKenParticle.PARTICLE_POSITION0 = 1;
     VertexShuriKenParticle.PARTICLE_COLOR0 = 2;
     VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0 = 3;
     VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4;
     VertexShuriKenParticle.PARTICLE_DIRECTIONTIME = 5;
     VertexShuriKenParticle.PARTICLE_STARTCOLOR0 = 6;
     VertexShuriKenParticle.PARTICLE_ENDCOLOR0 = 7;
     VertexShuriKenParticle.PARTICLE_STARTSIZE = 8;
     VertexShuriKenParticle.PARTICLE_STARTROTATION = 9;
     VertexShuriKenParticle.PARTICLE_STARTSPEED = 10;
     VertexShuriKenParticle.PARTICLE_RANDOM0 = 11;
     VertexShuriKenParticle.PARTICLE_RANDOM1 = 12;
     VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION = 13;
     VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION = 14;

     /**
      * <code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
      */
     class VertexShurikenParticleBillboard extends VertexShuriKenParticle {
         constructor(cornerTextureCoordinate, positionStartLifeTime, velocity, startColor, startSize, startRotation0, startRotation1, startRotation2, ageAddScale, time, startSpeed, randoms0, randoms1, simulationWorldPostion) {
             super();
             this._cornerTextureCoordinate = cornerTextureCoordinate;
             this._positionStartLifeTime = positionStartLifeTime;
             this._velocity = velocity;
             this._startColor = startColor;
             this._startSize = startSize;
             this._startRotation0 = startRotation0;
             this._startRotation1 = startRotation1;
             this._startRotation2 = startRotation2;
             this._startLifeTime = ageAddScale;
             this._time = time;
             this._startSpeed = startSpeed;
             this._randoms0 = this.random0;
             this._randoms1 = this.random1;
             this._simulationWorldPostion = simulationWorldPostion;
         }
         static get vertexDeclaration() {
             return VertexShurikenParticleBillboard._vertexDeclaration;
         }
         get cornerTextureCoordinate() {
             return this._cornerTextureCoordinate;
         }
         get positionStartLifeTime() {
             return this._positionStartLifeTime;
         }
         get velocity() {
             return this._velocity;
         }
         get startColor() {
             return this._startColor;
         }
         get startSize() {
             return this._startSize;
         }
         get startRotation0() {
             return this._startRotation0;
         }
         get startRotation1() {
             return this._startRotation1;
         }
         get startRotation2() {
             return this._startRotation2;
         }
         get startLifeTime() {
             return this._startLifeTime;
         }
         get time() {
             return this._time;
         }
         get startSpeed() {
             return this._startSpeed;
         }
         get random0() {
             return this._randoms0;
         }
         get random1() {
             return this._randoms1;
         }
         get simulationWorldPostion() {
             return this._simulationWorldPostion;
         }
     }
     /**@private */
     VertexShurikenParticleBillboard._vertexDeclaration = new VertexDeclaration(152, [new VertexElement(0, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0),
         new VertexElement(16, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME),
         new VertexElement(32, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME),
         new VertexElement(48, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_STARTCOLOR0),
         new VertexElement(64, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTSIZE),
         new VertexElement(76, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTROTATION),
         new VertexElement(88, VertexElementFormat.Single, VertexShuriKenParticle.PARTICLE_STARTSPEED),
         new VertexElement(92, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM0),
         new VertexElement(108, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM1),
         new VertexElement(124, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION),
         new VertexElement(136, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION)]);

     /**
         /**
          * <code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
          */
     class VertexShurikenParticleMesh extends VertexShuriKenParticle {
         constructor(cornerTextureCoordinate, positionStartLifeTime, velocity, startColor, startSize, startRotation0, startRotation1, startRotation2, ageAddScale, time, startSpeed, randoms0, randoms1, simulationWorldPostion) {
             super();
             this._cornerTextureCoordinate = cornerTextureCoordinate;
             this._positionStartLifeTime = positionStartLifeTime;
             this._velocity = velocity;
             this._startColor = startColor;
             this._startSize = startSize;
             this._startRotation0 = startRotation0;
             this._startRotation1 = startRotation1;
             this._startRotation2 = startRotation2;
             this._startLifeTime = ageAddScale;
             this._time = time;
             this._startSpeed = startSpeed;
             this._randoms0 = this.random0;
             this._randoms1 = this.random1;
             this._simulationWorldPostion = simulationWorldPostion;
         }
         static get vertexDeclaration() {
             return VertexShurikenParticleMesh._vertexDeclaration;
         }
         get cornerTextureCoordinate() {
             return this._cornerTextureCoordinate;
         }
         get position() {
             return this._positionStartLifeTime;
         }
         get velocity() {
             return this._velocity;
         }
         get startColor() {
             return this._startColor;
         }
         get startSize() {
             return this._startSize;
         }
         get startRotation0() {
             return this._startRotation0;
         }
         get startRotation1() {
             return this._startRotation1;
         }
         get startRotation2() {
             return this._startRotation2;
         }
         get startLifeTime() {
             return this._startLifeTime;
         }
         get time() {
             return this._time;
         }
         get startSpeed() {
             return this._startSpeed;
         }
         get random0() {
             return this._randoms0;
         }
         get random1() {
             return this._randoms1;
         }
         get simulationWorldPostion() {
             return this._simulationWorldPostion;
         }
     }
     /**@private */
     VertexShurikenParticleMesh._vertexDeclaration = new VertexDeclaration(172, [new VertexElement(0, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_POSITION0),
         new VertexElement(12, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_COLOR0),
         new VertexElement(28, VertexElementFormat.Vector2, VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0),
         new VertexElement(36, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME),
         new VertexElement(52, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME),
         new VertexElement(68, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_STARTCOLOR0),
         new VertexElement(84, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTSIZE),
         new VertexElement(96, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTROTATION),
         new VertexElement(108, VertexElementFormat.Single, VertexShuriKenParticle.PARTICLE_STARTSPEED),
         new VertexElement(112, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM0),
         new VertexElement(128, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM1),
         new VertexElement(144, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION),
         new VertexElement(156, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION)]);

     /**
          * <code>Rand</code> 类用于通过32位无符号整型随机种子创建随机数。
          */
     class Rand {
         /**
          * 创建一个 <code>Rand</code> 实例。
          * @param	seed  32位无符号整型随机种子。
          */
         constructor(seed) {
             /**@private */
             this._temp = new Uint32Array(1);
             /**获取随机种子。*/
             this.seeds = new Uint32Array(4);
             this.seeds[0] = seed;
             this.seeds[1] = this.seeds[0] * 0x6C078965 /*1812433253U*/ + 1;
             this.seeds[2] = this.seeds[1] * 0x6C078965 /*1812433253U*/ + 1;
             this.seeds[3] = this.seeds[2] * 0x6C078965 /*1812433253U*/ + 1;
         }
         /**
          * 通过无符号32位整形，获取32位浮点随机数。
          * @param 无符号32位整形随机数。
          * @return 32位浮点随机数。
          */
         static getFloatFromInt(v) {
             // take 23 bits of integer, and divide by 2^23-1
             return (v & 0x007FFFFF) * (1.0 / 8388607.0);
         }
         /**
          * 通过无符号32位整形，获取无符号8位字节随机数。
          * @param 无符号32位整形随机数。
          * @return 无符号8位字节随机数。
          */
         static getByteFromInt(v) {
             // take the most significant byte from the 23-bit value
             return (v & 0x007FFFFF) >>> 15 /*(23-8)*/;
         }
         /**
          * 获取随机种子。
          * @return 随机种子。
          */
         get seed() {
             return this.seeds[0];
         }
         /**
          * 设置随机种子。
          * @param	seed 随机种子。
          */
         set seed(seed) {
             this.seeds[0] = seed;
             this.seeds[1] = this.seeds[0] * 0x6C078965 /*1812433253U*/ + 1;
             this.seeds[2] = this.seeds[1] * 0x6C078965 /*1812433253U*/ + 1;
             this.seeds[3] = this.seeds[2] * 0x6C078965 /*1812433253U*/ + 1;
         }
         /**
          * 获取无符号32位整形随机数。
          * @return 无符号32位整形随机数。
          */
         getUint() {
             this._temp[0] = this.seeds[0] ^ (this.seeds[0] << 11);
             this.seeds[0] = this.seeds[1];
             this.seeds[1] = this.seeds[2];
             this.seeds[2] = this.seeds[3];
             this.seeds[3] = (this.seeds[3] ^ (this.seeds[3] >>> 19)) ^ (this._temp[0] ^ (this._temp[0] >>> 8));
             return this.seeds[3];
         }
         /**
          * 获取0到1之间的浮点随机数。
          * @return 0到1之间的浮点随机数。
          */
         getFloat() {
             this.getUint();
             return (this.seeds[3] & 0x007FFFFF) * (1.0 / 8388607.0);
         }
         /**
          * 获取-1到1之间的浮点随机数。
          * @return -1到1之间的浮点随机数。
          */
         getSignedFloat() {
             return this.getFloat() * 2.0 - 1.0;
         }
     }

     /**
      * <code>ShurikenParticleSystem</code> 类用于创建3D粒子数据模板。
      */
     class ShurikenParticleSystem extends GeometryElement {
         constructor(owner) {
             super();
             /** @private */
             this._tempRotationMatrix = new Matrix4x4();
             /** @private */
             this._boundingSphere = null;
             /** @private */
             this._boundingBox = null;
             /** @private */
             this._boundingBoxCorners = null;
             /** @private */
             this._owner = null;
             /** @private */
             this._ownerRender = null;
             /**@private */
             this._vertices = null;
             /**@private */
             this._floatCountPerVertex = 0;
             /**@private */
             this._startLifeTimeIndex = 0;
             /**@private */
             this._timeIndex = 0;
             /**@private */
             this._simulateUpdate = false;
             /**@private */
             this._firstActiveElement = 0;
             /**@private */
             this._firstNewElement = 0;
             /**@private */
             this._firstFreeElement = 0;
             /**@private */
             this._firstRetiredElement = 0;
             /**@private */
             this._drawCounter = 0;
             /**@private */
             this._bufferMaxParticles = 0;
             /**@private */
             this._emission = null;
             /**@private */
             this._shape = null;
             /**@private */
             this._isEmitting = false;
             /**@private */
             this._isPlaying = false;
             /**@private */
             this._isPaused = false;
             /**@private */
             this._playStartDelay = 0;
             /**@private 发射的累计时间。*/
             this._frameRateTime = 0;
             /**@private 一次循环内的累计时间。*/
             this._emissionTime = 0;
             /**@private */
             this._totalDelayTime = 0;
             /**@private */
             this._burstsIndex = 0;
             ///**@private 发射粒子最小时间间隔。*/
             //private var _minEmissionTime:Number;
             /**@private */
             this._velocityOverLifetime = null;
             /**@private */
             this._colorOverLifetime = null;
             /**@private */
             this._sizeOverLifetime = null;
             /**@private */
             this._rotationOverLifetime = null;
             /**@private */
             this._textureSheetAnimation = null;
             /**@private */
             this._startLifetimeType = 0;
             /**@private */
             this._startLifetimeConstant = 0;
             /**@private */
             this._startLifeTimeGradient = null;
             /**@private */
             this._startLifetimeConstantMin = 0;
             /**@private */
             this._startLifetimeConstantMax = 0;
             /**@private */
             this._startLifeTimeGradientMin = null;
             /**@private */
             this._startLifeTimeGradientMax = null;
             /**@private */
             this._maxStartLifetime = 0;
             /** @private */
             this._uvLength = new Vector2(); //TODO:
             /** @private */
             this._vertexStride = 0;
             /** @private */
             this._indexStride = 0;
             /**@private */
             this._vertexBuffer = null;
             /**@private */
             this._indexBuffer = null;
             /** @private */
             this._bufferState = new BufferState();
             /**@private */
             this._currentTime = 0;
             /**@private */
             this._startUpdateLoopCount = 0;
             /**@private */
             this._rand = null;
             /**@private */
             this._randomSeeds = null;
             /**粒子运行的总时长，单位为秒。*/
             this.duration = 0;
             /**是否循环。*/
             this.looping = false;
             /**是否预热。暂不支持*/
             this.prewarm = false;
             /**开始延迟类型，0为常量模式,1为随机随机双常量模式，不能和prewarm一起使用。*/
             this.startDelayType = 0;
             /**开始播放延迟，不能和prewarm一起使用。*/
             this.startDelay = 0;
             /**开始播放最小延迟，不能和prewarm一起使用。*/
             this.startDelayMin = 0;
             /**开始播放最大延迟，不能和prewarm一起使用。*/
             this.startDelayMax = 0;
             /**开始速度模式，0为恒定速度，2为两个恒定速度的随机插值。缺少1、3模式*/
             this.startSpeedType = 0;
             /**开始速度,0模式。*/
             this.startSpeedConstant = 0;
             /**最小开始速度,1模式。*/
             this.startSpeedConstantMin = 0;
             /**最大开始速度,1模式。*/
             this.startSpeedConstantMax = 0;
             /**开始尺寸是否为3D模式。*/
             this.threeDStartSize = false;
             /**开始尺寸模式,0为恒定尺寸，2为两个恒定尺寸的随机插值。缺少1、3模式和对应的二种3D模式*/
             this.startSizeType = 0;
             /**开始尺寸，0模式。*/
             this.startSizeConstant = 0;
             /**开始三维尺寸，0模式。*/
             this.startSizeConstantSeparate = null;
             /**最小开始尺寸，2模式。*/
             this.startSizeConstantMin = 0;
             /**最大开始尺寸，2模式。*/
             this.startSizeConstantMax = 0;
             /**最小三维开始尺寸，2模式。*/
             this.startSizeConstantMinSeparate = null;
             /**最大三维开始尺寸，2模式。*/
             this.startSizeConstantMaxSeparate = null;
             /**3D开始旋转，暂不支持*/
             this.threeDStartRotation = false;
             /**开始旋转模式,0为恒定尺寸，2为两个恒定旋转的随机插值,缺少2种模式,和对应的四种3D模式。*/
             this.startRotationType = 0;
             /**开始旋转，0模式。*/
             this.startRotationConstant = 0;
             /**开始三维旋转，0模式。*/
             this.startRotationConstantSeparate = null;
             /**最小开始旋转，1模式。*/
             this.startRotationConstantMin = 0;
             /**最大开始旋转，1模式。*/
             this.startRotationConstantMax = 0;
             /**最小开始三维旋转，1模式。*/
             this.startRotationConstantMinSeparate = null;
             /**最大开始三维旋转，1模式。*/
             this.startRotationConstantMaxSeparate = null;
             /**随机旋转方向，范围为0.0到1.0*/
             this.randomizeRotationDirection = 0;
             /**开始颜色模式，0为恒定颜色，2为两个恒定颜色的随机插值,缺少2种模式。*/
             this.startColorType = 0;
             /**开始颜色，0模式。*/
             this.startColorConstant = null;
             /**最小开始颜色，1模式。*/
             this.startColorConstantMin = null;
             /**最大开始颜色，1模式。*/
             this.startColorConstantMax = null;
             /**重力敏感度。*/
             this.gravityModifier = 0;
             /**模拟器空间,0为World,1为Local。暂不支持Custom。*/
             this.simulationSpace = 0;
             /**缩放模式，0为Hiercachy,1为Local,2为World。*/
             this.scaleMode = 0;
             /**激活时是否自动播放。*/
             this.playOnAwake = false;
             /**随机种子,注:play()前设置有效。*/
             this.randomSeed = null;
             /**是否使用随机种子。 */
             this.autoRandomSeed = false;
             /**是否为性能模式,性能模式下会延迟粒子释放。*/
             this.isPerformanceMode = false;
             this._firstActiveElement = 0;
             this._firstNewElement = 0;
             this._firstFreeElement = 0;
             this._firstRetiredElement = 0;
             this._owner = owner;
             this._ownerRender = owner.particleRenderer;
             this._boundingBoxCorners = [];
             this._boundingSphere = new BoundSphere(new Vector3(), Number.MAX_VALUE); //TODO:
             this._boundingBox = new BoundBox(new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)); //TODO:
             this._currentTime = 0;
             this._isEmitting = false;
             this._isPlaying = false;
             this._isPaused = false;
             this._burstsIndex = 0;
             this._frameRateTime = 0;
             this._emissionTime = 0;
             this._totalDelayTime = 0;
             this._simulateUpdate = false;
             this._bufferMaxParticles = 1;
             this.duration = 5.0;
             this.looping = true;
             this.prewarm = false;
             this.startDelayType = 0;
             this.startDelay = 0.0;
             this.startDelayMin = 0.0;
             this.startDelayMax = 0.0;
             this._startLifetimeType = 0;
             this._startLifetimeConstant = 5.0;
             this._startLifeTimeGradient = new GradientDataNumber();
             this._startLifetimeConstantMin = 0.0;
             this._startLifetimeConstantMax = 5.0;
             this._startLifeTimeGradientMin = new GradientDataNumber();
             this._startLifeTimeGradientMax = new GradientDataNumber();
             this._maxStartLifetime = 5.0; //_startLifetimeType默认为0，_startLifetimeConstant为5.0,因此该值为5.0
             this.startSpeedType = 0;
             this.startSpeedConstant = 5.0;
             this.startSpeedConstantMin = 0.0;
             this.startSpeedConstantMax = 5.0;
             this.threeDStartSize = false;
             this.startSizeType = 0;
             this.startSizeConstant = 1;
             this.startSizeConstantSeparate = new Vector3(1, 1, 1);
             this.startSizeConstantMin = 0;
             this.startSizeConstantMax = 1;
             this.startSizeConstantMinSeparate = new Vector3(0, 0, 0);
             this.startSizeConstantMaxSeparate = new Vector3(1, 1, 1);
             this.threeDStartRotation = false;
             this.startRotationType = 0;
             this.startRotationConstant = 0;
             this.startRotationConstantSeparate = new Vector3(0, 0, 0);
             this.startRotationConstantMin = 0.0;
             this.startRotationConstantMax = 0.0;
             this.startRotationConstantMinSeparate = new Vector3(0, 0, 0);
             this.startRotationConstantMaxSeparate = new Vector3(0, 0, 0);
             this.randomizeRotationDirection = 0.0;
             this.startColorType = 0;
             this.startColorConstant = new Vector4(1, 1, 1, 1);
             this.startColorConstantMin = new Vector4(1, 1, 1, 1);
             this.startColorConstantMax = new Vector4(1, 1, 1, 1);
             this.gravityModifier = 0.0;
             this.simulationSpace = 1;
             this.scaleMode = 0;
             this.playOnAwake = true;
             this._rand = new Rand(0);
             this.autoRandomSeed = true;
             this.randomSeed = new Uint32Array(1);
             this._randomSeeds = new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length);
             this.isPerformanceMode = true;
             this._emission = new Emission();
             this._emission.enbale = true;
         }
         /**获取最大粒子数。*/
         get maxParticles() {
             return this._bufferMaxParticles - 1;
         }
         /**设置最大粒子数,注意:谨慎修改此属性，有性能损耗。*/
         set maxParticles(value) {
             var newMaxParticles = value + 1;
             if (newMaxParticles !== this._bufferMaxParticles) {
                 this._bufferMaxParticles = newMaxParticles;
                 this._initBufferDatas();
             }
         }
         /**
          * 获取发射器。
          */
         get emission() {
             return this._emission;
         }
         /**
          * 粒子存活个数。
          */
         get aliveParticleCount() {
             if (this._firstNewElement >= this._firstRetiredElement)
                 return this._firstNewElement - this._firstRetiredElement;
             else
                 return this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
         }
         /**
          * 获取一次循环内的累计时间。
          * @return 一次循环内的累计时间。
          */
         get emissionTime() {
             return this._emissionTime > this.duration ? this.duration : this._emissionTime;
         }
         /**
          * 获取形状。
          */
         get shape() {
             return this._shape;
         }
         /**
          * 设置形状。
          */
         set shape(value) {
             if (this._shape !== value) {
                 if (value && value.enable)
                     this._owner._render._shaderValues.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SHAPE);
                 else
                     this._owner._render._shaderValues.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SHAPE);
                 this._shape = value;
             }
         }
         /**
          * 是否存活。
          */
         get isAlive() {
             if (this._isPlaying || this.aliveParticleCount > 0) //TODO:暂时忽略retired
                 return true;
             return false;
         }
         /**
          * 是否正在发射。
          */
         get isEmitting() {
             return this._isEmitting;
         }
         /**
          * 是否正在播放。
          */
         get isPlaying() {
             return this._isPlaying;
         }
         /**
          * 是否已暂停。
          */
         get isPaused() {
             return this._isPaused;
         }
         /**
          * 获取开始生命周期模式,0为固定时间，1为渐变时间，2为两个固定之间的随机插值,3为两个渐变时间的随机插值。
          */
         get startLifetimeType() {
             return this._startLifetimeType;
         }
         /**
          * 设置开始生命周期模式,0为固定时间，1为渐变时间，2为两个固定之间的随机插值,3为两个渐变时间的随机插值。
          */
         set startLifetimeType(value) {
             //if (value !== _startLifetimeType){
             var i, n;
             switch (this.startLifetimeType) {
                 case 0:
                     this._maxStartLifetime = this.startLifetimeConstant;
                     break;
                 case 1:
                     this._maxStartLifetime = -Number.MAX_VALUE;
                     var startLifeTimeGradient = startLifeTimeGradient;
                     for (i = 0, n = startLifeTimeGradient.gradientCount; i < n; i++)
                         this._maxStartLifetime = Math.max(this._maxStartLifetime, startLifeTimeGradient.getValueByIndex(i));
                     break;
                 case 2:
                     this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                     break;
                 case 3:
                     this._maxStartLifetime = -Number.MAX_VALUE;
                     var startLifeTimeGradientMin = startLifeTimeGradientMin;
                     for (i = 0, n = startLifeTimeGradientMin.gradientCount; i < n; i++)
                         this._maxStartLifetime = Math.max(this._maxStartLifetime, startLifeTimeGradientMin.getValueByIndex(i));
                     var startLifeTimeGradientMax = startLifeTimeGradientMax;
                     for (i = 0, n = startLifeTimeGradientMax.gradientCount; i < n; i++)
                         this._maxStartLifetime = Math.max(this._maxStartLifetime, startLifeTimeGradientMax.getValueByIndex(i));
                     break;
             }
             this._startLifetimeType = value;
             //}
         }
         /**
          * 获取开始生命周期，0模式,单位为秒。
          */
         get startLifetimeConstant() {
             return this._startLifetimeConstant;
         }
         /**
          * 设置开始生命周期，0模式,单位为秒。
          */
         set startLifetimeConstant(value) {
             if (this._startLifetimeType === 0)
                 this._maxStartLifetime = value;
             this._startLifetimeConstant = value;
         }
         /**
          * 获取开始渐变生命周期，1模式,单位为秒。
          */
         get startLifeTimeGradient() {
             return this._startLifeTimeGradient;
         }
         /**
          * 设置开始渐变生命周期，1模式,单位为秒。
          */
         set startLifeTimeGradient(value) {
             if (this._startLifetimeType === 1) {
                 this._maxStartLifetime = -Number.MAX_VALUE;
                 for (var i = 0, n = value.gradientCount; i < n; i++)
                     this._maxStartLifetime = Math.max(this._maxStartLifetime, value.getValueByIndex(i));
             }
             this._startLifeTimeGradient = value;
         }
         /**
          * 获取最小开始生命周期，2模式,单位为秒。
          */
         get startLifetimeConstantMin() {
             return this._startLifetimeConstantMin;
         }
         /**
          * 设置最小开始生命周期，2模式,单位为秒。
          */
         set startLifetimeConstantMin(value) {
             if (this._startLifetimeType === 2)
                 this._maxStartLifetime = Math.max(value, this._startLifetimeConstantMax);
             this._startLifetimeConstantMin = value;
         }
         /**
          * 获取最大开始生命周期，2模式,单位为秒。
          */
         get startLifetimeConstantMax() {
             return this._startLifetimeConstantMax;
         }
         /**
          * 设置最大开始生命周期，2模式,单位为秒。
          */
         set startLifetimeConstantMax(value) {
             if (this._startLifetimeType === 2)
                 this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, value);
             this._startLifetimeConstantMax = value;
         }
         /**
          * 获取开始渐变最小生命周期，3模式,单位为秒。
          */
         get startLifeTimeGradientMin() {
             return this._startLifeTimeGradientMin;
         }
         /**
          * 设置开始渐变最小生命周期，3模式,单位为秒。
          */
         set startLifeTimeGradientMin(value) {
             if (this._startLifetimeType === 3) {
                 var i, n;
                 this._maxStartLifetime = -Number.MAX_VALUE;
                 for (i = 0, n = value.gradientCount; i < n; i++)
                     this._maxStartLifetime = Math.max(this._maxStartLifetime, value.getValueByIndex(i));
                 for (i = 0, n = this._startLifeTimeGradientMax.gradientCount; i < n; i++)
                     this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(i));
             }
             this._startLifeTimeGradientMin = value;
         }
         /**
          * 获取开始渐变最大生命周期，3模式,单位为秒。
          */
         get startLifeTimeGradientMax() {
             return this._startLifeTimeGradientMax;
         }
         /**
          * 设置开始渐变最大生命周期，3模式,单位为秒。
          */
         set startLifeTimeGradientMax(value) {
             if (this._startLifetimeType === 3) {
                 var i, n;
                 this._maxStartLifetime = -Number.MAX_VALUE;
                 for (i = 0, n = this._startLifeTimeGradientMin.gradientCount; i < n; i++)
                     this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(i));
                 for (i = 0, n = value.gradientCount; i < n; i++)
                     this._maxStartLifetime = Math.max(this._maxStartLifetime, value.getValueByIndex(i));
             }
             this._startLifeTimeGradientMax = value;
         }
         /**
          * 获取生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @return 生命周期速度.
          */
         get velocityOverLifetime() {
             return this._velocityOverLifetime;
         }
         /**
          * 设置生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @param value 生命周期速度.
          */
         set velocityOverLifetime(value) {
             var shaDat = this._owner._render._shaderValues;
             if (value) {
                 var velocity = value.velocity;
                 var velocityType = velocity.type;
                 if (value.enbale) {
                     switch (velocityType) {
                         case 0:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                             break;
                         case 1:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                             break;
                         case 2:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                             break;
                         case 3:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                             break;
                     }
                 }
                 else {
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                 }
                 switch (velocityType) {
                     case 0:
                         shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, velocity.constant);
                         break;
                     case 1:
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, velocity.gradientX._elements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, velocity.gradientY._elements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, velocity.gradientZ._elements);
                         break;
                     case 2:
                         shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, velocity.constantMin);
                         shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONSTMAX, velocity.constantMax);
                         break;
                     case 3:
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, velocity.gradientXMin._elements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTXMAX, velocity.gradientXMax._elements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, velocity.gradientYMin._elements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTYMAX, velocity.gradientYMax._elements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, velocity.gradientZMin._elements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZMAX, velocity.gradientZMax._elements);
                         break;
                 }
                 shaDat.setInt(ShuriKenParticle3DShaderDeclaration.VOLSPACETYPE, value.space);
             }
             else {
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                 shaDat.setVector(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, null);
                 shaDat.setVector(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, null);
                 shaDat.setVector(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONSTMAX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTXMAX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTYMAX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZMAX, null);
                 shaDat.setInt(ShuriKenParticle3DShaderDeclaration.VOLSPACETYPE, undefined);
             }
             this._velocityOverLifetime = value;
         }
         /**
          * 获取生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @return 生命周期颜色
          */
         get colorOverLifetime() {
             return this._colorOverLifetime;
         }
         /**
          * 设置生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @param value 生命周期颜色
          */
         set colorOverLifetime(value) {
             var shaDat = this._owner._render._shaderValues;
             if (value) {
                 var color = value.color;
                 if (value.enbale) {
                     switch (color.type) {
                         case 1:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME);
                             break;
                         case 3:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                             break;
                     }
                 }
                 else {
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                 }
                 switch (color.type) {
                     case 1:
                         var gradientColor = color.gradient;
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, gradientColor._alphaElements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, gradientColor._rgbElements);
                         break;
                     case 3:
                         var minGradientColor = color.gradientMin;
                         var maxGradientColor = color.gradientMax;
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, minGradientColor._alphaElements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, minGradientColor._rgbElements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS, maxGradientColor._alphaElements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS, maxGradientColor._rgbElements);
                         break;
                 }
             }
             else {
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, gradientColor._alphaElements);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, gradientColor._rgbElements);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, minGradientColor._alphaElements);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, minGradientColor._rgbElements);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS, maxGradientColor._alphaElements);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS, maxGradientColor._rgbElements);
             }
             this._colorOverLifetime = value;
         }
         /**
          * 获取生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @return 生命周期尺寸
          */
         get sizeOverLifetime() {
             return this._sizeOverLifetime;
         }
         /**
          * 设置生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @param value 生命周期尺寸
          */
         set sizeOverLifetime(value) {
             var shaDat = this._owner._render._shaderValues;
             if (value) {
                 var size = value.size;
                 var sizeSeparate = size.separateAxes;
                 var sizeType = size.type;
                 if (value.enbale) {
                     switch (sizeType) {
                         case 0:
                             if (sizeSeparate)
                                 shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
                             else
                                 shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                             break;
                         case 2:
                             if (sizeSeparate)
                                 shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                             else
                                 shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                             break;
                     }
                 }
                 else {
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                 }
                 switch (sizeType) {
                     case 0:
                         if (sizeSeparate) {
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX, size.gradientX._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY, size.gradientY._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ, size.gradientZ._elements);
                         }
                         else {
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT, size.gradient._elements);
                         }
                         break;
                     case 2:
                         if (sizeSeparate) {
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX, size.gradientXMin._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTXMAX, size.gradientXMax._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY, size.gradientYMin._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTYMAX, size.gradientYMax._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ, size.gradientZMin._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZMAX, size.gradientZMax._elements);
                         }
                         else {
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT, size.gradientMin._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientMax, size.gradientMax._elements);
                         }
                         break;
                 }
             }
             else {
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTXMAX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTYMAX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZMAX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientMax, null);
             }
             this._sizeOverLifetime = value;
         }
         /**
          * 获取生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @return 生命周期旋转。
          */
         get rotationOverLifetime() {
             return this._rotationOverLifetime;
         }
         /**
          * 设置生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @param value 生命周期旋转。
          */
         set rotationOverLifetime(value) {
             var shaDat = this._owner._render._shaderValues;
             if (value) {
                 var rotation = value.angularVelocity;
                 if (!rotation) //TODO:兼容代码，RotationOverLifetime未支持全可能为空
                     return;
                 var rotationSeparate = rotation.separateAxes;
                 var rotationType = rotation.type;
                 if (value.enbale) {
                     if (rotationSeparate)
                         shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
                     else
                         shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME);
                     switch (rotationType) {
                         case 0:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                             break;
                         case 1:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                             break;
                         case 2:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                             break;
                         case 3:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                             break;
                     }
                 }
                 else {
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                 }
                 switch (rotationType) {
                     case 0:
                         if (rotationSeparate) {
                             shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE, rotation.constantSeparate);
                         }
                         else {
                             shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST, rotation.constant);
                         }
                         break;
                     case 1:
                         if (rotationSeparate) {
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX, rotation.gradientX._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY, rotation.gradientY._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ, rotation.gradientZ._elements);
                         }
                         else {
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT, rotation.gradient._elements);
                         }
                         break;
                     case 2:
                         if (rotationSeparate) {
                             shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE, rotation.constantMinSeparate);
                             shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAXSEPRARATE, rotation.constantMaxSeparate);
                         }
                         else {
                             shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST, rotation.constantMin);
                             shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAX, rotation.constantMax);
                         }
                         break;
                     case 3:
                         if (rotationSeparate) {
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX, rotation.gradientXMin._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTXMAX, rotation.gradientXMax._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY, rotation.gradientYMin._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTYMAX, rotation.gradientYMax._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ, rotation.gradientZMin._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZMAX, rotation.gradientZMax._elements);
                             //shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTW, rotation.gradientWMin._elements);
                             //shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTWMAX, rotation.gradientWMax._elements);
                         }
                         else {
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT, rotation.gradientMin._elements);
                             shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTMAX, rotation.gradientMax._elements);
                         }
                         break;
                 }
             }
             else {
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                 shaDat.setVector(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE, null);
                 shaDat.setVector(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAXSEPRARATE, null);
                 shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST, undefined);
                 shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAX, undefined);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTXMAX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTYMAX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZMAX, null);
                 //shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTW, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTWMAX, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTMAX, null);
             }
             this._rotationOverLifetime = value;
         }
         /**
          * 获取生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @return 生命周期纹理动画。
          */
         get textureSheetAnimation() {
             return this._textureSheetAnimation;
         }
         /**
          * 设置生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
          * @param value 生命周期纹理动画。
          */
         set textureSheetAnimation(value) {
             var shaDat = this._owner._render._shaderValues;
             if (value) {
                 var frameOverTime = value.frame;
                 var textureAniType = frameOverTime.type;
                 if (value.enable) {
                     switch (textureAniType) {
                         case 1:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                             break;
                         case 3:
                             shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                             break;
                     }
                 }
                 else {
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                     shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                 }
                 if (textureAniType === 1 || textureAniType === 3) {
                     shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONCYCLES, value.cycles);
                     var title = value.tiles;
                     var _uvLengthE = this._uvLength;
                     _uvLengthE.x = 1.0 / title.x;
                     _uvLengthE.y = 1.0 / title.y;
                     shaDat.setVector2(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                 }
                 switch (textureAniType) {
                     case 1:
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS, frameOverTime.frameOverTimeData._elements);
                         break;
                     case 3:
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS, frameOverTime.frameOverTimeDataMin._elements);
                         shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTMAXUVS, frameOverTime.frameOverTimeDataMax._elements);
                         break;
                 }
             }
             else {
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                 shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                 shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONCYCLES, undefined);
                 shaDat.setVector(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONSUBUVLENGTH, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS, null);
                 shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTMAXUVS, null);
             }
             this._textureSheetAnimation = value;
         }
         _getVertexBuffer(index = 0) {
             if (index === 0)
                 return this._vertexBuffer;
             else
                 return null;
         }
         _getIndexBuffer() {
             return this._indexBuffer;
         }
         /**
          * @private
          */
         _generateBoundingSphere() {
             var centerE = this._boundingSphere.center;
             centerE.x = 0;
             centerE.y = 0;
             centerE.z = 0;
             this._boundingSphere.radius = Number.MAX_VALUE;
         }
         /**
          * @private
          */
         _generateBoundingBox() {
             var particle = this._owner;
             var particleRender = particle.particleRenderer;
             var boundMin = this._boundingBox.min;
             var boundMax = this._boundingBox.max;
             var i, n;
             //MaxLifeTime
             var maxStartLifeTime;
             switch (this.startLifetimeType) {
                 case 0:
                     maxStartLifeTime = this.startLifetimeConstant;
                     break;
                 case 1:
                     maxStartLifeTime = -Number.MAX_VALUE;
                     var startLifeTimeGradient = startLifeTimeGradient;
                     for (i = 0, n = startLifeTimeGradient.gradientCount; i < n; i++)
                         maxStartLifeTime = Math.max(maxStartLifeTime, startLifeTimeGradient.getValueByIndex(i));
                     break;
                 case 2:
                     maxStartLifeTime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                     break;
                 case 3:
                     maxStartLifeTime = -Number.MAX_VALUE;
                     var startLifeTimeGradientMin = startLifeTimeGradientMin;
                     for (i = 0, n = startLifeTimeGradientMin.gradientCount; i < n; i++)
                         maxStartLifeTime = Math.max(maxStartLifeTime, startLifeTimeGradientMin.getValueByIndex(i));
                     var startLifeTimeGradientMax = startLifeTimeGradientMax;
                     for (i = 0, n = startLifeTimeGradientMax.gradientCount; i < n; i++)
                         maxStartLifeTime = Math.max(maxStartLifeTime, startLifeTimeGradientMax.getValueByIndex(i));
                     break;
             }
             //MinMaxSpeed
             var minStartSpeed, maxStartSpeed;
             switch (this.startSpeedType) {
                 case 0:
                     minStartSpeed = maxStartSpeed = this.startSpeedConstant;
                     break;
                 case 1: //TODO:
                     break;
                 case 2:
                     minStartSpeed = this.startLifetimeConstantMin;
                     maxStartSpeed = this.startLifetimeConstantMax;
                     break;
                 case 3: //TODO:
                     break;
             }
             //MinMaxPosition、MinMaxDiection
             var minPosition, maxPosition, minDirection, maxDirection;
             if (this._shape && this._shape.enable) ;
             else {
                 minPosition = maxPosition = Vector3._ZERO;
                 minDirection = Vector3._ZERO;
                 maxDirection = Vector3._UnitZ;
             }
             var startMinVelocity = new Vector3(minDirection.x * minStartSpeed, minDirection.y * minStartSpeed, minDirection.z * minStartSpeed);
             var startMaxVelocity = new Vector3(maxDirection.x * maxStartSpeed, maxDirection.y * maxStartSpeed, maxDirection.z * maxStartSpeed);
             if (this._velocityOverLifetime && this._velocityOverLifetime.enbale) {
                 var lifeMinVelocity;
                 var lifeMaxVelocity;
                 var velocity = this._velocityOverLifetime.velocity;
                 switch (velocity.type) {
                     case 0:
                         lifeMinVelocity = lifeMaxVelocity = velocity.constant;
                         break;
                     case 1:
                         lifeMinVelocity = lifeMaxVelocity = new Vector3(velocity.gradientX.getAverageValue(), velocity.gradientY.getAverageValue(), velocity.gradientZ.getAverageValue());
                         break;
                     case 2:
                         lifeMinVelocity = velocity.constantMin; //TODO:Min
                         lifeMaxVelocity = velocity.constantMax;
                         break;
                     case 3:
                         lifeMinVelocity = new Vector3(velocity.gradientXMin.getAverageValue(), velocity.gradientYMin.getAverageValue(), velocity.gradientZMin.getAverageValue());
                         lifeMaxVelocity = new Vector3(velocity.gradientXMax.getAverageValue(), velocity.gradientYMax.getAverageValue(), velocity.gradientZMax.getAverageValue());
                         break;
                 }
             }
             var positionScale, velocityScale;
             var transform = this._owner.transform;
             var worldPosition = transform.position;
             var sizeScale = ShurikenParticleSystem._tempVector39;
             var renderMode = particleRender.renderMode;
             switch (this.scaleMode) {
                 case 0:
                     var scale = transform.scale;
                     positionScale = scale;
                     sizeScale.x = scale.x;
                     sizeScale.y = scale.z;
                     sizeScale.z = scale.y;
                     (renderMode === 1) && (velocityScale = scale);
                     break;
                 case 1:
                     var localScale = transform.localScale;
                     positionScale = localScale;
                     sizeScale.x = localScale.x;
                     sizeScale.y = localScale.z;
                     sizeScale.z = localScale.y;
                     (renderMode === 1) && (velocityScale = localScale);
                     break;
                 case 2:
                     positionScale = transform.scale;
                     sizeScale.x = sizeScale.y = sizeScale.z = 1;
                     (renderMode === 1) && (velocityScale = Vector3._ONE);
                     break;
             }
             var minStratPosition, maxStratPosition;
             if (this._velocityOverLifetime && this._velocityOverLifetime.enbale) ;
             else {
                 minStratPosition = new Vector3(startMinVelocity.x * maxStartLifeTime, startMinVelocity.y * maxStartLifeTime, startMinVelocity.z * maxStartLifeTime);
                 maxStratPosition = new Vector3(startMaxVelocity.x * maxStartLifeTime, startMaxVelocity.y * maxStartLifeTime, startMaxVelocity.z * maxStartLifeTime);
                 if (this.scaleMode != 2) {
                     Vector3.add(minPosition, minStratPosition, boundMin);
                     Vector3.multiply(positionScale, boundMin, boundMin);
                     //Vector3.transformQuat(boundMin, worldRotation, boundMin);
                     Vector3.add(maxPosition, maxStratPosition, boundMax);
                     Vector3.multiply(positionScale, boundMax, boundMax);
                     //Vector3.transformQuat(boundMax, worldRotation, boundMax);
                 }
                 else {
                     Vector3.multiply(positionScale, minPosition, boundMin);
                     Vector3.add(boundMin, minStratPosition, boundMin);
                     //Vector3.transformQuat(boundMin, worldRotation, boundMin);
                     Vector3.multiply(positionScale, maxPosition, boundMax);
                     Vector3.add(boundMax, maxStratPosition, boundMax);
                     //Vector3.transformQuat(boundMax, worldRotation, boundMax);
                 }
             }
             switch (this.simulationSpace) {
                 case 0:
                     //TODO:不能用次方法计算
                     break;
                 case 1:
                     Vector3.add(boundMin, worldPosition, boundMin);
                     Vector3.add(boundMax, worldPosition, boundMax);
                     break;
             }
             //TODO:重力
             // 通过粒子最大尺寸扩充包围盒，最大尺寸为粒子对角线。TODO:HORIZONTALBILLBOARD和VERTICALBILLBOARD缩小cos45
             var maxSize, maxSizeY;
             switch (this.startSizeType) {
                 case 0:
                     if (this.threeDStartSize) {
                         var startSizeConstantSeparate = startSizeConstantSeparate;
                         maxSize = Math.max(startSizeConstantSeparate.x, startSizeConstantSeparate.y); //TODO:是否非Mesh模型下不用考虑Z
                         if (renderMode === 1)
                             maxSizeY = startSizeConstantSeparate.y;
                     }
                     else {
                         maxSize = this.startSizeConstant;
                         if (renderMode === 1)
                             maxSizeY = this.startSizeConstant;
                     }
                     break;
                 case 1: //TODO:
                     break;
                 case 2:
                     if (this.threeDStartSize) {
                         var startSizeConstantMaxSeparate = startSizeConstantMaxSeparate;
                         maxSize = Math.max(startSizeConstantMaxSeparate.x, startSizeConstantMaxSeparate.y);
                         if (renderMode === 1)
                             maxSizeY = startSizeConstantMaxSeparate.y;
                     }
                     else {
                         maxSize = this.startSizeConstantMax; //TODO:是否非Mesh模型下不用考虑Z
                         if (renderMode === 1)
                             maxSizeY = this.startSizeConstantMax;
                     }
                     break;
                 case 3: //TODO:
                     break;
             }
             if (this._sizeOverLifetime && this._sizeOverLifetime.enbale) {
                 var size = this._sizeOverLifetime.size;
                 maxSize *= this._sizeOverLifetime.size.getMaxSizeInGradient();
             }
             var threeDMaxSize = ShurikenParticleSystem._tempVector30;
             var rotSize, nonRotSize;
             switch (renderMode) {
                 case 0:
                     rotSize = maxSize * ShurikenParticleSystem.halfKSqrtOf2;
                     Vector3.scale(sizeScale, maxSize, threeDMaxSize);
                     Vector3.subtract(boundMin, threeDMaxSize, boundMin);
                     Vector3.add(boundMax, threeDMaxSize, boundMax);
                     break;
                 case 1:
                     var maxStretchPosition = ShurikenParticleSystem._tempVector31;
                     var maxStretchVelocity = ShurikenParticleSystem._tempVector32;
                     var minStretchVelocity = ShurikenParticleSystem._tempVector33;
                     var minStretchPosition = ShurikenParticleSystem._tempVector34;
                     if (this._velocityOverLifetime && this._velocityOverLifetime.enbale) ;
                     else {
                         Vector3.multiply(velocityScale, startMaxVelocity, maxStretchVelocity);
                         Vector3.multiply(velocityScale, startMinVelocity, minStretchVelocity);
                     }
                     var sizeStretch = maxSizeY * particleRender.stretchedBillboardLengthScale;
                     var maxStretchLength = Vector3.scalarLength(maxStretchVelocity) * particleRender.stretchedBillboardSpeedScale + sizeStretch;
                     var minStretchLength = Vector3.scalarLength(minStretchVelocity) * particleRender.stretchedBillboardSpeedScale + sizeStretch;
                     var norMaxStretchVelocity = ShurikenParticleSystem._tempVector35;
                     var norMinStretchVelocity = ShurikenParticleSystem._tempVector36;
                     Vector3.normalize(maxStretchVelocity, norMaxStretchVelocity);
                     Vector3.scale(norMaxStretchVelocity, maxStretchLength, minStretchPosition);
                     Vector3.subtract(maxStratPosition, minStretchPosition, minStretchPosition);
                     Vector3.normalize(minStretchVelocity, norMinStretchVelocity);
                     Vector3.scale(norMinStretchVelocity, minStretchLength, maxStretchPosition);
                     Vector3.add(minStratPosition, maxStretchPosition, maxStretchPosition);
                     rotSize = maxSize * ShurikenParticleSystem.halfKSqrtOf2;
                     Vector3.scale(sizeScale, rotSize, threeDMaxSize);
                     var halfNorMaxStretchVelocity = ShurikenParticleSystem._tempVector37;
                     var halfNorMinStretchVelocity = ShurikenParticleSystem._tempVector38;
                     Vector3.scale(norMaxStretchVelocity, 0.5, halfNorMaxStretchVelocity);
                     Vector3.scale(norMinStretchVelocity, 0.5, halfNorMinStretchVelocity);
                     Vector3.multiply(halfNorMaxStretchVelocity, sizeScale, halfNorMaxStretchVelocity);
                     Vector3.multiply(halfNorMinStretchVelocity, sizeScale, halfNorMinStretchVelocity);
                     Vector3.add(boundMin, halfNorMinStretchVelocity, boundMin);
                     Vector3.min(boundMin, minStretchPosition, boundMin);
                     Vector3.subtract(boundMin, threeDMaxSize, boundMin);
                     Vector3.subtract(boundMax, halfNorMaxStretchVelocity, boundMax);
                     Vector3.max(boundMax, maxStretchPosition, boundMax);
                     Vector3.add(boundMax, threeDMaxSize, boundMax);
                     break;
                 case 2:
                     maxSize *= Math.cos(0.78539816339744830961566084581988);
                     nonRotSize = maxSize * 0.5;
                     threeDMaxSize.x = sizeScale.x * nonRotSize;
                     threeDMaxSize.y = sizeScale.z * nonRotSize;
                     Vector3.subtract(boundMin, threeDMaxSize, boundMin);
                     Vector3.add(boundMax, threeDMaxSize, boundMax);
                     break;
                 case 3:
                     maxSize *= Math.cos(0.78539816339744830961566084581988);
                     nonRotSize = maxSize * 0.5;
                     Vector3.scale(sizeScale, nonRotSize, threeDMaxSize);
                     Vector3.subtract(boundMin, threeDMaxSize, boundMin);
                     Vector3.add(boundMax, threeDMaxSize, boundMax);
                     break;
             }
             //TODO:min
             //TODO:max
             this._boundingBox.getCorners(this._boundingBoxCorners);
         }
         /**
          * @private
          */
         _updateEmission() {
             if (!this.isAlive)
                 return;
             if (this._simulateUpdate) {
                 this._simulateUpdate = false;
             }
             else {
                 var elapsedTime = (this._startUpdateLoopCount !== Stat.loopCount && !this._isPaused) ? this._owner._scene.timer._delta / 1000.0 : 0;
                 elapsedTime = Math.min(ShurikenParticleSystem._maxElapsedTime, elapsedTime);
                 this._updateParticles(elapsedTime);
             }
         }
         /**
          * @private
          */
         _updateParticles(elapsedTime) {
             if (this._ownerRender.renderMode === 4 && !this._ownerRender.mesh) //renderMode=4且mesh为空时不更新
                 return;
             this._currentTime += elapsedTime;
             this._retireActiveParticles();
             this._freeRetiredParticles();
             //if (_firstActiveElement === _firstFreeElement){
             //_frameRateTime = 0//TODO:是否一起置零
             //_currentTime = 0;
             //}
             //if (_firstRetiredElement === _firstActiveElement)
             //_drawCounter = 0;
             this._totalDelayTime += elapsedTime;
             if (this._totalDelayTime < this._playStartDelay) {
                 return;
             }
             if (this._emission.enbale && this._isEmitting && !this._isPaused)
                 this._advanceTime(elapsedTime, this._currentTime);
         }
         /**
          * @private
          */
         _updateParticlesSimulationRestart(time) {
             this._firstActiveElement = 0;
             this._firstNewElement = 0;
             this._firstFreeElement = 0;
             this._firstRetiredElement = 0;
             this._burstsIndex = 0;
             this._frameRateTime = time; //TOD0:零还是time待 验证
             this._emissionTime = 0;
             this._totalDelayTime = 0;
             this._currentTime = time;
             var delayTime = time;
             if (delayTime < this._playStartDelay) {
                 this._totalDelayTime = delayTime;
                 return;
             }
             if (this._emission.enbale)
                 this._advanceTime(time, time); //TODO:如果time，time均为零brust无效
         }
         /**
          * @private
          */
         _retireActiveParticles() {
             const epsilon = 0.0001;
             while (this._firstActiveElement != this._firstNewElement) {
                 var index = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride;
                 var timeIndex = index + this._timeIndex; //11为Time
                 var particleAge = this._currentTime - this._vertices[timeIndex];
                 if (particleAge + epsilon < this._vertices[index + this._startLifeTimeIndex] /*_maxLifeTime*/) //7为真实lifeTime,particleAge>0为生命周期为负时
                     break;
                 this._vertices[timeIndex] = this._drawCounter;
                 this._firstActiveElement++;
                 if (this._firstActiveElement >= this._bufferMaxParticles)
                     this._firstActiveElement = 0;
             }
         }
         /**
          * @private
          */
         _freeRetiredParticles() {
             while (this._firstRetiredElement != this._firstActiveElement) {
                 var age = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex]; //11为Time
                 if (this.isPerformanceMode)
                     if (age < 3) //GPU从不滞后于CPU两帧，出于显卡驱动BUG等安全因素考虑滞后三帧
                         break;
                 this._firstRetiredElement++;
                 if (this._firstRetiredElement >= this._bufferMaxParticles)
                     this._firstRetiredElement = 0;
             }
         }
         /**
          * @private
          */
         _burst(fromTime, toTime) {
             var totalEmitCount = 0;
             var bursts = this._emission._bursts;
             for (var n = bursts.length; this._burstsIndex < n; this._burstsIndex++) { //TODO:_burstsIndex问题
                 var burst = bursts[this._burstsIndex];
                 var burstTime = burst.time;
                 if (fromTime <= burstTime && burstTime < toTime) {
                     var emitCount;
                     if (this.autoRandomSeed) {
                         emitCount = MathUtil.lerp(burst.minCount, burst.maxCount, Math.random());
                     }
                     else {
                         this._rand.seed = this._randomSeeds[0];
                         emitCount = MathUtil.lerp(burst.minCount, burst.maxCount, this._rand.getFloat());
                         this._randomSeeds[0] = this._rand.seed;
                     }
                     totalEmitCount += emitCount;
                 }
                 else {
                     break;
                 }
             }
             return totalEmitCount;
         }
         /**
          * @private
          */
         _advanceTime(elapsedTime, emitTime) {
             var i;
             var lastEmissionTime = this._emissionTime;
             this._emissionTime += elapsedTime;
             var totalEmitCount = 0;
             if (this._emissionTime > this.duration) {
                 if (this.looping) { //TODO:有while
                     totalEmitCount += this._burst(lastEmissionTime, this._emissionTime); //使用_emissionTime代替duration，否则无法触发time等于duration的burst //爆裂剩余未触发的//TODO:是否可以用_playbackTime代替计算，不必结束再爆裂一次。//TODO:待确认是否累计爆裂
                     this._emissionTime -= this.duration;
                     this._burstsIndex = 0;
                     totalEmitCount += this._burst(0, this._emissionTime);
                 }
                 else {
                     totalEmitCount = Math.min(this.maxParticles - this.aliveParticleCount, totalEmitCount);
                     for (i = 0; i < totalEmitCount; i++)
                         this.emit(emitTime);
                     this._isPlaying = false;
                     this.stop();
                     return;
                 }
             }
             else {
                 totalEmitCount += this._burst(lastEmissionTime, this._emissionTime);
             }
             totalEmitCount = Math.min(this.maxParticles - this.aliveParticleCount, totalEmitCount);
             for (i = 0; i < totalEmitCount; i++)
                 this.emit(emitTime);
             var emissionRate = this.emission.emissionRate;
             if (emissionRate > 0) {
                 var minEmissionTime = 1 / emissionRate;
                 this._frameRateTime += minEmissionTime;
                 this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; //大于最大声明周期的粒子一定会死亡，所以直接略过,TODO:是否更换机制
                 while (this._frameRateTime <= emitTime) {
                     if (this.emit(this._frameRateTime))
                         this._frameRateTime += minEmissionTime;
                     else
                         break;
                 }
                 this._frameRateTime = Math.floor(emitTime / minEmissionTime) * minEmissionTime;
             }
         }
         /**
          * @private
          */
         _initBufferDatas() {
             if (this._vertexBuffer) { //修改了maxCount以及renderMode以及Mesh等需要清空
                 this._vertexBuffer.destroy();
                 this._indexBuffer.destroy();
             }
             var render = this._ownerRender;
             var renderMode = render.renderMode;
             if (renderMode !== -1 && this.maxParticles > 0) {
                 var indices, i, j, m, indexOffset, perPartOffset, vertexDeclaration;
                 var vbMemorySize, memorySize;
                 var mesh = render.mesh;
                 if (renderMode === 4) {
                     if (mesh) {
                         var vertexBufferCount = mesh._vertexBuffers.length;
                         if (vertexBufferCount > 1) {
                             throw new Error("ShurikenParticleSystem: submesh Count mesh be One or all subMeshes have the same vertexDeclaration.");
                         }
                         else {
                             vertexDeclaration = VertexShurikenParticleMesh.vertexDeclaration;
                             this._floatCountPerVertex = vertexDeclaration.vertexStride / 4;
                             this._startLifeTimeIndex = 12;
                             this._timeIndex = 16;
                             this._vertexStride = mesh._vertexBuffers[0].vertexCount;
                             var totalVertexCount = this._bufferMaxParticles * this._vertexStride;
                             var vbCount = Math.floor(totalVertexCount / 65535) + 1;
                             var lastVBVertexCount = totalVertexCount % 65535;
                             if (vbCount > 1) { //TODO:随后支持
                                 throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                             }
                             vbMemorySize = vertexDeclaration.vertexStride * lastVBVertexCount;
                             this._vertexBuffer = new VertexBuffer3D(vbMemorySize, WebGLContext.DYNAMIC_DRAW);
                             this._vertexBuffer.vertexDeclaration = vertexDeclaration;
                             this._vertices = new Float32Array(this._floatCountPerVertex * lastVBVertexCount);
                             this._indexStride = mesh._indexBuffer.indexCount;
                             var indexDatas = mesh._indexBuffer.getData();
                             var indexCount = this._bufferMaxParticles * this._indexStride;
                             this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, indexCount, WebGLContext.STATIC_DRAW);
                             indices = new Uint16Array(indexCount);
                             memorySize = vbMemorySize + indexCount * 2;
                             indexOffset = 0;
                             for (i = 0; i < this._bufferMaxParticles; i++) {
                                 var indexValueOffset = i * this._vertexStride;
                                 for (j = 0, m = indexDatas.length; j < m; j++)
                                     indices[indexOffset++] = indexValueOffset + indexDatas[j];
                             }
                             this._indexBuffer.setData(indices);
                             this._bufferState.bind();
                             this._bufferState.applyVertexBuffer(this._vertexBuffer);
                             this._bufferState.applyIndexBuffer(this._indexBuffer);
                             this._bufferState.unBind();
                         }
                     }
                 }
                 else {
                     vertexDeclaration = VertexShurikenParticleBillboard.vertexDeclaration;
                     this._floatCountPerVertex = vertexDeclaration.vertexStride / 4;
                     this._startLifeTimeIndex = 7;
                     this._timeIndex = 11;
                     this._vertexStride = 4;
                     vbMemorySize = vertexDeclaration.vertexStride * this._bufferMaxParticles * this._vertexStride;
                     this._vertexBuffer = new VertexBuffer3D(vbMemorySize, WebGLContext.DYNAMIC_DRAW);
                     this._vertexBuffer.vertexDeclaration = vertexDeclaration;
                     this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride);
                     for (i = 0; i < this._bufferMaxParticles; i++) {
                         perPartOffset = i * this._floatCountPerVertex * this._vertexStride;
                         this._vertices[perPartOffset] = -0.5;
                         this._vertices[perPartOffset + 1] = -0.5;
                         this._vertices[perPartOffset + 2] = 0;
                         this._vertices[perPartOffset + 3] = 1;
                         perPartOffset += this._floatCountPerVertex;
                         this._vertices[perPartOffset] = 0.5;
                         this._vertices[perPartOffset + 1] = -0.5;
                         this._vertices[perPartOffset + 2] = 1;
                         this._vertices[perPartOffset + 3] = 1;
                         perPartOffset += this._floatCountPerVertex;
                         this._vertices[perPartOffset] = 0.5;
                         this._vertices[perPartOffset + 1] = 0.5;
                         this._vertices[perPartOffset + 2] = 1;
                         this._vertices[perPartOffset + 3] = 0;
                         perPartOffset += this._floatCountPerVertex;
                         this._vertices[perPartOffset] = -0.5;
                         this._vertices[perPartOffset + 1] = 0.5;
                         this._vertices[perPartOffset + 2] = 0;
                         this._vertices[perPartOffset + 3] = 0;
                     }
                     this._indexStride = 6;
                     this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, this._bufferMaxParticles * 6, WebGLContext.STATIC_DRAW);
                     indices = new Uint16Array(this._bufferMaxParticles * 6);
                     for (i = 0; i < this._bufferMaxParticles; i++) {
                         indexOffset = i * 6;
                         var firstVertex = i * this._vertexStride, secondVertex = firstVertex + 2;
                         indices[indexOffset++] = firstVertex;
                         indices[indexOffset++] = secondVertex;
                         indices[indexOffset++] = firstVertex + 1;
                         indices[indexOffset++] = firstVertex;
                         indices[indexOffset++] = firstVertex + 3;
                         indices[indexOffset++] = secondVertex;
                     }
                     this._indexBuffer.setData(indices);
                     memorySize = vbMemorySize + this._bufferMaxParticles * 6 * 2;
                     this._bufferState.bind();
                     this._bufferState.applyVertexBuffer(this._vertexBuffer);
                     this._bufferState.applyIndexBuffer(this._indexBuffer);
                     this._bufferState.unBind();
                 }
                 Resource._addMemory(memorySize, memorySize);
             }
         }
         /**
          * @private
          */
         /*override*/ destroy() {
             super.destroy();
             var memorySize = this._vertexBuffer._byteLength + this._indexBuffer.indexCount * 2;
             Resource._addMemory(-memorySize, -memorySize);
             this._bufferState.destroy();
             this._vertexBuffer.destroy();
             this._indexBuffer.destroy();
             this._emission.destroy();
             this._bufferState = null;
             this._vertexBuffer = null;
             this._indexBuffer = null;
             this._owner = null;
             this._vertices = null;
             this._indexBuffer = null;
             this._emission = null;
             this._shape = null;
             this.startLifeTimeGradient = null;
             this.startLifeTimeGradientMin = null;
             this.startLifeTimeGradientMax = null;
             this.startSizeConstantSeparate = null;
             this.startSizeConstantMinSeparate = null;
             this.startSizeConstantMaxSeparate = null;
             this.startRotationConstantSeparate = null;
             this.startRotationConstantMinSeparate = null;
             this.startRotationConstantMaxSeparate = null;
             this.startColorConstant = null;
             this.startColorConstantMin = null;
             this.startColorConstantMax = null;
             this._velocityOverLifetime = null;
             this._colorOverLifetime = null;
             this._sizeOverLifetime = null;
             this._rotationOverLifetime = null;
             this._textureSheetAnimation = null;
         }
         /**
          * 发射一个粒子。
          */
         emit(time) {
             var position = ShurikenParticleSystem._tempPosition;
             var direction = ShurikenParticleSystem._tempDirection;
             if (this._shape && this._shape.enable) {
                 if (this.autoRandomSeed)
                     this._shape.generatePositionAndDirection(position, direction);
                 else
                     this._shape.generatePositionAndDirection(position, direction, this._rand, this._randomSeeds);
             }
             else {
                 position.x = position.y = position.z = 0;
                 direction.x = direction.y = 0;
                 direction.z = 1;
             }
             return this.addParticle(position, direction, time); //TODO:提前判断优化
         }
         addParticle(position, direction, time) {
             Vector3.normalize(direction, direction);
             var nextFreeParticle = this._firstFreeElement + 1;
             if (nextFreeParticle >= this._bufferMaxParticles)
                 nextFreeParticle = 0;
             if (nextFreeParticle === this._firstRetiredElement)
                 return false;
             ShurikenParticleData.create(this, this._ownerRender, this._owner.transform);
             var particleAge = this._currentTime - time;
             if (particleAge >= ShurikenParticleData.startLifeTime) //如果时间已大于声明周期，则直接跳过,TODO:提前优化
                 return true;
             var randomVelocityX, randomVelocityY, randomVelocityZ, randomColor, randomSize, randomRotation, randomTextureAnimation;
             var needRandomVelocity = this._velocityOverLifetime && this._velocityOverLifetime.enbale;
             if (needRandomVelocity) {
                 var velocityType = this._velocityOverLifetime.velocity.type;
                 if (velocityType === 2 || velocityType === 3) {
                     if (this.autoRandomSeed) {
                         randomVelocityX = Math.random();
                         randomVelocityY = Math.random();
                         randomVelocityZ = Math.random();
                     }
                     else {
                         this._rand.seed = this._randomSeeds[9];
                         randomVelocityX = this._rand.getFloat();
                         randomVelocityY = this._rand.getFloat();
                         randomVelocityZ = this._rand.getFloat();
                         this._randomSeeds[9] = this._rand.seed;
                     }
                 }
                 else {
                     needRandomVelocity = false;
                 }
             }
             else {
                 needRandomVelocity = false;
             }
             var needRandomColor = this._colorOverLifetime && this._colorOverLifetime.enbale;
             if (needRandomColor) {
                 var colorType = this._colorOverLifetime.color.type;
                 if (colorType === 3) {
                     if (this.autoRandomSeed) {
                         randomColor = Math.random();
                     }
                     else {
                         this._rand.seed = this._randomSeeds[10];
                         randomColor = this._rand.getFloat();
                         this._randomSeeds[10] = this._rand.seed;
                     }
                 }
                 else {
                     needRandomColor = false;
                 }
             }
             else {
                 needRandomColor = false;
             }
             var needRandomSize = this._sizeOverLifetime && this._sizeOverLifetime.enbale;
             if (needRandomSize) {
                 var sizeType = this._sizeOverLifetime.size.type;
                 if (sizeType === 3) {
                     if (this.autoRandomSeed) {
                         randomSize = Math.random();
                     }
                     else {
                         this._rand.seed = this._randomSeeds[11];
                         randomSize = this._rand.getFloat();
                         this._randomSeeds[11] = this._rand.seed;
                     }
                 }
                 else {
                     needRandomSize = false;
                 }
             }
             else {
                 needRandomSize = false;
             }
             var needRandomRotation = this._rotationOverLifetime && this._rotationOverLifetime.enbale;
             if (needRandomRotation) {
                 var rotationType = this._rotationOverLifetime.angularVelocity.type;
                 if (rotationType === 2 || rotationType === 3) {
                     if (this.autoRandomSeed) {
                         randomRotation = Math.random();
                     }
                     else {
                         this._rand.seed = this._randomSeeds[12];
                         randomRotation = this._rand.getFloat();
                         this._randomSeeds[12] = this._rand.seed;
                     }
                 }
                 else {
                     needRandomRotation = false;
                 }
             }
             else {
                 needRandomRotation = false;
             }
             var needRandomTextureAnimation = this._textureSheetAnimation && this._textureSheetAnimation.enable;
             if (needRandomTextureAnimation) {
                 var textureAnimationType = this._textureSheetAnimation.frame.type;
                 if (textureAnimationType === 3) {
                     if (this.autoRandomSeed) {
                         randomTextureAnimation = Math.random();
                     }
                     else {
                         this._rand.seed = this._randomSeeds[15];
                         randomTextureAnimation = this._rand.getFloat();
                         this._randomSeeds[15] = this._rand.seed;
                     }
                 }
                 else {
                     needRandomTextureAnimation = false;
                 }
             }
             else {
                 needRandomTextureAnimation = false;
             }
             var startIndex = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride;
             var subU = ShurikenParticleData.startUVInfo[0];
             var subV = ShurikenParticleData.startUVInfo[1];
             var startU = ShurikenParticleData.startUVInfo[2];
             var startV = ShurikenParticleData.startUVInfo[3];
             var meshVertices, meshVertexStride, meshPosOffset, meshCorOffset, meshUVOffset, meshVertexIndex;
             var render = this._ownerRender;
             if (render.renderMode === 4) {
                 var meshVB = render.mesh._vertexBuffers[0];
                 meshVertices = meshVB.getData();
                 var meshVertexDeclaration = meshVB.vertexDeclaration;
                 meshPosOffset = meshVertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_POSITION0).offset / 4;
                 var colorElement = meshVertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_COLOR0);
                 meshCorOffset = colorElement ? colorElement.offset / 4 : -1;
                 var uvElement = meshVertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE0);
                 meshUVOffset = uvElement ? uvElement.offset / 4 : -1;
                 meshVertexStride = meshVertexDeclaration.vertexStride / 4;
                 meshVertexIndex = 0;
             }
             else {
                 this._vertices[startIndex + 2] = startU;
                 this._vertices[startIndex + 3] = startV + subV;
                 var secondOffset = startIndex + this._floatCountPerVertex;
                 this._vertices[secondOffset + 2] = startU + subU;
                 this._vertices[secondOffset + 3] = startV + subV;
                 var thirdOffset = secondOffset + this._floatCountPerVertex;
                 this._vertices[thirdOffset + 2] = startU + subU;
                 this._vertices[thirdOffset + 3] = startV;
                 var fourthOffset = thirdOffset + this._floatCountPerVertex;
                 this._vertices[fourthOffset + 2] = startU;
                 this._vertices[fourthOffset + 3] = startV;
             }
             for (var i = startIndex, n = startIndex + this._floatCountPerVertex * this._vertexStride; i < n; i += this._floatCountPerVertex) {
                 var offset;
                 if (render.renderMode === 4) {
                     offset = i;
                     var vertexOffset = meshVertexStride * (meshVertexIndex++);
                     var meshOffset = vertexOffset + meshPosOffset;
                     this._vertices[offset++] = meshVertices[meshOffset++];
                     this._vertices[offset++] = meshVertices[meshOffset++];
                     this._vertices[offset++] = meshVertices[meshOffset];
                     if (meshCorOffset === -1) {
                         this._vertices[offset++] = 1.0;
                         this._vertices[offset++] = 1.0;
                         this._vertices[offset++] = 1.0;
                         this._vertices[offset++] = 1.0;
                     }
                     else {
                         meshOffset = vertexOffset + meshCorOffset;
                         this._vertices[offset++] = meshVertices[meshOffset++];
                         this._vertices[offset++] = meshVertices[meshOffset++];
                         this._vertices[offset++] = meshVertices[meshOffset++];
                         this._vertices[offset++] = meshVertices[meshOffset];
                     }
                     if (meshUVOffset === -1) {
                         this._vertices[offset++] = 0.0;
                         this._vertices[offset++] = 0.0;
                     }
                     else {
                         meshOffset = vertexOffset + meshUVOffset;
                         this._vertices[offset++] = startU + meshVertices[meshOffset++] * subU;
                         this._vertices[offset++] = startV + meshVertices[meshOffset] * subV;
                     }
                 }
                 else {
                     offset = i + 4;
                 }
                 this._vertices[offset++] = position.x;
                 this._vertices[offset++] = position.y;
                 this._vertices[offset++] = position.z;
                 this._vertices[offset++] = ShurikenParticleData.startLifeTime;
                 this._vertices[offset++] = direction.x;
                 this._vertices[offset++] = direction.y;
                 this._vertices[offset++] = direction.z;
                 this._vertices[offset++] = time;
                 this._vertices[offset++] = ShurikenParticleData.startColor.x;
                 this._vertices[offset++] = ShurikenParticleData.startColor.y;
                 this._vertices[offset++] = ShurikenParticleData.startColor.z;
                 this._vertices[offset++] = ShurikenParticleData.startColor.w;
                 this._vertices[offset++] = ShurikenParticleData.startSize[0];
                 this._vertices[offset++] = ShurikenParticleData.startSize[1];
                 this._vertices[offset++] = ShurikenParticleData.startSize[2];
                 this._vertices[offset++] = ShurikenParticleData.startRotation[0];
                 this._vertices[offset++] = ShurikenParticleData.startRotation[1];
                 this._vertices[offset++] = ShurikenParticleData.startRotation[2];
                 this._vertices[offset++] = ShurikenParticleData.startSpeed;
                 // (_vertices[offset] = XX);TODO:29预留
                 needRandomColor && (this._vertices[offset + 1] = randomColor);
                 needRandomSize && (this._vertices[offset + 2] = randomSize);
                 needRandomRotation && (this._vertices[offset + 3] = randomRotation);
                 needRandomTextureAnimation && (this._vertices[offset + 4] = randomTextureAnimation);
                 if (needRandomVelocity) {
                     this._vertices[offset + 5] = randomVelocityX;
                     this._vertices[offset + 6] = randomVelocityY;
                     this._vertices[offset + 7] = randomVelocityZ;
                 }
                 switch (this.simulationSpace) {
                     case 0:
                         offset += 8;
                         this._vertices[offset++] = ShurikenParticleData.simulationWorldPostion[0];
                         this._vertices[offset++] = ShurikenParticleData.simulationWorldPostion[1];
                         this._vertices[offset++] = ShurikenParticleData.simulationWorldPostion[2];
                         this._vertices[offset++] = ShurikenParticleData.simulationWorldRotation[0];
                         this._vertices[offset++] = ShurikenParticleData.simulationWorldRotation[1];
                         this._vertices[offset++] = ShurikenParticleData.simulationWorldRotation[2];
                         this._vertices[offset++] = ShurikenParticleData.simulationWorldRotation[3];
                         break;
                     case 1:
                         break;
                     default:
                         throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                 }
             }
             this._firstFreeElement = nextFreeParticle;
             return true;
         }
         addNewParticlesToVertexBuffer() {
             var start;
             if (this._firstNewElement < this._firstFreeElement) {
                 start = this._firstNewElement * this._vertexStride * this._floatCountPerVertex;
                 this._vertexBuffer.setData(this._vertices, start, start, (this._firstFreeElement - this._firstNewElement) * this._vertexStride * this._floatCountPerVertex);
             }
             else {
                 start = this._firstNewElement * this._vertexStride * this._floatCountPerVertex;
                 this._vertexBuffer.setData(this._vertices, start, start, (this._bufferMaxParticles - this._firstNewElement) * this._vertexStride * this._floatCountPerVertex);
                 if (this._firstFreeElement > 0) {
                     this._vertexBuffer.setData(this._vertices, 0, 0, this._firstFreeElement * this._vertexStride * this._floatCountPerVertex);
                 }
             }
             this._firstNewElement = this._firstFreeElement;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getType() {
             return ShurikenParticleSystem._type;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _prepareRender(state) {
             this._updateEmission();
             //设备丢失时, setData  here
             if (this._firstNewElement != this._firstFreeElement)
                 this.addNewParticlesToVertexBuffer();
             this._drawCounter++;
             if (this._firstActiveElement != this._firstFreeElement)
                 return true;
             else
                 return false;
         }
         /**
          * @private
          */
         /*override*/ _render(state) {
             this._bufferState.bind();
             var indexCount;
             var gl = LayaGL.instance;
             if (this._firstActiveElement < this._firstFreeElement) {
                 indexCount = (this._firstFreeElement - this._firstActiveElement) * this._indexStride;
                 gl.drawElements(WebGLContext.TRIANGLES, indexCount, WebGLContext.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride);
                 Stat.trianglesFaces += indexCount / 3;
                 Stat.renderBatches++;
             }
             else {
                 indexCount = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride;
                 gl.drawElements(WebGLContext.TRIANGLES, indexCount, WebGLContext.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride);
                 Stat.trianglesFaces += indexCount / 3;
                 Stat.renderBatches++;
                 if (this._firstFreeElement > 0) {
                     indexCount = this._firstFreeElement * this._indexStride;
                     gl.drawElements(WebGLContext.TRIANGLES, indexCount, WebGLContext.UNSIGNED_SHORT, 0);
                     Stat.trianglesFaces += indexCount / 3;
                     Stat.renderBatches++;
                 }
             }
         }
         /**
          * 开始发射粒子。
          */
         play() {
             this._burstsIndex = 0;
             this._isEmitting = true;
             this._isPlaying = true;
             this._isPaused = false;
             this._emissionTime = 0;
             this._totalDelayTime = 0;
             if (!this.autoRandomSeed) {
                 for (var i = 0, n = this._randomSeeds.length; i < n; i++)
                     this._randomSeeds[i] = this.randomSeed[0] + ShurikenParticleSystem._RANDOMOFFSET[i];
             }
             switch (this.startDelayType) {
                 case 0:
                     this._playStartDelay = this.startDelay;
                     break;
                 case 1:
                     if (this.autoRandomSeed) {
                         this._playStartDelay = MathUtil.lerp(this.startDelayMin, this.startDelayMax, Math.random());
                     }
                     else {
                         this._rand.seed = this._randomSeeds[2];
                         this._playStartDelay = MathUtil.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat());
                         this._randomSeeds[2] = this._rand.seed;
                     }
                     break;
                 default:
                     throw new Error("Utils3D: startDelayType is invalid.");
             }
             this._frameRateTime = this._currentTime + this._playStartDelay; //同步频率模式发射时间,更新函数中小于延迟时间不会更新此时间。
             this._startUpdateLoopCount = Stat.loopCount;
         }
         /**
          * 暂停发射粒子。
          */
         pause() {
             this._isPaused = true;
         }
         /**
          * 通过指定时间增加粒子播放进度，并暂停播放。
          * @param time 进度时间.如果restart为true,粒子播放时间会归零后再更新进度。
          * @param restart 是否重置播放状态。
          */
         simulate(time, restart = true) {
             this._simulateUpdate = true;
             if (restart) {
                 this._updateParticlesSimulationRestart(time);
             }
             else {
                 this._isPaused = false; //如果当前状态为暂停则无法发射粒子
                 this._updateParticles(time);
             }
             this.pause();
         }
         /**
          * 停止发射粒子。
          */
         stop() {
             this._burstsIndex = 0;
             this._isEmitting = false;
             this._emissionTime = 0;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var dest = destObject;
             dest.duration = this.duration;
             dest.looping = this.looping;
             dest.prewarm = this.prewarm;
             dest.startDelayType = this.startDelayType;
             dest.startDelay = this.startDelay;
             dest.startDelayMin = this.startDelayMin;
             dest.startDelayMax = this.startDelayMax;
             dest._maxStartLifetime = this._maxStartLifetime;
             dest.startLifetimeType = this.startLifetimeType;
             dest.startLifetimeConstant = this.startLifetimeConstant;
             this.startLifeTimeGradient.cloneTo(dest.startLifeTimeGradient);
             dest.startLifetimeConstantMin = this.startLifetimeConstantMin;
             dest.startLifetimeConstantMax = this.startLifetimeConstantMax;
             this.startLifeTimeGradientMin.cloneTo(dest.startLifeTimeGradientMin);
             this.startLifeTimeGradientMax.cloneTo(dest.startLifeTimeGradientMax);
             dest.startSpeedType = this.startSpeedType;
             dest.startSpeedConstant = this.startSpeedConstant;
             dest.startSpeedConstantMin = this.startSpeedConstantMin;
             dest.startSpeedConstantMax = this.startSpeedConstantMax;
             dest.threeDStartSize = this.threeDStartSize;
             dest.startSizeType = this.startSizeType;
             dest.startSizeConstant = this.startSizeConstant;
             this.startSizeConstantSeparate.cloneTo(dest.startSizeConstantSeparate);
             dest.startSizeConstantMin = this.startSizeConstantMin;
             dest.startSizeConstantMax = this.startSizeConstantMax;
             this.startSizeConstantMinSeparate.cloneTo(dest.startSizeConstantMinSeparate);
             this.startSizeConstantMaxSeparate.cloneTo(dest.startSizeConstantMaxSeparate);
             dest.threeDStartRotation = this.threeDStartRotation;
             dest.startRotationType = this.startRotationType;
             dest.startRotationConstant = this.startRotationConstant;
             this.startRotationConstantSeparate.cloneTo(dest.startRotationConstantSeparate);
             dest.startRotationConstantMin = this.startRotationConstantMin;
             dest.startRotationConstantMax = this.startRotationConstantMax;
             this.startRotationConstantMinSeparate.cloneTo(dest.startRotationConstantMinSeparate);
             this.startRotationConstantMaxSeparate.cloneTo(dest.startRotationConstantMaxSeparate);
             dest.randomizeRotationDirection = this.randomizeRotationDirection;
             dest.startColorType = this.startColorType;
             this.startColorConstant.cloneTo(dest.startColorConstant);
             this.startColorConstantMin.cloneTo(dest.startColorConstantMin);
             this.startColorConstantMax.cloneTo(dest.startColorConstantMax);
             dest.gravityModifier = this.gravityModifier;
             dest.simulationSpace = this.simulationSpace;
             dest.scaleMode = this.scaleMode;
             dest.playOnAwake = this.playOnAwake;
             //dest.autoRandomSeed = autoRandomSeed;
             dest.maxParticles = this.maxParticles;
             //TODO:可做更优判断
             (this._emission) && (dest._emission = this._emission.clone());
             (this.shape) && (dest.shape = this.shape.clone());
             (this.velocityOverLifetime) && (dest.velocityOverLifetime = this.velocityOverLifetime.clone());
             (this.colorOverLifetime) && (dest.colorOverLifetime = this.colorOverLifetime.clone());
             (this.sizeOverLifetime) && (dest.sizeOverLifetime = this.sizeOverLifetime.clone());
             (this.rotationOverLifetime) && (dest.rotationOverLifetime = this.rotationOverLifetime.clone());
             (this.textureSheetAnimation) && (dest.textureSheetAnimation = this.textureSheetAnimation.clone());
             //
             dest.isPerformanceMode = this.isPerformanceMode;
             dest._isEmitting = this._isEmitting;
             dest._isPlaying = this._isPlaying;
             dest._isPaused = this._isPaused;
             dest._playStartDelay = this._playStartDelay;
             dest._frameRateTime = this._frameRateTime;
             dest._emissionTime = this._emissionTime;
             dest._totalDelayTime = this._totalDelayTime;
             dest._burstsIndex = this._burstsIndex;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new ShurikenParticleSystem(null);
             this.cloneTo(dest);
             return dest;
         }
     }
     /** @private 0:Burst,1:预留,2:StartDelay,3:StartColor,4:StartSize,5:StartRotation,6:randomizeRotationDirection,7:StartLifetime,8:StartSpeed,9:VelocityOverLifetime,10:ColorOverLifetime,11:SizeOverLifetime,12:RotationOverLifetime,13-15:TextureSheetAnimation,16-17:Shape*/
     ShurikenParticleSystem._RANDOMOFFSET = new Uint32Array([0x23571a3e, 0xc34f56fe, 0x13371337, 0x12460f3b, 0x6aed452e, 0xdec4aea1, 0x96aa4de3, 0x8d2c8431, 0xf3857f6f, 0xe0fbd834, 0x13740583, 0x591bc05c, 0x40eb95e4, 0xbc524e5f, 0xaf502044, 0xa614b381, 0x1034e524, 0xfc524e5f]);
     /** @private */
     ShurikenParticleSystem.halfKSqrtOf2 = 1.42 * 0.5;
     /** @private */
     ShurikenParticleSystem._maxElapsedTime = 1.0 / 3.0;
     /**@private */
     ShurikenParticleSystem._tempVector30 = new Vector3();
     /**@private */
     ShurikenParticleSystem._tempVector31 = new Vector3();
     /**@private */
     ShurikenParticleSystem._tempVector32 = new Vector3();
     /**@private */
     ShurikenParticleSystem._tempVector33 = new Vector3();
     /**@private */
     ShurikenParticleSystem._tempVector34 = new Vector3();
     /**@private */
     ShurikenParticleSystem._tempVector35 = new Vector3();
     /**@private */
     ShurikenParticleSystem._tempVector36 = new Vector3();
     /**@private */
     ShurikenParticleSystem._tempVector37 = new Vector3();
     /**@private */
     ShurikenParticleSystem._tempVector38 = new Vector3();
     /**@private */
     ShurikenParticleSystem._tempVector39 = new Vector3();
     /** @private */
     ShurikenParticleSystem._tempPosition = new Vector3();
     /** @private */
     ShurikenParticleSystem._tempDirection = new Vector3();
     /**@private */
     ShurikenParticleSystem._type = GeometryElement._typeCounter++;

     /**
      * <code>Burst</code> 类用于粒子的爆裂描述。
      */
     class Burst {
         /**
          * 获取爆裂时间,单位为秒。
          * @return 爆裂时间,单位为秒。
          */
         get time() {
             return this._time;
         }
         /**
          * 获取爆裂的最小数量。
          * @return 爆裂的最小数量。
          */
         get minCount() {
             return this._minCount;
         }
         /**
          * 获取爆裂的最大数量。
          * @return 爆裂的最大数量。
          */
         get maxCount() {
             return this._maxCount;
         }
         /**
          * 创建一个 <code>Burst</code> 实例。
          * @param time 爆裂时间,单位为秒。
          * @param minCount 爆裂的最小数量。
          * @param time 爆裂的最大数量。
          */
         constructor(time, minCount, maxCount) {
             this._time = time;
             this._minCount = minCount;
             this._maxCount = maxCount;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destBurst = destObject;
             destBurst._time = this._time;
             destBurst._minCount = this._minCount;
             destBurst._maxCount = this._maxCount;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destBurst = new Burst(this._time, this._minCount, this._maxCount);
             this.cloneTo(destBurst);
             return destBurst;
         }
     }

     /**
      * <code>GradientColor</code> 类用于创建渐变颜色。
      */
     class GradientColor {
         /**
          * 创建一个 <code>GradientColor,不允许new，请使用静态创建函数。</code> 实例。
          */
         constructor() {
             /**@private */
             this._type = 0;
             /**@private */
             this._constant = null;
             /**@private */
             this._constantMin = null;
             /**@private */
             this._constantMax = null;
             /**@private */
             this._gradient = null;
             /**@private */
             this._gradientMin = null;
             /**@private */
             this._gradientMax = null;
         }
         /**
          * 通过固定颜色创建一个 <code>GradientColor</code> 实例。
          * @param constant 固定颜色。
          */
         static createByConstant(constant) {
             var gradientColor = new GradientColor();
             gradientColor._type = 0;
             gradientColor._constant = constant;
             return gradientColor;
         }
         /**
          * 通过渐变颜色创建一个 <code>GradientColor</code> 实例。
          * @param gradient 渐变色。
          */
         static createByGradient(gradient) {
             var gradientColor = new GradientColor();
             gradientColor._type = 1;
             gradientColor._gradient = gradient;
             return gradientColor;
         }
         /**
          * 通过随机双固定颜色创建一个 <code>GradientColor</code> 实例。
          * @param minConstant 最小固定颜色。
          * @param maxConstant 最大固定颜色。
          */
         static createByRandomTwoConstant(minConstant, maxConstant) {
             var gradientColor = new GradientColor();
             gradientColor._type = 2;
             gradientColor._constantMin = minConstant;
             gradientColor._constantMax = maxConstant;
             return gradientColor;
         }
         /**
          * 通过随机双渐变颜色创建一个 <code>GradientColor</code> 实例。
          * @param minGradient 最小渐变颜色。
          * @param maxGradient 最大渐变颜色。
          */
         static createByRandomTwoGradient(minGradient, maxGradient) {
             var gradientColor = new GradientColor();
             gradientColor._type = 3;
             gradientColor._gradientMin = minGradient;
             gradientColor._gradientMax = maxGradient;
             return gradientColor;
         }
         /**
          *生命周期颜色类型,0为固定颜色模式,1渐变模式,2为随机双固定颜色模式,3随机双渐变模式。
          */
         get type() {
             return this._type;
         }
         /**
          * 固定颜色。
          */
         get constant() {
             return this._constant;
         }
         /**
          * 最小固定颜色。
          */
         get constantMin() {
             return this._constantMin;
         }
         /**
          * 最大固定颜色。
          */
         get constantMax() {
             return this._constantMax;
         }
         /**
          * 渐变颜色。
          */
         get gradient() {
             return this._gradient;
         }
         /**
          * 最小渐变颜色。
          */
         get gradientMin() {
             return this._gradientMin;
         }
         /**
          * 最大渐变颜色。
          */
         get gradientMax() {
             return this._gradientMax;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destGradientColor = destObject;
             destGradientColor._type = this._type;
             this._constant.cloneTo(destGradientColor._constant);
             this._constantMin.cloneTo(destGradientColor._constantMin);
             this._constantMax.cloneTo(destGradientColor._constantMax);
             this._gradient.cloneTo(destGradientColor._gradient);
             this._gradientMin.cloneTo(destGradientColor._gradientMin);
             this._gradientMax.cloneTo(destGradientColor._gradientMax);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destGradientColor = new GradientColor();
             this.cloneTo(destGradientColor);
             return destGradientColor;
         }
     }

     /**
      * <code>ColorOverLifetime</code> 类用于粒子的生命周期颜色。
      */
     class ColorOverLifetime {
         /**
          *获取颜色。
          */
         get color() {
             return this._color;
         }
         /**
          * 创建一个 <code>ColorOverLifetime</code> 实例。
          */
         constructor(color) {
             this._color = color;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destColorOverLifetime = destObject;
             this._color.cloneTo(destColorOverLifetime._color);
             destColorOverLifetime.enbale = this.enbale;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destColor;
             switch (this._color.type) {
                 case 0:
                     destColor = GradientColor.createByConstant(this._color.constant.clone());
                     break;
                 case 1:
                     destColor = GradientColor.createByGradient(this._color.gradient.clone());
                     break;
                 case 2:
                     destColor = GradientColor.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                     break;
                 case 3:
                     destColor = GradientColor.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
                     break;
             }
             var destColorOverLifetime = new ColorOverLifetime(destColor);
             destColorOverLifetime.enbale = this.enbale;
             return destColorOverLifetime;
         }
     }

     /**
      * <code>FrameOverTime</code> 类用于创建时间帧。
      */
     class FrameOverTime {
         /**
          * 创建一个 <code>FrameOverTime,不允许new，请使用静态创建函数。</code> 实例。
          */
         constructor() {
             /**@private */
             this._type = 0;
             /**@private */
             this._constant = 0;
             /**@private */
             this._overTime = null;
             /**@private */
             this._constantMin = 0;
             /**@private */
             this._constantMax = 0;
             /**@private */
             this._overTimeMin = null;
             /**@private */
             this._overTimeMax = null;
         }
         /**
          * 通过固定帧创建一个 <code>FrameOverTime</code> 实例。
          * @param	constant 固定帧。
          * @return 时间帧。
          */
         static createByConstant(constant) {
             var rotationOverLifetime = new FrameOverTime();
             rotationOverLifetime._type = 0;
             rotationOverLifetime._constant = constant;
             return rotationOverLifetime;
         }
         /**
          * 通过时间帧创建一个 <code>FrameOverTime</code> 实例。
          * @param	overTime 时间帧。
          * @return 时间帧。
          */
         static createByOverTime(overTime) {
             var rotationOverLifetime = new FrameOverTime();
             rotationOverLifetime._type = 1;
             rotationOverLifetime._overTime = overTime;
             return rotationOverLifetime;
         }
         /**
          * 通过随机双固定帧创建一个 <code>FrameOverTime</code> 实例。
          * @param	constantMin 最小固定帧。
          * @param	constantMax 最大固定帧。
          * @return 时间帧。
          */
         static createByRandomTwoConstant(constantMin, constantMax) {
             var rotationOverLifetime = new FrameOverTime();
             rotationOverLifetime._type = 2;
             rotationOverLifetime._constantMin = constantMin;
             rotationOverLifetime._constantMax = constantMax;
             return rotationOverLifetime;
         }
         /**
          * 通过随机双时间帧创建一个 <code>FrameOverTime</code> 实例。
          * @param	gradientFrameMin 最小时间帧。
          * @param	gradientFrameMax 最大时间帧。
          * @return 时间帧。
          */
         static createByRandomTwoOverTime(gradientFrameMin, gradientFrameMax) {
             var rotationOverLifetime = new FrameOverTime();
             rotationOverLifetime._type = 3;
             rotationOverLifetime._overTimeMin = gradientFrameMin;
             rotationOverLifetime._overTimeMax = gradientFrameMax;
             return rotationOverLifetime;
         }
         /**
          *生命周期旋转类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
          */
         get type() {
             return this._type;
         }
         /**
          * 固定帧。
          */
         get constant() {
             return this._constant;
         }
         /**
          * 时间帧。
          */
         get frameOverTimeData() {
             return this._overTime;
         }
         /**
          * 最小固定帧。
          */
         get constantMin() {
             return this._constantMin;
         }
         /**
          * 最大固定帧。
          */
         get constantMax() {
             return this._constantMax;
         }
         /**
          * 最小时间帧。
          */
         get frameOverTimeDataMin() {
             return this._overTimeMin;
         }
         /**
          * 最大时间帧。
          */
         get frameOverTimeDataMax() {
             return this._overTimeMax;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destFrameOverTime = destObject;
             destFrameOverTime._type = this._type;
             destFrameOverTime._constant = this._constant;
             this._overTime.cloneTo(destFrameOverTime._overTime);
             destFrameOverTime._constantMin = this._constantMin;
             destFrameOverTime._constantMax = this._constantMax;
             this._overTimeMin.cloneTo(destFrameOverTime._overTimeMin);
             this._overTimeMax.cloneTo(destFrameOverTime._overTimeMax);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destFrameOverTime = new FrameOverTime();
             this.cloneTo(destFrameOverTime);
             return destFrameOverTime;
         }
     }

     /**
      * <code>GradientRotation</code> 类用于创建渐变角速度。
      */
     class GradientAngularVelocity {
         /**
          * 创建一个 <code>GradientAngularVelocity,不允许new，请使用静态创建函数。</code> 实例。
          */
         constructor() {
             /**@private */
             this._type = 0;
             /**@private */
             this._separateAxes = false;
             /**@private */
             this._constant = 0;
             /**@private */
             this._constantSeparate = null;
             /**@private */
             this._gradient = null;
             /**@private */
             this._gradientX = null;
             /**@private */
             this._gradientY = null;
             /**@private */
             this._gradientZ = null;
             /**@private */
             this._gradientW = null;
             /**@private */
             this._constantMin = 0;
             /**@private */
             this._constantMax = 0;
             /**@private */
             this._constantMinSeparate = null;
             /**@private */
             this._constantMaxSeparate = null;
             /**@private */
             this._gradientMin = null;
             /**@private */
             this._gradientMax = null;
             /**@private */
             this._gradientXMin = null;
             /**@private */
             this._gradientXMax = null;
             /**@private */
             this._gradientYMin = null;
             /**@private */
             this._gradientYMax = null;
             /**@private */
             this._gradientZMin = null;
             /**@private */
             this._gradientZMax = null;
             /**@private */
             this._gradientWMin = null;
             /**@private */
             this._gradientWMax = null;
         }
         /**
          * 通过固定角速度创建一个 <code>GradientAngularVelocity</code> 实例。
          * @param	constant 固定角速度。
          * @return 渐变角速度。
          */
         static createByConstant(constant) {
             var gradientAngularVelocity = new GradientAngularVelocity();
             gradientAngularVelocity._type = 0;
             gradientAngularVelocity._separateAxes = false;
             gradientAngularVelocity._constant = constant;
             return gradientAngularVelocity;
         }
         /**
          * 通过分轴固定角速度创建一个 <code>GradientAngularVelocity</code> 实例。
          * @param	separateConstant 分轴固定角速度。
          * @return 渐变角速度。
          */
         static createByConstantSeparate(separateConstant) {
             var gradientAngularVelocity = new GradientAngularVelocity();
             gradientAngularVelocity._type = 0;
             gradientAngularVelocity._separateAxes = true;
             gradientAngularVelocity._constantSeparate = separateConstant;
             return gradientAngularVelocity;
         }
         /**
          * 通过渐变角速度创建一个 <code>GradientAngularVelocity</code> 实例。
          * @param	gradient 渐变角速度。
          * @return 渐变角速度。
          */
         static createByGradient(gradient) {
             var gradientAngularVelocity = new GradientAngularVelocity();
             gradientAngularVelocity._type = 1;
             gradientAngularVelocity._separateAxes = false;
             gradientAngularVelocity._gradient = gradient;
             return gradientAngularVelocity;
         }
         /**
          * 通过分轴渐变角速度创建一个 <code>GradientAngularVelocity</code> 实例。
          * @param	gradientX X轴渐变角速度。
          * @param	gradientY Y轴渐变角速度。
          * @param	gradientZ Z轴渐变角速度。
          * @return  渐变角速度。
          */
         static createByGradientSeparate(gradientX, gradientY, gradientZ) {
             var gradientAngularVelocity = new GradientAngularVelocity();
             gradientAngularVelocity._type = 1;
             gradientAngularVelocity._separateAxes = true;
             gradientAngularVelocity._gradientX = gradientX;
             gradientAngularVelocity._gradientY = gradientY;
             gradientAngularVelocity._gradientZ = gradientZ;
             return gradientAngularVelocity;
         }
         /**
          * 通过随机双固定角速度创建一个 <code>GradientAngularVelocity</code> 实例。
          * @param	constantMin 最小固定角速度。
          * @param	constantMax 最大固定角速度。
          * @return 渐变角速度。
          */
         static createByRandomTwoConstant(constantMin, constantMax) {
             var gradientAngularVelocity = new GradientAngularVelocity();
             gradientAngularVelocity._type = 2;
             gradientAngularVelocity._separateAxes = false;
             gradientAngularVelocity._constantMin = constantMin;
             gradientAngularVelocity._constantMax = constantMax;
             return gradientAngularVelocity;
         }
         /**
          * 通过随机分轴双固定角速度创建一个 <code>GradientAngularVelocity</code> 实例。
          * @param	separateConstantMin  最小分轴固定角速度。
          * @param	separateConstantMax  最大分轴固定角速度。
          * @return  渐变角速度。
          */
         static createByRandomTwoConstantSeparate(separateConstantMin, separateConstantMax) {
             var gradientAngularVelocity = new GradientAngularVelocity();
             gradientAngularVelocity._type = 2;
             gradientAngularVelocity._separateAxes = true;
             gradientAngularVelocity._constantMinSeparate = separateConstantMin;
             gradientAngularVelocity._constantMaxSeparate = separateConstantMax;
             return gradientAngularVelocity;
         }
         /**
          * 通过随机双渐变角速度创建一个 <code>GradientAngularVelocity</code> 实例。
          * @param	gradientMin 最小渐变角速度。
          * @param	gradientMax 最大渐变角速度。
          * @return  渐变角速度。
          */
         static createByRandomTwoGradient(gradientMin, gradientMax) {
             var gradientAngularVelocity = new GradientAngularVelocity();
             gradientAngularVelocity._type = 3;
             gradientAngularVelocity._separateAxes = false;
             gradientAngularVelocity._gradientMin = gradientMin;
             gradientAngularVelocity._gradientMax = gradientMax;
             return gradientAngularVelocity;
         }
         /**
          * 通过分轴随机双渐变角速度创建一个 <code>GradientAngularVelocity</code> 实例。
          * @param	gradientXMin  最小X轴渐变角速度。
          * @param	gradientXMax  最大X轴渐变角速度。
          * @param	gradientYMin  最小Y轴渐变角速度。
          * @param	gradientYMax  最大Y轴渐变角速度。
          * @param	gradientZMin  最小Z轴渐变角速度。
          * @param	gradientZMax  最大Z轴渐变角速度。
          * @return  渐变角速度。
          */
         static createByRandomTwoGradientSeparate(gradientXMin, gradientXMax, gradientYMin, gradientYMax, gradientZMin, gradientZMax, gradientWMin, gradientWMax) {
             var gradientAngularVelocity = new GradientAngularVelocity();
             gradientAngularVelocity._type = 3;
             gradientAngularVelocity._separateAxes = true;
             gradientAngularVelocity._gradientXMin = gradientXMin;
             gradientAngularVelocity._gradientXMax = gradientXMax;
             gradientAngularVelocity._gradientYMin = gradientYMin;
             gradientAngularVelocity._gradientYMax = gradientYMax;
             gradientAngularVelocity._gradientZMin = gradientZMin;
             gradientAngularVelocity._gradientZMax = gradientZMax;
             gradientAngularVelocity._gradientWMin = gradientWMin;
             gradientAngularVelocity._gradientWMax = gradientWMax;
             return gradientAngularVelocity;
         }
         /**
          *生命周期角速度类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
          */
         get type() {
             return this._type;
         }
         /**
          *是否分轴。
          */
         get separateAxes() {
             return this._separateAxes;
         }
         /**
          * 固定角速度。
          */
         get constant() {
             return this._constant;
         }
         /**
          * 分轴固定角速度。
          */
         get constantSeparate() {
             return this._constantSeparate;
         }
         /**
          * 渐变角速度。
          */
         get gradient() {
             return this._gradient;
         }
         /**
          * 渐变角角速度X。
          */
         get gradientX() {
             return this._gradientX;
         }
         /**
          * 渐变角速度Y。
          */
         get gradientY() {
             return this._gradientY;
         }
         /**
          *渐变角速度Z。
          */
         get gradientZ() {
             return this._gradientZ;
         }
         /**
          *渐变角速度Z。
          */
         get gradientW() {
             return this._gradientW;
         }
         /**
          * 最小随机双固定角速度。
          */
         get constantMin() {
             return this._constantMin;
         }
         /**
          * 最大随机双固定角速度。
          */
         get constantMax() {
             return this._constantMax;
         }
         /**
          * 最小分轴随机双固定角速度。
          */
         get constantMinSeparate() {
             return this._constantMinSeparate;
         }
         /**
          * 最大分轴随机双固定角速度。
          */
         get constantMaxSeparate() {
             return this._constantMaxSeparate;
         }
         /**
          *最小渐变角速度。
          */
         get gradientMin() {
             return this._gradientMin;
         }
         /**
          * 最大渐变角速度。
          */
         get gradientMax() {
             return this._gradientMax;
         }
         /**
          * 最小渐变角速度X。
          */
         get gradientXMin() {
             return this._gradientXMin;
         }
         /**
          * 最大渐变角速度X。
          */
         get gradientXMax() {
             return this._gradientXMax;
         }
         /**
          * 最小渐变角速度Y。
          */
         get gradientYMin() {
             return this._gradientYMin;
         }
         /**
          *最大渐变角速度Y。
          */
         get gradientYMax() {
             return this._gradientYMax;
         }
         /**
          * 最小渐变角速度Z。
          */
         get gradientZMin() {
             return this._gradientZMin;
         }
         /**
          * 最大渐变角速度Z。
          */
         get gradientZMax() {
             return this._gradientZMax;
         }
         /**
          * 最小渐变角速度Z。
          */
         get gradientWMin() {
             return this._gradientWMin;
         }
         /**
          * 最大渐变角速度Z。
          */
         get gradientWMax() {
             return this._gradientWMax;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destGradientAngularVelocity = destObject;
             destGradientAngularVelocity._type = this._type;
             destGradientAngularVelocity._separateAxes = this._separateAxes;
             destGradientAngularVelocity._constant = this._constant;
             this._constantSeparate.cloneTo(destGradientAngularVelocity._constantSeparate);
             this._gradient.cloneTo(destGradientAngularVelocity._gradient);
             this._gradientX.cloneTo(destGradientAngularVelocity._gradientX);
             this._gradientY.cloneTo(destGradientAngularVelocity._gradientY);
             this._gradientZ.cloneTo(destGradientAngularVelocity._gradientZ);
             destGradientAngularVelocity._constantMin = this._constantMin;
             destGradientAngularVelocity._constantMax = this._constantMax;
             this._constantMinSeparate.cloneTo(destGradientAngularVelocity._constantMinSeparate);
             this._constantMaxSeparate.cloneTo(destGradientAngularVelocity._constantMaxSeparate);
             this._gradientMin.cloneTo(destGradientAngularVelocity._gradientMin);
             this._gradientMax.cloneTo(destGradientAngularVelocity._gradientMax);
             this._gradientXMin.cloneTo(destGradientAngularVelocity._gradientXMin);
             this._gradientXMax.cloneTo(destGradientAngularVelocity._gradientXMax);
             this._gradientYMin.cloneTo(destGradientAngularVelocity._gradientYMin);
             this._gradientYMax.cloneTo(destGradientAngularVelocity._gradientYMax);
             this._gradientZMin.cloneTo(destGradientAngularVelocity._gradientZMin);
             this._gradientZMax.cloneTo(destGradientAngularVelocity._gradientZMax);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destGradientAngularVelocity = new GradientAngularVelocity();
             this.cloneTo(destGradientAngularVelocity);
             return destGradientAngularVelocity;
         }
     }

     /**
      * <code>GradientDataInt</code> 类用于创建整形渐变。
      */
     class GradientDataInt {
         /**
          * 创建一个 <code>GradientDataInt</code> 实例。
          */
         constructor() {
             /**@private */
             this._currentLength = 0;
             this._elements = new Float32Array(8);
         }
         /**整形渐变数量。*/
         get gradientCount() {
             return this._currentLength / 2;
         }
         /**
          * 增加整形渐变。
          * @param	key 生命周期，范围为0到1。
          * @param	value 整形值。
          */
         add(key, value) {
             if (this._currentLength < 8) {
                 if ((this._currentLength === 6) && ((key !== 1))) {
                     key = 1;
                     console.log("Warning:the forth key is  be force set to 1.");
                 }
                 this._elements[this._currentLength++] = key;
                 this._elements[this._currentLength++] = value;
             }
             else {
                 console.log("Warning:data count must lessEqual than 4");
             }
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destGradientDataInt = destObject;
             destGradientDataInt._currentLength = this._currentLength;
             var destElements = destGradientDataInt._elements;
             for (var i = 0, n = this._elements.length; i < n; i++) {
                 destElements[i] = this._elements[i];
             }
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destGradientDataInt = new GradientDataInt();
             this.cloneTo(destGradientDataInt);
             return destGradientDataInt;
         }
     }

     /**
      * <code>GradientSize</code> 类用于创建渐变尺寸。
      */
     class GradientSize {
         /**
          * 创建一个 <code>GradientSize,不允许new，请使用静态创建函数。</code> 实例。
          */
         constructor() {
             /**@private */
             this._type = 0;
             /**@private */
             this._separateAxes = false;
             /**@private */
             this._gradient = null;
             /**@private */
             this._gradientX = null;
             /**@private */
             this._gradientY = null;
             /**@private */
             this._gradientZ = null;
             /**@private */
             this._constantMin = 0;
             /**@private */
             this._constantMax = 0;
             /**@private */
             this._constantMinSeparate = null;
             /**@private */
             this._constantMaxSeparate = null;
             /**@private */
             this._gradientMin = null;
             /**@private */
             this._gradientMax = null;
             /**@private */
             this._gradientXMin = null;
             /**@private */
             this._gradientXMax = null;
             /**@private */
             this._gradientYMin = null;
             /**@private */
             this._gradientYMax = null;
             /**@private */
             this._gradientZMin = null;
             /**@private */
             this._gradientZMax = null;
         }
         /**
          * 通过渐变尺寸创建一个 <code>GradientSize</code> 实例。
          * @param	gradient 渐变尺寸。
          * @return  渐变尺寸。
          */
         static createByGradient(gradient) {
             var gradientSize = new GradientSize();
             gradientSize._type = 0;
             gradientSize._separateAxes = false;
             gradientSize._gradient = gradient;
             return gradientSize;
         }
         /**
          * 通过分轴渐变尺寸创建一个 <code>GradientSize</code> 实例。
          * @param	gradientX 渐变尺寸X。
          * @param	gradientY 渐变尺寸Y。
          * @param	gradientZ 渐变尺寸Z。
          * @return  渐变尺寸。
          */
         static createByGradientSeparate(gradientX, gradientY, gradientZ) {
             var gradientSize = new GradientSize();
             gradientSize._type = 0;
             gradientSize._separateAxes = true;
             gradientSize._gradientX = gradientX;
             gradientSize._gradientY = gradientY;
             gradientSize._gradientZ = gradientZ;
             return gradientSize;
         }
         /**
          * 通过随机双固定尺寸创建一个 <code>GradientSize</code> 实例。
          * @param	constantMin 最小固定尺寸。
          * @param	constantMax 最大固定尺寸。
          * @return 渐变尺寸。
          */
         static createByRandomTwoConstant(constantMin, constantMax) {
             var gradientSize = new GradientSize();
             gradientSize._type = 1;
             gradientSize._separateAxes = false;
             gradientSize._constantMin = constantMin;
             gradientSize._constantMax = constantMax;
             return gradientSize;
         }
         /**
          * 通过分轴随机双固定尺寸创建一个 <code>GradientSize</code> 实例。
          * @param	constantMinSeparate 分轴最小固定尺寸.
          * @param	constantMaxSeparate 分轴最大固定尺寸。
          * @return   渐变尺寸。
          */
         static createByRandomTwoConstantSeparate(constantMinSeparate, constantMaxSeparate) {
             var gradientSize = new GradientSize();
             gradientSize._type = 1;
             gradientSize._separateAxes = true;
             gradientSize._constantMinSeparate = constantMinSeparate;
             gradientSize._constantMaxSeparate = constantMaxSeparate;
             return gradientSize;
         }
         /**
          * 通过随机双渐变尺寸创建一个 <code>GradientSize</code> 实例。
          * @param	gradientMin 最小渐变尺寸。
          * @param	gradientMax 最大渐变尺寸。
          * @return 渐变尺寸。
          */
         static createByRandomTwoGradient(gradientMin, gradientMax) {
             var gradientSize = new GradientSize();
             gradientSize._type = 2;
             gradientSize._separateAxes = false;
             gradientSize._gradientMin = gradientMin;
             gradientSize._gradientMax = gradientMax;
             return gradientSize;
         }
         /**
          * 通过分轴随机双渐变尺寸创建一个 <code>GradientSize</code> 实例。
          * @param	gradientXMin X轴最小渐变尺寸。
          * @param	gradientXMax X轴最大渐变尺寸。
          * @param	gradientYMin Y轴最小渐变尺寸。
          * @param	gradientYMax Y轴最大渐变尺寸。
          * @param	gradientZMin Z轴最小渐变尺寸。
          * @param	gradientZMax Z轴最大渐变尺寸。
          * @return  渐变尺寸。
          */
         static createByRandomTwoGradientSeparate(gradientXMin, gradientXMax, gradientYMin, gradientYMax, gradientZMin, gradientZMax) {
             var gradientSize = new GradientSize();
             gradientSize._type = 2;
             gradientSize._separateAxes = true;
             gradientSize._gradientXMin = gradientXMin;
             gradientSize._gradientXMax = gradientXMax;
             gradientSize._gradientYMin = gradientYMin;
             gradientSize._gradientYMax = gradientYMax;
             gradientSize._gradientZMin = gradientZMin;
             gradientSize._gradientZMax = gradientZMax;
             return gradientSize;
         }
         /**
          *生命周期尺寸类型，0曲线模式，1随机双常量模式，2随机双曲线模式。
          */
         get type() {
             return this._type;
         }
         /**
          *是否分轴。
          */
         get separateAxes() {
             return this._separateAxes;
         }
         /**
          * 渐变尺寸。
          */
         get gradient() {
             return this._gradient;
         }
         /**
          * 渐变尺寸X。
          */
         get gradientX() {
             return this._gradientX;
         }
         /**
          * 渐变尺寸Y。
          */
         get gradientY() {
             return this._gradientY;
         }
         /**
          *渐变尺寸Z。
          */
         get gradientZ() {
             return this._gradientZ;
         }
         /**
          *最小随机双固定尺寸。
          */
         get constantMin() {
             return this._constantMin;
         }
         /**
          * 最大随机双固定尺寸。
          */
         get constantMax() {
             return this._constantMax;
         }
         /**
          * 最小分轴随机双固定尺寸。
          */
         get constantMinSeparate() {
             return this._constantMinSeparate;
         }
         /**
          *  最小分轴随机双固定尺寸。
          */
         get constantMaxSeparate() {
             return this._constantMaxSeparate;
         }
         /**
          *渐变最小尺寸。
          */
         get gradientMin() {
             return this._gradientMin;
         }
         /**
          * 渐变最大尺寸。
          */
         get gradientMax() {
             return this._gradientMax;
         }
         /**
          * 渐变最小尺寸X。
          */
         get gradientXMin() {
             return this._gradientXMin;
         }
         /**
          * 渐变最大尺寸X。
          */
         get gradientXMax() {
             return this._gradientXMax;
         }
         /**
          * 渐变最小尺寸Y。
          */
         get gradientYMin() {
             return this._gradientYMin;
         }
         /**
          *渐变最大尺寸Y。
          */
         get gradientYMax() {
             return this._gradientYMax;
         }
         /**
          * 渐变最小尺寸Z。
          */
         get gradientZMin() {
             return this._gradientZMin;
         }
         /**
          * 渐变最大尺寸Z。
          */
         get gradientZMax() {
             return this._gradientZMax;
         }
         /**
          * 获取最大尺寸。
          */
         getMaxSizeInGradient() {
             var i, n;
             var maxSize = -Number.MAX_VALUE;
             switch (this._type) {
                 case 0:
                     if (this._separateAxes) {
                         for (i = 0, n = this._gradientX.gradientCount; i < n; i++)
                             maxSize = Math.max(maxSize, this._gradientX.getValueByIndex(i));
                         for (i = 0, n = this._gradientY.gradientCount; i < n; i++)
                             maxSize = Math.max(maxSize, this._gradientY.getValueByIndex(i));
                         //TODO:除了RenderMode为MeshZ无效
                     }
                     else {
                         for (i = 0, n = this._gradient.gradientCount; i < n; i++)
                             maxSize = Math.max(maxSize, this._gradient.getValueByIndex(i));
                     }
                     break;
                 case 1:
                     if (this._separateAxes) {
                         maxSize = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x);
                         maxSize = Math.max(maxSize, this._constantMinSeparate.y);
                         maxSize = Math.max(maxSize, this._constantMaxSeparate.y);
                         //TODO:除了RenderMode为MeshZ无效
                     }
                     else {
                         maxSize = Math.max(this._constantMin, this._constantMax);
                     }
                     break;
                 case 2:
                     if (this._separateAxes) {
                         for (i = 0, n = this._gradientXMin.gradientCount; i < n; i++)
                             maxSize = Math.max(maxSize, this._gradientXMin.getValueByIndex(i));
                         for (i = 0, n = this._gradientXMax.gradientCount; i < n; i++)
                             maxSize = Math.max(maxSize, this._gradientXMax.getValueByIndex(i));
                         for (i = 0, n = this._gradientYMin.gradientCount; i < n; i++)
                             maxSize = Math.max(maxSize, this._gradientYMin.getValueByIndex(i));
                         for (i = 0, n = this._gradientZMax.gradientCount; i < n; i++)
                             maxSize = Math.max(maxSize, this._gradientZMax.getValueByIndex(i));
                         //TODO:除了RenderMode为MeshZ无效
                     }
                     else {
                         for (i = 0, n = this._gradientMin.gradientCount; i < n; i++)
                             maxSize = Math.max(maxSize, this._gradientMin.getValueByIndex(i));
                         for (i = 0, n = this._gradientMax.gradientCount; i < n; i++)
                             maxSize = Math.max(maxSize, this._gradientMax.getValueByIndex(i));
                     }
                     break;
             }
             return maxSize;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destGradientSize = destObject;
             destGradientSize._type = this._type;
             destGradientSize._separateAxes = this._separateAxes;
             this._gradient.cloneTo(destGradientSize._gradient);
             this._gradientX.cloneTo(destGradientSize._gradientX);
             this._gradientY.cloneTo(destGradientSize._gradientY);
             this._gradientZ.cloneTo(destGradientSize._gradientZ);
             destGradientSize._constantMin = this._constantMin;
             destGradientSize._constantMax = this._constantMax;
             this._constantMinSeparate.cloneTo(destGradientSize._constantMinSeparate);
             this._constantMaxSeparate.cloneTo(destGradientSize._constantMaxSeparate);
             this._gradientMin.cloneTo(destGradientSize._gradientMin);
             this._gradientMax.cloneTo(destGradientSize._gradientMax);
             this._gradientXMin.cloneTo(destGradientSize._gradientXMin);
             this._gradientXMax.cloneTo(destGradientSize._gradientXMax);
             this._gradientYMin.cloneTo(destGradientSize._gradientYMin);
             this._gradientYMax.cloneTo(destGradientSize._gradientYMax);
             this._gradientZMin.cloneTo(destGradientSize._gradientZMin);
             this._gradientZMax.cloneTo(destGradientSize._gradientZMax);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destGradientSize = new GradientSize();
             this.cloneTo(destGradientSize);
             return destGradientSize;
         }
     }

     /**
      * <code>GradientVelocity</code> 类用于创建渐变速度。
      */
     class GradientVelocity {
         /**
          * 创建一个 <code>GradientVelocity,不允许new，请使用静态创建函数。</code> 实例。
          */
         constructor() {
             /**@private */
             this._type = 0;
             /**@private */
             this._constant = null;
             /**@private */
             this._gradientX = null;
             /**@private */
             this._gradientY = null;
             /**@private */
             this._gradientZ = null;
             /**@private */
             this._constantMin = null;
             /**@private */
             this._constantMax = null;
             /**@private */
             this._gradientXMin = null;
             /**@private */
             this._gradientXMax = null;
             /**@private */
             this._gradientYMin = null;
             /**@private */
             this._gradientYMax = null;
             /**@private */
             this._gradientZMin = null;
             /**@private */
             this._gradientZMax = null;
         }
         /**
          * 通过固定速度创建一个 <code>GradientVelocity</code> 实例。
          * @param	constant 固定速度。
          * @return 渐变速度。
          */
         static createByConstant(constant) {
             var gradientVelocity = new GradientVelocity();
             gradientVelocity._type = 0;
             gradientVelocity._constant = constant;
             return gradientVelocity;
         }
         /**
          * 通过渐变速度创建一个 <code>GradientVelocity</code> 实例。
          * @param	gradientX 渐变速度X。
          * @param	gradientY 渐变速度Y。
          * @param	gradientZ 渐变速度Z。
          * @return  渐变速度。
          */
         static createByGradient(gradientX, gradientY, gradientZ) {
             var gradientVelocity = new GradientVelocity();
             gradientVelocity._type = 1;
             gradientVelocity._gradientX = gradientX;
             gradientVelocity._gradientY = gradientY;
             gradientVelocity._gradientZ = gradientZ;
             return gradientVelocity;
         }
         /**
          * 通过随机双固定速度创建一个 <code>GradientVelocity</code> 实例。
          * @param	constantMin 最小固定角速度。
          * @param	constantMax 最大固定角速度。
          * @return 渐变速度。
          */
         static createByRandomTwoConstant(constantMin, constantMax) {
             var gradientVelocity = new GradientVelocity();
             gradientVelocity._type = 2;
             gradientVelocity._constantMin = constantMin;
             gradientVelocity._constantMax = constantMax;
             return gradientVelocity;
         }
         /**
          * 通过随机双渐变速度创建一个 <code>GradientVelocity</code> 实例。
          * @param	gradientXMin X轴最小渐变速度。
          * @param	gradientXMax X轴最大渐变速度。
          * @param	gradientYMin Y轴最小渐变速度。
          * @param	gradientYMax Y轴最大渐变速度。
          * @param	gradientZMin Z轴最小渐变速度。
          * @param	gradientZMax Z轴最大渐变速度。
          * @return  渐变速度。
          */
         static createByRandomTwoGradient(gradientXMin, gradientXMax, gradientYMin, gradientYMax, gradientZMin, gradientZMax) {
             var gradientVelocity = new GradientVelocity();
             gradientVelocity._type = 3;
             gradientVelocity._gradientXMin = gradientXMin;
             gradientVelocity._gradientXMax = gradientXMax;
             gradientVelocity._gradientYMin = gradientYMin;
             gradientVelocity._gradientYMax = gradientYMax;
             gradientVelocity._gradientZMin = gradientZMin;
             gradientVelocity._gradientZMax = gradientZMax;
             return gradientVelocity;
         }
         /**
          *生命周期速度类型，0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
          */
         get type() {
             return this._type;
         }
         /**固定速度。*/
         get constant() {
             return this._constant;
         }
         /**
          * 渐变速度X。
          */
         get gradientX() {
             return this._gradientX;
         }
         /**
          * 渐变速度Y。
          */
         get gradientY() {
             return this._gradientY;
         }
         /**
          *渐变速度Z。
          */
         get gradientZ() {
             return this._gradientZ;
         }
         /**最小固定速度。*/
         get constantMin() {
             return this._constantMin;
         }
         /**最大固定速度。*/
         get constantMax() {
             return this._constantMax;
         }
         /**
          * 渐变最小速度X。
          */
         get gradientXMin() {
             return this._gradientXMin;
         }
         /**
          * 渐变最大速度X。
          */
         get gradientXMax() {
             return this._gradientXMax;
         }
         /**
          * 渐变最小速度Y。
          */
         get gradientYMin() {
             return this._gradientYMin;
         }
         /**
          *渐变最大速度Y。
          */
         get gradientYMax() {
             return this._gradientYMax;
         }
         /**
          * 渐变最小速度Z。
          */
         get gradientZMin() {
             return this._gradientZMin;
         }
         /**
          * 渐变最大速度Z。
          */
         get gradientZMax() {
             return this._gradientZMax;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destGradientVelocity = destObject;
             destGradientVelocity._type = this._type;
             this._constant.cloneTo(destGradientVelocity._constant);
             this._gradientX.cloneTo(destGradientVelocity._gradientX);
             this._gradientY.cloneTo(destGradientVelocity._gradientY);
             this._gradientZ.cloneTo(destGradientVelocity._gradientZ);
             this._constantMin.cloneTo(destGradientVelocity._constantMin);
             this._constantMax.cloneTo(destGradientVelocity._constantMax);
             this._gradientXMin.cloneTo(destGradientVelocity._gradientXMin);
             this._gradientXMax.cloneTo(destGradientVelocity._gradientXMax);
             this._gradientYMin.cloneTo(destGradientVelocity._gradientYMin);
             this._gradientYMax.cloneTo(destGradientVelocity._gradientYMax);
             this._gradientZMin.cloneTo(destGradientVelocity._gradientZMin);
             this._gradientZMax.cloneTo(destGradientVelocity._gradientZMax);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destGradientVelocity = new GradientVelocity();
             this.cloneTo(destGradientVelocity);
             return destGradientVelocity;
         }
     }

     /**
      * <code>RotationOverLifetime</code> 类用于粒子的生命周期旋转。
      */
     class RotationOverLifetime {
         /**
          *获取角速度。
          */
         get angularVelocity() {
             return this._angularVelocity;
         }
         /**
          * 创建一个 <code>RotationOverLifetime,不允许new，请使用静态创建函数。</code> 实例。
          */
         constructor(angularVelocity) {
             this._angularVelocity = angularVelocity;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destRotationOverLifetime = destObject;
             this._angularVelocity.cloneTo(destRotationOverLifetime._angularVelocity);
             destRotationOverLifetime.enbale = this.enbale;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destAngularVelocity;
             switch (this._angularVelocity.type) {
                 case 0:
                     if (this._angularVelocity.separateAxes)
                         destAngularVelocity = GradientAngularVelocity.createByConstantSeparate(this._angularVelocity.constantSeparate.clone());
                     else
                         destAngularVelocity = GradientAngularVelocity.createByConstant(this._angularVelocity.constant);
                     break;
                 case 1:
                     if (this._angularVelocity.separateAxes)
                         destAngularVelocity = GradientAngularVelocity.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone());
                     else
                         destAngularVelocity = GradientAngularVelocity.createByGradient(this._angularVelocity.gradient.clone());
                     break;
                 case 2:
                     if (this._angularVelocity.separateAxes)
                         destAngularVelocity = GradientAngularVelocity.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone());
                     else
                         destAngularVelocity = GradientAngularVelocity.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                     break;
                 case 3:
                     if (this._angularVelocity.separateAxes)
                         destAngularVelocity = GradientAngularVelocity.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone());
                     else
                         destAngularVelocity = GradientAngularVelocity.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
                     break;
             }
             var destRotationOverLifetime = new RotationOverLifetime(destAngularVelocity);
             destRotationOverLifetime.enbale = this.enbale;
             return destRotationOverLifetime;
         }
     }

     /**
      * <code>BaseShape</code> 类用于粒子形状。
      */
     class BaseShape {
         /**
          * 创建一个 <code>BaseShape</code> 实例。
          */
         constructor() {
         }
         /**@private */
         _getShapeBoundBox(boundBox) {
             throw new Error("BaseShape: must override it.");
         }
         /**@private */
         _getSpeedBoundBox(boundBox) {
             throw new Error("BaseShape: must override it.");
         }
         /**
          * 用于生成粒子初始位置和方向。
          * @param	position 粒子位置。
          * @param	direction 粒子方向。
          */
         generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
             throw new Error("BaseShape: must override it.");
         }
         /**
          * @private
          */
         _calculateProceduralBounds(boundBox, emitterPosScale, minMaxBounds) {
             this._getShapeBoundBox(boundBox);
             var min = boundBox.min;
             var max = boundBox.max;
             Vector3.multiply(min, emitterPosScale, min);
             Vector3.multiply(max, emitterPosScale, max);
             var speedBounds = new BoundBox(new Vector3(), new Vector3());
             if (this.randomDirection /* && (m_Type != kCone) && (m_Type != kConeShell)*/) //TODO:randomDirection应换成0到1
              {
                 speedBounds.min = new Vector3(-1, -1, -1);
                 speedBounds.max = new Vector3(1, 1, 1);
                 //minMaxBounds = Abs(minMaxBounds);
             }
             else {
                 this._getSpeedBoundBox(speedBounds);
             }
             var maxSpeedBound = new BoundBox(new Vector3(), new Vector3());
             var maxSpeedMin = maxSpeedBound.min;
             var maxSpeedMax = maxSpeedBound.max;
             Vector3.scale(speedBounds.min, minMaxBounds.y, maxSpeedMin);
             Vector3.scale(speedBounds.max, minMaxBounds.y, maxSpeedMax);
             Vector3.add(boundBox.min, maxSpeedMin, maxSpeedMin);
             Vector3.add(boundBox.max, maxSpeedMax, maxSpeedMax);
             Vector3.min(boundBox.min, maxSpeedMin, boundBox.min);
             Vector3.max(boundBox.max, maxSpeedMin, boundBox.max);
             var minSpeedBound = new BoundBox(new Vector3(), new Vector3());
             var minSpeedMin = minSpeedBound.min;
             var minSpeedMax = minSpeedBound.max;
             Vector3.scale(speedBounds.min, minMaxBounds.x, minSpeedMin);
             Vector3.scale(speedBounds.max, minMaxBounds.x, minSpeedMax);
             Vector3.min(minSpeedBound.min, minSpeedMax, maxSpeedMin);
             Vector3.max(minSpeedBound.min, minSpeedMax, maxSpeedMax);
             Vector3.min(boundBox.min, maxSpeedMin, boundBox.min);
             Vector3.max(boundBox.max, maxSpeedMin, boundBox.max);
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destShape = destObject;
             destShape.enable = this.enable;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destShape = new BaseShape();
             this.cloneTo(destShape);
             return destShape;
         }
     }

     /**
      * ...
      * @author ...
      */
     class ShapeUtils {
         static _randomPointUnitArcCircle(arc, out, rand = null) {
             var angle;
             if (rand)
                 angle = rand.getFloat() * arc;
             else
                 angle = Math.random() * arc;
             out.x = Math.cos(angle);
             out.y = Math.sin(angle);
         }
         static _randomPointInsideUnitArcCircle(arc, out, rand = null) {
             ShapeUtils._randomPointUnitArcCircle(arc, out, rand);
             var range;
             if (rand)
                 range = Math.pow(rand.getFloat(), 1.0 / 2.0);
             else
                 range = Math.pow(Math.random(), 1.0 / 2.0);
             out.x = out.x * range;
             out.y = out.y * range;
         }
         static _randomPointUnitCircle(out, rand = null) {
             var angle;
             if (rand)
                 angle = rand.getFloat() * Math.PI * 2;
             else
                 angle = Math.random() * Math.PI * 2;
             out.x = Math.cos(angle);
             out.y = Math.sin(angle);
         }
         static _randomPointInsideUnitCircle(out, rand = null) {
             ShapeUtils._randomPointUnitCircle(out);
             var range;
             if (rand)
                 range = Math.pow(rand.getFloat(), 1.0 / 2.0);
             else
                 range = Math.pow(Math.random(), 1.0 / 2.0);
             out.x = out.x * range;
             out.y = out.y * range;
         }
         static _randomPointUnitSphere(out, rand = null) {
             var z;
             var a;
             if (rand) {
                 z = out.z = rand.getFloat() * 2 - 1.0;
                 a = rand.getFloat() * Math.PI * 2;
             }
             else {
                 z = out.z = Math.random() * 2 - 1.0;
                 a = Math.random() * Math.PI * 2;
             }
             var r = Math.sqrt(1.0 - z * z);
             out.x = r * Math.cos(a);
             out.y = r * Math.sin(a);
         }
         static _randomPointInsideUnitSphere(out, rand = null) {
             ShapeUtils._randomPointUnitSphere(out);
             var range;
             if (rand)
                 range = Math.pow(rand.getFloat(), 1.0 / 3.0);
             else
                 range = Math.pow(Math.random(), 1.0 / 3.0);
             out.x = out.x * range;
             out.y = out.y * range;
             out.z = out.z * range;
         }
         static _randomPointInsideHalfUnitBox(out, rand = null) {
             if (rand) {
                 out.x = (rand.getFloat() - 0.5);
                 out.y = (rand.getFloat() - 0.5);
                 out.z = (rand.getFloat() - 0.5);
             }
             else {
                 out.x = (Math.random() - 0.5);
                 out.y = (Math.random() - 0.5);
                 out.z = (Math.random() - 0.5);
             }
         }
         constructor() {
         }
     }

     /**
      * <code>BoxShape</code> 类用于创建球形粒子形状。
      */
     class BoxShape extends BaseShape {
         /**
          * 创建一个 <code>BoxShape</code> 实例。
          */
         constructor() {
             super();
             this.x = 1.0;
             this.y = 1.0;
             this.z = 1.0;
             this.randomDirection = false;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getShapeBoundBox(boundBox) {
             var min = boundBox.min;
             min.x = -this.x * 0.5;
             min.y = -this.y * 0.5;
             min.z = -this.z * 0.5;
             var max = boundBox.max;
             max.x = this.x * 0.5;
             max.y = this.y * 0.5;
             max.z = this.z * 0.5;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getSpeedBoundBox(boundBox) {
             var min = boundBox.min;
             min.x = 0.0;
             min.y = 0.0;
             min.z = 0.0;
             var max = boundBox.max;
             max.x = 0.0;
             max.y = 1.0;
             max.z = 0.0;
         }
         /**
          *  用于生成粒子初始位置和方向。
          * @param	position 粒子位置。
          * @param	direction 粒子方向。
          */
         /*override*/ generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
             if (rand) {
                 rand.seed = randomSeeds[16];
                 ShapeUtils._randomPointInsideHalfUnitBox(position, rand);
                 randomSeeds[16] = rand.seed;
             }
             else {
                 ShapeUtils._randomPointInsideHalfUnitBox(position);
             }
             position.x = this.x * position.x;
             position.y = this.y * position.y;
             position.z = this.z * position.z;
             if (this.randomDirection) {
                 if (rand) {
                     rand.seed = randomSeeds[17];
                     ShapeUtils._randomPointUnitSphere(direction, rand);
                     randomSeeds[17] = rand.seed;
                 }
                 else {
                     ShapeUtils._randomPointUnitSphere(direction);
                 }
             }
             else {
                 direction.x = 0.0;
                 direction.y = 0.0;
                 direction.z = 1.0;
             }
         }
         /*override*/ cloneTo(destObject) {
             super.cloneTo(destObject);
             var destShape = destObject;
             destShape.x = this.x;
             destShape.y = this.y;
             destShape.z = this.z;
             destShape.randomDirection = this.randomDirection;
         }
     }

     /**
      * <code>CircleShape</code> 类用于创建环形粒子形状。
      */
     class CircleShape extends BaseShape {
         /**
          * 创建一个 <code>CircleShape</code> 实例。
          */
         constructor() {
             super();
             this.radius = 1.0;
             this.arc = 360.0 / 180.0 * Math.PI;
             this.emitFromEdge = false;
             this.randomDirection = false;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getShapeBoundBox(boundBox) {
             var min = boundBox.min;
             min.x = min.z = -this.radius;
             min.y = 0;
             var max = boundBox.max;
             max.x = max.z = this.radius;
             max.y = 0;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getSpeedBoundBox(boundBox) {
             var min = boundBox.min;
             min.x = min.y = -1;
             min.z = 0;
             var max = boundBox.max;
             max.x = max.y = 1;
             max.z = 0;
         }
         /**
          *  用于生成粒子初始位置和方向。
          * @param	position 粒子位置。
          * @param	direction 粒子方向。
          */
         /*override*/ generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
             var positionPoint = CircleShape._tempPositionPoint;
             if (rand) {
                 rand.seed = randomSeeds[16];
                 if (this.emitFromEdge)
                     ShapeUtils._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint, rand);
                 else
                     ShapeUtils._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint, rand);
                 randomSeeds[16] = rand.seed;
             }
             else {
                 if (this.emitFromEdge)
                     ShapeUtils._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint);
                 else
                     ShapeUtils._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint);
             }
             position.x = -positionPoint.x;
             position.y = positionPoint.y;
             position.z = 0;
             Vector3.scale(position, this.radius, position);
             if (this.randomDirection) {
                 if (rand) {
                     rand.seed = randomSeeds[17];
                     ShapeUtils._randomPointUnitSphere(direction, rand);
                     randomSeeds[17] = rand.seed;
                 }
                 else {
                     ShapeUtils._randomPointUnitSphere(direction);
                 }
             }
             else {
                 position.cloneTo(direction);
             }
         }
         /*override*/ cloneTo(destObject) {
             super.cloneTo(destObject);
             var destShape = destObject;
             destShape.radius = this.radius;
             destShape.arc = this.arc;
             destShape.emitFromEdge = this.emitFromEdge;
             destShape.randomDirection = this.randomDirection;
         }
     }
     /** @private */
     CircleShape._tempPositionPoint = new Vector2();

     /**
      * <code>ConeShape</code> 类用于创建锥形粒子形状。
      */
     class ConeShape extends BaseShape {
         /**
          * 创建一个 <code>ConeShape</code> 实例。
          */
         constructor() {
             super();
             this.angle = 25.0 / 180.0 * Math.PI;
             this.radius = 1.0;
             this.length = 5.0;
             this.emitType = 0;
             this.randomDirection = false;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getShapeBoundBox(boundBox) {
             const coneRadius2 = this.radius + this.length * Math.sin(this.angle);
             const coneLength = this.length * Math.cos(this.angle);
             var min = boundBox.min;
             min.x = min.y = -coneRadius2;
             min.z = 0;
             var max = boundBox.max;
             max.x = max.y = coneRadius2;
             max.z = coneLength; //TODO:是否为负
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getSpeedBoundBox(boundBox) {
             const sinA = Math.sin(this.angle);
             var min = boundBox.min;
             min.x = min.y = -sinA;
             min.z = 0;
             var max = boundBox.max;
             max.x = max.y = sinA;
             max.z = 1;
         }
         /**
          *  用于生成粒子初始位置和方向。
          * @param	position 粒子位置。
          * @param	direction 粒子方向。
          */
         /*override*/ generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
             var positionPointE = ConeShape._tempPositionPoint;
             var positionX;
             var positionY;
             var directionPointE;
             var dirCosA = Math.cos(this.angle);
             var dirSinA = Math.sin(this.angle);
             switch (this.emitType) {
                 case 0:
                     if (rand) {
                         rand.seed = randomSeeds[16];
                         ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, rand);
                         randomSeeds[16] = rand.seed;
                     }
                     else {
                         ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
                     }
                     positionX = positionPointE.x;
                     positionY = positionPointE.y;
                     position.x = positionX * this.radius;
                     position.y = positionY * this.radius;
                     position.z = 0;
                     if (this.randomDirection) {
                         if (rand) {
                             rand.seed = randomSeeds[17];
                             ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, rand);
                             randomSeeds[17] = rand.seed;
                         }
                         else {
                             ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
                         }
                         directionPointE = ConeShape._tempDirectionPoint;
                         direction.x = directionPointE.x * dirSinA;
                         direction.y = directionPointE.y * dirSinA;
                     }
                     else {
                         direction.x = positionX * dirSinA;
                         direction.y = positionY * dirSinA;
                     }
                     direction.z = dirCosA;
                     break;
                 case 1:
                     if (rand) {
                         rand.seed = randomSeeds[16];
                         ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint, rand);
                         randomSeeds[16] = rand.seed;
                     }
                     else {
                         ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
                     }
                     positionX = positionPointE.x;
                     positionY = positionPointE.y;
                     position.x = positionX * this.radius;
                     position.y = positionY * this.radius;
                     position.z = 0;
                     if (this.randomDirection) {
                         if (rand) {
                             rand.seed = randomSeeds[17];
                             ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, rand);
                             randomSeeds[17] = rand.seed;
                         }
                         else {
                             ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
                         }
                         directionPointE = ConeShape._tempDirectionPoint;
                         direction.x = directionPointE.x * dirSinA;
                         direction.y = directionPointE.y * dirSinA;
                     }
                     else {
                         direction.x = positionX * dirSinA;
                         direction.y = positionY * dirSinA;
                     }
                     direction.z = dirCosA;
                     break;
                 case 2:
                     if (rand) {
                         rand.seed = randomSeeds[16];
                         ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, rand);
                     }
                     else {
                         ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
                     }
                     positionX = positionPointE.x;
                     positionY = positionPointE.y;
                     position.x = positionX * this.radius;
                     position.y = positionY * this.radius;
                     position.z = 0;
                     direction.x = positionX * dirSinA;
                     direction.y = positionY * dirSinA;
                     direction.z = dirCosA;
                     Vector3.normalize(direction, direction);
                     if (rand) {
                         Vector3.scale(direction, this.length * rand.getFloat(), direction);
                         randomSeeds[16] = rand.seed;
                     }
                     else {
                         Vector3.scale(direction, this.length * Math.random(), direction);
                     }
                     Vector3.add(position, direction, position);
                     if (this.randomDirection) {
                         if (rand) {
                             rand.seed = randomSeeds[17];
                             ShapeUtils._randomPointUnitSphere(direction, rand);
                             randomSeeds[17] = rand.seed;
                         }
                         else {
                             ShapeUtils._randomPointUnitSphere(direction);
                         }
                     }
                     break;
                 case 3:
                     if (rand) {
                         rand.seed = randomSeeds[16];
                         ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint, rand);
                     }
                     else {
                         ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
                     }
                     positionX = positionPointE.x;
                     positionY = positionPointE.y;
                     position.x = positionX * this.radius;
                     position.y = positionY * this.radius;
                     position.z = 0;
                     direction.x = positionX * dirSinA;
                     direction.y = positionY * dirSinA;
                     direction.z = dirCosA;
                     Vector3.normalize(direction, direction);
                     if (rand) {
                         Vector3.scale(direction, this.length * rand.getFloat(), direction);
                         randomSeeds[16] = rand.seed;
                     }
                     else {
                         Vector3.scale(direction, this.length * Math.random(), direction);
                     }
                     Vector3.add(position, direction, position);
                     if (this.randomDirection) {
                         if (rand) {
                             rand.seed = randomSeeds[17];
                             ShapeUtils._randomPointUnitSphere(direction, rand);
                             randomSeeds[17] = rand.seed;
                         }
                         else {
                             ShapeUtils._randomPointUnitSphere(direction);
                         }
                     }
                     break;
                 default:
                     throw new Error("ConeShape:emitType is invalid.");
             }
         }
         /*override*/ cloneTo(destObject) {
             super.cloneTo(destObject);
             var destShape = destObject;
             destShape.angle = this.angle;
             destShape.radius = this.radius;
             destShape.length = this.length;
             destShape.emitType = this.emitType;
             destShape.randomDirection = this.randomDirection;
         }
     }
     /** @private */
     ConeShape._tempPositionPoint = new Vector2();
     /** @private */
     ConeShape._tempDirectionPoint = new Vector2();

     /**
      * <code>HemisphereShape</code> 类用于创建半球形粒子形状。
      */
     class HemisphereShape extends BaseShape {
         /**
          * 创建一个 <code>HemisphereShape</code> 实例。
          */
         constructor() {
             super();
             this.radius = 1.0;
             this.emitFromShell = false;
             this.randomDirection = false;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getShapeBoundBox(boundBox) {
             var min = boundBox.min;
             min.x = min.y = min.z = -this.radius;
             var max = boundBox.max;
             max.x = max.y = this.radius;
             max.z = 0;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getSpeedBoundBox(boundBox) {
             var min = boundBox.min;
             min.x = min.y = -1;
             min.z = 0;
             var max = boundBox.max;
             max.x = max.y = max.z = 1;
         }
         /**
          *  用于生成粒子初始位置和方向。
          * @param	position 粒子位置。
          * @param	direction 粒子方向。
          */
         /*override*/ generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
             if (rand) {
                 rand.seed = randomSeeds[16];
                 if (this.emitFromShell)
                     ShapeUtils._randomPointUnitSphere(position, rand);
                 else
                     ShapeUtils._randomPointInsideUnitSphere(position, rand);
                 randomSeeds[16] = rand.seed;
             }
             else {
                 if (this.emitFromShell)
                     ShapeUtils._randomPointUnitSphere(position);
                 else
                     ShapeUtils._randomPointInsideUnitSphere(position);
             }
             Vector3.scale(position, this.radius, position);
             var z = position.z;
             (z < 0.0) && (position.z = z * -1.0);
             if (this.randomDirection) {
                 if (rand) {
                     rand.seed = randomSeeds[17];
                     ShapeUtils._randomPointUnitSphere(direction, rand);
                     randomSeeds[17] = rand.seed;
                 }
                 else {
                     ShapeUtils._randomPointUnitSphere(direction);
                 }
             }
             else {
                 position.cloneTo(direction);
             }
         }
         /*override*/ cloneTo(destObject) {
             super.cloneTo(destObject);
             var destShape = destObject;
             destShape.radius = this.radius;
             destShape.emitFromShell = this.emitFromShell;
             destShape.randomDirection = this.randomDirection;
         }
     }

     /**
      * <code>SphereShape</code> 类用于创建球形粒子形状。
      */
     class SphereShape extends BaseShape {
         /**
          * 创建一个 <code>SphereShape</code> 实例。
          */
         constructor() {
             super();
             this.radius = 1.0;
             this.emitFromShell = false;
             this.randomDirection = false;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getShapeBoundBox(boundBox) {
             var min = boundBox.min;
             min.x = min.y = min.z = -this.radius;
             var max = boundBox.max;
             max.x = max.y = max.z = this.radius;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getSpeedBoundBox(boundBox) {
             var min = boundBox.min;
             min.x = min.y = min.z = -1;
             var max = boundBox.max;
             max.x = max.y = max.z = 1;
         }
         /**
          *  用于生成粒子初始位置和方向。
          * @param	position 粒子位置。
          * @param	direction 粒子方向。
          */
         /*override*/ generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
             if (rand) {
                 rand.seed = randomSeeds[16];
                 if (this.emitFromShell)
                     ShapeUtils._randomPointUnitSphere(position, rand);
                 else
                     ShapeUtils._randomPointInsideUnitSphere(position, rand);
                 randomSeeds[16] = rand.seed;
             }
             else {
                 if (this.emitFromShell)
                     ShapeUtils._randomPointUnitSphere(position);
                 else
                     ShapeUtils._randomPointInsideUnitSphere(position);
             }
             Vector3.scale(position, this.radius, position);
             if (this.randomDirection) {
                 if (rand) {
                     rand.seed = randomSeeds[17];
                     ShapeUtils._randomPointUnitSphere(direction, rand);
                     randomSeeds[17] = rand.seed;
                 }
                 else {
                     ShapeUtils._randomPointUnitSphere(direction);
                 }
             }
             else {
                 position.cloneTo(direction);
             }
         }
         /*override*/ cloneTo(destObject) {
             super.cloneTo(destObject);
             var destShape = destObject;
             destShape.radius = this.radius;
             destShape.emitFromShell = this.emitFromShell;
             destShape.randomDirection = this.randomDirection;
         }
     }

     /**
      * <code>SizeOverLifetime</code> 类用于粒子的生命周期尺寸。
      */
     class SizeOverLifetime {
         /**
          *获取尺寸。
          */
         get size() {
             return this._size;
         }
         /**
          * 创建一个 <code>SizeOverLifetime</code> 实例。
          */
         constructor(size) {
             this._size = size;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destSizeOverLifetime = destObject;
             this._size.cloneTo(destSizeOverLifetime._size);
             destSizeOverLifetime.enbale = this.enbale;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destSize;
             switch (this._size.type) {
                 case 0:
                     if (this._size.separateAxes)
                         destSize = GradientSize.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone());
                     else
                         destSize = GradientSize.createByGradient(this._size.gradient.clone());
                     break;
                 case 1:
                     if (this._size.separateAxes)
                         destSize = GradientSize.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone());
                     else
                         destSize = GradientSize.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                     break;
                 case 2:
                     if (this._size.separateAxes)
                         destSize = GradientSize.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone());
                     else
                         destSize = GradientSize.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
                     break;
             }
             var destSizeOverLifetime = new SizeOverLifetime(destSize);
             destSizeOverLifetime.enbale = this.enbale;
             return destSizeOverLifetime;
         }
     }

     /**
      * <code>StartFrame</code> 类用于创建开始帧。
      */
     class StartFrame {
         /**
          * 创建一个 <code>StartFrame,不允许new，请使用静态创建函数。</code> 实例。
          */
         constructor() {
             /**@private */
             this._type = 0;
             /**@private */
             this._constant = 0;
             /**@private */
             this._constantMin = 0;
             /**@private */
             this._constantMax = 0;
         }
         /**
          * 通过随机常量旋转创建一个 <code>StartFrame</code> 实例。
          * @param	constant  固定帧。
          * @return 开始帧。
          */
         static createByConstant(constant) {
             var rotationOverLifetime = new StartFrame();
             rotationOverLifetime._type = 0;
             rotationOverLifetime._constant = constant;
             return rotationOverLifetime;
         }
         /**
          *  通过随机双常量旋转创建一个 <code>StartFrame</code> 实例。
          * @param	constantMin 最小固定帧。
          * @param	constantMax 最大固定帧。
          * @return 开始帧。
          */
         static createByRandomTwoConstant(constantMin, constantMax) {
             var rotationOverLifetime = new StartFrame();
             rotationOverLifetime._type = 1;
             rotationOverLifetime._constantMin = constantMin;
             rotationOverLifetime._constantMax = constantMax;
             return rotationOverLifetime;
         }
         /**
          *开始帧类型,0常量模式，1随机双常量模式。
          */
         get type() {
             return this._type;
         }
         /**
          * 固定帧。
          */
         get constant() {
             return this._constant;
         }
         /**
          * 最小固定帧。
          */
         get constantMin() {
             return this._constantMin;
         }
         /**
          * 最大固定帧。
          */
         get constantMax() {
             return this._constantMax;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destStartFrame = destObject;
             destStartFrame._type = this._type;
             destStartFrame._constant = this._constant;
             destStartFrame._constantMin = this._constantMin;
             destStartFrame._constantMax = this._constantMax;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destStartFrame = new StartFrame();
             this.cloneTo(destStartFrame);
             return destStartFrame;
         }
     }

     /**
      * <code>TextureSheetAnimation</code> 类用于创建粒子帧动画。
      */
     class TextureSheetAnimation {
         /**
          * 创建一个 <code>TextureSheetAnimation</code> 实例。
          * @param frame 动画帧。
          * @param  startFrame 开始帧。
          */
         constructor(frame, startFrame) {
             /**类型,0为whole sheet、1为singal row。*/
             this.type = 0;
             /**是否随机行，type为1时有效。*/
             this.randomRow = false;
             /**行索引,type为1时有效。*/
             this.rowIndex = 0;
             /**循环次数。*/
             this.cycles = 0;
             /**UV通道类型,0为Noting,1为Everything,待补充,暂不支持。*/
             this.enableUVChannels = 0;
             /**是否启用*/
             this.enable = false;
             this.tiles = new Vector2(1, 1);
             this.type = 0;
             this.randomRow = true;
             this.rowIndex = 0;
             this.cycles = 1;
             this.enableUVChannels = 1; //TODO:待补充
             this._frame = frame;
             this._startFrame = startFrame;
         }
         /**获取时间帧率。*/
         get frame() {
             return this._frame;
         }
         /**获取开始帧率。*/
         get startFrame() {
             return this._startFrame;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destTextureSheetAnimation = destObject;
             this.tiles.cloneTo(destTextureSheetAnimation.tiles);
             destTextureSheetAnimation.type = this.type;
             destTextureSheetAnimation.randomRow = this.randomRow;
             this._frame.cloneTo(destTextureSheetAnimation._frame);
             this._startFrame.cloneTo(destTextureSheetAnimation._startFrame);
             destTextureSheetAnimation.cycles = this.cycles;
             destTextureSheetAnimation.enableUVChannels = this.enableUVChannels;
             destTextureSheetAnimation.enable = this.enable;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destFrame;
             switch (this._frame.type) {
                 case 0:
                     destFrame = FrameOverTime.createByConstant(this._frame.constant);
                     break;
                 case 1:
                     destFrame = FrameOverTime.createByOverTime(this._frame.frameOverTimeData.clone());
                     break;
                 case 2:
                     destFrame = FrameOverTime.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                     break;
                 case 3:
                     destFrame = FrameOverTime.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
                     break;
             }
             var destStartFrame;
             switch (this._startFrame.type) {
                 case 0:
                     destStartFrame = StartFrame.createByConstant(this._startFrame.constant);
                     break;
                 case 1:
                     destStartFrame = StartFrame.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
                     break;
             }
             var destTextureSheetAnimation = new TextureSheetAnimation(destFrame, destStartFrame);
             this.tiles.cloneTo(destTextureSheetAnimation.tiles);
             destTextureSheetAnimation.type = this.type;
             destTextureSheetAnimation.randomRow = this.randomRow;
             destTextureSheetAnimation.cycles = this.cycles;
             destTextureSheetAnimation.enableUVChannels = this.enableUVChannels;
             destTextureSheetAnimation.enable = this.enable;
             return destTextureSheetAnimation;
         }
     }

     /**
      * <code>VelocityOverLifetime</code> 类用于粒子的生命周期速度。
      */
     class VelocityOverLifetime {
         /**
          * 创建一个 <code>VelocityOverLifetime</code> 实例。
          */
         constructor(velocity) {
             /**是否启用*/
             this.enbale = false;
             /**速度空间,0为local,1为world。*/
             this.space = 0;
             this._velocity = velocity;
         }
         /**
          *获取尺寸。
          */
         get velocity() {
             return this._velocity;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destVelocityOverLifetime = destObject;
             this._velocity.cloneTo(destVelocityOverLifetime._velocity);
             destVelocityOverLifetime.enbale = this.enbale;
             destVelocityOverLifetime.space = this.space;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destVelocity;
             switch (this._velocity.type) {
                 case 0:
                     destVelocity = GradientVelocity.createByConstant(this._velocity.constant.clone());
                     break;
                 case 1:
                     destVelocity = GradientVelocity.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                     break;
                 case 2:
                     destVelocity = GradientVelocity.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                     break;
                 case 3:
                     destVelocity = GradientVelocity.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone());
                     break;
             }
             var destVelocityOverLifetime = new VelocityOverLifetime(destVelocity);
             destVelocityOverLifetime.enbale = this.enbale;
             destVelocityOverLifetime.space = this.space;
             return destVelocityOverLifetime;
         }
     }

     /**
      * <code>ShuriKenParticle3D</code> 3D粒子。
      */
     class ShuriKenParticle3D extends RenderableSprite3D {
         /**
          * @private
          */
         static __init__() {
             ShuriKenParticle3D.shaderDefines = new ShaderDefines(RenderableSprite3D.shaderDefines);
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_BILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("SPHERHBILLBOARD");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("STRETCHEDBILLBOARD");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("HORIZONTALBILLBOARD");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("VERTICALBILLBOARD");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME = ShuriKenParticle3D.shaderDefines.registerDefine("COLOROVERLIFETIME");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = ShuriKenParticle3D.shaderDefines.registerDefine("RANDOMCOLOROVERLIFETIME");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECONSTANT");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECURVE");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCURVE");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONCURVE");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONRANDOMCURVE");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIME");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMESEPERATE");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECONSTANT");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECURVE");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCONSTANTS");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVE");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVESEPERATE");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVES");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_MESH = ShuriKenParticle3D.shaderDefines.registerDefine("RENDERMODE_MESH");
             ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SHAPE = ShuriKenParticle3D.shaderDefines.registerDefine("SHAPE");
         }
         /**
          * 获取粒子系统。
          * @return  粒子系统。
          */
         get particleSystem() {
             return this._particleSystem;
         }
         /**
          * 获取粒子渲染器。
          * @return  粒子渲染器。
          */
         get particleRenderer() {
             return this._render;
         }
         /**
          * 创建一个 <code>Particle3D</code> 实例。
          * @param settings value 粒子配置。
          */
         constructor() {
             super(null);
             this._render = new ShurikenParticleRenderer(this);
             this._particleSystem = new ShurikenParticleSystem(this);
             var elements = this._render._renderElements;
             var element = elements[0] = new RenderElement();
             element.setTransform(this._transform);
             element.render = this._render;
             element.setGeometry(this._particleSystem);
             element.material = ShurikenParticleMaterial.defaultMaterial;
         }
         /**
          * @private
          */
         static _initStartLife(gradientData) {
             var gradient = new GradientDataNumber();
             var startLifetimesData = gradientData.startLifetimes;
             for (var i = 0, n = startLifetimesData.length; i < n; i++) {
                 var valueData = startLifetimesData[i];
                 gradient.add(valueData.key, valueData.value);
             }
             return gradient;
         }
         /**
          * @private
          */
         _initParticleVelocity(gradientData) {
             var gradient = new GradientDataNumber();
             var velocitysData = gradientData.velocitys;
             for (var i = 0, n = velocitysData.length; i < n; i++) {
                 var valueData = velocitysData[i];
                 gradient.add(valueData.key, valueData.value);
             }
             return gradient;
         }
         /**
          * @private
          */
         _initParticleColor(gradientColorData) {
             var gradientColor = new Gradient(4, 4);
             var alphasData = gradientColorData.alphas;
             var i, n;
             for (i = 0, n = alphasData.length; i < n; i++) {
                 var alphaData = alphasData[i];
                 if ((i === 3) && ((alphaData.key !== 1))) {
                     alphaData.key = 1;
                     console.log("GradientDataColor warning:the forth key is  be force set to 1.");
                 }
                 gradientColor.addColorAlpha(alphaData.key, alphaData.value);
             }
             var rgbsData = gradientColorData.rgbs;
             for (i = 0, n = rgbsData.length; i < n; i++) {
                 var rgbData = rgbsData[i];
                 var rgbValue = rgbData.value;
                 if ((i === 3) && ((rgbData.key !== 1))) {
                     rgbData.key = 1;
                     console.log("GradientDataColor warning:the forth key is  be force set to 1.");
                 }
                 gradientColor.addColorRGB(rgbData.key, new Color(rgbValue[0], rgbValue[1], rgbValue[2], 1.0));
             }
             return gradientColor;
         }
         /**
          * @private
          */
         _initParticleSize(gradientSizeData) {
             var gradientSize = new GradientDataNumber();
             var sizesData = gradientSizeData.sizes;
             for (var i = 0, n = sizesData.length; i < n; i++) {
                 var valueData = sizesData[i];
                 gradientSize.add(valueData.key, valueData.value);
             }
             return gradientSize;
         }
         /**
          * @private
          */
         _initParticleRotation(gradientData) {
             var gradient = new GradientDataNumber();
             var angularVelocitysData = gradientData.angularVelocitys;
             for (var i = 0, n = angularVelocitysData.length; i < n; i++) {
                 var valueData = angularVelocitysData[i];
                 gradient.add(valueData.key, valueData.value / 180.0 * Math.PI);
             }
             return gradient;
         }
         /**
          * @private
          */
         _initParticleFrame(overTimeFramesData) {
             var overTimeFrame = new GradientDataInt();
             var framesData = overTimeFramesData.frames;
             for (var i = 0, n = framesData.length; i < n; i++) {
                 var frameData = framesData[i];
                 overTimeFrame.add(frameData.key, frameData.value);
             }
             return overTimeFrame;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             super._parse(data, spriteMap);
             const anglelToRad = Math.PI / 180.0;
             var i, n;
             //Render
             var particleRender = this.particleRenderer;
             var material;
             var materialData = data.material;
             (materialData) && (material = Loader.getRes(materialData.path));
             particleRender.sharedMaterial = material;
             var meshPath = data.meshPath;
             (meshPath) && (particleRender.mesh = Loader.getRes(meshPath));
             particleRender.renderMode = data.renderMode;
             particleRender.stretchedBillboardCameraSpeedScale = data.stretchedBillboardCameraSpeedScale;
             particleRender.stretchedBillboardSpeedScale = data.stretchedBillboardSpeedScale;
             particleRender.stretchedBillboardLengthScale = data.stretchedBillboardLengthScale;
             particleRender.sortingFudge = data.sortingFudge ? data.sortingFudge : 0.0;
             //particleSystem
             var particleSystem = this.particleSystem;
             particleSystem.isPerformanceMode = data.isPerformanceMode;
             particleSystem.duration = data.duration;
             particleSystem.looping = data.looping;
             particleSystem.prewarm = data.prewarm;
             particleSystem.startDelayType = data.startDelayType;
             particleSystem.startDelay = data.startDelay;
             particleSystem.startDelayMin = data.startDelayMin;
             particleSystem.startDelayMax = data.startDelayMax;
             particleSystem.startLifetimeType = data.startLifetimeType;
             particleSystem.startLifetimeConstant = data.startLifetimeConstant;
             particleSystem.startLifeTimeGradient = ShuriKenParticle3D._initStartLife(data.startLifetimeGradient);
             particleSystem.startLifetimeConstantMin = data.startLifetimeConstantMin;
             particleSystem.startLifetimeConstantMax = data.startLifetimeConstantMax;
             particleSystem.startLifeTimeGradientMin = ShuriKenParticle3D._initStartLife(data.startLifetimeGradientMin);
             particleSystem.startLifeTimeGradientMax = ShuriKenParticle3D._initStartLife(data.startLifetimeGradientMax);
             particleSystem.startSpeedType = data.startSpeedType;
             particleSystem.startSpeedConstant = data.startSpeedConstant;
             particleSystem.startSpeedConstantMin = data.startSpeedConstantMin;
             particleSystem.startSpeedConstantMax = data.startSpeedConstantMax;
             particleSystem.threeDStartSize = data.threeDStartSize;
             particleSystem.startSizeType = data.startSizeType;
             particleSystem.startSizeConstant = data.startSizeConstant;
             var startSizeConstantSeparateArray = data.startSizeConstantSeparate;
             var startSizeConstantSeparateElement = particleSystem.startSizeConstantSeparate;
             startSizeConstantSeparateElement.x = startSizeConstantSeparateArray[0];
             startSizeConstantSeparateElement.y = startSizeConstantSeparateArray[1];
             startSizeConstantSeparateElement.z = startSizeConstantSeparateArray[2];
             particleSystem.startSizeConstantMin = data.startSizeConstantMin;
             particleSystem.startSizeConstantMax = data.startSizeConstantMax;
             var startSizeConstantMinSeparateArray = data.startSizeConstantMinSeparate;
             var startSizeConstantMinSeparateElement = particleSystem.startSizeConstantMinSeparate;
             startSizeConstantMinSeparateElement.x = startSizeConstantMinSeparateArray[0];
             startSizeConstantMinSeparateElement.y = startSizeConstantMinSeparateArray[1];
             startSizeConstantMinSeparateElement.z = startSizeConstantMinSeparateArray[2];
             var startSizeConstantMaxSeparateArray = data.startSizeConstantMaxSeparate;
             var startSizeConstantMaxSeparateElement = particleSystem.startSizeConstantMaxSeparate;
             startSizeConstantMaxSeparateElement.x = startSizeConstantMaxSeparateArray[0];
             startSizeConstantMaxSeparateElement.y = startSizeConstantMaxSeparateArray[1];
             startSizeConstantMaxSeparateElement.z = startSizeConstantMaxSeparateArray[2];
             particleSystem.threeDStartRotation = data.threeDStartRotation;
             particleSystem.startRotationType = data.startRotationType;
             particleSystem.startRotationConstant = data.startRotationConstant * anglelToRad;
             var startRotationConstantSeparateArray = data.startRotationConstantSeparate;
             var startRotationConstantSeparateElement = particleSystem.startRotationConstantSeparate;
             startRotationConstantSeparateElement.x = startRotationConstantSeparateArray[0] * anglelToRad;
             startRotationConstantSeparateElement.y = startRotationConstantSeparateArray[1] * anglelToRad;
             startRotationConstantSeparateElement.z = startRotationConstantSeparateArray[2] * anglelToRad;
             particleSystem.startRotationConstantMin = data.startRotationConstantMin * anglelToRad;
             particleSystem.startRotationConstantMax = data.startRotationConstantMax * anglelToRad;
             var startRotationConstantMinSeparateArray = data.startRotationConstantMinSeparate;
             var startRotationConstantMinSeparateElement = particleSystem.startRotationConstantMinSeparate;
             startRotationConstantMinSeparateElement.x = startRotationConstantMinSeparateArray[0] * anglelToRad;
             startRotationConstantMinSeparateElement.y = startRotationConstantMinSeparateArray[1] * anglelToRad;
             startRotationConstantMinSeparateElement.z = startRotationConstantMinSeparateArray[2] * anglelToRad;
             var startRotationConstantMaxSeparateArray = data.startRotationConstantMaxSeparate;
             var startRotationConstantMaxSeparateElement = particleSystem.startRotationConstantMaxSeparate;
             startRotationConstantMaxSeparateElement.x = startRotationConstantMaxSeparateArray[0] * anglelToRad;
             startRotationConstantMaxSeparateElement.y = startRotationConstantMaxSeparateArray[1] * anglelToRad;
             startRotationConstantMaxSeparateElement.z = startRotationConstantMaxSeparateArray[2] * anglelToRad;
             particleSystem.randomizeRotationDirection = data.randomizeRotationDirection;
             particleSystem.startColorType = data.startColorType;
             var startColorConstantArray = data.startColorConstant;
             var startColorConstantElement = particleSystem.startColorConstant;
             startColorConstantElement.x = startColorConstantArray[0];
             startColorConstantElement.y = startColorConstantArray[1];
             startColorConstantElement.z = startColorConstantArray[2];
             startColorConstantElement.w = startColorConstantArray[3];
             var startColorConstantMinArray = data.startColorConstantMin;
             var startColorConstantMinElement = particleSystem.startColorConstantMin;
             startColorConstantMinElement.x = startColorConstantMinArray[0];
             startColorConstantMinElement.y = startColorConstantMinArray[1];
             startColorConstantMinElement.z = startColorConstantMinArray[2];
             startColorConstantMinElement.w = startColorConstantMinArray[3];
             var startColorConstantMaxArray = data.startColorConstantMax;
             var startColorConstantMaxElement = particleSystem.startColorConstantMax;
             startColorConstantMaxElement.x = startColorConstantMaxArray[0];
             startColorConstantMaxElement.y = startColorConstantMaxArray[1];
             startColorConstantMaxElement.z = startColorConstantMaxArray[2];
             startColorConstantMaxElement.w = startColorConstantMaxArray[3];
             particleSystem.gravityModifier = data.gravityModifier;
             particleSystem.simulationSpace = data.simulationSpace;
             particleSystem.scaleMode = data.scaleMode;
             particleSystem.playOnAwake = data.playOnAwake;
             particleSystem.maxParticles = data.maxParticles;
             var autoRandomSeed = data.autoRandomSeed;
             (autoRandomSeed != null) && (particleSystem.autoRandomSeed = autoRandomSeed);
             var randomSeed = data.randomSeed;
             (randomSeed != null) && (particleSystem.randomSeed[0] = randomSeed);
             //Emission
             var emissionData = data.emission;
             var emission = particleSystem.emission;
             if (emissionData) {
                 emission.emissionRate = emissionData.emissionRate;
                 var burstsData = emissionData.bursts;
                 if (burstsData)
                     for (i = 0, n = burstsData.length; i < n; i++) {
                         var brust = burstsData[i];
                         emission.addBurst(new Burst(brust.time, brust.min, brust.max));
                     }
                 emission.enbale = emissionData.enable;
             }
             else {
                 emission.enbale = false;
             }
             //Shape
             var shapeData = data.shape;
             if (shapeData) {
                 var shape;
                 switch (shapeData.shapeType) {
                     case 0:
                         var sphereShape;
                         shape = sphereShape = new SphereShape();
                         sphereShape.radius = shapeData.sphereRadius;
                         sphereShape.emitFromShell = shapeData.sphereEmitFromShell;
                         sphereShape.randomDirection = shapeData.sphereRandomDirection;
                         break;
                     case 1:
                         var hemiSphereShape;
                         shape = hemiSphereShape = new HemisphereShape();
                         hemiSphereShape.radius = shapeData.hemiSphereRadius;
                         hemiSphereShape.emitFromShell = shapeData.hemiSphereEmitFromShell;
                         hemiSphereShape.randomDirection = shapeData.hemiSphereRandomDirection;
                         break;
                     case 2:
                         var coneShape;
                         shape = coneShape = new ConeShape();
                         coneShape.angle = shapeData.coneAngle * anglelToRad;
                         coneShape.radius = shapeData.coneRadius;
                         coneShape.length = shapeData.coneLength;
                         coneShape.emitType = shapeData.coneEmitType;
                         coneShape.randomDirection = shapeData.coneRandomDirection;
                         break;
                     case 3:
                         var boxShape;
                         shape = boxShape = new BoxShape();
                         boxShape.x = shapeData.boxX;
                         boxShape.y = shapeData.boxY;
                         boxShape.z = shapeData.boxZ;
                         boxShape.randomDirection = shapeData.boxRandomDirection;
                         break;
                     case 7:
                         var circleShape;
                         shape = circleShape = new CircleShape();
                         circleShape.radius = shapeData.circleRadius;
                         circleShape.arc = shapeData.circleArc * anglelToRad;
                         circleShape.emitFromEdge = shapeData.circleEmitFromEdge;
                         circleShape.randomDirection = shapeData.circleRandomDirection;
                         break;
                     /**
                      * ------------------------临时调整，待日后完善-------------------------------------
                      */
                     default:
                         var tempShape;
                         shape = tempShape = new CircleShape();
                         tempShape.radius = shapeData.circleRadius;
                         tempShape.arc = shapeData.circleArc * anglelToRad;
                         tempShape.emitFromEdge = shapeData.circleEmitFromEdge;
                         tempShape.randomDirection = shapeData.circleRandomDirection;
                         break;
                 }
                 shape.enable = shapeData.enable;
                 particleSystem.shape = shape;
             }
             //VelocityOverLifetime
             var velocityOverLifetimeData = data.velocityOverLifetime;
             if (velocityOverLifetimeData) {
                 var velocityData = velocityOverLifetimeData.velocity;
                 var velocity;
                 switch (velocityData.type) {
                     case 0:
                         var constantData = velocityData.constant;
                         velocity = GradientVelocity.createByConstant(new Vector3(constantData[0], constantData[1], constantData[2]));
                         break;
                     case 1:
                         velocity = GradientVelocity.createByGradient(this._initParticleVelocity(velocityData.gradientX), this._initParticleVelocity(velocityData.gradientY), this._initParticleVelocity(velocityData.gradientZ));
                         break;
                     case 2:
                         var constantMinData = velocityData.constantMin;
                         var constantMaxData = velocityData.constantMax;
                         velocity = GradientVelocity.createByRandomTwoConstant(new Vector3(constantMinData[0], constantMinData[1], constantMinData[2]), new Vector3(constantMaxData[0], constantMaxData[1], constantMaxData[2]));
                         break;
                     case 3:
                         velocity = GradientVelocity.createByRandomTwoGradient(this._initParticleVelocity(velocityData.gradientXMin), this._initParticleVelocity(velocityData.gradientXMax), this._initParticleVelocity(velocityData.gradientYMin), this._initParticleVelocity(velocityData.gradientYMax), this._initParticleVelocity(velocityData.gradientZMin), this._initParticleVelocity(velocityData.gradientZMax));
                         break;
                 }
                 var velocityOverLifetime = new VelocityOverLifetime(velocity);
                 velocityOverLifetime.space = velocityOverLifetimeData.space;
                 velocityOverLifetime.enbale = velocityOverLifetimeData.enable;
                 particleSystem.velocityOverLifetime = velocityOverLifetime;
             }
             //ColorOverLifetime
             var colorOverLifetimeData = data.colorOverLifetime;
             if (colorOverLifetimeData) {
                 var colorData = colorOverLifetimeData.color;
                 var color;
                 switch (colorData.type) {
                     case 0:
                         var constColorData = colorData.constant;
                         color = GradientColor.createByConstant(new Vector4(constColorData[0], constColorData[1], constColorData[2], constColorData[3]));
                         break;
                     case 1:
                         color = GradientColor.createByGradient(this._initParticleColor(colorData.gradient));
                         break;
                     case 2:
                         var minConstColorData = colorData.constantMin;
                         var maxConstColorData = colorData.constantMax;
                         color = GradientColor.createByRandomTwoConstant(new Vector4(minConstColorData[0], minConstColorData[1], minConstColorData[2], minConstColorData[3]), new Vector4(maxConstColorData[0], maxConstColorData[1], maxConstColorData[2], maxConstColorData[3]));
                         break;
                     case 3:
                         color = GradientColor.createByRandomTwoGradient(this._initParticleColor(colorData.gradientMin), this._initParticleColor(colorData.gradientMax));
                         break;
                 }
                 var colorOverLifetime = new ColorOverLifetime(color);
                 colorOverLifetime.enbale = colorOverLifetimeData.enable;
                 particleSystem.colorOverLifetime = colorOverLifetime;
             }
             //SizeOverLifetime
             var sizeOverLifetimeData = data.sizeOverLifetime;
             if (sizeOverLifetimeData) {
                 var sizeData = sizeOverLifetimeData.size;
                 var size;
                 switch (sizeData.type) {
                     case 0:
                         if (sizeData.separateAxes) {
                             size = GradientSize.createByGradientSeparate(this._initParticleSize(sizeData.gradientX), this._initParticleSize(sizeData.gradientY), this._initParticleSize(sizeData.gradientZ));
                         }
                         else {
                             size = GradientSize.createByGradient(this._initParticleSize(sizeData.gradient));
                         }
                         break;
                     case 1:
                         if (sizeData.separateAxes) {
                             var constantMinSeparateData = sizeData.constantMinSeparate;
                             var constantMaxSeparateData = sizeData.constantMaxSeparate;
                             size = GradientSize.createByRandomTwoConstantSeparate(new Vector3(constantMinSeparateData[0], constantMinSeparateData[1], constantMinSeparateData[2]), new Vector3(constantMaxSeparateData[0], constantMaxSeparateData[1], constantMaxSeparateData[2]));
                         }
                         else {
                             size = GradientSize.createByRandomTwoConstant(sizeData.constantMin, sizeData.constantMax);
                         }
                         break;
                     case 2:
                         if (sizeData.separateAxes) {
                             size = GradientSize.createByRandomTwoGradientSeparate(this._initParticleSize(sizeData.gradientXMin), this._initParticleSize(sizeData.gradientYMin), this._initParticleSize(sizeData.gradientZMin), this._initParticleSize(sizeData.gradientXMax), this._initParticleSize(sizeData.gradientYMax), this._initParticleSize(sizeData.gradientZMax));
                         }
                         else {
                             size = GradientSize.createByRandomTwoGradient(this._initParticleSize(sizeData.gradientMin), this._initParticleSize(sizeData.gradientMax));
                         }
                         break;
                 }
                 var sizeOverLifetime = new SizeOverLifetime(size);
                 sizeOverLifetime.enbale = sizeOverLifetimeData.enable;
                 particleSystem.sizeOverLifetime = sizeOverLifetime;
             }
             //RotationOverLifetime
             var rotationOverLifetimeData = data.rotationOverLifetime;
             if (rotationOverLifetimeData) {
                 var angularVelocityData = rotationOverLifetimeData.angularVelocity;
                 var angularVelocity;
                 switch (angularVelocityData.type) {
                     case 0:
                         if (angularVelocityData.separateAxes) {
                             var conSep = angularVelocityData.constantSeparate;
                             angularVelocity = GradientAngularVelocity.createByConstantSeparate(new Vector3(conSep[0] * anglelToRad, conSep[1] * anglelToRad, conSep[2] * anglelToRad));
                         }
                         else {
                             angularVelocity = GradientAngularVelocity.createByConstant(angularVelocityData.constant * anglelToRad);
                         }
                         break;
                     case 1:
                         if (angularVelocityData.separateAxes) {
                             angularVelocity = GradientAngularVelocity.createByGradientSeparate(this._initParticleRotation(angularVelocityData.gradientX), this._initParticleRotation(angularVelocityData.gradientY), this._initParticleRotation(angularVelocityData.gradientZ));
                         }
                         else {
                             angularVelocity = GradientAngularVelocity.createByGradient(this._initParticleRotation(angularVelocityData.gradient));
                         }
                         break;
                     case 2:
                         if (angularVelocityData.separateAxes) {
                             var minSep = angularVelocityData.constantMinSeparate; //TODO:Y是否要取负数
                             var maxSep = angularVelocityData.constantMaxSeparate; //TODO:Y是否要取负数
                             angularVelocity = GradientAngularVelocity.createByRandomTwoConstantSeparate(new Vector3(minSep[0] * anglelToRad, minSep[1] * anglelToRad, minSep[2] * anglelToRad), new Vector3(maxSep[0] * anglelToRad, maxSep[1] * anglelToRad, maxSep[2] * anglelToRad));
                         }
                         else {
                             angularVelocity = GradientAngularVelocity.createByRandomTwoConstant(angularVelocityData.constantMin * anglelToRad, angularVelocityData.constantMax * anglelToRad);
                         }
                         break;
                     case 3:
                         if (angularVelocityData.separateAxes) ;
                         else {
                             angularVelocity = GradientAngularVelocity.createByRandomTwoGradient(this._initParticleRotation(angularVelocityData.gradientMin), this._initParticleRotation(angularVelocityData.gradientMax));
                         }
                         break;
                 }
                 var rotationOverLifetime = new RotationOverLifetime(angularVelocity);
                 rotationOverLifetime.enbale = rotationOverLifetimeData.enable;
                 particleSystem.rotationOverLifetime = rotationOverLifetime;
             }
             //TextureSheetAnimation
             var textureSheetAnimationData = data.textureSheetAnimation;
             if (textureSheetAnimationData) {
                 var frameData = textureSheetAnimationData.frame;
                 var frameOverTime;
                 switch (frameData.type) {
                     case 0:
                         frameOverTime = FrameOverTime.createByConstant(frameData.constant);
                         break;
                     case 1:
                         frameOverTime = FrameOverTime.createByOverTime(this._initParticleFrame(frameData.overTime));
                         break;
                     case 2:
                         frameOverTime = FrameOverTime.createByRandomTwoConstant(frameData.constantMin, frameData.constantMax);
                         break;
                     case 3:
                         frameOverTime = FrameOverTime.createByRandomTwoOverTime(this._initParticleFrame(frameData.overTimeMin), this._initParticleFrame(frameData.overTimeMax));
                         break;
                 }
                 var startFrameData = textureSheetAnimationData.startFrame;
                 var startFrame;
                 switch (startFrameData.type) {
                     case 0:
                         startFrame = StartFrame.createByConstant(startFrameData.constant);
                         break;
                     case 1:
                         startFrame = StartFrame.createByRandomTwoConstant(startFrameData.constantMin, startFrameData.constantMax);
                         break;
                 }
                 var textureSheetAnimation = new TextureSheetAnimation(frameOverTime, startFrame);
                 textureSheetAnimation.enable = textureSheetAnimationData.enable;
                 var tilesData = textureSheetAnimationData.tiles;
                 textureSheetAnimation.tiles = new Vector2(tilesData[0], tilesData[1]);
                 textureSheetAnimation.type = textureSheetAnimationData.type;
                 textureSheetAnimation.randomRow = textureSheetAnimationData.randomRow;
                 var rowIndex = textureSheetAnimationData.rowIndex;
                 (rowIndex !== undefined) && (textureSheetAnimation.rowIndex = rowIndex);
                 textureSheetAnimation.cycles = textureSheetAnimationData.cycles;
                 particleSystem.textureSheetAnimation = textureSheetAnimation;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _activeHierarchy(activeChangeComponents) {
             super._activeHierarchy(activeChangeComponents);
             (this.particleSystem.playOnAwake) && (this.particleSystem.play());
         }
         /**
          * @inheritDoc
          */
         /*override*/ _inActiveHierarchy(activeChangeComponents) {
             super._inActiveHierarchy(activeChangeComponents);
             (this.particleSystem.isAlive) && (this.particleSystem.simulate(0, true));
         }
         /**
          * @private
          */
         /*override*/ _cloneTo(destObject, srcSprite, dstSprite) {
             var destShuriKenParticle3D = destObject;
             var destParticleSystem = destShuriKenParticle3D._particleSystem;
             this._particleSystem.cloneTo(destParticleSystem);
             var destParticleRender = destShuriKenParticle3D._render;
             var particleRender = this._render;
             destParticleRender.sharedMaterials = particleRender.sharedMaterials;
             destParticleRender.enable = particleRender.enable;
             destParticleRender.renderMode = particleRender.renderMode;
             destParticleRender.mesh = particleRender.mesh;
             destParticleRender.stretchedBillboardCameraSpeedScale = particleRender.stretchedBillboardCameraSpeedScale;
             destParticleRender.stretchedBillboardSpeedScale = particleRender.stretchedBillboardSpeedScale;
             destParticleRender.stretchedBillboardLengthScale = particleRender.stretchedBillboardLengthScale;
             destParticleRender.sortingFudge = particleRender.sortingFudge;
             super._cloneTo(destObject, srcSprite, dstSprite); //父类函数在最后,组件应该最后赋值，否则获取材质默认值等相关函数会有问题
         }
         /**
          * <p>销毁此对象。</p>
          * @param	destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
          */
         /*override*/ destroy(destroyChild = true) {
             if (this.destroyed)
                 return;
             super.destroy(destroyChild);
             this._particleSystem.destroy();
             this._particleSystem = null;
         }
         /**
          * @private
          */
         _create() {
             return new ShuriKenParticle3D();
         }
     }

     class SkinnedMeshSprite3DShaderDeclaration {
     }

     /**
      * <code>SkinMeshRenderer</code> 类用于蒙皮渲染器。
      */
     class SkinnedMeshRenderer extends MeshRenderer {
         /**
          * 创建一个 <code>SkinnedMeshRender</code> 实例。
          */
         constructor(owner) {
             super(owner);
             /** @private */
             this._bones = [];
             /** @private */
             this._skinnedDataLoopMarks = [];
             /**@private */
             this._localBounds = new Bounds(Vector3._ZERO, Vector3._ZERO);
             /** @private */
             this._cacheAnimationNode = []; //[兼容性]
             (owner) && (this._owner.transform.off(Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange)); //需要移除
         }
         /**
          * 获取局部边界。
          * @return 边界。
          */
         get localBounds() {
             return this._localBounds;
         }
         /**
          * 设置局部边界。
          * @param value 边界
          */
         set localBounds(value) {
             this._localBounds = value;
         }
         /**
          * 获取根节点。
          * @return 根节点。
          */
         get rootBone() {
             return this._cacheRootBone;
         }
         /**
          * 设置根节点。
          * @param value 根节点。
          */
         set rootBone(value) {
             if (this._cacheRootBone != value) {
                 if (this._cacheRootBone)
                     this._cacheRootBone.transform.off(Event.TRANSFORM_CHANGED, this, this._boundChange);
                 value.transform.on(Event.TRANSFORM_CHANGED, this, this._boundChange);
                 this._cacheRootBone = value;
                 this._boundChange(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE);
             }
         }
         /**
          * 用于蒙皮的骨骼。
          */
         get bones() {
             return this._bones;
         }
         /**
          * @private
          */
         _computeSkinnedDataForNative() {
             if (this._cacheMesh && this._cacheAvatar /*兼容*/ || this._cacheMesh && !this._cacheAvatar) {
                 var bindPoses = this._cacheMesh._inverseBindPoses;
                 var meshBindPoseIndices = this._cacheMesh._bindPoseIndices;
                 var pathMarks = this._cacheMesh._skinDataPathMarks;
                 for (var i = 0, n = this._cacheMesh.subMeshCount; i < n; i++) {
                     var subMeshBoneIndices = this._cacheMesh._getSubMesh(i)._boneIndicesList;
                     var subData = this._skinnedData[i];
                     for (var j = 0, m = subMeshBoneIndices.length; j < m; j++) {
                         var boneIndices = subMeshBoneIndices[j];
                         if (this._cacheAvatar && Render.supportWebGLPlusAnimation) //[Native]
                             this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, boneIndices, meshBindPoseIndices, subData[j]);
                         else
                             this._computeSubSkinnedData(bindPoses, boneIndices, meshBindPoseIndices, subData[j], pathMarks);
                     }
                 }
             }
         }
         _computeSkinnedData() {
             if (this._cacheMesh && this._cacheAvatar /*兼容*/ || this._cacheMesh && !this._cacheAvatar) {
                 var bindPoses = this._cacheMesh._inverseBindPoses;
                 var meshBindPoseIndices = this._cacheMesh._bindPoseIndices;
                 var pathMarks = this._cacheMesh._skinDataPathMarks;
                 for (var i = 0, n = this._cacheMesh.subMeshCount; i < n; i++) {
                     var subMeshBoneIndices = this._cacheMesh._getSubMesh(i)._boneIndicesList;
                     var subData = this._skinnedData[i];
                     for (var j = 0, m = subMeshBoneIndices.length; j < m; j++) {
                         var boneIndices = subMeshBoneIndices[j];
                         this._computeSubSkinnedData(bindPoses, boneIndices, meshBindPoseIndices, subData[j], pathMarks);
                     }
                 }
             }
         }
         /**
          * @private
          */
         _computeSubSkinnedData(bindPoses, boneIndices, meshBindPoseInices, data, pathMarks) {
             for (var k = 0, q = boneIndices.length; k < q; k++) {
                 var index = boneIndices[k];
                 if (this._skinnedDataLoopMarks[index] === Stat.loopCount) {
                     var p = pathMarks[index];
                     var preData = this._skinnedData[p[0]][p[1]];
                     var srcIndex = p[2] * 16;
                     var dstIndex = k * 16;
                     for (var d = 0; d < 16; d++)
                         data[dstIndex + d] = preData[srcIndex + d];
                 }
                 else {
                     if (!this._cacheAvatar) {
                         var boneIndex = meshBindPoseInices[index];
                         Utils3D._mulMatrixArray(this._bones[boneIndex].transform.worldMatrix.elements, bindPoses[boneIndex], data, k * 16);
                     }
                     else { //[兼容代码]
                         Utils3D._mulMatrixArray(this._cacheAnimationNode[index].transform.getWorldMatrix(), bindPoses[meshBindPoseInices[index]], data, k * 16);
                     }
                     this._skinnedDataLoopMarks[index] = Stat.loopCount;
                 }
             }
         }
         /**
          * @private
          */
         _boundChange(flag) {
             this._boundsChange = true;
             if (this._octreeNode) {
                 if (this._cacheAvatar) { //兼容性 
                     if (this._indexInOctreeMotionList === -1) //_octreeNode表示在八叉树队列中
                         this._octreeNode._octree.addMotionObject(this);
                 }
                 else {
                     flag &= Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE; //过滤有用TRANSFORM标记
                     if (flag) {
                         if (this._indexInOctreeMotionList === -1) //_octreeNode表示在八叉树队列中
                             this._octreeNode._octree.addMotionObject(this);
                     }
                 }
             }
         }
         /**
          *@inheritDoc
             */
         /*override*/ _createRenderElement() {
             return new RenderElement();
         }
         /**
          *@inheritDoc
             */
         /*override*/ _onMeshChange(value) {
             super._onMeshChange(value);
             this._cacheMesh = value;
             var subMeshCount = value.subMeshCount;
             this._skinnedData = [];
             this._skinnedDataLoopMarks.length = value._bindPoseIndices.length;
             for (var i = 0; i < subMeshCount; i++) {
                 var subBoneIndices = value._getSubMesh(i)._boneIndicesList;
                 var subCount = subBoneIndices.length;
                 var subData = this._skinnedData[i] = [];
                 for (var j = 0; j < subCount; j++)
                     subData[j] = new Float32Array(subBoneIndices[j].length * 16);
             }
             (this._cacheAvatar && value) && (this._getCacheAnimationNodes()); //[兼容性]
         }
         /**
          * @private
          */
         _setCacheAnimator(animator) {
             this._cacheAnimator = animator;
             this._shaderValues.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE);
             this._setRootNode(); //[兼容性API]
         }
         /**
          * @inheritDoc
          */
         /*override*/ _calculateBoundingBox() {
             if (!this._cacheAvatar) {
                 if (this._cacheRootBone)
                     this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds);
                 else
                     this._localBounds._tranform(this._owner.transform.worldMatrix, this._bounds);
             }
             else { //[兼容性API]
                 if (this._cacheAnimator && this._rootBone) {
                     var worldMat = SkinnedMeshRenderer._tempMatrix4x4;
                     Utils3D.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, this._cacheRootAnimationNode.transform.getWorldMatrix(), worldMat);
                     this._localBounds._tranform(worldMat, this._bounds);
                 }
                 else {
                     super._calculateBoundingBox();
                 }
             }
             if (Render.supportWebGLPlusCulling) { //[NATIVE]
                 var min = this._bounds.getMin();
                 var max = this._bounds.getMax();
                 var buffer = FrustumCulling._cullingBuffer;
                 buffer[this._cullingBufferIndex + 1] = min.x;
                 buffer[this._cullingBufferIndex + 2] = min.y;
                 buffer[this._cullingBufferIndex + 3] = min.z;
                 buffer[this._cullingBufferIndex + 4] = max.x;
                 buffer[this._cullingBufferIndex + 5] = max.y;
                 buffer[this._cullingBufferIndex + 6] = max.z;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _renderUpdate(context, transform) {
             if (this._cacheAnimator) {
                 this._computeSkinnedData();
                 if (!this._cacheAvatar) {
                     this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, Matrix4x4.DEFAULT);
                 }
                 else { //[兼容性]
                     var aniOwnerTrans = this._cacheAnimator.owner._transform;
                     this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, aniOwnerTrans.worldMatrix);
                 }
             }
             else {
                 this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, transform.worldMatrix);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _renderUpdateWithCamera(context, transform) {
             var projectionView = context.projectionViewMatrix;
             if (!this._cacheAvatar) {
                 this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView);
             }
             else { //[兼容性]
                 if (this._cacheAnimator) {
                     var aniOwnerTrans = this._cacheAnimator.owner._transform;
                     Matrix4x4.multiply(projectionView, aniOwnerTrans.worldMatrix, this._projectionViewWorldMatrix);
                 }
                 else {
                     Matrix4x4.multiply(projectionView, transform.worldMatrix, this._projectionViewWorldMatrix);
                 }
                 this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _destroy() {
             super._destroy();
             if (!this._cacheAvatar) {
                 (this._cacheRootBone && !this._cacheRootBone.destroyed) && (this._cacheRootBone.transform.off(Event.TRANSFORM_CHANGED, this, this._boundChange));
             }
             else { //[兼容性]
                 if (this._cacheRootAnimationNode)
                     this._cacheRootAnimationNode.transform.off(Event.TRANSFORM_CHANGED, this, this._boundChange);
             }
         }
         /**
          * 获取包围盒,只读,不允许修改其值。
          * @return 包围盒。
          */
         get bounds() {
             if (this._boundsChange || this._cacheAvatar) { //有this._cacheAvatar会导致裁剪后动画不更新。动画不更新包围不更新。包围盒不更新就永远裁掉了
                 this._calculateBoundingBox();
                 this._boundsChange = false;
             }
             return this._bounds;
         }
         /**
          * @private
          */
         _setRootBone(name) {
             this._rootBone = name;
             this._setRootNode(); //[兼容性API]
         }
         /**
          * @private
          */
         _setRootNode() {
             var rootNode;
             if (this._cacheAnimator && this._rootBone && this._cacheAvatar)
                 rootNode = this._cacheAnimator._avatarNodeMap[this._rootBone];
             else
                 rootNode = null;
             if (this._cacheRootAnimationNode != rootNode) {
                 this._boundChange(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE);
                 if (this._cacheRootAnimationNode)
                     this._cacheRootAnimationNode.transform.off(Event.TRANSFORM_CHANGED, this, this._boundChange);
                 (rootNode) && (rootNode.transform.on(Event.TRANSFORM_CHANGED, this, this._boundChange));
                 this._cacheRootAnimationNode = rootNode;
             }
         }
         /**
          * @private
          */
         _getCacheAnimationNodes() {
             var meshBoneNames = this._cacheMesh._boneNames;
             var bindPoseIndices = this._cacheMesh._bindPoseIndices;
             var innerBindPoseCount = bindPoseIndices.length;
             if (!Render.supportWebGLPlusAnimation) {
                 this._cacheAnimationNode.length = innerBindPoseCount;
                 var nodeMap = this._cacheAnimator._avatarNodeMap;
                 for (var i = 0; i < innerBindPoseCount; i++) {
                     var node = nodeMap[meshBoneNames[bindPoseIndices[i]]];
                     this._cacheAnimationNode[i] = node;
                 }
             }
             else { //[NATIVE]
                 this._cacheAnimationNodeIndices = new Uint16Array(innerBindPoseCount);
                 var nodeMapC = this._cacheAnimator._avatarNodeMap;
                 for (i = 0; i < innerBindPoseCount; i++) {
                     var nodeC = nodeMapC[meshBoneNames[bindPoseIndices[i]]];
                     this._cacheAnimationNodeIndices[i] = nodeC._worldMatrixIndex;
                 }
             }
         }
         /**
          * @private
          */
         _setCacheAvatar(value) {
             if (this._cacheAvatar !== value) {
                 if (this._cacheMesh) {
                     this._cacheAvatar = value;
                     if (value) {
                         this._shaderValues.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE);
                         this._getCacheAnimationNodes();
                     }
                 }
                 else {
                     this._cacheAvatar = value;
                 }
                 this._setRootNode();
             }
         }
         /**
          * @private [NATIVE]
          */
         _computeSubSkinnedDataNative(worldMatrixs, cacheAnimationNodeIndices, inverseBindPosesBuffer, boneIndices, bindPoseInices, data) {
             LayaGL.instance.computeSubSkinnedData(worldMatrixs, cacheAnimationNodeIndices, inverseBindPosesBuffer, boneIndices, bindPoseInices, data);
         }
     }
     /**@private */
     SkinnedMeshRenderer._tempMatrix4x4 = new Matrix4x4();

     /**
      * <code>SkinnedMeshSprite3D</code> 类用于创建网格。
      */
     class SkinnedMeshSprite3D extends RenderableSprite3D {
         /**
          * 创建一个 <code>MeshSprite3D</code> 实例。
          * @param mesh 网格,同时会加载网格所用默认材质。
          * @param name 名字。
          */
         constructor(mesh = null, name = null) {
             super(name);
             this._meshFilter = new MeshFilter(this);
             this._render = new SkinnedMeshRenderer(this);
             (mesh) && (this._meshFilter.sharedMesh = mesh);
         }
         /**
          * @private
          */
         static __init__() {
             SkinnedMeshSprite3D.shaderDefines = new ShaderDefines(MeshSprite3D.shaderDefines);
             SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE = SkinnedMeshSprite3D.shaderDefines.registerDefine("BONE");
         }
         /**
          * 获取网格过滤器。
          * @return  网格过滤器。
          */
         get meshFilter() {
             return this._meshFilter;
         }
         /**
          * 获取网格渲染器。
          * @return  网格渲染器。
          */
         get skinnedMeshRenderer() {
             return this._render;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             super._parse(data, spriteMap);
             var render = this.skinnedMeshRenderer;
             var lightmapIndex = data.lightmapIndex;
             (lightmapIndex != null) && (render.lightmapIndex = lightmapIndex);
             var lightmapScaleOffsetArray = data.lightmapScaleOffset;
             (lightmapScaleOffsetArray) && (render.lightmapScaleOffset = new Vector4(lightmapScaleOffsetArray[0], lightmapScaleOffsetArray[1], lightmapScaleOffsetArray[2], lightmapScaleOffsetArray[3]));
             var meshPath;
             meshPath = data.meshPath;
             if (meshPath) {
                 var mesh = Loader.getRes(meshPath); //加载失败mesh为空
                 (mesh) && (this.meshFilter.sharedMesh = mesh);
             }
             var materials = data.materials;
             if (materials) {
                 var sharedMaterials = render.sharedMaterials;
                 var materialCount = materials.length;
                 sharedMaterials.length = materialCount;
                 for (var i = 0; i < materialCount; i++) {
                     sharedMaterials[i] = Loader.getRes(materials[i].path);
                 }
                 render.sharedMaterials = sharedMaterials;
             }
             var boundBox = data.boundBox;
             var min = boundBox.min;
             var max = boundBox.max;
             render.localBounds.setMin(new Vector3(min[0], min[1], min[2]));
             render.localBounds.setMax(new Vector3(max[0], max[1], max[2]));
             if (spriteMap) {
                 var rootBoneData = data.rootBone;
                 render.rootBone = spriteMap[rootBoneData];
                 var bonesData = data.bones;
                 var n;
                 for (i = 0, n = bonesData.length; i < n; i++)
                     render.bones.push(spriteMap[bonesData[i]]);
             }
             else { //[兼容代码]
                 (data.rootBone) && (render._setRootBone(data.rootBone)); //[兼容性]
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _changeHierarchyAnimator(animator) {
             super._changeHierarchyAnimator(animator);
             this.skinnedMeshRenderer._setCacheAnimator(animator);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _changeAnimatorAvatar(avatar) {
             this.skinnedMeshRenderer._setCacheAvatar(avatar);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _cloneTo(destObject, srcRoot, dstRoot) {
             var meshSprite3D = destObject;
             meshSprite3D.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
             var meshRender = this._render;
             var destMeshRender = meshSprite3D._render;
             destMeshRender.enable = meshRender.enable;
             destMeshRender.sharedMaterials = meshRender.sharedMaterials;
             destMeshRender.castShadow = meshRender.castShadow;
             var lightmapScaleOffset = meshRender.lightmapScaleOffset;
             lightmapScaleOffset && (destMeshRender.lightmapScaleOffset = lightmapScaleOffset.clone());
             destMeshRender.receiveShadow = meshRender.receiveShadow;
             destMeshRender.sortingFudge = meshRender.sortingFudge;
             destMeshRender._rootBone = meshRender._rootBone;
             var bones = meshRender.bones;
             var destBones = destMeshRender.bones;
             var bonesCount = bones.length;
             destBones.length = bonesCount;
             var rootBone = meshRender.rootBone;
             if (rootBone) {
                 var pathes = Utils3D._getHierarchyPath(srcRoot, rootBone, SkinnedMeshSprite3D._tempArray0);
                 if (pathes)
                     destMeshRender.rootBone = Utils3D._getNodeByHierarchyPath(dstRoot, pathes);
                 else
                     destMeshRender.rootBone = rootBone;
             }
             for (var i = 0; i < bones.length; i++) {
                 pathes = Utils3D._getHierarchyPath(srcRoot, bones[i], SkinnedMeshSprite3D._tempArray0);
                 if (pathes)
                     destBones[i] = Utils3D._getNodeByHierarchyPath(dstRoot, pathes);
                 else
                     destBones[i] = bones[i];
             }
             var lbb = meshRender.localBounds;
             (lbb) && (lbb.cloneTo(destMeshRender.localBounds));
             super._cloneTo(destObject, srcRoot, dstRoot); //父类函数在最后,组件应该最后赋值，否则获取材质默认值等相关函数会有问题
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy(destroyChild = true) {
             if (this.destroyed)
                 return;
             super.destroy(destroyChild);
             this._meshFilter.destroy();
         }
         /**
          * @private
          */
         _create() {
             return new SkinnedMeshSprite3D();
         }
     }
     /**@private */
     SkinnedMeshSprite3D._tempArray0 = [];
     /**着色器变量名，蒙皮动画。*/
     SkinnedMeshSprite3D.BONES = Shader3D.propertyNameToID("u_Bones");
     /**@private */
     SkinnedMeshSprite3D.shaderDefines = null;

     /**
      * <code>TrailMaterial</code> 类用于实现拖尾材质。
      */
     class TrailMaterial extends BaseMaterial {
         constructor() {
             super();
             this.setShaderName("Trail");
             this._color = new Vector4(1.0, 1.0, 1.0, 1.0);
             this._shaderValues.setVector(TrailMaterial.TINTCOLOR, new Vector4(1.0, 1.0, 1.0, 1.0));
             this.renderMode = TrailMaterial.RENDERMODE_ALPHABLENDED;
         }
         /**
          * @private
          */
         static __initDefine__() {
             TrailMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
             TrailMaterial.SHADERDEFINE_MAINTEXTURE = TrailMaterial.shaderDefines.registerDefine("MAINTEXTURE");
             TrailMaterial.SHADERDEFINE_TILINGOFFSET = TrailMaterial.shaderDefines.registerDefine("TILINGOFFSET");
             TrailMaterial.SHADERDEFINE_ADDTIVEFOG = TrailMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
         }
         /**
          * @private
          */
         get _TintColorR() {
             return this._color.x;
         }
         /**
          * @private
          */
         set _TintColorR(value) {
             this._color.x = value;
             this.color = this._color;
         }
         /**
          * @private
          */
         get _TintColorG() {
             return this._color.y;
         }
         /**
          * @private
          */
         set _TintColorG(value) {
             this._color.y = value;
             this.color = this._color;
         }
         /**
          * @private
          */
         get _TintColorB() {
             return this._color.z;
         }
         /**
          * @private
          */
         set _TintColorB(value) {
             this._color.z = value;
             this.color = this._color;
         }
         /**@private */
         get _TintColorA() {
             return this._color.w;
         }
         /**
          * @private
          */
         set _TintColorA(value) {
             this._color.w = value;
             this.color = this._color;
         }
         /**
          * @private
          */
         get _MainTex_STX() {
             return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).x;
         }
         /**
          * @private
          */
         set _MainTex_STX(x) {
             var tilOff = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
             tilOff.x = x;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STY() {
             return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).y;
         }
         /**
          * @private
          */
         set _MainTex_STY(y) {
             var tilOff = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
             tilOff.y = y;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STZ() {
             return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).z;
         }
         /**
          * @private
          */
         set _MainTex_STZ(z) {
             var tilOff = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
             tilOff.z = z;
             this.tilingOffset = tilOff;
         }
         /**
          * @private
          */
         get _MainTex_STW() {
             return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).w;
         }
         /**
          * @private
          */
         set _MainTex_STW(w) {
             var tilOff = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
             tilOff.w = w;
             this.tilingOffset = tilOff;
         }
         /**
          * 设置渲染模式。
          * @return 渲染模式。
          */
         set renderMode(value) {
             switch (value) {
                 case TrailMaterial.RENDERMODE_ADDTIVE:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_NONE;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                     break;
                 case TrailMaterial.RENDERMODE_ALPHABLENDED:
                     this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                     this.alphaTest = false;
                     this.depthWrite = false;
                     this.cull = RenderState.CULL_NONE;
                     this.blend = RenderState.BLEND_ENABLE_ALL;
                     this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                     this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                     this.depthTest = RenderState.DEPTHTEST_LESS;
                     this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                     break;
                 default:
                     throw new Error("TrailMaterial : renderMode value error.");
             }
         }
         /**
          * 获取颜色R分量。
          * @return 颜色R分量。
          */
         get colorR() {
             return this._TintColorR;
         }
         /**
          * 设置颜色R分量。
          * @param value 颜色R分量。
          */
         set colorR(value) {
             this._TintColorR = value;
         }
         /**
          * 获取颜色G分量。
          * @return 颜色G分量。
          */
         get colorG() {
             return this._TintColorG;
         }
         /**
          * 设置颜色G分量。
          * @param value 颜色G分量。
          */
         set colorG(value) {
             this._TintColorG = value;
         }
         /**
          * 获取颜色B分量。
          * @return 颜色B分量。
          */
         get colorB() {
             return this._TintColorB;
         }
         /**
          * 设置颜色B分量。
          * @param value 颜色B分量。
          */
         set colorB(value) {
             this._TintColorB = value;
         }
         /**
          * 获取颜色Z分量。
          * @return 颜色Z分量。
          */
         get colorA() {
             return this._TintColorA;
         }
         /**
          * 设置颜色alpha分量。
          * @param value 颜色alpha分量。
          */
         set colorA(value) {
             this._TintColorA = value;
         }
         /**
          * 获取颜色。
          * @return 颜色。
          */
         get color() {
             return this._shaderValues.getVector(TrailMaterial.TINTCOLOR);
         }
         /**
          * 设置颜色。
          * @param value 颜色。
          */
         set color(value) {
             this._shaderValues.setVector(TrailMaterial.TINTCOLOR, value);
         }
         /**
          * 获取贴图。
          * @return 贴图。
          */
         get texture() {
             return this._shaderValues.getTexture(TrailMaterial.MAINTEXTURE);
         }
         /**
          * 设置贴图。
          * @param value 贴图。
          */
         set texture(value) {
             if (value)
                 this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE);
             else
                 this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE);
             this._shaderValues.setTexture(TrailMaterial.MAINTEXTURE, value);
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @return 纹理平铺和偏移X分量。
          */
         get tilingOffsetX() {
             return this._MainTex_STX;
         }
         /**
          * 获取纹理平铺和偏移X分量。
          * @param x 纹理平铺和偏移X分量。
          */
         set tilingOffsetX(x) {
             this._MainTex_STX = x;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @return 纹理平铺和偏移Y分量。
          */
         get tilingOffsetY() {
             return this._MainTex_STY;
         }
         /**
          * 获取纹理平铺和偏移Y分量。
          * @param y 纹理平铺和偏移Y分量。
          */
         set tilingOffsetY(y) {
             this._MainTex_STY = y;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @return 纹理平铺和偏移Z分量。
          */
         get tilingOffsetZ() {
             return this._MainTex_STZ;
         }
         /**
          * 获取纹理平铺和偏移Z分量。
          * @param z 纹理平铺和偏移Z分量。
          */
         set tilingOffsetZ(z) {
             this._MainTex_STZ = z;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @return 纹理平铺和偏移W分量。
          */
         get tilingOffsetW() {
             return this._MainTex_STW;
         }
         /**
          * 获取纹理平铺和偏移W分量。
          * @param w 纹理平铺和偏移W分量。
          */
         set tilingOffsetW(w) {
             this._MainTex_STW = w;
         }
         /**
          * 获取纹理平铺和偏移。
          * @return 纹理平铺和偏移。
          */
         get tilingOffset() {
             return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
         }
         /**
          * 设置纹理平铺和偏移。
          * @param value 纹理平铺和偏移。
          */
         set tilingOffset(value) {
             if (value) {
                 if (value.x != 1 || value.y != 1 || value.z != 0 || value.w != 0)
                     this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET);
                 else
                     this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             else {
                 this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET);
             }
             this._shaderValues.setVector(TrailMaterial.TILINGOFFSET, value);
         }
         /**
          * 设置是否写入深度。
          * @param value 是否写入深度。
          */
         set depthWrite(value) {
             this._shaderValues.setBool(TrailMaterial.DEPTH_WRITE, value);
         }
         /**
          * 获取是否写入深度。
          * @return 是否写入深度。
          */
         get depthWrite() {
             return this._shaderValues.getBool(TrailMaterial.DEPTH_WRITE);
         }
         /**
          * 设置剔除方式。
          * @param value 剔除方式。
          */
         set cull(value) {
             this._shaderValues.setInt(TrailMaterial.CULL, value);
         }
         /**
          * 获取剔除方式。
          * @return 剔除方式。
          */
         get cull() {
             return this._shaderValues.getInt(TrailMaterial.CULL);
         }
         /**
          * 设置混合方式。
          * @param value 混合方式。
          */
         set blend(value) {
             this._shaderValues.setInt(TrailMaterial.BLEND, value);
         }
         /**
          * 获取混合方式。
          * @return 混合方式。
          */
         get blend() {
             return this._shaderValues.getInt(TrailMaterial.BLEND);
         }
         /**
          * 设置混合源。
          * @param value 混合源
          */
         set blendSrc(value) {
             this._shaderValues.setInt(TrailMaterial.BLEND_SRC, value);
         }
         /**
          * 获取混合源。
          * @return 混合源。
          */
         get blendSrc() {
             return this._shaderValues.getInt(TrailMaterial.BLEND_SRC);
         }
         /**
          * 设置混合目标。
          * @param value 混合目标
          */
         set blendDst(value) {
             this._shaderValues.setInt(TrailMaterial.BLEND_DST, value);
         }
         /**
          * 获取混合目标。
          * @return 混合目标。
          */
         get blendDst() {
             return this._shaderValues.getInt(TrailMaterial.BLEND_DST);
         }
         /**
          * 设置深度测试方式。
          * @param value 深度测试方式
          */
         set depthTest(value) {
             this._shaderValues.setInt(TrailMaterial.DEPTH_TEST, value);
         }
         /**
          * 获取深度测试方式。
          * @return 深度测试方式。
          */
         get depthTest() {
             return this._shaderValues.getInt(TrailMaterial.DEPTH_TEST);
         }
         /**
      * 克隆。
      * @return	 克隆副本。
      */
         clone() {
             var dest = new TrailMaterial();
             this.cloneTo(dest);
             return dest;
         }
     }
     /**渲染状态_透明混合。*/
     TrailMaterial.RENDERMODE_ALPHABLENDED = 0;
     /**渲染状态_加色法混合。*/
     TrailMaterial.RENDERMODE_ADDTIVE = 1;
     TrailMaterial.MAINTEXTURE = Shader3D.propertyNameToID("u_MainTexture");
     TrailMaterial.TINTCOLOR = Shader3D.propertyNameToID("u_MainColor");
     TrailMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset");
     TrailMaterial.CULL = Shader3D.propertyNameToID("s_Cull");
     TrailMaterial.BLEND = Shader3D.propertyNameToID("s_Blend");
     TrailMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
     TrailMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
     TrailMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
     TrailMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
     /**@private */
     TrailMaterial.shaderDefines = null;

     /**
          * <code>KeyFrame</code> 类用于创建关键帧实例。
          */
     class Keyframe {
         /**
          * 创建一个 <code>KeyFrame</code> 实例。
          */
         constructor() {
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destKeyFrame = destObject;
             destKeyFrame.time = this.time;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new Keyframe();
             this.cloneTo(dest);
             return dest;
         }
     }

     /**
          * <code>FloatKeyFrame</code> 类用于创建浮点关键帧实例。
          */
     class FloatKeyframe extends Keyframe {
         /**
          * 创建一个 <code>FloatKeyFrame</code> 实例。
          */
         constructor() {
             super();
         }
         /**
          * @inheritDoc
          */
         /*override*/ cloneTo(destObject) {
             super.cloneTo(destObject);
             var destKeyFrame = destObject;
             destKeyFrame.inTangent = this.inTangent;
             destKeyFrame.outTangent = this.outTangent;
             destKeyFrame.value = this.value;
         }
     }

     class TextureMode {
     }
     /**
      * 拉伸模式。
      */
     TextureMode.Stretch = 0;
     /**
      * 平铺模式。
      */
     TextureMode.Tile = 1;

     /**
      * <code>VertexTrail</code> 类用于创建拖尾顶点结构。
      */
     class VertexTrail {
         constructor() {
         }
         static get vertexDeclaration1() {
             return VertexTrail._vertexDeclaration1;
         }
         static get vertexDeclaration2() {
             return VertexTrail._vertexDeclaration2;
         }
         get vertexDeclaration() {
             return VertexTrail._vertexDeclaration1;
         }
     }
     VertexTrail.TRAIL_POSITION0 = 0;
     VertexTrail.TRAIL_OFFSETVECTOR = 1;
     VertexTrail.TRAIL_TIME0 = 2;
     VertexTrail.TRAIL_TEXTURECOORDINATE0Y = 3;
     VertexTrail.TRAIL_TEXTURECOORDINATE0X = 4;
     VertexTrail.TRAIL_COLOR = 5;
     VertexTrail._vertexDeclaration1 = new VertexDeclaration(32, [new VertexElement(0, VertexElementFormat.Vector3, VertexTrail.TRAIL_POSITION0),
         new VertexElement(12, VertexElementFormat.Vector3, VertexTrail.TRAIL_OFFSETVECTOR),
         new VertexElement(24, VertexElementFormat.Single, VertexTrail.TRAIL_TIME0),
         new VertexElement(28, VertexElementFormat.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0Y)]);
     VertexTrail._vertexDeclaration2 = new VertexDeclaration(20, [new VertexElement(0, VertexElementFormat.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0X),
         new VertexElement(4, VertexElementFormat.Color, VertexTrail.TRAIL_COLOR)]);

     var TrailAlignment;
     (function (TrailAlignment) {
         TrailAlignment[TrailAlignment["View"] = 0] = "View";
         TrailAlignment[TrailAlignment["TransformZ"] = 1] = "TransformZ";
     })(TrailAlignment || (TrailAlignment = {}));

     /**
      * <code>TrailGeometry</code> 类用于创建拖尾渲染单元。
      */
     class TrailGeometry extends GeometryElement {
         constructor(owner) {
             super();
             /**@private */
             this._floatCountPerVertices1 = 8;
             /**@private */
             this._floatCountPerVertices2 = 5;
             /**@private */
             this._increaseSegementCount = 16;
             /**@private */
             this._activeIndex = 0;
             /**@private */
             this._endIndex = 0;
             /**@private */
             this._needAddFirstVertex = false;
             /**@private */
             this._isTempEndVertex = false;
             /**@private */
             this._vertices1 = null;
             /**@private */
             this._vertices2 = null;
             /**@private */
             this._lastFixedVertexPosition = new Vector3();
             /** @private */
             this._bufferState = new BufferState();
             this.tmpColor = new Color();
             this._owner = owner;
             //初始化_segementCount
             this._segementCount = this._increaseSegementCount;
             this._resizeData(this._segementCount, this._bufferState);
         }
         /**
          * @private
          */
         _resizeData(segementCount, bufferState) {
             this._subBirthTime = new Float32Array(segementCount);
             this._subDistance = new Float64Array(segementCount);
             var vertexCount = segementCount * 2;
             var vertexDeclaration1 = VertexTrail.vertexDeclaration1;
             var vertexDeclaration2 = VertexTrail.vertexDeclaration2;
             var vertexBuffers = [];
             var vertexbuffer1Size = vertexCount * vertexDeclaration1.vertexStride;
             var vertexbuffer2Size = vertexCount * vertexDeclaration2.vertexStride;
             var memorySize = vertexbuffer1Size + vertexbuffer2Size;
             this._vertices1 = new Float32Array(vertexCount * this._floatCountPerVertices1);
             this._vertices2 = new Float32Array(vertexCount * this._floatCountPerVertices2);
             this._vertexBuffer1 = new VertexBuffer3D(vertexbuffer1Size, WebGLContext.STATIC_DRAW, false);
             this._vertexBuffer1.vertexDeclaration = vertexDeclaration1;
             this._vertexBuffer2 = new VertexBuffer3D(vertexbuffer2Size, WebGLContext.DYNAMIC_DRAW, false);
             this._vertexBuffer2.vertexDeclaration = vertexDeclaration2;
             vertexBuffers.push(this._vertexBuffer1);
             vertexBuffers.push(this._vertexBuffer2);
             bufferState.bind();
             bufferState.applyVertexBuffers(vertexBuffers);
             bufferState.unBind();
             Resource._addMemory(memorySize, memorySize);
         }
         /**
          * @private
          */
         _resetData() {
             var count = this._endIndex - this._activeIndex;
             //提前取出旧数据，否则_resizeData会覆盖
             var oldVertices1 = new Float32Array(this._vertices1.buffer, this._floatCountPerVertices1 * 2 * this._activeIndex * 4, this._floatCountPerVertices1 * 2 * count);
             var oldVertices2 = new Float32Array(this._vertices2.buffer, this._floatCountPerVertices2 * 2 * this._activeIndex * 4, this._floatCountPerVertices2 * 2 * count);
             var oldSubDistance = new Float64Array(this._subDistance.buffer, this._activeIndex * 8, count); //修改距离数据
             var oldSubBirthTime = new Float32Array(this._subBirthTime.buffer, this._activeIndex * 4, count); //修改出生时间数据
             if (count === this._segementCount) { //当前count=_segementCount表示已满,需要扩充
                 this._vertexBuffer1.destroy();
                 this._vertexBuffer2.destroy();
                 this._segementCount += this._increaseSegementCount;
                 this._resizeData(this._segementCount, this._bufferState);
             }
             this._vertices1.set(oldVertices1, 0);
             this._vertices2.set(oldVertices2, 0);
             this._subDistance.set(oldSubDistance, 0);
             this._subBirthTime.set(oldSubBirthTime, 0);
             this._endIndex = count;
             this._activeIndex = 0;
             this._vertexBuffer1.setData(this._vertices1, 0, this._floatCountPerVertices1 * 2 * this._activeIndex, this._floatCountPerVertices1 * 2 * count);
             this._vertexBuffer2.setData(this._vertices2, 0, this._floatCountPerVertices2 * 2 * this._activeIndex, this._floatCountPerVertices2 * 2 * count);
         }
         /**
          * @private
          * 更新Trail数据
          */
         _updateTrail(camera, lastPosition, position) {
             if (!Vector3.equals(lastPosition, position)) { //位置不变不产生分段
                 if ((this._endIndex - this._activeIndex) === 0)
                     this._addTrailByFirstPosition(camera, position); //当前分段全部消失时,需要添加一个首分段
                 else
                     this._addTrailByNextPosition(camera, position);
             }
         }
         /**
          * @private
          * 通过起始位置添加TrailRenderElement起始数据
          */
         _addTrailByFirstPosition(camera, position) {
             (this._endIndex === this._segementCount) && (this._resetData());
             this._subDistance[this._endIndex] = 0;
             this._subBirthTime[this._endIndex] = this._owner._curtime;
             this._endIndex++;
             position.cloneTo(this._lastFixedVertexPosition);
             this._needAddFirstVertex = true;
         }
         /**
          * @private
          * 通过位置更新TrailRenderElement数据
          */
         _addTrailByNextPosition(camera, position) {
             var cameraMatrix = camera.viewMatrix;
             Vector3.transformCoordinate(position, cameraMatrix, TrailGeometry._tempVector33);
             var delVector3 = TrailGeometry._tempVector30;
             var pointAtoBVector3 = TrailGeometry._tempVector31;
             Vector3.transformCoordinate(this._lastFixedVertexPosition, cameraMatrix, TrailGeometry._tempVector34);
             Vector3.subtract(TrailGeometry._tempVector33, TrailGeometry._tempVector34, delVector3);
             switch (this._owner.alignment) {
                 case TrailAlignment.View:
                     Vector3.cross(TrailGeometry._tempVector33, delVector3, pointAtoBVector3);
                     break;
                 case TrailAlignment.TransformZ:
                     var forward = TrailGeometry._tempVector32;
                     this._owner._owner.transform.getForward(forward);
                     Vector3.cross(delVector3, forward, pointAtoBVector3); //实时更新模式需要和view一样根据当前forward重新计算
                     break;
             }
             Vector3.normalize(pointAtoBVector3, pointAtoBVector3);
             Vector3.scale(pointAtoBVector3, this._owner.widthMultiplier / 2, pointAtoBVector3);
             var delLength = Vector3.scalarLength(delVector3);
             var tempEndIndex;
             var offset;
             if (this._needAddFirstVertex) {
                 this._updateVerticesByPositionData(position, pointAtoBVector3, this._endIndex - 1); //延迟更新首分段数据
                 this._needAddFirstVertex = false;
             }
             if (delLength - this._owner.minVertexDistance >= MathUtils3D.zeroTolerance) { //大于最小距离产生新分段
                 if (this._isTempEndVertex) {
                     tempEndIndex = this._endIndex - 1;
                     offset = delLength - this._subDistance[tempEndIndex];
                     this._updateVerticesByPosition(position, pointAtoBVector3, delLength, tempEndIndex);
                     this._owner._totalLength += offset; //不产生新分段要通过差值更新总距离
                 }
                 else {
                     (this._endIndex === this._segementCount) && (this._resetData());
                     this._updateVerticesByPosition(position, pointAtoBVector3, delLength, this._endIndex);
                     this._owner._totalLength += delLength;
                     this._endIndex++;
                 }
                 position.cloneTo(this._lastFixedVertexPosition);
                 this._isTempEndVertex = false;
             }
             else {
                 if (this._isTempEndVertex) {
                     tempEndIndex = this._endIndex - 1;
                     offset = delLength - this._subDistance[tempEndIndex];
                     this._updateVerticesByPosition(position, pointAtoBVector3, delLength, tempEndIndex);
                     this._owner._totalLength += offset; //不产生新分段要通过差值更新总距离
                 }
                 else {
                     (this._endIndex === this._segementCount) && (this._resetData());
                     this._updateVerticesByPosition(position, pointAtoBVector3, delLength, this._endIndex);
                     this._owner._totalLength += delLength;
                     this._endIndex++;
                 }
                 this._isTempEndVertex = true;
             }
         }
         /**
          * @private
          * 通过位置更新顶点数据
          */
         _updateVerticesByPositionData(position, pointAtoBVector3, index) {
             var vertexOffset = this._floatCountPerVertices1 * 2 * index;
             var curtime = this._owner._curtime;
             this._vertices1[vertexOffset] = position.x;
             this._vertices1[vertexOffset + 1] = position.y;
             this._vertices1[vertexOffset + 2] = position.z;
             this._vertices1[vertexOffset + 3] = -pointAtoBVector3.x;
             this._vertices1[vertexOffset + 4] = -pointAtoBVector3.y;
             this._vertices1[vertexOffset + 5] = -pointAtoBVector3.z;
             this._vertices1[vertexOffset + 6] = curtime;
             this._vertices1[vertexOffset + 7] = 1.0;
             this._vertices1[vertexOffset + 8] = position.x;
             this._vertices1[vertexOffset + 9] = position.y;
             this._vertices1[vertexOffset + 10] = position.z;
             this._vertices1[vertexOffset + 11] = pointAtoBVector3.x;
             this._vertices1[vertexOffset + 12] = pointAtoBVector3.y;
             this._vertices1[vertexOffset + 13] = pointAtoBVector3.z;
             this._vertices1[vertexOffset + 14] = curtime;
             this._vertices1[vertexOffset + 15] = 0.0;
             var floatCount = this._floatCountPerVertices1 * 2;
             this._vertexBuffer1.setData(this._vertices1, vertexOffset, vertexOffset, floatCount);
         }
         /**
          * @private
          * 通过位置更新顶点数据、距离、出生时间
          */
         _updateVerticesByPosition(position, pointAtoBVector3, delDistance, index) {
             this._updateVerticesByPositionData(position, pointAtoBVector3, index);
             this._subDistance[index] = delDistance;
             this._subBirthTime[index] = this._owner._curtime;
         }
         /**
          * @private
          * 更新VertexBuffer2数据
          */
         _updateVertexBufferUV() {
             var vertexCount = this._endIndex;
             var curLength = 0;
             var gradient = this._owner.colorGradient;
             var startAlphaIndex = gradient.colorAlphaKeysCount - 1;
             var startColorIndex = gradient.colorRGBKeysCount - 1;
             var totalLength = this._owner._totalLength;
             for (var i = this._activeIndex; i < vertexCount; i++) {
                 (i !== this._activeIndex) && (curLength += this._subDistance[i]);
                 var uvX;
                 var lerpFactor;
                 if (this._owner.textureMode == TextureMode.Stretch) {
                     uvX = 1.0 - curLength / totalLength;
                     lerpFactor = uvX;
                 }
                 else {
                     lerpFactor = 1.0 - curLength / totalLength;
                     uvX = 1.0 - (totalLength - curLength);
                 }
                 startColorIndex = gradient.evaluateColorRGB(lerpFactor, this.tmpColor, startColorIndex, true);
                 startAlphaIndex = gradient.evaluateColorAlpha(lerpFactor, this.tmpColor, startAlphaIndex, true);
                 var stride = this._floatCountPerVertices2 * 2;
                 var index = i * stride;
                 this._vertices2[index + 0] = uvX;
                 this._vertices2[index + 1] = this.tmpColor.r;
                 this._vertices2[index + 2] = this.tmpColor.g;
                 this._vertices2[index + 3] = this.tmpColor.b;
                 this._vertices2[index + 4] = this.tmpColor.a;
                 this._vertices2[index + 5] = uvX;
                 this._vertices2[index + 6] = this.tmpColor.r;
                 this._vertices2[index + 7] = this.tmpColor.g;
                 this._vertices2[index + 8] = this.tmpColor.b;
                 this._vertices2[index + 9] = this.tmpColor.a;
             }
             var offset = this._activeIndex * stride;
             this._vertexBuffer2.setData(this._vertices2, offset, offset, vertexCount * stride - offset);
         }
         /**
          * @private
          */
         _updateDisappear() {
             var count = this._endIndex;
             for (var i = this._activeIndex; i < count; i++) {
                 if (this._owner._curtime - this._subBirthTime[i] >= this._owner.time + MathUtils3D.zeroTolerance) {
                     var nextIndex = i + 1;
                     if (nextIndex !== count)
                         this._owner._totalLength -= this._subDistance[nextIndex]; //移除分段要减去下一分段到当前分段的距离
                     if (this._isTempEndVertex && (nextIndex === count - 1)) { //如果只剩最后一分段要将其转化为固定分段
                         var offset = this._floatCountPerVertices1 * i * 2;
                         var fixedPos = this._lastFixedVertexPosition;
                         fixedPos.x = this._vertices1[0];
                         fixedPos.y = this._vertices1[1];
                         fixedPos.z = this._vertices1[2];
                         this._isTempEndVertex = false;
                     }
                     this._activeIndex++;
                 }
                 else {
                     break;
                 }
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getType() {
             return TrailGeometry._type;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _prepareRender(state) {
             return this._endIndex - this._activeIndex > 1; //当前分段为0或1时不渲染
         }
         /**
          * @inheritDoc
          */
         /*override*/ _render(state) {
             this._bufferState.bind();
             var start = this._activeIndex * 2;
             var count = this._endIndex * 2 - start;
             LayaGL.instance.drawArrays(WebGLContext.TRIANGLE_STRIP, start, count);
             Stat.renderBatches++;
             Stat.trianglesFaces += count - 2;
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy() {
             super.destroy();
             var memorySize = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
             Resource._addMemory(-memorySize, -memorySize);
             this._bufferState.destroy();
             this._vertexBuffer1.destroy();
             this._vertexBuffer2.destroy();
             this._bufferState = null;
             this._vertices1 = null;
             this._vertexBuffer1 = null;
             this._vertices2 = null;
             this._vertexBuffer2 = null;
             this._subBirthTime = null;
             this._subDistance = null;
             this._lastFixedVertexPosition = null;
         }
     }
     /** 轨迹准线_面向摄像机。*/
     TrailGeometry.ALIGNMENT_VIEW = 0;
     /** 轨迹准线_面向运动方向。*/
     TrailGeometry.ALIGNMENT_TRANSFORM_Z = 1;
     /**@private */
     TrailGeometry._tempVector30 = new Vector3();
     /**@private */
     TrailGeometry._tempVector31 = new Vector3();
     /**@private */
     TrailGeometry._tempVector32 = new Vector3();
     /**@private */
     TrailGeometry._tempVector33 = new Vector3();
     /**@private */
     TrailGeometry._tempVector34 = new Vector3();
     /**@private */
     TrailGeometry._type = GeometryElement._typeCounter++;

     /**
      * <code>TrailFilter</code> 类用于创建拖尾过滤器。
      */
     class TrailFilter {
         constructor(owner) {
             /**@private 拖尾总长度*/
             this._totalLength = 0;
             this._lastPosition = new Vector3();
             this._curtime = 0;
             /**轨迹准线。*/
             this.alignment = TrailFilter.ALIGNMENT_VIEW;
             this._owner = owner;
             this._initDefaultData();
             this.addRenderElement();
         }
         /**
          * 获取淡出时间。
          * @return  淡出时间。
          */
         get time() {
             return this._time;
         }
         /**
          * 设置淡出时间。
          * @param value 淡出时间。
          */
         set time(value) {
             this._time = value;
             this._owner._render._shaderValues.setNumber(TrailFilter.LIFETIME, value);
         }
         /**
          * 获取新旧顶点之间最小距离。
          * @return  新旧顶点之间最小距离。
          */
         get minVertexDistance() {
             return this._minVertexDistance;
         }
         /**
          * 设置新旧顶点之间最小距离。
          * @param value 新旧顶点之间最小距离。
          */
         set minVertexDistance(value) {
             this._minVertexDistance = value;
         }
         /**
          * 获取宽度倍数。
          * @return  宽度倍数。
          */
         get widthMultiplier() {
             return this._widthMultiplier;
         }
         /**
          * 设置宽度倍数。
          * @param value 宽度倍数。
          */
         set widthMultiplier(value) {
             this._widthMultiplier = value;
         }
         /**
          * 获取宽度曲线。
          * @return  宽度曲线。
          */
         get widthCurve() {
             return this._widthCurve;
         }
         /**
          * 设置宽度曲线。
          * @param value 宽度曲线。
          */
         set widthCurve(value) {
             this._widthCurve = value;
             var widthCurveFloatArray = new Float32Array(value.length * 4);
             var i, j, index = 0;
             for (i = 0, j = value.length; i < j; i++) {
                 widthCurveFloatArray[index++] = value[i].time;
                 widthCurveFloatArray[index++] = value[i].inTangent;
                 widthCurveFloatArray[index++] = value[i].outTangent;
                 widthCurveFloatArray[index++] = value[i].value;
             }
             this._owner._render._shaderValues.setBuffer(TrailFilter.WIDTHCURVE, widthCurveFloatArray);
             this._owner._render._shaderValues.setInt(TrailFilter.WIDTHCURVEKEYLENGTH, value.length);
         }
         /**
          * 获取颜色梯度。
          * @return  颜色梯度。
          */
         get colorGradient() {
             return this._colorGradient;
         }
         /**
          * 设置颜色梯度。
          * @param value 颜色梯度。
          */
         set colorGradient(value) {
             this._colorGradient = value;
         }
         /**
          * 获取纹理模式。
          * @return  纹理模式。
          */
         get textureMode() {
             return this._textureMode;
         }
         /**
          * 设置纹理模式。
          * @param value 纹理模式。
          */
         set textureMode(value) {
             this._textureMode = value;
         }
         /**
          * @private
          */
         addRenderElement() {
             var render = this._owner._render;
             var elements = render._renderElements;
             var material = render.sharedMaterials[0];
             (material) || (material = TrailMaterial.defaultMaterial);
             var element = new RenderElement();
             element.setTransform(this._owner._transform);
             element.render = render;
             element.material = material;
             this._trialGeometry = new TrailGeometry(this);
             element.setGeometry(this._trialGeometry);
             elements.push(element);
         }
         /**
          * @private
          */
         _update(state) {
             var render = this._owner._render;
             this._curtime += state.scene.timer._delta / 1000;
             render._shaderValues.setNumber(TrailFilter.CURTIME, this._curtime);
             var curPos = this._owner.transform.position;
             var element = render._renderElements[0]._geometry;
             element._updateDisappear();
             element._updateTrail(state.camera, this._lastPosition, curPos);
             element._updateVertexBufferUV();
             curPos.cloneTo(this._lastPosition);
         }
         /**
          * @private
          */
         _initDefaultData() {
             this.time = 5.0;
             this.minVertexDistance = 0.1;
             this.widthMultiplier = 1;
             this.textureMode = TextureMode.Stretch;
             var widthKeyFrames = [];
             var widthKeyFrame1 = new FloatKeyframe();
             widthKeyFrame1.time = 0;
             widthKeyFrame1.inTangent = 0;
             widthKeyFrame1.outTangent = 0;
             widthKeyFrame1.value = 1;
             widthKeyFrames.push(widthKeyFrame1);
             var widthKeyFrame2 = new FloatKeyframe();
             widthKeyFrame2.time = 1;
             widthKeyFrame2.inTangent = 0;
             widthKeyFrame2.outTangent = 0;
             widthKeyFrame2.value = 1;
             widthKeyFrames.push(widthKeyFrame2);
             this.widthCurve = widthKeyFrames;
             var gradient = new Gradient(2, 2);
             gradient.mode = GradientMode.Blend;
             gradient.addColorRGB(0, Color.WHITE);
             gradient.addColorRGB(1, Color.WHITE);
             gradient.addColorAlpha(0, 1);
             gradient.addColorAlpha(1, 1);
             this.colorGradient = gradient;
         }
         /**
          * @private
          */
         destroy() {
             this._trialGeometry.destroy();
             this._trialGeometry = null;
             this._widthCurve = null;
             this._colorGradient = null;
         }
     }
     TrailFilter.CURTIME = Shader3D.propertyNameToID("u_CurTime");
     TrailFilter.LIFETIME = Shader3D.propertyNameToID("u_LifeTime");
     TrailFilter.WIDTHCURVE = Shader3D.propertyNameToID("u_WidthCurve");
     TrailFilter.WIDTHCURVEKEYLENGTH = Shader3D.propertyNameToID("u_WidthCurveKeyLength");
     //--------------------------------------------------兼容---------------------------------------------------------------------
     /** 轨迹准线_面向摄像机。*/
     TrailFilter.ALIGNMENT_VIEW = 0;
     /** 轨迹准线_面向运动方向。*/
     TrailFilter.ALIGNMENT_TRANSFORM_Z = 1;

     /**
      * <code>TrailRenderer</code> 类用于创建拖尾渲染器。
      */
     class TrailRenderer extends BaseRender {
         constructor(owner) {
             super(owner);
             this._projectionViewWorldMatrix = new Matrix4x4();
             this._supportOctree = false;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _calculateBoundingBox() {
             var min = this._bounds.getMin();
             min.x = -Number.MAX_VALUE;
             min.y = -Number.MAX_VALUE;
             min.z = -Number.MAX_VALUE;
             this._bounds.setMin(min);
             var max = this._bounds.getMax();
             max.x = Number.MAX_VALUE;
             max.y = Number.MAX_VALUE;
             max.z = Number.MAX_VALUE;
             this._bounds.setMax(max);
             if (Render.supportWebGLPlusCulling) { //[NATIVE]
                 var min = this._bounds.getMin();
                 var max = this._bounds.getMax();
                 var buffer = FrustumCulling._cullingBuffer;
                 buffer[this._cullingBufferIndex + 1] = min.x;
                 buffer[this._cullingBufferIndex + 2] = min.y;
                 buffer[this._cullingBufferIndex + 3] = min.z;
                 buffer[this._cullingBufferIndex + 4] = max.x;
                 buffer[this._cullingBufferIndex + 5] = max.y;
                 buffer[this._cullingBufferIndex + 6] = max.z;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _needRender(boundFrustum) {
             return true;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _renderUpdate(state, transform) {
             super._renderUpdate(state, transform);
             this._owner.trailFilter._update(state);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _renderUpdateWithCamera(context, transform) {
             var projectionView = context.projectionViewMatrix;
             if (transform) {
                 Matrix4x4.multiply(projectionView, transform.worldMatrix, this._projectionViewWorldMatrix);
                 this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix);
             }
             else {
                 this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView);
             }
         }
     }

     /**
      * <code>TrailSprite3D</code> 类用于创建拖尾渲染精灵。
      */
     class TrailSprite3D extends RenderableSprite3D {
         /**
          * @private
          */
         static __init__() {
             TrailSprite3D.shaderDefines = new ShaderDefines(RenderableSprite3D.shaderDefines);
         }
         /**
          * 获取Trail过滤器。
          * @return  Trail过滤器。
          */
         get trailFilter() {
             return this._geometryFilter;
         }
         /**
          * 获取Trail渲染器。
          * @return  Trail渲染器。
          */
         get trailRenderer() {
             return this._render;
         }
         constructor(name = null) {
             super(name);
             this._render = new TrailRenderer(this);
             this._geometryFilter = new TrailFilter(this);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             super._parse(data, spriteMap);
             var render = this._render;
             var filter = this._geometryFilter;
             var i, j;
             var materials = data.materials;
             if (materials) {
                 var sharedMaterials = render.sharedMaterials;
                 var materialCount = materials.length;
                 sharedMaterials.length = materialCount;
                 for (i = 0; i < materialCount; i++)
                     sharedMaterials[i] = Loader.getRes(materials[i].path);
                 render.sharedMaterials = sharedMaterials;
             }
             filter.time = data.time;
             filter.minVertexDistance = data.minVertexDistance;
             filter.widthMultiplier = data.widthMultiplier;
             filter.textureMode = data.textureMode;
             (data.alignment != null) && (filter.alignment = data.alignment);
             //widthCurve
             var widthCurve = [];
             var widthCurveData = data.widthCurve;
             for (i = 0, j = widthCurveData.length; i < j; i++) {
                 var trailkeyframe = new FloatKeyframe();
                 trailkeyframe.time = widthCurveData[i].time;
                 trailkeyframe.inTangent = widthCurveData[i].inTangent;
                 trailkeyframe.outTangent = widthCurveData[i].outTangent;
                 trailkeyframe.value = widthCurveData[i].value;
                 widthCurve.push(trailkeyframe);
             }
             filter.widthCurve = widthCurve;
             //colorGradient
             var colorGradientData = data.colorGradient;
             var colorKeys = colorGradientData.colorKeys;
             var alphaKeys = colorGradientData.alphaKeys;
             var colorGradient = new Gradient(colorKeys.length, alphaKeys.length);
             colorGradient.mode = colorGradientData.mode;
             for (i = 0, j = colorKeys.length; i < j; i++) {
                 var colorKey = colorKeys[i];
                 colorGradient.addColorRGB(colorKey.time, new Color(colorKey.value[0], colorKey.value[1], colorKey.value[2], 1.0));
             }
             for (i = 0, j = alphaKeys.length; i < j; i++) {
                 var alphaKey = alphaKeys[i];
                 colorGradient.addColorAlpha(alphaKey.time, alphaKey.value);
             }
             filter.colorGradient = colorGradient;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onActive() {
             super._onActive();
             this._transform.position.cloneTo(this._geometryFilter._lastPosition); //激活时需要重置上次位置
         }
         /**
          * @inheritDoc
          */
         /*override*/ _cloneTo(destObject, srcSprite, dstSprite) {
             super._cloneTo(destObject, srcSprite, dstSprite);
             var i, j;
             var destTrailSprite3D = destObject;
             var destTrailFilter = destTrailSprite3D.trailFilter;
             destTrailFilter.time = this.trailFilter.time;
             destTrailFilter.minVertexDistance = this.trailFilter.minVertexDistance;
             destTrailFilter.widthMultiplier = this.trailFilter.widthMultiplier;
             destTrailFilter.textureMode = this.trailFilter.textureMode;
             var widthCurveData = this.trailFilter.widthCurve;
             var widthCurve = [];
             for (i = 0, j = widthCurveData.length; i < j; i++) {
                 var keyFrame = new FloatKeyframe();
                 widthCurveData[i].cloneTo(keyFrame);
                 widthCurve.push(keyFrame);
             }
             destTrailFilter.widthCurve = widthCurve;
             var destColorGradient = new Gradient(this.trailFilter.colorGradient.maxColorRGBKeysCount, this.trailFilter.colorGradient.maxColorAlphaKeysCount);
             this.trailFilter.colorGradient.cloneTo(destColorGradient);
             destTrailFilter.colorGradient = destColorGradient;
             var destTrailRender = destTrailSprite3D.trailRenderer;
             destTrailRender.sharedMaterial = this.trailRenderer.sharedMaterial;
         }
         /**
          * <p>销毁此对象。</p>
          * @param	destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
          */
         /*override*/ destroy(destroyChild = true) {
             if (this.destroyed)
                 return;
             super.destroy(destroyChild);
             this._geometryFilter.destroy();
             this._geometryFilter = null;
         }
         /**
          * @private
          */
         _create() {
             return new TrailSprite3D();
         }
     }

     /**
          * @private
          *  <code>shaderVariable</code> 类用于保存shader变量上传相关信息。
          */
     class ShaderVariable {
         /**
          * 创建一个 <code>shaderVariable</code> 实例。
          */
         constructor() {
             this.textureID = -1;
         }
     }

     /**
      * @private
      * <code>ShaderInstance</code> 类用于实现ShaderInstance。
      */
     class ShaderInstance extends Resource {
         /**
          * 创建一个 <code>ShaderInstance</code> 实例。
          */
         constructor(vs, ps, attributeMap, uniformMap, shaderPass) {
             super();
             /**@private */
             this._stateParamsMap = [];
             /**@private */
             this._uploadMark = -1;
             /** @private */
             this._uploadRenderType = -1;
             this._vs = vs;
             this._ps = ps;
             this._attributeMap = attributeMap;
             this._uniformMap = uniformMap;
             this._shaderPass = shaderPass;
             this._create();
             this.lock = true;
         }
         /**
          *@private
          */
         _create() {
             var gl = LayaGL.instance;
             this._program = gl.createProgram();
             this._vshader = this._createShader(gl, this._vs, WebGLContext.VERTEX_SHADER);
             this._pshader = this._createShader(gl, this._ps, WebGLContext.FRAGMENT_SHADER);
             gl.attachShader(this._program, this._vshader);
             gl.attachShader(this._program, this._pshader);
             for (var k in this._attributeMap) //根据声明调整location,便于VAO使用
                 gl.bindAttribLocation(this._program, this._attributeMap[k], k);
             gl.linkProgram(this._program);
             if (!Render.isConchApp && Shader3D.debugMode && !gl.getProgramParameter(this._program, WebGLContext.LINK_STATUS))
                 throw gl.getProgramInfoLog(this._program);
             var sceneParms = [];
             var cameraParms = [];
             var spriteParms = [];
             var materialParms = [];
             var customParms = [];
             this._customUniformParamsMap = [];
             var nUniformNum = gl.getProgramParameter(this._program, WebGLContext.ACTIVE_UNIFORMS);
             WebGLContext.useProgram(gl, this._program);
             this._curActTexIndex = 0;
             var one, i, n;
             for (i = 0; i < nUniformNum; i++) {
                 var uniformData = gl.getActiveUniform(this._program, i);
                 var uniName = uniformData.name;
                 one = new ShaderVariable();
                 one.location = gl.getUniformLocation(this._program, uniName);
                 if (uniName.indexOf('[0]') > 0) {
                     one.name = uniName = uniName.substr(0, uniName.length - 3);
                     one.isArray = true;
                 }
                 else {
                     one.name = uniName;
                     one.isArray = false;
                 }
                 one.type = uniformData.type;
                 this._addShaderUnifiormFun(one);
                 var uniformPeriod = this._uniformMap[uniName];
                 if (uniformPeriod != null) {
                     one.dataOffset = Shader3D.propertyNameToID(uniName);
                     switch (uniformPeriod) {
                         case Shader3D.PERIOD_CUSTOM:
                             customParms.push(one);
                             break;
                         case Shader3D.PERIOD_MATERIAL:
                             materialParms.push(one);
                             break;
                         case Shader3D.PERIOD_SPRITE:
                             spriteParms.push(one);
                             break;
                         case Shader3D.PERIOD_CAMERA:
                             cameraParms.push(one);
                             break;
                         case Shader3D.PERIOD_SCENE:
                             sceneParms.push(one);
                             break;
                         default:
                             throw new Error("Shader3D: period is unkonw.");
                     }
                 }
             }
             //Native版本分别存入funid、webglFunid,location、type、offset, +4是因为第一个存长度了 所以是*4*5+4
             this._sceneUniformParamsMap = LayaGL.instance.createCommandEncoder(sceneParms.length * 4 * 5 + 4, 64, true);
             for (i = 0, n = sceneParms.length; i < n; i++)
                 this._sceneUniformParamsMap.addShaderUniform(sceneParms[i]);
             this._cameraUniformParamsMap = LayaGL.instance.createCommandEncoder(cameraParms.length * 4 * 5 + 4, 64, true);
             for (i = 0, n = cameraParms.length; i < n; i++)
                 this._cameraUniformParamsMap.addShaderUniform(cameraParms[i]);
             this._spriteUniformParamsMap = LayaGL.instance.createCommandEncoder(spriteParms.length * 4 * 5 + 4, 64, true);
             for (i = 0, n = spriteParms.length; i < n; i++)
                 this._spriteUniformParamsMap.addShaderUniform(spriteParms[i]);
             this._materialUniformParamsMap = LayaGL.instance.createCommandEncoder(materialParms.length * 4 * 5 + 4, 64, true);
             for (i = 0, n = materialParms.length; i < n; i++)
                 this._materialUniformParamsMap.addShaderUniform(materialParms[i]);
             this._customUniformParamsMap.length = customParms.length;
             for (i = 0, n = customParms.length; i < n; i++) {
                 var custom = customParms[i];
                 this._customUniformParamsMap[custom.dataOffset] = custom;
             }
             var stateMap = this._shaderPass._stateMap;
             for (var s in stateMap)
                 this._stateParamsMap[stateMap[s]] = Shader3D.propertyNameToID(s);
         }
         /**
          * @private
          */
         _getRenderState(shaderDatas, stateIndex) {
             var stateID = this._stateParamsMap[stateIndex];
             if (stateID == null)
                 return null;
             else
                 return shaderDatas[stateID];
         }
         /**
          * @inheritDoc
          */
         /*override*/ _disposeResource() {
             LayaGL.instance.deleteShader(this._vshader);
             LayaGL.instance.deleteShader(this._pshader);
             LayaGL.instance.deleteProgram(this._program);
             this._vshader = this._pshader = this._program = null;
             this._setGPUMemory(0);
             this._curActTexIndex = 0;
         }
         /**
          * @private
          */
         _addShaderUnifiormFun(one) {
             var gl = LayaGL.instance;
             one.caller = this;
             var isArray = one.isArray;
             switch (one.type) {
                 case WebGLContext.BOOL:
                     one.fun = this._uniform1i;
                     one.uploadedValue = new Array(1);
                     break;
                 case WebGLContext.INT:
                     one.fun = isArray ? this._uniform1iv : this._uniform1i; //TODO:优化
                     one.uploadedValue = new Array(1);
                     break;
                 case WebGLContext.FLOAT:
                     one.fun = isArray ? this._uniform1fv : this._uniform1f;
                     one.uploadedValue = new Array(1);
                     break;
                 case WebGLContext.FLOAT_VEC2:
                     one.fun = isArray ? this._uniform_vec2v : this._uniform_vec2;
                     one.uploadedValue = new Array(2);
                     break;
                 case WebGLContext.FLOAT_VEC3:
                     one.fun = isArray ? this._uniform_vec3v : this._uniform_vec3;
                     one.uploadedValue = new Array(3);
                     break;
                 case WebGLContext.FLOAT_VEC4:
                     one.fun = isArray ? this._uniform_vec4v : this._uniform_vec4;
                     one.uploadedValue = new Array(4);
                     break;
                 case WebGLContext.FLOAT_MAT2:
                     one.fun = this._uniformMatrix2fv;
                     break;
                 case WebGLContext.FLOAT_MAT3:
                     one.fun = this._uniformMatrix3fv;
                     break;
                 case WebGLContext.FLOAT_MAT4:
                     one.fun = isArray ? this._uniformMatrix4fv : this._uniformMatrix4f;
                     break;
                 case WebGLContext.SAMPLER_2D:
                     gl.uniform1i(one.location, this._curActTexIndex);
                     one.textureID = WebGLContext._glTextureIDs[this._curActTexIndex++];
                     one.fun = this._uniform_sampler2D;
                     break;
                 case 0x8b5f: //sampler3D
                     gl.uniform1i(one.location, this._curActTexIndex);
                     one.textureID = WebGLContext._glTextureIDs[this._curActTexIndex++];
                     one.fun = this._uniform_sampler3D;
                     break;
                 case WebGLContext.SAMPLER_CUBE:
                     gl.uniform1i(one.location, this._curActTexIndex);
                     one.textureID = WebGLContext._glTextureIDs[this._curActTexIndex++];
                     one.fun = this._uniform_samplerCube;
                     break;
                 default:
                     throw new Error("compile shader err!");
                     break;
             }
         }
         /**
          * @private
          */
         _createShader(gl, str, type) {
             var shader = gl.createShader(type);
             gl.shaderSource(shader, str);
             gl.compileShader(shader);
             if (Shader3D.debugMode && !gl.getShaderParameter(shader, WebGLContext.COMPILE_STATUS))
                 throw gl.getShaderInfoLog(shader);
             return shader;
         }
         /**
          * @private
          */
         _uniform1f(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value) {
                 LayaGL.instance.uniform1f(one.location, uploadedValue[0] = value);
                 return 1;
             }
             return 0;
         }
         /**
          * @private
          */
         _uniform1fv(one, value) {
             if (value.length < 4) {
                 var uploadedValue = one.uploadedValue;
                 if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                     LayaGL.instance.uniform1fv(one.location, value);
                     uploadedValue[0] = value[0];
                     uploadedValue[1] = value[1];
                     uploadedValue[2] = value[2];
                     uploadedValue[3] = value[3];
                     return 1;
                 }
                 return 0;
             }
             else {
                 LayaGL.instance.uniform1fv(one.location, value);
                 return 1;
             }
         }
         /**
          * @private
          */
         _uniform_vec2(one, v) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== v.x || uploadedValue[1] !== v.y) {
                 LayaGL.instance.uniform2f(one.location, uploadedValue[0] = v.x, uploadedValue[1] = v.y);
                 return 1;
             }
             return 0;
         }
         /**
          * @private
          */
         _uniform_vec2v(one, value) {
             if (value.length < 2) {
                 var uploadedValue = one.uploadedValue;
                 if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                     LayaGL.instance.uniform2fv(one.location, value);
                     uploadedValue[0] = value[0];
                     uploadedValue[1] = value[1];
                     uploadedValue[2] = value[2];
                     uploadedValue[3] = value[3];
                     return 1;
                 }
                 return 0;
             }
             else {
                 LayaGL.instance.uniform2fv(one.location, value);
                 return 1;
             }
         }
         /**
          * @private
          */
         _uniform_vec3(one, v) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== v.x || uploadedValue[1] !== v.y || uploadedValue[2] !== v.z) {
                 LayaGL.instance.uniform3f(one.location, uploadedValue[0] = v.x, uploadedValue[1] = v.y, uploadedValue[2] = v.z);
                 return 1;
             }
             return 0;
         }
         /**
          * @private
          */
         _uniform_vec3v(one, v) {
             LayaGL.instance.uniform3fv(one.location, v);
             return 1;
         }
         /**
          * @private
          */
         _uniform_vec4(one, v) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== v.x || uploadedValue[1] !== v.y || uploadedValue[2] !== v.z || uploadedValue[3] !== v.w) {
                 LayaGL.instance.uniform4f(one.location, uploadedValue[0] = v.x, uploadedValue[1] = v.y, uploadedValue[2] = v.z, uploadedValue[3] = v.w);
                 return 1;
             }
             return 0;
         }
         /**
          * @private
          */
         _uniform_vec4v(one, v) {
             LayaGL.instance.uniform4fv(one.location, v);
             return 1;
         }
         /**
          * @private
          */
         _uniformMatrix2fv(one, value) {
             LayaGL.instance.uniformMatrix2fv(one.location, false, value);
             return 1;
         }
         /**
          * @private
          */
         _uniformMatrix3fv(one, value) {
             LayaGL.instance.uniformMatrix3fv(one.location, false, value);
             return 1;
         }
         /**
          * @private
          */
         _uniformMatrix4f(one, m) {
             var value = m.elements;
             LayaGL.instance.uniformMatrix4fv(one.location, false, value);
             return 1;
         }
         /**
          * @private
          */
         _uniformMatrix4fv(one, m) {
             LayaGL.instance.uniformMatrix4fv(one.location, false, m);
             return 1;
         }
         /**
          * @private
          */
         _uniform1i(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value) {
                 LayaGL.instance.uniform1i(one.location, uploadedValue[0] = value);
                 return 1;
             }
             return 0;
         }
         /**
          * @private
          */
         _uniform1iv(one, value) {
             LayaGL.instance.uniform1iv(one.location, value);
             return 1;
         }
         /**
          * @private
          */
         _uniform_ivec2(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1]) {
                 LayaGL.instance.uniform2i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
                 return 1;
             }
             return 0;
         }
         /**
          * @private
          */
         _uniform_ivec2v(one, value) {
             LayaGL.instance.uniform2iv(one.location, value);
             return 1;
         }
         /**
          * @private
          */
         _uniform_vec3i(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
                 LayaGL.instance.uniform3i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
                 return 1;
             }
             return 0;
         }
         /**
          * @private
          */
         _uniform_vec3vi(one, value) {
             LayaGL.instance.uniform3iv(one.location, value);
             return 1;
         }
         /**
          * @private
          */
         _uniform_vec4i(one, value) {
             var uploadedValue = one.uploadedValue;
             if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                 LayaGL.instance.uniform4i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
                 return 1;
             }
             return 0;
         }
         /**
          * @private
          */
         _uniform_vec4vi(one, value) {
             LayaGL.instance.uniform4iv(one.location, value);
             return 1;
         }
         /**
          * @private
          */
         _uniform_sampler2D(one, texture) {
             var value = texture._getSource() || texture.defaulteTexture._getSource();
             var gl = LayaGL.instance;
             WebGLContext.activeTexture(gl, one.textureID);
             WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_2D, value);
             return 0;
         }
         _uniform_sampler3D(one, texture) {
             var value = texture._getSource() || texture.defaulteTexture._getSource();
             var gl = LayaGL.instance;
             WebGLContext.activeTexture(gl, one.textureID);
             WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_3D, value);
             return 0;
         }
         /**
          * @private
          */
         _uniform_samplerCube(one, texture) {
             var value = texture._getSource() || texture.defaulteTexture._getSource();
             var gl = LayaGL.instance;
             WebGLContext.activeTexture(gl, one.textureID);
             WebGLContext.bindTexture(gl, WebGLContext.TEXTURE_CUBE_MAP, value);
             return 0;
         }
         /**
          * @private
          */
         bind() {
             return WebGLContext.useProgram(LayaGL.instance, this._program);
         }
         /**
          * @private
          */
         uploadUniforms(shaderUniform, shaderDatas, uploadUnTexture) {
             Stat.shaderCall += LayaGLRunner.uploadShaderUniforms(LayaGL.instance, shaderUniform, shaderDatas, uploadUnTexture);
         }
         /**
          * @private
          */
         uploadRenderStateBlendDepth(shaderDatas) {
             var gl = LayaGL.instance;
             var renderState = this._shaderPass.renderState;
             var datas = shaderDatas.getData();
             var depthWrite = this._getRenderState(datas, Shader3D.RENDER_STATE_DEPTH_WRITE);
             var depthTest = this._getRenderState(datas, Shader3D.RENDER_STATE_DEPTH_TEST);
             var blend = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND);
             depthWrite == null && (depthWrite = renderState.depthWrite);
             depthTest == null && (depthTest = renderState.depthTest);
             blend == null && (blend = renderState.blend);
             WebGLContext.setDepthMask(gl, depthWrite);
             if (depthTest === RenderState.DEPTHTEST_OFF)
                 WebGLContext.setDepthTest(gl, false);
             else {
                 WebGLContext.setDepthTest(gl, true);
                 WebGLContext.setDepthFunc(gl, depthTest);
             }
             switch (blend) {
                 case RenderState.BLEND_DISABLE:
                     WebGLContext.setBlend(gl, false);
                     break;
                 case RenderState.BLEND_ENABLE_ALL:
                     WebGLContext.setBlend(gl, true);
                     var srcBlend = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_SRC);
                     srcBlend == null && (srcBlend = renderState.srcBlend);
                     var dstBlend = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_DST);
                     dstBlend == null && (dstBlend = renderState.dstBlend);
                     WebGLContext.setBlendFunc(gl, srcBlend, dstBlend);
                     break;
                 case RenderState.BLEND_ENABLE_SEPERATE:
                     WebGLContext.setBlend(gl, true);
                     var srcRGB = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_SRC_RGB);
                     srcRGB == null && (srcRGB = renderState.srcBlendRGB);
                     var dstRGB = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_DST_RGB);
                     dstRGB == null && (dstRGB = renderState.dstBlendRGB);
                     var srcAlpha = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_SRC_ALPHA);
                     srcAlpha == null && (srcAlpha = renderState.srcBlendAlpha);
                     var dstAlpha = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_DST_ALPHA);
                     dstAlpha == null && (dstAlpha = renderState.dstBlendAlpha);
                     WebGLContext.setBlendFuncSeperate(gl, srcRGB, dstRGB, srcAlpha, dstAlpha);
                     break;
             }
         }
         /**
          * @private
          */
         uploadRenderStateFrontFace(shaderDatas, isTarget, invertFront) {
             var gl = LayaGL.instance;
             var renderState = this._shaderPass.renderState;
             var datas = shaderDatas.getData();
             var cull = this._getRenderState(datas, Shader3D.RENDER_STATE_CULL);
             cull == null && (cull = renderState.cull);
             var forntFace;
             switch (cull) {
                 case RenderState.CULL_NONE:
                     WebGLContext.setCullFace(gl, false);
                     break;
                 case RenderState.CULL_FRONT:
                     WebGLContext.setCullFace(gl, true);
                     //forntFace = isTarget ? invertFront ? WebGLContext.CCW : WebGLContext.CW : invertFront ? WebGLContext.CW : WebGLContext.CCW;
                     if (isTarget) {
                         if (invertFront)
                             forntFace = WebGLContext.CCW;
                         else
                             forntFace = WebGLContext.CW;
                     }
                     else {
                         if (invertFront)
                             forntFace = WebGLContext.CW;
                         else
                             forntFace = WebGLContext.CCW;
                     }
                     WebGLContext.setFrontFace(gl, forntFace);
                     break;
                 case RenderState.CULL_BACK:
                     WebGLContext.setCullFace(gl, true);
                     if (isTarget) {
                         if (invertFront)
                             forntFace = WebGLContext.CW;
                         else
                             forntFace = WebGLContext.CCW;
                     }
                     else {
                         if (invertFront)
                             forntFace = WebGLContext.CCW;
                         else
                             forntFace = WebGLContext.CW;
                     }
                     WebGLContext.setFrontFace(gl, forntFace);
                     break;
             }
         }
         /**
          * @private
          */
         uploadCustomUniform(index, data) {
             Stat.shaderCall += LayaGLRunner.uploadCustomUniform(LayaGL.instance, this._customUniformParamsMap, index, data);
         }
         /**
          * @private
          * [NATIVE]
          */
         _uniformMatrix2fvForNative(one, value) {
             LayaGL.instance.uniformMatrix2fvEx(one.location, false, value);
             return 1;
         }
         /**
          * @private
          * [NATIVE]
          */
         _uniformMatrix3fvForNative(one, value) {
             LayaGL.instance.uniformMatrix3fvEx(one.location, false, value);
             return 1;
         }
         /**
          * @private
          * [NATIVE]
          */
         _uniformMatrix4fvForNative(one, m) {
             LayaGL.instance.uniformMatrix4fvEx(one.location, false, m);
             return 1;
         }
     }

     /**
      * <code>ShaderPass</code> 类用于实现ShaderPass。
      */
     class ShaderPass extends ShaderCompile {
         constructor(owner, vs, ps, stateMap) {
             super(vs, ps, null);
             /**@private */
             this._renderState = new RenderState();
             this._owner = owner;
             this._cacheSharders = [];
             this._publicValidDefine = 0;
             this._spriteValidDefine = 0;
             this._materialValidDefine = 0;
             var publicDefineMap = this._owner._publicDefinesMap;
             var spriteDefineMap = this._owner._spriteDefinesMap;
             var materialDefineMap = this._owner._materialDefinesMap;
             for (var k in this.defs) {
                 if (publicDefineMap[k] != null)
                     this._publicValidDefine |= publicDefineMap[k];
                 else if (spriteDefineMap[k] != null)
                     this._spriteValidDefine |= spriteDefineMap[k];
                 else if (materialDefineMap[k] != null)
                     this._materialValidDefine |= materialDefineMap[k];
             }
             this._stateMap = stateMap;
         }
         /**
          * 获取渲染状态。
          * @return 渲染状态。
          */
         get renderState() {
             return this._renderState;
         }
         /**
          * @private
          */
         _definesToNameDic(value, int2Name) {
             var o = {};
             var d = 1;
             for (var i = 0; i < 32; i++) {
                 d = 1 << i;
                 if (d > value)
                     break;
                 if (value & d) {
                     var name = int2Name[d];
                     o[name] = "";
                 }
             }
             return o;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _compileToTree(parent, lines, start, includefiles, defs) {
             var node, preNode;
             var text, name, fname;
             var ofs, words, noUseNode;
             var i, n, j;
             for (i = start; i < lines.length; i++) {
                 text = lines[i];
                 if (text.length < 1)
                     continue;
                 ofs = text.indexOf("//");
                 if (ofs === 0)
                     continue;
                 if (ofs >= 0)
                     text = text.substr(0, ofs);
                 node = noUseNode || new ShaderNode(includefiles);
                 noUseNode = null;
                 node.text = text;
                 if ((ofs = text.indexOf("#")) >= 0) {
                     name = "#";
                     for (j = ofs + 1, n = text.length; j < n; j++) {
                         var c = text.charAt(j);
                         if (c === ' ' || c === '\t' || c === '?')
                             break;
                         name += c;
                     }
                     node.name = name;
                     switch (name) {
                         case "#ifdef":
                         case "#ifndef":
                             node.setParent(parent);
                             parent = node;
                             if (defs) {
                                 words = text.substr(j).split(ShaderCompile._splitToWordExps3);
                                 for (j = 0; j < words.length; j++) {
                                     text = words[j];
                                     text.length && (defs[text] = true);
                                 }
                             }
                             continue;
                         case "#if":
                         case "#elif":
                             node.setParent(parent);
                             parent = node;
                             if (defs) {
                                 words = text.substr(j).split(ShaderCompile._splitToWordExps3);
                                 for (j = 0; j < words.length; j++) {
                                     text = words[j];
                                     text.length && text != "defined" && (defs[text] = true);
                                 }
                             }
                             continue;
                         case "#else":
                             parent = parent.parent;
                             preNode = parent.childs[parent.childs.length - 1];
                             node.setParent(parent);
                             parent = node;
                             continue;
                         case "#endif":
                             parent = parent.parent;
                             preNode = parent.childs[parent.childs.length - 1];
                             node.setParent(parent);
                             continue;
                         case "#include": //这里有问题,主要是空格
                             words = ShaderCompile.splitToWords(text, null);
                             var inlcudeFile = ShaderCompile.includes[words[1]];
                             if (!inlcudeFile) {
                                 throw "ShaderCompile error no this include file:" + words[1];
                             }
                             if ((ofs = words[0].indexOf("?")) < 0) {
                                 node.setParent(parent);
                                 text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
                                 this._compileToTree(node, text.split('\n'), 0, includefiles, defs);
                                 node.text = "";
                                 continue;
                             }
                             node.setCondition(words[0].substr(ofs + 1), ShaderCompile.IFDEF_YES);
                             node.text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
                             break;
                         case "#import":
                             words = ShaderCompile.splitToWords(text, null);
                             fname = words[1];
                             includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });
                             continue;
                     }
                 }
                 else {
                     preNode = parent.childs[parent.childs.length - 1];
                     if (preNode && !preNode.name) {
                         includefiles.length > 0 && ShaderCompile.splitToWords(text, preNode);
                         noUseNode = node;
                         preNode.text += "\n" + text;
                         continue;
                     }
                     includefiles.length > 0 && ShaderCompile.splitToWords(text, node);
                 }
                 node.setParent(parent);
             }
         }
         /**
          * @private
          */
         withCompile(publicDefine, spriteDefine, materialDefine) {
             publicDefine &= this._publicValidDefine;
             spriteDefine &= this._spriteValidDefine;
             materialDefine &= this._materialValidDefine;
             var shader;
             var spriteDefShaders, materialDefShaders;
             spriteDefShaders = this._cacheSharders[publicDefine];
             if (spriteDefShaders) {
                 materialDefShaders = spriteDefShaders[spriteDefine];
                 if (materialDefShaders) {
                     shader = materialDefShaders[materialDefine];
                     if (shader)
                         return shader;
                 }
                 else {
                     materialDefShaders = spriteDefShaders[spriteDefine] = [];
                 }
             }
             else {
                 spriteDefShaders = this._cacheSharders[publicDefine] = [];
                 materialDefShaders = spriteDefShaders[spriteDefine] = [];
             }
             var publicDefGroup = this._definesToNameDic(publicDefine, this._owner._publicDefines);
             var spriteDefGroup = this._definesToNameDic(spriteDefine, this._owner._spriteDefines);
             var materialDefGroup = this._definesToNameDic(materialDefine, this._owner._materialDefines);
             var key;
             if (Shader3D.debugMode) {
                 var publicDefGroupStr = "";
                 for (key in publicDefGroup)
                     publicDefGroupStr += key + " ";
                 var spriteDefGroupStr = "";
                 for (key in spriteDefGroup)
                     spriteDefGroupStr += key + " ";
                 var materialDefGroupStr = "";
                 for (key in materialDefGroup)
                     materialDefGroupStr += key + " ";
                 if (!WebGL.shaderHighPrecision)
                     publicDefine += Shader3D.SHADERDEFINE_HIGHPRECISION; //输出宏定义要保持设备无关性
                 console.log("%cShader3DDebugMode---(Name:" + this._owner._owner._name + " PassIndex:" + this._owner._passes.indexOf(this) + " PublicDefine:" + publicDefine + " SpriteDefine:" + spriteDefine + " MaterialDefine:" + materialDefine + " PublicDefineGroup:" + publicDefGroupStr + " SpriteDefineGroup:" + spriteDefGroupStr + "MaterialDefineGroup: " + materialDefGroupStr + ")---ShaderCompile3DDebugMode", "color:green");
             }
             var defMap = {};
             var defineStr = "";
             if (publicDefGroup) {
                 for (key in publicDefGroup) {
                     defineStr += "#define " + key + "\n";
                     defMap[key] = true;
                 }
             }
             if (spriteDefGroup) {
                 for (key in spriteDefGroup) {
                     defineStr += "#define " + key + "\n";
                     defMap[key] = true;
                 }
             }
             if (materialDefGroup) {
                 for (key in materialDefGroup) {
                     defineStr += "#define " + key + "\n";
                     defMap[key] = true;
                 }
             }
             var vs = this._VS.toscript(defMap, []);
             var vsVersion = '';
             if (vs[0].indexOf('#version') == 0) {
                 vsVersion = vs[0] + '\n';
                 vs.shift();
             }
             var ps = this._PS.toscript(defMap, []);
             var psVersion = '';
             if (ps[0].indexOf('#version') == 0) {
                 psVersion = ps[0] + '\n';
                 ps.shift();
             }
             shader = new ShaderInstance(vsVersion + defineStr + vs.join('\n'), psVersion + defineStr + ps.join('\n'), this._owner._attributeMap || this._owner._owner._attributeMap, this._owner._uniformMap || this._owner._owner._uniformMap, this);
             materialDefShaders[materialDefine] = shader;
             return shader;
         }
     }

     /**
      * <code>SubShader</code> 类用于创建SubShader。
      */
     class SubShader {
         /**
          * 创建一个 <code>SubShader</code> 实例。
          * @param	attributeMap  顶点属性表。
          * @param	uniformMap  uniform属性表。
          * @param	spriteDefines  spriteDefines 精灵宏定义。
          * @param	materialDefines  materialDefines 材质宏定义。
          */
         constructor(attributeMap, uniformMap, spriteDefines = null, materialDefines = null) {
             /**@private */
             this._flags = {};
             /**@private */
             this._passes = [];
             this._publicDefines = [];
             this._publicDefinesMap = {};
             this._spriteDefines = [];
             this._spriteDefinesMap = {};
             this._materialDefines = [];
             this._materialDefinesMap = {};
             this._addDefines(this._publicDefines, this._publicDefinesMap, Shader3D._globleDefines);
             (spriteDefines) && (this._addDefines(this._spriteDefines, this._spriteDefinesMap, spriteDefines.defines));
             (materialDefines) && (this._addDefines(this._materialDefines, this._materialDefinesMap, materialDefines.defines));
             this._attributeMap = attributeMap;
             this._uniformMap = uniformMap;
         }
         /**
          * @private
          */
         _addDefines(defines, definesMap, supportDefines) {
             for (var k in supportDefines) {
                 var name = supportDefines[k];
                 var i = parseInt(k);
                 defines[i] = name;
                 definesMap[name] = i;
             }
         }
         /**
          * 通过名称获取宏定义值。
          * @param	name 名称。
          * @return 宏定义值。
          */
         getMaterialDefineByName(name) {
             return this._materialDefinesMap[name];
         }
         /**
          *添加标记。
          * @param key 标记键。
          * @param value 标记值。
          */
         setFlag(key, value) {
             if (value)
                 this._flags[key] = value;
             else
                 delete this._flags[key];
         }
         /**
          * 获取标记值。
          * @return key 标记键。
          */
         getFlag(key) {
             return this._flags[key];
         }
         /**
          * @private
          */
         addShaderPass(vs, ps, stateMap = null) {
             var shaderPass = new ShaderPass(this, vs, ps, stateMap);
             this._passes.push(shaderPass);
             return shaderPass;
         }
     }

     var BlitScreenPS = "#ifdef FSHIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTex;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n\r\n";

     var BlitScreenVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}";

     var EffectPS = "#ifdef FSHIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  2.0 * u_AlbedoColor;\r\n\t#ifdef COLOR\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t#ifdef MAINTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\n";

     var EffectVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec4 a_Color;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\t\t\r\n\tv_Color = a_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}";

     var extendTerrainPS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_Normal;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\n#include \"ShadowHelper.glsl\"\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\nvarying float v_posViewZ;\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\nuniform sampler2D u_SplatAlphaTexture;\r\n\r\nuniform sampler2D u_DiffuseTexture1;\r\nuniform sampler2D u_DiffuseTexture2;\r\nuniform sampler2D u_DiffuseTexture3;\r\nuniform sampler2D u_DiffuseTexture4;\r\nuniform sampler2D u_DiffuseTexture5;\r\n\r\nuniform vec4 u_DiffuseScaleOffset1;\r\nuniform vec4 u_DiffuseScaleOffset2;\r\nuniform vec4 u_DiffuseScaleOffset3;\r\nuniform vec4 u_DiffuseScaleOffset4;\r\nuniform vec4 u_DiffuseScaleOffset5;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform sampler2D u_LightMap;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 splatAlpha = vec4(1.0);\r\n\t#ifdef ExtendTerrain_DETAIL_NUM1\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM2\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM3\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM4\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM5\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\r\n\t#endif\r\n\t\tgl_FragColor.w = splatAlpha.a;\r\n\t\t\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n    vec3 normal = v_Normal;\r\n\tvec3 dif, spe;\r\n#endif\r\n\r\nvec3 diffuse = vec3(0.0);\r\nvec3 specular= vec3(0.0);\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tvec3 toEye;\r\n\t#ifdef FOG\r\n\t\ttoEye=u_CameraPos-v_PositionWorld;\r\n\t\tfloat toEyeLength=length(toEye);\r\n\t\ttoEye/=toEyeLength;\r\n\t#else\r\n\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tLayaAirBlinnPhongDiectionLight(vec3(0.0), 1.0, normal, vec3(1.0), toEye,u_DirectionLight, dif, spe);\r\n\tdiffuse+=dif;\r\n\tspecular+=spe;\r\n#endif\r\n \r\n#ifdef POINTLIGHT\r\n\tLayaAirBlinnPhongPointLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_PointLight, dif, spe);\r\n\tdiffuse+=dif;\r\n\tspecular+=spe;\r\n#endif\r\n\r\n#ifdef SPOTLIGHT\r\n\tLayaAirBlinnPhongSpotLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_SpotLight, dif, spe);\r\n\tdiffuse+=dif;\r\n\tspecular+=spe;\r\n#endif\r\n\r\nvec3 globalDiffuse = u_AmbientColor;\r\n#ifdef LIGHTMAP\r\n\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tfloat shadowValue = 1.0;\r\n\t#ifdef SHADOWMAP_PSSM3\r\n\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM2\r\n\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif \r\n\t#ifdef SHADOWMAP_PSSM1\r\n\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t#endif\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\r\n#else\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef RECEIVESHADOW\r\n\t\tgl_FragColor.rgb += specular * shadowValue;\r\n\t#else\r\n\t\tgl_FragColor.rgb += specular;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n#endif\r\n}\r\n\r\n\r\n\r\n\r\n\r\n";

     var extendTerrainVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec2 a_Texcoord0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\tuniform mat4 u_WorldMat;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tvarying float v_posViewZ;\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n  \r\n\tv_Texcoord0 = a_Texcoord0;\r\n  \r\n\t#ifdef LIGHTMAP\r\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\r\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\r\n\t#endif\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_Normal = a_Normal;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}";

     var LightingGLSL = "\r\nstruct DirectionLight {\r\n\tvec3 Color;\r\n\tvec3 Direction;\r\n};\r\n\r\nstruct PointLight {\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tfloat Range;\r\n};\r\n\r\nstruct SpotLight {\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tvec3 Direction;\r\n\tfloat Spot;\r\n\tfloat Range;\r\n};\r\n\r\n// Laya中使用衰减纹理\r\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\r\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\r\n\treturn attenuation * attenuation;\r\n}\r\n\r\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\r\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat attenuationFactor = 30.0;\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\r\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\r\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\r\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\r\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\r\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\r\n\tattenuation /= 1.0 - attenuationFactor;\r\n\treturn attenuation;\r\n}\r\n\r\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tmediump vec3 h = normalize(viewDir-lightVec);\r\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\r\n\tfloat nh = max (0.0, dot (h,normal));\r\n\tdiffuseColor=lightColor * ln;\r\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\r\n}\r\n\r\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec=normalize(light.Direction);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec,diffuseColor,specularColor);\r\n}\r\n\r\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.Position;\r\n\t//if( length(lightVec) > light.Range )\r\n\t//\treturn;\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec/length(lightVec),diffuseColor,specularColor);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range);\r\n\tdiffuseColor *= attenuate;\r\n\tspecularColor*= attenuate;\r\n}\r\n\r\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.Position;\r\n\t//if( length(lightVec) > light.Range)\r\n\t//\treturn;\r\n\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,normalLightVec,diffuseColor,specularColor);\r\n\tvec2 cosAngles=cos(vec2(light.Spot,light.Spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.Direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range)*dl;\r\n\tdiffuseColor *=attenuate;\r\n\tspecularColor *=attenuate;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\r\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\r\n\r\n\t// Build orthonormal basis.\r\n\tvec3 N = normalize(unitNormal);\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN*normalT;\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tvec3 N = normalize(unitNormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 DecodeLightmap(vec4 color) {\r\n\treturn color.rgb*color.a*5.0;\r\n}\r\n\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\nmat3 inverse(mat3 m) {\r\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n  float b01 = a22 * a11 - a12 * a21;\r\n  float b11 = -a22 * a10 + a12 * a20;\r\n  float b21 = a21 * a10 - a11 * a20;\r\n\r\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\r\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\r\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\n\r\n";

     var linePS = "#ifdef HIGHPRECISION\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nuniform vec4 u_Color;\r\n\r\nvoid main()\r\n{\r\n  gl_FragColor = v_Color * u_Color; \r\n}\r\n\r\n";

     var lineVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec4 u_Color;\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n\tv_Color=a_Color*u_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}";

     var MeshBlinnPhongPS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\nuniform vec4 u_DiffuseColor;\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n\tuniform sampler2D u_DiffuseTexture;\r\n#endif\r\n\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tuniform vec3 u_MaterialSpecular;\r\n\tuniform float u_Shininess;\r\n\t#ifdef SPECULARMAP \r\n\t\tuniform sampler2D u_SpecularTexture;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\tuniform sampler2D u_NormalTexture;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#include \"ShadowHelper.glsl\"\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\t//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\nvoid main_normal()\r\n{\r\n\tvec3 globalDiffuse=u_AmbientColor;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 normal;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\t\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\r\n\t\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\r\n\t\t#else\r\n\t\t\tnormal = normalize(v_Normal);\r\n\t\t#endif\r\n\t\tvec3 viewDir= normalize(v_ViewDir);\r\n\t#endif\r\n\t\r\n\tvec4 mainColor=u_DiffuseColor;\r\n\t#ifdef DIFFUSEMAP\r\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\r\n\t\tmainColor=mainColor*difTexColor;\r\n\t#endif \r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tmainColor=mainColor*v_Color;\r\n\t#endif \r\n    \r\n\t#ifdef ALPHATEST\r\n\t\tif(mainColor.a<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\t\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 dif,spe;\r\n\t\t#ifdef SPECULARMAP\r\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\r\n\t\t#else\r\n\t\t\t#ifdef DIFFUSEMAP\r\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\r\n\t\t\t#else\r\n\t\t\t\tvec3 gloss=vec3(1.0);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t\r\n\t#ifdef DIRECTIONLIGHT\r\n\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\r\n\t\tdiffuse+=dif;\r\n\t\tspecular+=spe;\r\n\t#endif\r\n \r\n\t#ifdef POINTLIGHT\r\n\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\r\n\t\tdiffuse+=dif;\r\n\t\tspecular+=spe;\r\n\t#endif\r\n\r\n\t#ifdef SPOTLIGHT\r\n\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\r\n\t\tdiffuse+=dif;\r\n\t\tspecular+=spe;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3(u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2(u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1(u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse*shadowValue),mainColor.a);\r\n\t#else\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t#ifdef RECEIVESHADOW\r\n\t\t\tgl_FragColor.rgb+=specular*shadowValue;\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb+=specular;\r\n\t\t#endif\r\n\t#endif\r\n\t  \r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}\r\n\r\n";

     var MeshBlinnPhongVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tattribute vec4 a_Color;\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal; \r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t#ifdef GPU_INSTANCE\r\n\t\tattribute mat4 a_WorldMat;\r\n\t#else\r\n\t\tuniform mat4 u_WorldMat;\r\n\t#endif\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n  varying vec4 v_lightMVPPos;\r\n  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tmat4 worldMat;\r\n\t\t#ifdef GPU_INSTANCE\r\n\t\t\tworldMat = a_WorldMat;\r\n\t\t#else\r\n\t\t\tworldMat = u_WorldMat;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tmat3 worldInvMat;\r\n\t\t#ifdef BONE\r\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\r\n\t\t#else\r\n\t\t\tworldInvMat=inverse(mat3(worldMat));\r\n\t\t#endif  \r\n\t\tv_Normal=a_Normal*worldInvMat;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\r\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\t#ifdef SCALEOFFSETLIGHTINGMAPUV\r\n\t\t\t#ifdef UV1\r\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t\t#else\r\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t\t#endif \r\n\t\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\r\n\t\t#else\r\n\t\t\t#ifdef UV1\r\n\t\t\t\tv_LightMapUV=a_Texcoord1;\r\n\t\t\t#else\r\n\t\t\t\tv_LightMapUV=a_Texcoord0;\r\n\t\t\t#endif \r\n\t\t#endif \r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color=a_Color;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}";

     var ParticleShuriKenPS = "#ifdef HIGHPRECISION\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\nvarying float v_Discard;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n\t//varying vec3 v_PositionWorld;\r\n\t//uniform vec3 u_CameraPos;\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_MeshColor;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\t\t\r\n\t#ifdef DIFFUSEMAP\r\n\t\tif(v_Discard!=0.0)\r\n\t\t\tdiscard;\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=v_Color;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\t//vec3 toEye=u_CameraPos-v_PositionWorld;\r\n\t\t//float toEyeLength=length(toEye);\r\n\t\t//toEye/=toEyeLength;\r\n\t\t\r\n\t\t//float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\t//gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\t//gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}";

     var ParticleShuriKenVS = "#include \"Lighting.glsl\";\r\n\r\n#ifdef HIGHPRECISION\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec4 a_CornerTextureCoordinate;\r\n#endif\r\n#ifdef RENDERMODE_MESH\r\n\tattribute vec3 a_MeshPosition;\r\n\tattribute vec4 a_MeshColor;\r\n\tattribute vec2 a_MeshTextureCoordinate;\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nattribute vec4 a_ShapePositionStartLifeTime;\r\nattribute vec4 a_DirectionTime;\r\nattribute vec4 a_StartColor;\r\nattribute vec3 a_StartSize;\r\nattribute vec3 a_StartRotation0;\r\nattribute float a_StartSpeed;\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n  attribute vec4 a_Random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  attribute vec4 a_Random1;\r\n#endif\r\nattribute vec3 a_SimulationWorldPostion;\r\nattribute vec4 a_SimulationWorldRotation;\r\n\r\nvarying float v_Discard;\r\nvarying vec4 v_Color;\r\n#ifdef DIFFUSEMAP\r\n\tvarying vec2 v_TextureCoordinate;\r\n#endif\r\n\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\tuniform vec3 u_CameraPos;\r\n#endif\r\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\r\nuniform vec3 u_CameraUp;\r\n\r\nuniform  float u_StretchedBillboardLengthScale;\r\nuniform  float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  int  u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\n  uniform  vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n  uniform  vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\r\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\r\n#endif\r\n\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  float u_ROLAngularVelocityConst;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  float u_ROLAngularVelocityConstMax;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\r\n  #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n  #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\n  uniform  float u_TSACycles;\r\n  uniform  vec2 u_TSASubUVLength;\r\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\r\n#endif\r\n\r\n#ifdef FOG\r\n\t//varying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\r\n{\r\n\tfloat halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n\tfloat halfYaw = rot.y * 0.5;\r\n\r\n\tfloat sinRoll = sin(halfRoll);\r\n\tfloat cosRoll = cos(halfRoll);\r\n\tfloat sinPitch = sin(halfPitch);\r\n\tfloat cosPitch = cos(halfPitch);\r\n\tfloat sinYaw = sin(halfYaw);\r\n\tfloat cosYaw = cos(halfYaw);\r\n\r\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\n//假定axis已经归一化\r\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\r\n{\r\n\tfloat halfAngle = angle * 0.5;\r\n\tfloat sin = sin(halfAngle);\r\n\t\r\n\tfloat quaX = axis.x * sin;\r\n\tfloat quaY = axis.y * sin;\r\n\tfloat quaZ = axis.z * sin;\r\n\tfloat quaW = cos(halfAngle);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \r\n{\r\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n \r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat curValue;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn curValue;\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat totalValue=0.0;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\tfloat lastValue=lastGradientNumber.y;\r\n\t\t\r\n\t\tif(key>=normalizedAge){\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n\treturn totalValue;\r\n}\r\n#endif\r\n\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\r\n{\r\n\tvec4 overTimeColor;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientAlpha=gradientAlphas[i];\r\n\t\tfloat alphaKey=gradientAlpha.x;\r\n\t\tif(alphaKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\r\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\r\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\r\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec4 gradientColor=gradientColors[i];\r\n\t\tfloat colorKey=gradientColor.x;\r\n\t\tif(colorKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\r\n\t\t\tfloat lastColorKey=lastGradientColor.x;\r\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\r\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn overTimeColor;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\r\n{\r\n\tfloat overTimeFrame;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientFrame=gradientFrames[i];\r\n\t\tfloat key=gradientFrame.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\r\n\t\t\tfloat lastKey=lastGradientFrame.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn floor(overTimeFrame);\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n  vec3 outLifeVelocity;\r\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t outLifeVelocity=u_VOLVelocityConst; \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMECURVE\r\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\r\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\r\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n  #endif\r\n\t\t\t\t\t\r\n  return outLifeVelocity;\r\n} \r\n#endif\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\r\n{\r\n   vec3 startPosition;\r\n   vec3 lifePosition;\r\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMECURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n\t#endif\r\n\t\r\n\tvec3 finalPosition;\r\n\tif(u_VOLSpaceType==0){\r\n\t  if(u_ScalingMode!=2)\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\r\n\t  else\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\r\n\t}\r\n\telse{\r\n\t  if(u_ScalingMode!=2)\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\r\n\t  else\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\r\n\t}\r\n  #else\r\n\t startPosition=startVelocity*age;\r\n\t vec3 finalPosition;\r\n\t if(u_ScalingMode!=2)\r\n\t\t\tfinalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\r\n\t else\r\n\t   \tfinalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\r\n  #endif\r\n  \r\n  if(u_SimulationSpace==0)\r\n    finalPosition=finalPosition+a_SimulationWorldPostion;\r\n  else if(u_SimulationSpace==1) \r\n    finalPosition=finalPosition+u_WorldPosition;\r\n  \r\n  finalPosition+=0.5*gravityVelocity*age;\r\n \r\n  return  finalPosition;\r\n}\r\n\r\n\r\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\r\n{\r\n\t#ifdef COLOROVERLIFETIME\r\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\r\n\t#endif\r\n\t\r\n\t#ifdef RANDOMCOLOROVERLIFETIME\r\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\r\n\t#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\r\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\r\n{ \r\n\t#ifdef TEXTURESHEETANIMATIONCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\r\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\treturn uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\r\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\r\n\tvec3 lifeVelocity;\r\n\tif(normalizedAge<1.0){ \r\n\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\r\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\r\n\t#endif \r\n\tvec3 gravityVelocity=u_Gravity*age;\r\n\t\r\n\tvec4 worldRotation;\r\n\tif(u_SimulationSpace==0)\r\n\t\tworldRotation=a_SimulationWorldRotation;\r\n\telse\r\n\t\tworldRotation=u_WorldRotation;\r\n\t\r\n\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\r\n   \r\n   \r\n   #ifdef SPHERHBILLBOARD\r\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n        vec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\r\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n        vec3 upVector = normalize(cross(sideVector,u_CameraDirection));\r\n\t    corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\r\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\tfloat c = cos(rot);\r\n\t\t\t\tfloat s = sin(rot);\r\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t}\r\n\t\t#else\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tfloat c = cos(a_StartRotation0.x);\r\n\t\t\t\tfloat s = sin(a_StartRotation0.x);\r\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t}\r\n\t\t#endif\r\n   #endif\r\n   \r\n   #ifdef STRETCHEDBILLBOARD\r\n\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\tvec3 velocity;\r\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t    if(u_VOLSpaceType==0)\r\n\t\t  velocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\r\n\t    else\r\n\t\t  velocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\r\n    #else\r\n\t    velocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\r\n    #endif\t\r\n\t\tvec3 cameraUpVector = normalize(velocity);\r\n\t\tvec3 direction = normalize(center-u_CameraPos);\r\n        vec3 sideVector = normalize(cross(direction,normalize(velocity)));\r\n\t\t\r\n\t\tsideVector=u_SizeScale.xzy*sideVector;\r\n\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\r\n\t\t\r\n\t    vec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\r\n\t    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\r\n\t    corner=rotaionZHalfPI*corner;\r\n\t    corner.y=corner.y-abs(corner.y);\r\n\t\t\r\n\t    float speed=length(velocity);//TODO:\r\n\t    center +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\r\n   #endif\r\n   \r\n   #ifdef HORIZONTALBILLBOARD\r\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n        const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\r\n\t    const vec3 sideVector = vec3(-1.0,0.0,0.0);\r\n\t\t\r\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n        float c = cos(rot);\r\n        float s = sin(rot);\r\n        mat2 rotation= mat2(c, -s, s, c);\r\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n   #endif\r\n   \r\n   #ifdef VERTICALBILLBOARD\r\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n        const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\r\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\r\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n        float c = cos(rot);\r\n        float s = sin(rot);\r\n        mat2 rotation= mat2(c, -s, s, c);\r\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n   #endif\r\n   \r\n   #ifdef RENDERMODE_MESH\r\n\t    vec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\r\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\r\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\r\n\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\r\n\t\t\t\t#endif\t\t\r\n\t\t\t}\r\n\t\t#else\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\r\n\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\r\n\t\t\t\t\t#else\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\r\n\t\t\t\t\t#endif\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t#endif\r\n\t\tv_MeshColor=a_MeshColor;\r\n   #endif\r\n   \r\n    gl_Position=u_Projection*u_View*vec4(center,1.0);\r\n    v_Color = computeParticleColor(a_StartColor, normalizedAge);\r\n\t#ifdef DIFFUSEMAP\r\n\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef RENDERMODE_MESH\r\n\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y)*u_TilingOffset.xy+vec2(u_TilingOffset.z,-u_TilingOffset.w);//需要特殊处理\r\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y);//需要特殊处理\r\n\t\t#endif\r\n\t#endif\r\n    v_Discard=0.0;\r\n\t  \r\n\t#ifdef FOG\r\n\t\t//v_PositionWorld=center;\r\n\t#endif\r\n   }\r\n   else\r\n\t{\r\n\t\tv_Discard=1.0;\r\n\t}\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\n";

     var BRDFGLSL = "struct LayaGI\r\n{\r\n\tvec3 diffuse;\r\n\tvec3 specular;\r\n};\r\n\r\nvec4 LayaAirBRDF(in vec3 diffuseColor, in vec3 specularColor, in float oneMinusReflectivity, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\r\n{\r\n\tfloat perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\r\n\tvec3 halfDir = SafeNormalize(viewDir - lightDir);\r\n\t\r\n\tfloat nv = abs(dot(normal, viewDir));\r\n\t\r\n\tfloat nl = clamp(dot(normal,   -lightDir),  0.0, 1.0);\r\n\tfloat nh = clamp(dot(normal,     halfDir),  0.0, 1.0);\r\n\tfloat lv = clamp(dot(lightDir,   viewDir),  0.0, 1.0);\r\n\tfloat lh = clamp(dot(lightDir,  -halfDir),  0.0, 1.0);\r\n\t\r\n\tfloat diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\r\n\t\r\n\tfloat roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\t\r\n\t//#if UNITY_BRDF_GGX\r\n\tfloat V = SmithJointGGXVisibilityTerm(nl, nv, roughness);\r\n\tfloat D = GGXTerm(nh, roughness);\r\n\t\r\n\tfloat specularTerm = V * D * PI;\r\n\t\r\n\tspecularTerm = sqrt(max(0.0001, specularTerm));\r\n\tspecularTerm = max(0.0, specularTerm * nl);\r\n\t\r\n\tfloat surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\r\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity), 0.0, 1.0);\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = diffuseColor * (gi.diffuse + lightColor * diffuseTerm) \r\n\t\t\t  + specularTerm * lightColor * FresnelTerm (specularColor, lh)\r\n\t\t\t  + surfaceReduction * gi.specular * FresnelLerp(specularColor, vec3(grazingTerm), nv);\r\n\t\r\n\treturn color;\r\n}";

     var PBRSpecularLightingGLSL = "#include \"PBRUtils.glsl\"\r\n#include \"BRDF.glsl\"\r\n\r\nvec4 PBRSpecularLight(in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\r\n{\r\n\tfloat oneMinusReflectivity;\r\n\tvec3 diffuseColor;\r\n\tfloat alpha;\r\n\t\r\n\tdiffuseColor = EnergyConservationBetweenDiffuseAndSpecular (albedoColor.rgb, specularColor, oneMinusReflectivity);\r\n\t\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\t\r\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n}\r\n\r\nvec4 PBRSpecularDiectionLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\r\n{\r\n\tvec3 lightVec = normalize(light.Direction);\r\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi);\r\n}\r\n\r\nvec4 PBRSpecularPointLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\r\n\tfloat distance = dot(lightCoord, lightCoord);\r\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\r\n\tvec3 lightVec = normalize(pos - light.Position);\r\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n\r\nvec4 PBRSpecularSpotLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightVec =  pos - light.Position;\r\n\tvec3 normalLightVec = normalize(lightVec);\r\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\r\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\r\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\r\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n\r\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n//{\r\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\r\n//\t\r\n//\tfloat distance = dot(lightCoord, lightCoord);\r\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\r\n//\tvec3 lightVec = normalize(pos - light.Position);\r\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n//}\r\n\r\nvec4 SpecularGloss(float albedoTextureAlpha, in vec2 uv0)\r\n{\r\n    vec4 sg;\r\n\t\r\n\t#ifdef SPECULARTEXTURE\r\n\t\tvec4 specularTextureColor = texture2D(u_SpecularTexture, uv0);\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.rgb = specularTextureColor.rgb;\r\n\t\t\tsg.a = albedoTextureAlpha;\r\n\t\t#else\r\n\t\t\tsg = specularTextureColor;\r\n\t\t#endif\r\n\t\tsg.a *= u_smoothnessScale;\r\n\t#else\r\n\t\tsg.rgb = u_SpecularColor.rgb;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.a = albedoTextureAlpha * u_smoothnessScale;\r\n\t\t#else\r\n\t\t\tsg.a = u_smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n    return sg;\r\n}\r\n\r\n";

     var PBRStandardLightingGLSL = "#include \"PBRUtils.glsl\"\r\n#include \"BRDF.glsl\"\r\n\r\nvec4 PBRStandardLight(in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\r\n{\r\n\tfloat oneMinusReflectivity;\r\n\tvec3 diffuseColor;\r\n\tvec3 specularColor;\r\n\tfloat alpha;\r\n\t\r\n\tdiffuseColor = DiffuseAndSpecularFromMetallic (albedoColor.rgb, metallic, specularColor, oneMinusReflectivity);\r\n\t\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\t\r\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n}\r\n\r\nvec4 PBRStandardDiectionLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\r\n{\r\n\tvec3 lightVec = normalize(light.Direction);\r\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi);\r\n}\r\n\r\nvec4 PBRStandardPointLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\r\n\tfloat distance = dot(lightCoord, lightCoord);\r\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\r\n\tvec3 lightVec = normalize(pos - light.Position);\r\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n\r\nvec4 PBRStandardSpotLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightVec =  pos - light.Position;\r\n\tvec3 normalLightVec = normalize(lightVec);\r\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\r\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\r\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\r\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n\r\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n//{\r\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\r\n//\t\r\n//\tfloat distance = dot(lightCoord, lightCoord);\r\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\r\n//\tvec3 lightVec = normalize(pos - light.Position);\r\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n//}\r\n\r\nvec2 MetallicGloss(in float albedoTextureAlpha, in vec2 uv0)\r\n{\r\n\tvec2 mg;\r\n\t\r\n\t#ifdef METALLICGLOSSTEXTURE\r\n\t\tvec4 metallicGlossTextureColor = texture2D(u_MetallicGlossTexture, uv0);\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tmg.r = metallicGlossTextureColor.r;\r\n\t\t\tmg.g = albedoTextureAlpha;\r\n\t\t#else\r\n\t\t    mg = metallicGlossTextureColor.ra;\r\n\t\t#endif\r\n\t\tmg.g *= u_smoothnessScale;\r\n\t#else\r\n\t\tmg.r = u_metallic;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tmg.g = albedoTextureAlpha * u_smoothnessScale;\r\n\t\t#else\r\n\t\t\tmg.g = u_smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\treturn mg;\r\n}\r\n\r\n";

     var PBRUtilsGLSL = "struct DirectionLight\r\n{\r\n\tvec3 Color;\r\n\tvec3 Direction;\r\n};\r\n\r\nstruct PointLight\r\n{\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tfloat Range;\r\n};\r\n\r\nstruct SpotLight\r\n{\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tvec3 Direction;\r\n\tfloat SpotAngle;\r\n\tfloat Range;\r\n};\r\n\r\nvec3 UnpackScaleNormal(in vec2 uv0)\r\n{\r\n\t#ifdef NORMALTEXTURE\r\n\t\tvec3 normalT;\r\n\t\tvec4 normalMapSample = texture2D(u_NormalTexture, uv0);\r\n\t\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\t\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\t\tnormalT.xy *= u_normalScale;\r\n\t\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\t\t\r\n\t\tvec3 T = normalize(v_Tangent);\r\n\t\tvec3 B = normalize(v_Binormal);\r\n\t\tvec3 N = normalize(v_Normal);\r\n\t\tmat3 TBN = mat3(T, B, N);\r\n\t\t\r\n\t\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\t\treturn bumpedNormal;\r\n\t#else\r\n\t\treturn normalize(v_Normal);\r\n\t#endif\r\n}\r\n\r\nvec4 DielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\r\n\r\nfloat PI = 3.14159265359;\r\n\r\nvec3 FresnelTerm (in vec3 F0, in float cosA)\r\n{\r\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosA, 5.0);\r\n}\r\n\r\nvec3 FresnelLerp (in vec3 F0, in vec3 F90, float cosA)\r\n{\r\n    float t = pow(1.0 - cosA, 5.0);\r\n    return mix(F0, F90, t);\r\n}\r\n\r\nfloat PerceptualRoughnessToRoughness(in float perceptualRoughness)\r\n{\r\n\treturn perceptualRoughness * perceptualRoughness;\r\n}\r\n\r\nfloat PerceptualRoughnessToSpecularPower(in float perceptualRoughness)\r\n{\r\n\tfloat m = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat sq = max(0.0001, m * m);\r\n\tfloat n = (2.0 / sq) - 2.0;\r\n\tn = max(n, 0.0001);\r\n\treturn n;\r\n}\r\n\r\nfloat RoughnessToPerceptualRoughness(in float roughness)\r\n{\r\n\treturn sqrt(roughness);\r\n}\r\n\r\nfloat SmoothnessToRoughness(in float smoothness)\r\n{\r\n\treturn (1.0 - smoothness) * (1.0 - smoothness);\r\n}\r\n\r\nfloat SmoothnessToPerceptualRoughness(in float smoothness)\r\n{\r\n\treturn (1.0 - smoothness);\r\n}\r\n\r\nvec3 SafeNormalize(in vec3 inVec)\r\n{\r\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\r\n\treturn inVec * (1.0 / sqrt(dp3));\r\n}\r\n\r\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float perceptualRoughness)\r\n{\r\n\tfloat fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\r\n\tfloat lightScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL,5.0));\r\n\tfloat viewScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV,5.0));\r\n\r\n\treturn lightScatter * viewScatter;\r\n}\r\n\r\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\r\n{\r\n\tfloat a = roughness;\r\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\r\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\r\n\r\n\treturn 0.5 / (lambdaV + lambdaL + 0.00001);\r\n}\r\n\r\nfloat GGXTerm (float NdotH, float roughness)\r\n{\r\n\tfloat a2 = roughness * roughness;\r\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0;\r\n\treturn 0.31830988618 * a2 / (d * d + 0.0000001);\r\n}\r\n\r\nfloat OneMinusReflectivityFromMetallic(in float metallic)\r\n{\r\n\tfloat oneMinusDielectricSpec = DielectricSpecularColor.a;\r\n\treturn oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\r\n}\r\n\r\nfloat SpecularStrength(vec3 specular)\r\n{\r\n    //(SHADER_TARGET < 30)return specular.r; \r\n    return max (max (specular.r, specular.g), specular.b);\r\n}\r\n\r\nvec3 DiffuseAndSpecularFromMetallic(in vec3 diffuseColor, in float metallic, out vec3 specularColor, out float oneMinusReflectivity)\r\n{\r\n\tspecularColor = mix(DielectricSpecularColor.rgb, diffuseColor, metallic);\r\n\toneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\r\n\treturn diffuseColor * oneMinusReflectivity;\r\n}\r\n\r\nvec3 EnergyConservationBetweenDiffuseAndSpecular(in vec3 diffuseColor, in vec3 specularColor, out float oneMinusReflectivity)\r\n{\r\n\toneMinusReflectivity = 1.0 - SpecularStrength(specularColor);\r\n\treturn diffuseColor * oneMinusReflectivity;\r\n}\r\n\r\nvec4 Occlusion(in vec2 uv0){\r\n\t#ifdef OCCLUSIONTEXTURE\r\n\t\tvec4 occlusionTextureColor = texture2D(u_OcclusionTexture, uv0);\r\n\t\tfloat occ = occlusionTextureColor.g;\r\n\t\tfloat oneMinusT = 1.0 - u_occlusionStrength;\r\n\t\tfloat lerpOneTo = oneMinusT + occ * u_occlusionStrength;\r\n\t\treturn occlusionTextureColor * lerpOneTo;\r\n\t#else\r\n\t\treturn vec4(1.0);\r\n\t#endif\r\n}\r\n\r\nvec2 ParallaxOffset(in vec3 viewDir){\r\n\t#ifdef PARALLAXTEXTURE\r\n\t\tfloat h = texture2D(u_ParallaxTexture, v_Texcoord0).g;\r\n\t\th = h * u_parallaxScale - u_parallaxScale / 2.0;\r\n\t\tvec3 v = viewDir;\r\n\t\tv.z += 0.42;\r\n\t\tvec2 offset = h * (v.xy / v.z);\r\n\t\treturn v_Texcoord0 + offset;\r\n\t#else\r\n\t\treturn v_Texcoord0;\r\n\t#endif\r\n}\r\n\r\nvec3 ReflectCubeMap(in vec3 viewDir, in vec3 normal){\r\n\t#ifdef REFLECTMAP\r\n\t\tvec3 incident = -viewDir;\r\n\t\tvec3 reflectionVector = reflect(incident, normal);\r\n\t\tvec3 reflectionColor = textureCube(u_ReflectTexture, vec3(-reflectionVector.x, reflectionVector.yz)).rgb;\r\n\t\treturn reflectionColor * u_ReflectIntensity;\r\n\t#else\r\n\t\treturn vec3(0.0);\r\n\t#endif\r\n}\r\n\r\nfloat LayaAttenuation(in vec3 L, in float invLightRadius)\r\n{\r\n\tfloat fRatio = clamp(length(L) * invLightRadius, 0.0, 1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio) * clamp(4.0*(1.0 - fRatio), 0.0, 1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\nvec3 LayaPreMultiplyAlpha(vec3 diffColor, float alpha, float oneMinusReflectivity, out float outModifiedAlpha)\r\n{\r\n\t#ifdef ALPHAPREMULTIPLY\r\n\t\tdiffColor *= alpha;\r\n\t\toutModifiedAlpha = 1.0 - oneMinusReflectivity + alpha * oneMinusReflectivity;\r\n\t#else\r\n\t\toutModifiedAlpha = alpha;\r\n\t#endif\r\n\treturn diffColor;\r\n}\r\n\r\n";

     var PBRSpecularPS = "#ifdef FSHIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\nuniform vec3 u_AmbientColor;\r\nuniform vec4 u_AlbedoColor;\r\nuniform vec4 u_SpecularColor;\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n#ifdef SPECULARTEXTURE\r\n\tuniform sampler2D u_SpecularTexture;\r\n#endif\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_normalScale;\r\n#endif\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_parallaxScale;\r\n#endif\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n#ifdef EMISSION\r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n#ifdef REFLECTMAP\r\n\tuniform samplerCube u_ReflectTexture;\r\n\tuniform float u_ReflectIntensity;\r\n#endif\r\n\r\nuniform float u_AlphaTestValue;\r\nuniform float u_metallic;\r\nuniform float u_smoothness;\r\nuniform float u_smoothnessScale;\r\n\r\nuniform sampler2D u_RangeTexture;\r\n//uniform sampler2D u_AngleTexture;\r\nuniform mat4 u_PointLightMatrix;\r\n//uniform mat4 u_SpotLightMatrix;\r\n\r\n#include \"PBRSpecularLighting.glsl\"\r\n#include \"ShadowHelper.glsl\"\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\n\r\nvoid main_normal()\r\n{\t\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\t\r\n\tvec2 uv0 = ParallaxOffset(viewDir);\r\n\t\r\n\tvec4 sg;\r\n\tvec4 albedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tvec4 albedoTextureColor = texture2D(u_AlbedoTexture, uv0);\r\n\t\talbedoColor = albedoTextureColor * u_AlbedoColor;\r\n\t\tsg = SpecularGloss(albedoTextureColor.a, uv0);\r\n\t#else\r\n\t\talbedoColor = u_AlbedoColor;\r\n\t\tsg = SpecularGloss(1.0, uv0);\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(albedoColor.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\tvec3 normal = UnpackScaleNormal(uv0);\r\n\t\r\n\tLayaGI gi;\r\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\r\n\tgi.specular = ReflectCubeMap(viewDir, normal);\r\n\t\r\n\t//float a = (sg.r+sg.g+sg.b) / 3.0;\r\n  \r\n\tvec4 color = vec4(0.0);\r\n\t\r\n\t#ifdef DIRECTIONLIGHT\r\n\t\tcolor += PBRSpecularDiectionLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_DirectionLight, gi);\r\n\t#endif\r\n \r\n\t#ifdef POINTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRSpecularPointLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_PointLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef SPOTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRSpecularSpotLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef EMISSION\r\n\t\tvec4 emissionColor = u_EmissionColor;\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\r\n\t\t#endif\r\n\t\tcolor.rgb += emissionColor.rgb;\r\n\t#endif\r\n\t\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\r\n\t#else\r\n\t\tgl_FragColor = color;\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}\r\n\r\n";

     var PBRSpecularVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\nuniform vec3 u_CameraPos;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n\t  varying vec4 v_lightMVPPos;\r\n\t  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t \r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0 = a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tmat4 worldMat;\r\n\t\t#ifdef GPU_INSTANCE\r\n\t\t\tworldMat = a_WorldMat;\r\n\t\t#else\r\n\t\t\tworldMat = u_WorldMat;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tmat3 worldInvMat;\r\n\t\t#ifdef BONE\r\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\r\n\t\t#else\r\n\t\t\tworldInvMat=inverse(mat3(worldMat));\r\n\t\t#endif  \r\n\t\tv_Normal=a_Normal*worldInvMat;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\r\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\r\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n  \r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}";

     var PBRStandardPS = "#ifdef FSHIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\nuniform vec3 u_AmbientColor;\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n#ifdef METALLICGLOSSTEXTURE\r\n\tuniform sampler2D u_MetallicGlossTexture;\r\n#endif\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_normalScale;\r\n#endif\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_parallaxScale;\r\n#endif\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n#ifdef EMISSION\r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n#ifdef REFLECTMAP\r\n\tuniform samplerCube u_ReflectTexture;\r\n\tuniform float u_ReflectIntensity;\r\n#endif\r\n\r\nuniform float u_AlphaTestValue;\r\nuniform float u_metallic;\r\nuniform float u_smoothness;\r\nuniform float u_smoothnessScale;\r\n\r\nuniform sampler2D u_RangeTexture;\r\n//uniform sampler2D u_AngleTexture;\r\nuniform mat4 u_PointLightMatrix;\r\n//uniform mat4 u_SpotLightMatrix;\r\n\r\n#include \"PBRStandardLighting.glsl\"\r\n#include \"ShadowHelper.glsl\"\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\n\r\nvoid main_normal()\r\n{\t\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\t\r\n\tvec2 uv0 = ParallaxOffset(viewDir);\r\n\t\r\n\tvec2 mg;\r\n\tvec4 albedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tvec4 abledoTextureColor = texture2D(u_AlbedoTexture, uv0);\r\n\t\talbedoColor = abledoTextureColor * u_AlbedoColor;\r\n\t\tmg = MetallicGloss(abledoTextureColor.a, uv0);\r\n\t#else\r\n\t\talbedoColor = u_AlbedoColor;\r\n\t\tmg = MetallicGloss(1.0, uv0);\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(albedoColor.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tvec3 normal = UnpackScaleNormal(uv0);\r\n  \r\n\tLayaGI gi;\r\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\r\n\tgi.specular = ReflectCubeMap(viewDir, normal);\r\n  \r\n\tvec4 color = vec4(0.0);\r\n\t\r\n\t#ifdef DIRECTIONLIGHT\r\n\t\tcolor += PBRStandardDiectionLight(albedoColor, mg.r, mg.g, normal, viewDir, u_DirectionLight, gi);\r\n\t#endif\r\n \r\n\t#ifdef POINTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRStandardPointLight(albedoColor, mg.r, mg.g, normal, viewDir, u_PointLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef SPOTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRStandardSpotLight(albedoColor, mg.r, mg.g, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef EMISSION\r\n\t\tvec4 emissionColor = u_EmissionColor;\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\r\n\t\t#endif\r\n\t\tcolor.rgb += emissionColor.rgb;\r\n\t#endif\r\n\t\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\r\n\t#else\r\n\t\tgl_FragColor = color;\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}";

     var PBRStandardVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\nuniform vec3 u_CameraPos;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n\t  varying vec4 v_lightMVPPos;\r\n\t  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t \r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0 = a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tmat4 worldMat;\r\n\t\t#ifdef GPU_INSTANCE\r\n\t\t\tworldMat = a_WorldMat;\r\n\t\t#else\r\n\t\t\tworldMat = u_WorldMat;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tmat3 worldInvMat;\r\n\t\t#ifdef BONE\r\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\r\n\t\t#else\r\n\t\t\tworldInvMat=inverse(mat3(worldMat));\r\n\t\t#endif  \r\n\t\tv_Normal=a_Normal*worldInvMat;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\r\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\r\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n  \r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}";

     var BloomVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}";

     var BloomDownsample13PS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}";

     var BloomDownsample4PS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}";

     var BloomPrefilter13PS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}";

     var BloomPrefilter4PS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}";

     var BloomUpsampleBoxPS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}";

     var BloomUpsampleTentPS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}";

     var ColorsGLSL = "#include \"StdLib.glsl\";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\nmediump vec3 sRGBToLinear(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn c * c;\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n\t#else\r\n\t\tmediump vec3 linearRGBLo = c / 12.92;\r\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n\t\treturn linearRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 sRGBToLinear(mediump vec4 c){\r\n    return vec4(sRGBToLinear(c.rgb), c.a);\r\n}\r\n\r\n\r\n\r\nmediump vec3 linearToSRGB(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn sqrt(c);\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n\t#else\r\n\t\tmediump vec3 sRGBLo = c * 12.92;\r\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n\t\treturn sRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 linearToSRGB(mediump vec4 c){\r\n    return vec4(linearToSRGB(c.rgb), c.a);\r\n}";

     var CompositePS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform sampler2D u_Bloom_DirtTex;\r\nuniform vec4 u_BloomTex_TexelSize;\r\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\r\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\r\nuniform mediump vec3 u_Bloom_Color;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\tcolor = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn't massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\tfinalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}";

     var CompositeVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}";

     var SamplingGLSL = "// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}";

     var StdLibGLSL = "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}";

     var ShadowHelperGLSL = "uniform sampler2D u_shadowMap1;\r\nuniform sampler2D u_shadowMap2;\r\nuniform sampler2D u_shadowMap3;\r\nuniform vec2\t  u_shadowPCFoffset;\r\nuniform vec4     u_shadowPSSMDistance;\r\nvec4 packDepth(const in float depth)\r\n{\r\n\tconst vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\r\n\tconst vec4 bitMask\t= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\r\n\tvec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\r\n\tres -= res.xxyz * bitMask;\r\n\treturn res;\r\n}\r\nfloat unpackDepth(const in vec4 rgbaDepth)\r\n{\r\n\tconst vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\r\n\tfloat depth = dot(rgbaDepth, bitShift);\r\n\treturn depth;\r\n}\r\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\r\n{\r\n\tvec2 texelpos =texcoord / invsize;\r\n\tvec2 lerps = fract( texelpos );\r\n\tfloat sourcevals[4];\r\n\tsourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\r\n\tsourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\r\n\tsourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\r\n\tsourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\r\n\treturn mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\r\n}\r\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\tnPSNum += int(posViewZ>pssmDistance.z);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\telse if( nPSNum == 2 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[3];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t} \r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap3,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tif( posViewZ < pssmDistance.x )\r\n\t{\r\n\t\tvec3 vText = lightMVPPos.xyz / lightMVPPos.w;\r\n\t\tfloat fMyZ = vText.z - zBias;\r\n\t\t/*\r\n\t\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\t\tbool bInFrustum = all( bInFrustumVec );\r\n\t\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\t\tbool bFrustumTest = all( bFrustumTestVec );\r\n\t\t*/\r\n\t\tif ( fMyZ <= 1.0 ) \r\n\t\t{\r\n\t\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue = value/4.0;\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\t\t\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\t\t\r\n\t\t\tvec4 color = texture2D( shadowMap1,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n}";

     var SkyBoxPS = "#ifdef HIGHPRECISION\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nuniform samplerCube u_CubeTexture;\r\nuniform float u_Exposure;\r\nuniform vec4 u_TintColor;\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\r\n\tgl_FragColor=vec4(color,1.0);\r\n}\r\n\r\n";

     var SkyBoxVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform float u_Rotation;\r\nvarying vec3 v_Texcoord;\r\n\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * 3.141593 / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\r\n\tgl_Position = (u_MvpMatrix*position).xyww;\r\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n";

     var SkyBoxProceduralPS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\nuniform float u_SunSize;\r\nuniform float u_SunSizeConvergence;\r\nuniform DirectionLight u_DirectionLight;\r\n\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_DirectionLight.Direction, -ray);\r\n\t#endif\r\n\r\n\tcol = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n\r\n";

     var SkyBoxProceduralVS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec3 u_SkyTint;\r\nuniform vec3 u_GroundTint;\r\nuniform float u_Exposure;\r\nuniform float u_AtmosphereThickness;\r\nuniform DirectionLight u_DirectionLight;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main () {\r\n\tgl_Position = (u_MvpMatrix*a_Position).xyww;\r\n\r\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_DirectionLight.Direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_DirectionLight.Color), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n";

     var TrailPS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTexture;\r\nuniform vec4 u_MainColor;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = 2.0 * u_MainColor * v_Color;\r\n\t#ifdef MAINTEXTURE\r\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n\t\tcolor *= mainTextureColor;\r\n\t#endif\r\n\tgl_FragColor = color;\r\n}\r\n\r\n     ";

     var TrailVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec3 a_Position;\r\nattribute vec3 a_OffsetVector;\r\nattribute vec4 a_Color;\r\nattribute float a_Texcoord0X;\r\nattribute float a_Texcoord0Y;\r\nattribute float a_BirthTime;\r\n\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\nuniform vec4 u_TilingOffset;\r\n\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n\tfloat t2 = t * t;\r\n\tfloat t3 = t2 * t;\r\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n\tfloat b = t3 - 2.0 * t2 + t;\r\n\tfloat c = t3 - t2;\r\n\tfloat d = -2.0 * t3 + 3.0 * t2;\r\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n\tfloat width;\r\n\tif(normalizeTime == 0.0){\r\n\t\twidth=u_WidthCurve[0].w;\r\n\t}\r\n\telse if(normalizeTime >= 1.0){\r\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n\telse{\r\n\t\tfor(int i = 0; i < 10; i ++ )\r\n\t\t{\r\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\r\n\t\t\t\twidth=u_WidthCurve[i].w;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\r\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\r\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t\tfloat outTangent = lastFrame.z;\r\n\t\t\t\tfloat inTangent = nextFrame.y;\r\n\t\t\t\tfloat value1 = lastFrame.w;\r\n\t\t\t\tfloat value2 = nextFrame.w;\r\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn width;\r\n}\t\r\n\r\nvoid main()\r\n{\r\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\t#else\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\r\n\t#endif\r\n\t\r\n\tv_Color = a_Color;\r\n\t\r\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n";

     var UnlitPS = "#ifdef FSHIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  u_AlbedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(color.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n}\r\n\r\n";

     var UnlitVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_Position;\r\n\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}";

     var WaterPrimaryPS = "#ifdef FSHIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_MainTexture;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n#endif\r\n\r\nuniform vec4 u_HorizonColor;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\n#include \"Lighting.glsl\"\r\n\r\nvoid main()\r\n{\r\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\r\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\r\n\t\r\n\tvec3 normal1 = NormalSampleToWorldSpace1(bumpColor1, v_Tangent, v_Binormal, v_Normal);\r\n\tvec3 normal2 = NormalSampleToWorldSpace1(bumpColor2, v_Tangent, v_Binormal, v_Normal);\r\n\t\r\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\tfloat fresnel = dot(viewDir, normal);\r\n\t\r\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\r\n\tcolor.a = u_HorizonColor.a;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n\r\n";

     var WaterPrimaryVS = "#include \"Lighting.glsl\";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform mat4 u_WorldMat;\r\nuniform vec3 u_CameraPos;\r\nuniform float u_WaveScale;\r\nuniform vec4 u_WaveSpeed;\r\nuniform float u_Time;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionWorld = u_WorldMat * a_Position;\r\n\tvec4 position = u_MvpMatrix * a_Position;\r\n\t\r\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\r\n\t\r\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\r\n\tv_Texcoord1 = temp.wz;\r\n\t\r\n\tmat3 worldMat = mat3(u_WorldMat);\r\n\tv_Normal = worldMat * a_Normal;\r\n\tv_Tangent = worldMat * a_Tangent0.xyz;\r\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\r\n\t\r\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\r\n\tgl_Position = position;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}";

     /**
      * @private
      * <code>ShaderInit</code> 类用于初始化内置Shader。
      */
     class ShaderInit3D {
         /**
          * 创建一个 <code>ShaderInit</code> 实例。
          */
         constructor() {
         }
         /**
          * @private
          */
         static __init__() {
             ShaderInit3D._rangeAttenTex = Utils3D._buildTexture2D(1024, 1, BaseTexture.FORMAT_ALPHA8, TextureGenerator.lightAttenTexture); //TODO:移动位置
             ShaderInit3D._rangeAttenTex.wrapModeU = BaseTexture.WARPMODE_CLAMP;
             ShaderInit3D._rangeAttenTex.wrapModeV = BaseTexture.WARPMODE_CLAMP;
             ShaderInit3D._rangeAttenTex.lock = true;
             Shader3D.SHADERDEFINE_HIGHPRECISION = Shader3D.registerPublicDefine("HIGHPRECISION");
             Shader3D.addInclude("Lighting.glsl", LightingGLSL);
             Shader3D.addInclude("ShadowHelper.glsl", ShadowHelperGLSL);
             Shader3D.addInclude("BRDF.glsl", BRDFGLSL);
             Shader3D.addInclude("PBRUtils.glsl", PBRUtilsGLSL);
             Shader3D.addInclude("PBRStandardLighting.glsl", PBRStandardLightingGLSL);
             Shader3D.addInclude("PBRSpecularLighting.glsl", PBRSpecularLightingGLSL);
             Shader3D.addInclude("Colors.glsl", ColorsGLSL);
             Shader3D.addInclude("Sampling.glsl", SamplingGLSL);
             Shader3D.addInclude("StdLib.glsl", StdLibGLSL);
             var attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0,
                 'a_Color': VertexMesh.MESH_COLOR0,
                 'a_Normal': VertexMesh.MESH_NORMAL0,
                 'a_Texcoord0': VertexMesh.MESH_TEXTURECOORDINATE0,
                 'a_Texcoord1': VertexMesh.MESH_TEXTURECOORDINATE1,
                 'a_BoneWeights': VertexMesh.MESH_BLENDWEIGHT0,
                 'a_BoneIndices': VertexMesh.MESH_BLENDINDICES0,
                 'a_Tangent0': VertexMesh.MESH_TANGENT0,
                 'a_MvpMatrix': VertexMesh.MESH_MVPMATRIX_ROW0,
                 'a_WorldMat': VertexMesh.MESH_WORLDMATRIX_ROW0
             };
             var uniformMap = {
                 'u_Bones': Shader3D.PERIOD_CUSTOM,
                 'u_DiffuseTexture': Shader3D.PERIOD_MATERIAL,
                 'u_SpecularTexture': Shader3D.PERIOD_MATERIAL,
                 'u_NormalTexture': Shader3D.PERIOD_MATERIAL,
                 'u_AlphaTestValue': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseColor': Shader3D.PERIOD_MATERIAL,
                 'u_MaterialSpecular': Shader3D.PERIOD_MATERIAL,
                 'u_Shininess': Shader3D.PERIOD_MATERIAL,
                 'u_TilingOffset': Shader3D.PERIOD_MATERIAL,
                 'u_WorldMat': Shader3D.PERIOD_SPRITE,
                 'u_MvpMatrix': Shader3D.PERIOD_SPRITE,
                 'u_LightmapScaleOffset': Shader3D.PERIOD_SPRITE,
                 'u_LightMap': Shader3D.PERIOD_SPRITE,
                 'u_CameraPos': Shader3D.PERIOD_CAMERA,
                 'u_ReflectTexture': Shader3D.PERIOD_SCENE,
                 'u_ReflectIntensity': Shader3D.PERIOD_SCENE,
                 'u_FogStart': Shader3D.PERIOD_SCENE,
                 'u_FogRange': Shader3D.PERIOD_SCENE,
                 'u_FogColor': Shader3D.PERIOD_SCENE,
                 'u_DirectionLight.Color': Shader3D.PERIOD_SCENE,
                 'u_DirectionLight.Direction': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Position': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Range': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Color': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Position': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Direction': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Range': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Spot': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Color': Shader3D.PERIOD_SCENE,
                 'u_AmbientColor': Shader3D.PERIOD_SCENE,
                 'u_shadowMap1': Shader3D.PERIOD_SCENE,
                 'u_shadowMap2': Shader3D.PERIOD_SCENE,
                 'u_shadowMap3': Shader3D.PERIOD_SCENE,
                 'u_shadowPSSMDistance': Shader3D.PERIOD_SCENE,
                 'u_lightShadowVP': Shader3D.PERIOD_SCENE,
                 'u_shadowPCFoffset': Shader3D.PERIOD_SCENE
             };
             var stateMap = {
                 's_Cull': Shader3D.RENDER_STATE_CULL,
                 's_Blend': Shader3D.RENDER_STATE_BLEND,
                 's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                 's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                 's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                 's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE
             };
             var shader = Shader3D.add("BLINNPHONG", null, null, true);
             var subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, BlinnPhongMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(MeshBlinnPhongVS, MeshBlinnPhongPS, stateMap);
             attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0,
                 'a_Color': VertexMesh.MESH_COLOR0
             };
             uniformMap = {
                 'u_MvpMatrix': Shader3D.PERIOD_SPRITE,
                 'u_Color': Shader3D.PERIOD_MATERIAL
             };
             stateMap = {
                 's_Cull': Shader3D.RENDER_STATE_CULL,
                 's_Blend': Shader3D.RENDER_STATE_BLEND,
                 's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                 's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                 's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                 's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE
             };
             shader = Shader3D.add("LineShader");
             subShader = new SubShader(attributeMap, uniformMap);
             shader.addSubShader(subShader);
             subShader.addShaderPass(lineVS, linePS, stateMap);
             //PBRStandard
             attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0,
                 'a_Normal': VertexMesh.MESH_NORMAL0,
                 'a_Tangent0': VertexMesh.MESH_TANGENT0,
                 'a_Texcoord0': VertexMesh.MESH_TEXTURECOORDINATE0,
                 'a_BoneWeights': VertexMesh.MESH_BLENDWEIGHT0,
                 'a_BoneIndices': VertexMesh.MESH_BLENDINDICES0,
                 'a_MvpMatrix': VertexMesh.MESH_MVPMATRIX_ROW0,
                 'a_WorldMat': VertexMesh.MESH_WORLDMATRIX_ROW0
             };
             uniformMap = {
                 'u_Bones': Shader3D.PERIOD_CUSTOM,
                 'u_MvpMatrix': Shader3D.PERIOD_SPRITE,
                 'u_WorldMat': Shader3D.PERIOD_SPRITE,
                 'u_CameraPos': Shader3D.PERIOD_CAMERA,
                 'u_AlphaTestValue': Shader3D.PERIOD_MATERIAL,
                 'u_AlbedoColor': Shader3D.PERIOD_MATERIAL,
                 'u_EmissionColor': Shader3D.PERIOD_MATERIAL,
                 'u_AlbedoTexture': Shader3D.PERIOD_MATERIAL,
                 'u_NormalTexture': Shader3D.PERIOD_MATERIAL,
                 'u_ParallaxTexture': Shader3D.PERIOD_MATERIAL,
                 'u_MetallicGlossTexture': Shader3D.PERIOD_MATERIAL,
                 'u_OcclusionTexture': Shader3D.PERIOD_MATERIAL,
                 'u_EmissionTexture': Shader3D.PERIOD_MATERIAL,
                 'u_metallic': Shader3D.PERIOD_MATERIAL,
                 'u_smoothness': Shader3D.PERIOD_MATERIAL,
                 'u_smoothnessScale': Shader3D.PERIOD_MATERIAL,
                 'u_occlusionStrength': Shader3D.PERIOD_MATERIAL,
                 'u_normalScale': Shader3D.PERIOD_MATERIAL,
                 'u_parallaxScale': Shader3D.PERIOD_MATERIAL,
                 'u_TilingOffset': Shader3D.PERIOD_MATERIAL,
                 'u_DirectionLight.Direction': Shader3D.PERIOD_SCENE,
                 'u_DirectionLight.Color': Shader3D.PERIOD_SCENE,
                 'u_PointLightMatrix': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Position': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Range': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Color': Shader3D.PERIOD_SCENE,
                 //'u_SpotLightMatrix':  Shader3D.PERIOD_SCENE, 
                 'u_SpotLight.Position': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Direction': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Range': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.SpotAngle': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Color': Shader3D.PERIOD_SCENE,
                 'u_RangeTexture': Shader3D.PERIOD_SCENE,
                 //'u_AngleTexture':Shader3D.PERIOD_SCENE,
                 'u_ReflectTexture': Shader3D.PERIOD_SCENE,
                 'u_ReflectIntensity': Shader3D.PERIOD_SCENE,
                 'u_AmbientColor': Shader3D.PERIOD_SCENE,
                 'u_shadowMap1': Shader3D.PERIOD_SCENE,
                 'u_shadowMap2': Shader3D.PERIOD_SCENE,
                 'u_shadowMap3': Shader3D.PERIOD_SCENE,
                 'u_shadowPSSMDistance': Shader3D.PERIOD_SCENE,
                 'u_lightShadowVP': Shader3D.PERIOD_SCENE,
                 'u_shadowPCFoffset': Shader3D.PERIOD_SCENE,
                 'u_FogStart': Shader3D.PERIOD_SCENE,
                 'u_FogRange': Shader3D.PERIOD_SCENE,
                 'u_FogColor': Shader3D.PERIOD_SCENE
             };
             stateMap = {
                 's_Cull': Shader3D.RENDER_STATE_CULL,
                 's_Blend': Shader3D.RENDER_STATE_BLEND,
                 's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                 's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                 's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                 's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE
             };
             shader = Shader3D.add("PBRStandard", null, null, true);
             subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, PBRStandardMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(PBRStandardVS, PBRStandardPS, stateMap);
             //PBRSpecular
             attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0,
                 'a_Normal': VertexMesh.MESH_NORMAL0,
                 'a_Tangent0': VertexMesh.MESH_TANGENT0,
                 'a_Texcoord0': VertexMesh.MESH_TEXTURECOORDINATE0,
                 'a_BoneWeights': VertexMesh.MESH_BLENDWEIGHT0,
                 'a_BoneIndices': VertexMesh.MESH_BLENDINDICES0,
                 'a_MvpMatrix': VertexMesh.MESH_MVPMATRIX_ROW0,
                 'a_WorldMat': VertexMesh.MESH_WORLDMATRIX_ROW0
             };
             uniformMap = {
                 'u_Bones': Shader3D.PERIOD_CUSTOM,
                 'u_MvpMatrix': Shader3D.PERIOD_SPRITE,
                 'u_WorldMat': Shader3D.PERIOD_SPRITE,
                 'u_CameraPos': Shader3D.PERIOD_CAMERA,
                 'u_AlphaTestValue': Shader3D.PERIOD_MATERIAL,
                 'u_AlbedoColor': Shader3D.PERIOD_MATERIAL,
                 'u_SpecularColor': Shader3D.PERIOD_MATERIAL,
                 'u_EmissionColor': Shader3D.PERIOD_MATERIAL,
                 'u_AlbedoTexture': Shader3D.PERIOD_MATERIAL,
                 'u_NormalTexture': Shader3D.PERIOD_MATERIAL,
                 'u_ParallaxTexture': Shader3D.PERIOD_MATERIAL,
                 'u_SpecularTexture': Shader3D.PERIOD_MATERIAL,
                 'u_OcclusionTexture': Shader3D.PERIOD_MATERIAL,
                 'u_EmissionTexture': Shader3D.PERIOD_MATERIAL,
                 'u_smoothness': Shader3D.PERIOD_MATERIAL,
                 'u_smoothnessScale': Shader3D.PERIOD_MATERIAL,
                 'u_occlusionStrength': Shader3D.PERIOD_MATERIAL,
                 'u_normalScale': Shader3D.PERIOD_MATERIAL,
                 'u_parallaxScale': Shader3D.PERIOD_MATERIAL,
                 'u_TilingOffset': Shader3D.PERIOD_MATERIAL,
                 'u_DirectionLight.Direction': Shader3D.PERIOD_SCENE,
                 'u_DirectionLight.Color': Shader3D.PERIOD_SCENE,
                 'u_PointLightMatrix': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Position': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Range': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Color': Shader3D.PERIOD_SCENE,
                 //'u_SpotLightMatrix':  Shader3D.PERIOD_SCENE, 
                 'u_SpotLight.Position': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Direction': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Range': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.SpotAngle': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Color': Shader3D.PERIOD_SCENE,
                 'u_RangeTexture': Shader3D.PERIOD_SCENE,
                 //'u_AngleTexture': Shader3D.PERIOD_SCENE,
                 'u_ReflectTexture': Shader3D.PERIOD_SCENE,
                 'u_ReflectIntensity': Shader3D.PERIOD_SCENE,
                 'u_AmbientColor': Shader3D.PERIOD_SCENE,
                 'u_shadowMap1': Shader3D.PERIOD_SCENE,
                 'u_shadowMap2': Shader3D.PERIOD_SCENE,
                 'u_shadowMap3': Shader3D.PERIOD_SCENE,
                 'u_shadowPSSMDistance': Shader3D.PERIOD_SCENE,
                 'u_lightShadowVP': Shader3D.PERIOD_SCENE,
                 'u_shadowPCFoffset': Shader3D.PERIOD_SCENE,
                 'u_FogStart': Shader3D.PERIOD_SCENE,
                 'u_FogRange': Shader3D.PERIOD_SCENE,
                 'u_FogColor': Shader3D.PERIOD_SCENE
             };
             stateMap = {
                 's_Cull': Shader3D.RENDER_STATE_CULL,
                 's_Blend': Shader3D.RENDER_STATE_BLEND,
                 's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                 's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                 's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                 's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE
             };
             shader = Shader3D.add("PBRSpecular", null, null, true);
             subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, PBRSpecularMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(PBRSpecularVS, PBRSpecularPS, stateMap);
             //unlit
             attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0,
                 'a_Color': VertexMesh.MESH_COLOR0,
                 'a_Texcoord0': VertexMesh.MESH_TEXTURECOORDINATE0,
                 'a_BoneWeights': VertexMesh.MESH_BLENDWEIGHT0,
                 'a_BoneIndices': VertexMesh.MESH_BLENDINDICES0,
                 'a_MvpMatrix': VertexMesh.MESH_MVPMATRIX_ROW0
             };
             uniformMap = {
                 'u_Bones': Shader3D.PERIOD_CUSTOM,
                 'u_AlbedoTexture': Shader3D.PERIOD_MATERIAL,
                 'u_AlbedoColor': Shader3D.PERIOD_MATERIAL,
                 'u_TilingOffset': Shader3D.PERIOD_MATERIAL,
                 'u_AlphaTestValue': Shader3D.PERIOD_MATERIAL,
                 'u_MvpMatrix': Shader3D.PERIOD_SPRITE,
                 'u_FogStart': Shader3D.PERIOD_SCENE,
                 'u_FogRange': Shader3D.PERIOD_SCENE,
                 'u_FogColor': Shader3D.PERIOD_SCENE
             };
             stateMap = {
                 's_Cull': Shader3D.RENDER_STATE_CULL,
                 's_Blend': Shader3D.RENDER_STATE_BLEND,
                 's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                 's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                 's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                 's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE
             };
             shader = Shader3D.add("Unlit", null, null, true);
             subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, UnlitMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(UnlitVS, UnlitPS, stateMap);
             //meshEffect
             attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0,
                 'a_Texcoord0': VertexMesh.MESH_TEXTURECOORDINATE0,
                 'a_BoneWeights': VertexMesh.MESH_BLENDWEIGHT0,
                 'a_BoneIndices': VertexMesh.MESH_BLENDINDICES0,
                 'a_MvpMatrix': VertexMesh.MESH_MVPMATRIX_ROW0
             };
             uniformMap = {
                 'u_Bones': Shader3D.PERIOD_CUSTOM,
                 'u_AlbedoTexture': Shader3D.PERIOD_MATERIAL,
                 'u_AlbedoColor': Shader3D.PERIOD_MATERIAL,
                 'u_TilingOffset': Shader3D.PERIOD_MATERIAL,
                 'u_AlphaTestValue': Shader3D.PERIOD_MATERIAL,
                 'u_MvpMatrix': Shader3D.PERIOD_SPRITE,
                 'u_FogStart': Shader3D.PERIOD_SCENE,
                 'u_FogRange': Shader3D.PERIOD_SCENE,
                 'u_FogColor': Shader3D.PERIOD_SCENE
             };
             stateMap = {
                 's_Cull': Shader3D.RENDER_STATE_CULL,
                 's_Blend': Shader3D.RENDER_STATE_BLEND,
                 's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                 's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                 's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                 's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE
             };
             shader = Shader3D.add("Effect", null, null, true);
             subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, EffectMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(EffectVS, EffectPS, stateMap);
             //ShurikenParticle
             attributeMap = {
                 'a_CornerTextureCoordinate': VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0,
                 'a_MeshPosition': VertexShuriKenParticle.PARTICLE_POSITION0,
                 'a_MeshColor': VertexShuriKenParticle.PARTICLE_COLOR0,
                 'a_MeshTextureCoordinate': VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0,
                 'a_ShapePositionStartLifeTime': VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME,
                 'a_DirectionTime': VertexShuriKenParticle.PARTICLE_DIRECTIONTIME,
                 'a_StartColor': VertexShuriKenParticle.PARTICLE_STARTCOLOR0,
                 'a_EndColor': VertexShuriKenParticle.PARTICLE_ENDCOLOR0,
                 'a_StartSize': VertexShuriKenParticle.PARTICLE_STARTSIZE,
                 'a_StartRotation0': VertexShuriKenParticle.PARTICLE_STARTROTATION,
                 'a_StartSpeed': VertexShuriKenParticle.PARTICLE_STARTSPEED,
                 'a_Random0': VertexShuriKenParticle.PARTICLE_RANDOM0,
                 'a_Random1': VertexShuriKenParticle.PARTICLE_RANDOM1,
                 'a_SimulationWorldPostion': VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION,
                 'a_SimulationWorldRotation': VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION
             };
             uniformMap = {
                 'u_Tintcolor': Shader3D.PERIOD_MATERIAL,
                 'u_TilingOffset': Shader3D.PERIOD_MATERIAL,
                 'u_texture': Shader3D.PERIOD_MATERIAL,
                 'u_WorldPosition': Shader3D.PERIOD_SPRITE,
                 'u_WorldRotation': Shader3D.PERIOD_SPRITE,
                 'u_PositionScale': Shader3D.PERIOD_SPRITE,
                 'u_SizeScale': Shader3D.PERIOD_SPRITE,
                 'u_ScalingMode': Shader3D.PERIOD_SPRITE,
                 'u_Gravity': Shader3D.PERIOD_SPRITE,
                 'u_ThreeDStartRotation': Shader3D.PERIOD_SPRITE,
                 'u_StretchedBillboardLengthScale': Shader3D.PERIOD_SPRITE,
                 'u_StretchedBillboardSpeedScale': Shader3D.PERIOD_SPRITE,
                 'u_SimulationSpace': Shader3D.PERIOD_SPRITE,
                 'u_CurrentTime': Shader3D.PERIOD_SPRITE,
                 'u_ColorOverLifeGradientAlphas': Shader3D.PERIOD_SPRITE,
                 'u_ColorOverLifeGradientColors': Shader3D.PERIOD_SPRITE,
                 'u_MaxColorOverLifeGradientAlphas': Shader3D.PERIOD_SPRITE,
                 'u_MaxColorOverLifeGradientColors': Shader3D.PERIOD_SPRITE,
                 'u_VOLVelocityConst': Shader3D.PERIOD_SPRITE,
                 'u_VOLVelocityGradientX': Shader3D.PERIOD_SPRITE,
                 'u_VOLVelocityGradientY': Shader3D.PERIOD_SPRITE,
                 'u_VOLVelocityGradientZ': Shader3D.PERIOD_SPRITE,
                 'u_VOLVelocityConstMax': Shader3D.PERIOD_SPRITE,
                 'u_VOLVelocityGradientMaxX': Shader3D.PERIOD_SPRITE,
                 'u_VOLVelocityGradientMaxY': Shader3D.PERIOD_SPRITE,
                 'u_VOLVelocityGradientMaxZ': Shader3D.PERIOD_SPRITE,
                 'u_VOLSpaceType': Shader3D.PERIOD_SPRITE,
                 'u_SOLSizeGradient': Shader3D.PERIOD_SPRITE,
                 'u_SOLSizeGradientX': Shader3D.PERIOD_SPRITE,
                 'u_SOLSizeGradientY': Shader3D.PERIOD_SPRITE,
                 'u_SOLSizeGradientZ': Shader3D.PERIOD_SPRITE,
                 'u_SOLSizeGradientMax': Shader3D.PERIOD_SPRITE,
                 'u_SOLSizeGradientMaxX': Shader3D.PERIOD_SPRITE,
                 'u_SOLSizeGradientMaxY': Shader3D.PERIOD_SPRITE,
                 'u_SOLSizeGradientMaxZ': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityConst': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityConstSeprarate': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityGradient': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityGradientX': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityGradientY': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityGradientZ': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityConstMax': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityConstMaxSeprarate': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityGradientMax': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityGradientMaxX': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityGradientMaxY': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityGradientMaxZ': Shader3D.PERIOD_SPRITE,
                 'u_ROLAngularVelocityGradientMaxW': Shader3D.PERIOD_SPRITE,
                 'u_TSACycles': Shader3D.PERIOD_SPRITE,
                 'u_TSASubUVLength': Shader3D.PERIOD_SPRITE,
                 'u_TSAGradientUVs': Shader3D.PERIOD_SPRITE,
                 'u_TSAMaxGradientUVs': Shader3D.PERIOD_SPRITE,
                 'u_CameraPos': Shader3D.PERIOD_CAMERA,
                 'u_CameraDirection': Shader3D.PERIOD_CAMERA,
                 'u_CameraUp': Shader3D.PERIOD_CAMERA,
                 'u_View': Shader3D.PERIOD_CAMERA,
                 'u_Projection': Shader3D.PERIOD_CAMERA,
                 'u_FogStart': Shader3D.PERIOD_SCENE,
                 'u_FogRange': Shader3D.PERIOD_SCENE,
                 'u_FogColor': Shader3D.PERIOD_SCENE
             };
             stateMap = {
                 's_Cull': Shader3D.RENDER_STATE_CULL,
                 's_Blend': Shader3D.RENDER_STATE_BLEND,
                 's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                 's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                 's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                 's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE
             };
             shader = Shader3D.add("PARTICLESHURIKEN");
             subShader = new SubShader(attributeMap, uniformMap, ShuriKenParticle3D.shaderDefines, ShurikenParticleMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(ParticleShuriKenVS, ParticleShuriKenPS, stateMap);
             attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0
             };
             uniformMap = {
                 'u_TintColor': Shader3D.PERIOD_MATERIAL,
                 'u_Exposure': Shader3D.PERIOD_MATERIAL,
                 'u_Rotation': Shader3D.PERIOD_MATERIAL,
                 'u_CubeTexture': Shader3D.PERIOD_MATERIAL,
                 'u_MvpMatrix': Shader3D.PERIOD_CAMERA
             }; //TODO:优化
             shader = Shader3D.add("SkyBox");
             subShader = new SubShader(attributeMap, uniformMap);
             shader.addSubShader(subShader);
             subShader.addShaderPass(SkyBoxVS, SkyBoxPS);
             attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0
             };
             uniformMap = {
                 'u_SunSize': Shader3D.PERIOD_MATERIAL,
                 'u_SunSizeConvergence': Shader3D.PERIOD_MATERIAL,
                 'u_AtmosphereThickness': Shader3D.PERIOD_MATERIAL,
                 'u_SkyTint': Shader3D.PERIOD_MATERIAL,
                 'u_GroundTint': Shader3D.PERIOD_MATERIAL,
                 'u_Exposure': Shader3D.PERIOD_MATERIAL,
                 'u_MvpMatrix': Shader3D.PERIOD_CAMERA,
                 'u_DirectionLight.Direction': Shader3D.PERIOD_SCENE,
                 'u_DirectionLight.Color': Shader3D.PERIOD_SCENE
             };
             shader = Shader3D.add("SkyBoxProcedural");
             subShader = new SubShader(attributeMap, uniformMap, null, SkyProceduralMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(SkyBoxProceduralVS, SkyBoxProceduralPS);
             //extendTerrain的shader
             attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0,
                 'a_Normal': VertexMesh.MESH_NORMAL0,
                 'a_Texcoord0': VertexMesh.MESH_TEXTURECOORDINATE0
             };
             uniformMap = {
                 'u_MvpMatrix': Shader3D.PERIOD_SPRITE,
                 'u_WorldMat': Shader3D.PERIOD_SPRITE,
                 'u_CameraPos': Shader3D.PERIOD_CAMERA,
                 'u_LightmapScaleOffset': Shader3D.PERIOD_SPRITE,
                 'u_LightMap': Shader3D.PERIOD_SPRITE,
                 'u_SplatAlphaTexture': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseTexture1': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseTexture2': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseTexture3': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseTexture4': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseTexture5': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseScaleOffset1': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseScaleOffset2': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseScaleOffset3': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseScaleOffset4': Shader3D.PERIOD_MATERIAL,
                 'u_DiffuseScaleOffset5': Shader3D.PERIOD_MATERIAL,
                 'u_FogStart': Shader3D.PERIOD_SCENE,
                 'u_FogRange': Shader3D.PERIOD_SCENE,
                 'u_FogColor': Shader3D.PERIOD_SCENE,
                 'u_DirectionLight.Direction': Shader3D.PERIOD_SCENE,
                 'u_DirectionLight.Color': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Position': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Range': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Attenuation': Shader3D.PERIOD_SCENE,
                 'u_PointLight.Color': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Position': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Direction': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Range': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Spot': Shader3D.PERIOD_SCENE,
                 'u_SpotLight.Color': Shader3D.PERIOD_SCENE,
                 'u_AmbientColor': Shader3D.PERIOD_SCENE,
                 'u_shadowMap1': Shader3D.PERIOD_SCENE,
                 'u_shadowMap2': Shader3D.PERIOD_SCENE,
                 'u_shadowMap3': Shader3D.PERIOD_SCENE,
                 'u_shadowPSSMDistance': Shader3D.PERIOD_SCENE,
                 'u_lightShadowVP': Shader3D.PERIOD_SCENE,
                 'u_shadowPCFoffset': Shader3D.PERIOD_SCENE
             };
             stateMap = {
                 's_Cull': Shader3D.RENDER_STATE_CULL,
                 's_Blend': Shader3D.RENDER_STATE_BLEND,
                 's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                 's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                 's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                 's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE
             };
             shader = Shader3D.add("ExtendTerrain");
             subShader = new SubShader(attributeMap, uniformMap, RenderableSprite3D.shaderDefines, ExtendTerrainMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(extendTerrainVS, extendTerrainPS, stateMap);
             //Trail
             attributeMap = {
                 'a_Position': VertexTrail.TRAIL_POSITION0,
                 'a_OffsetVector': VertexTrail.TRAIL_OFFSETVECTOR,
                 'a_Texcoord0X': VertexTrail.TRAIL_TEXTURECOORDINATE0X,
                 'a_Texcoord0Y': VertexTrail.TRAIL_TEXTURECOORDINATE0Y,
                 'a_BirthTime': VertexTrail.TRAIL_TIME0,
                 'a_Color': VertexTrail.TRAIL_COLOR
             };
             uniformMap = {
                 'u_MvpMatrix': Shader3D.PERIOD_SPRITE,
                 'u_View': Shader3D.PERIOD_CAMERA,
                 'u_Projection': Shader3D.PERIOD_CAMERA,
                 'u_TilingOffset': Shader3D.PERIOD_MATERIAL,
                 'u_MainTexture': Shader3D.PERIOD_MATERIAL,
                 'u_MainColor': Shader3D.PERIOD_MATERIAL,
                 'u_CurTime': Shader3D.PERIOD_SPRITE,
                 'u_LifeTime': Shader3D.PERIOD_SPRITE,
                 'u_WidthCurve': Shader3D.PERIOD_SPRITE,
                 'u_WidthCurveKeyLength': Shader3D.PERIOD_SPRITE,
                 'u_GradientColorkey': Shader3D.PERIOD_SPRITE,
                 'u_GradientAlphakey': Shader3D.PERIOD_SPRITE
             };
             stateMap = {
                 's_Cull': Shader3D.RENDER_STATE_CULL,
                 's_Blend': Shader3D.RENDER_STATE_BLEND,
                 's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                 's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                 's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                 's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE
             };
             shader = Shader3D.add("Trail");
             subShader = new SubShader(attributeMap, uniformMap, TrailSprite3D.shaderDefines, TrailMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(TrailVS, TrailPS, stateMap);
             //WaterPrimary
             attributeMap = {
                 'a_Position': VertexMesh.MESH_POSITION0,
                 'a_Normal': VertexMesh.MESH_NORMAL0,
                 'a_Tangent0': VertexMesh.MESH_TANGENT0
             };
             uniformMap = {
                 'u_MvpMatrix': Shader3D.PERIOD_SPRITE,
                 'u_WorldMat': Shader3D.PERIOD_SPRITE,
                 'u_CameraPos': Shader3D.PERIOD_CAMERA,
                 'u_Time': Shader3D.PERIOD_SCENE,
                 'u_MainTexture': Shader3D.PERIOD_MATERIAL,
                 'u_NormalTexture': Shader3D.PERIOD_MATERIAL,
                 'u_HorizonColor': Shader3D.PERIOD_MATERIAL,
                 'u_WaveScale': Shader3D.PERIOD_MATERIAL,
                 'u_WaveSpeed': Shader3D.PERIOD_MATERIAL
             };
             shader = Shader3D.add("WaterPrimary");
             subShader = new SubShader(attributeMap, uniformMap, null, WaterPrimaryMaterial.shaderDefines);
             shader.addSubShader(subShader);
             subShader.addShaderPass(WaterPrimaryVS, WaterPrimaryPS);
             //BlitScreen
             attributeMap = {
                 'a_PositionTexcoord': VertexMesh.MESH_POSITION0
             };
             uniformMap = {
                 'u_MainTex': Shader3D.PERIOD_MATERIAL
             };
             shader = Shader3D.add("BlitScreen");
             subShader = new SubShader(attributeMap, uniformMap, null, null);
             shader.addSubShader(subShader);
             var shaderPass = subShader.addShaderPass(BlitScreenVS, BlitScreenPS);
             var renderState = shaderPass.renderState;
             renderState.depthTest = RenderState.DEPTHTEST_ALWAYS;
             renderState.depthWrite = false;
             renderState.cull = RenderState.CULL_NONE;
             renderState.blend = RenderState.BLEND_DISABLE;
             //PostProcessBloom
             attributeMap = {
                 'a_PositionTexcoord': VertexMesh.MESH_POSITION0
             };
             uniformMap = {
                 'u_MainTex': Shader3D.PERIOD_MATERIAL,
                 'u_BloomTex': Shader3D.PERIOD_MATERIAL,
                 'u_AutoExposureTex': Shader3D.PERIOD_MATERIAL,
                 'u_MainTex_TexelSize': Shader3D.PERIOD_MATERIAL,
                 'u_SampleScale': Shader3D.PERIOD_MATERIAL,
                 'u_Threshold': Shader3D.PERIOD_MATERIAL,
                 'u_Params': Shader3D.PERIOD_MATERIAL
             };
             shader = Shader3D.add("PostProcessBloom", attributeMap, uniformMap);
             //subShader0
             subShader = new SubShader(null, null, null, null);
             shader.addSubShader(subShader);
             shaderPass = subShader.addShaderPass(BloomVS, BloomPrefilter13PS);
             renderState = shaderPass.renderState;
             renderState.depthTest = RenderState.DEPTHTEST_ALWAYS;
             renderState.depthWrite = false;
             renderState.cull = RenderState.CULL_NONE;
             renderState.blend = RenderState.BLEND_DISABLE;
             //subShader1
             subShader = new SubShader(null, null, null, null);
             shader.addSubShader(subShader);
             shaderPass = subShader.addShaderPass(BloomVS, BloomPrefilter4PS);
             renderState = shaderPass.renderState;
             renderState.depthTest = RenderState.DEPTHTEST_ALWAYS;
             renderState.depthWrite = false;
             renderState.cull = RenderState.CULL_NONE;
             renderState.blend = RenderState.BLEND_DISABLE;
             //subShader2
             subShader = new SubShader(null, null, null, null);
             shader.addSubShader(subShader);
             shaderPass = subShader.addShaderPass(BloomVS, BloomDownsample13PS);
             renderState = shaderPass.renderState;
             renderState.depthTest = RenderState.DEPTHTEST_ALWAYS;
             renderState.depthWrite = false;
             renderState.cull = RenderState.CULL_NONE;
             renderState.blend = RenderState.BLEND_DISABLE;
             //subShader3
             subShader = new SubShader(null, null, null, null);
             shader.addSubShader(subShader);
             shaderPass = subShader.addShaderPass(BloomVS, BloomDownsample4PS);
             renderState = shaderPass.renderState;
             renderState.depthTest = RenderState.DEPTHTEST_ALWAYS;
             renderState.depthWrite = false;
             renderState.cull = RenderState.CULL_NONE;
             renderState.blend = RenderState.BLEND_DISABLE;
             //subShader4
             subShader = new SubShader(null, null, null, null);
             shader.addSubShader(subShader);
             shaderPass = subShader.addShaderPass(BloomVS, BloomUpsampleTentPS);
             renderState = shaderPass.renderState;
             renderState.depthTest = RenderState.DEPTHTEST_ALWAYS;
             renderState.depthWrite = false;
             renderState.cull = RenderState.CULL_NONE;
             renderState.blend = RenderState.BLEND_DISABLE;
             //subShader5
             subShader = new SubShader(null, null, null, null);
             shader.addSubShader(subShader);
             shaderPass = subShader.addShaderPass(BloomVS, BloomUpsampleBoxPS);
             renderState = shaderPass.renderState;
             renderState.depthTest = RenderState.DEPTHTEST_ALWAYS;
             renderState.depthWrite = false;
             renderState.cull = RenderState.CULL_NONE;
             renderState.blend = RenderState.BLEND_DISABLE;
             //PostProcessBloom
             attributeMap = {
                 'a_PositionTexcoord': VertexMesh.MESH_POSITION0
             };
             uniformMap = {
                 'u_MainTex': Shader3D.PERIOD_MATERIAL,
                 'u_BloomTex': Shader3D.PERIOD_MATERIAL,
                 'u_AutoExposureTex': Shader3D.PERIOD_MATERIAL,
                 'u_Bloom_DirtTileOffset': Shader3D.PERIOD_MATERIAL,
                 'u_Bloom_DirtTex': Shader3D.PERIOD_MATERIAL,
                 'u_BloomTex_TexelSize': Shader3D.PERIOD_MATERIAL,
                 'u_Bloom_Settings': Shader3D.PERIOD_MATERIAL,
                 'u_Bloom_Color': Shader3D.PERIOD_MATERIAL
             };
             shader = Shader3D.add("PostProcessComposite", attributeMap, uniformMap);
             subShader = new SubShader(null, null, null, PostProcess.shaderDefines);
             shader.addSubShader(subShader);
             shaderPass = subShader.addShaderPass(CompositeVS, CompositePS);
             renderState = shaderPass.renderState;
             renderState.depthTest = RenderState.DEPTHTEST_ALWAYS;
             renderState.depthWrite = false;
             renderState.cull = RenderState.CULL_NONE;
             renderState.blend = RenderState.BLEND_DISABLE;
         }
     }

     /**
      * <code>PixelLineMaterial</code> 类用于实现像素线材质。
      */
     class PixelLineMaterial extends BaseMaterial {
         constructor() {
             super();
             this.setShaderName("LineShader");
             this._shaderValues.setVector(PixelLineMaterial.COLOR, new Vector4(1.0, 1.0, 1.0, 1.0));
         }
         /**
         * @private
         */
         static __initDefine__() {
             PixelLineMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines);
         }
         /**
          * 获取颜色。
          * @return 颜色。
          */
         get color() {
             return this._shaderValues.getVector(PixelLineMaterial.COLOR);
         }
         /**
          * 设置颜色。
          * @param value 颜色。
          */
         set color(value) {
             this._shaderValues.setVector(PixelLineMaterial.COLOR, value);
         }
         /**
          * 设置是否写入深度。
          * @param value 是否写入深度。
          */
         set depthWrite(value) {
             this._shaderValues.setBool(PixelLineMaterial.DEPTH_WRITE, value);
         }
         /**
          * 获取是否写入深度。
          * @return 是否写入深度。
          */
         get depthWrite() {
             return this._shaderValues.getBool(PixelLineMaterial.DEPTH_WRITE);
         }
         /**
          * 设置剔除方式。
          * @param value 剔除方式。
          */
         set cull(value) {
             this._shaderValues.setInt(PixelLineMaterial.CULL, value);
         }
         /**
          * 获取剔除方式。
          * @return 剔除方式。
          */
         get cull() {
             return this._shaderValues.getInt(PixelLineMaterial.CULL);
         }
         /**
          * 设置混合方式。
          * @param value 混合方式。
          */
         set blend(value) {
             this._shaderValues.setInt(PixelLineMaterial.BLEND, value);
         }
         /**
          * 获取混合方式。
          * @return 混合方式。
          */
         get blend() {
             return this._shaderValues.getInt(PixelLineMaterial.BLEND);
         }
         /**
          * 设置混合源。
          * @param value 混合源
          */
         set blendSrc(value) {
             this._shaderValues.setInt(PixelLineMaterial.BLEND_SRC, value);
         }
         /**
          * 获取混合源。
          * @return 混合源。
          */
         get blendSrc() {
             return this._shaderValues.getInt(PixelLineMaterial.BLEND_SRC);
         }
         /**
          * 设置混合目标。
          * @param value 混合目标
          */
         set blendDst(value) {
             this._shaderValues.setInt(PixelLineMaterial.BLEND_DST, value);
         }
         /**
          * 获取混合目标。
          * @return 混合目标。
          */
         get blendDst() {
             return this._shaderValues.getInt(PixelLineMaterial.BLEND_DST);
         }
         /**
          * 设置深度测试方式。
          * @param value 深度测试方式
          */
         set depthTest(value) {
             this._shaderValues.setInt(PixelLineMaterial.DEPTH_TEST, value);
         }
         /**
          * 获取深度测试方式。
          * @return 深度测试方式。
          */
         get depthTest() {
             return this._shaderValues.getInt(PixelLineMaterial.DEPTH_TEST);
         }
         /**
      * 克隆。
      * @return	 克隆副本。
      */
         clone() {
             var dest = new PixelLineMaterial();
             this.cloneTo(dest);
             return dest;
         }
     }
     PixelLineMaterial.COLOR = Shader3D.propertyNameToID("u_Color");
     /**@private */
     PixelLineMaterial.shaderDefines = null;
     PixelLineMaterial.CULL = Shader3D.propertyNameToID("s_Cull");
     PixelLineMaterial.BLEND = Shader3D.propertyNameToID("s_Blend");
     PixelLineMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
     PixelLineMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
     PixelLineMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
     PixelLineMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");

     /**
      * ...
      * @author
      */
     class PixelLineVertex {
         constructor() {
         }
         static get vertexDeclaration() {
             return PixelLineVertex._vertexDeclaration;
         }
         get vertexDeclaration() {
             return PixelLineVertex._vertexDeclaration;
         }
     }
     PixelLineVertex._vertexDeclaration = new VertexDeclaration(28, [new VertexElement(0, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0),
         new VertexElement(12, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0)]);

     /**
      * <code>PixelLineFilter</code> 类用于线过滤器。
      */
     class PixelLineFilter extends GeometryElement {
         constructor(owner, maxLineCount) {
             super();
             /** @private */
             this._floatCountPerVertices = 7;
             /** @private */
             this._minUpdate = Number.MAX_VALUE;
             /** @private */
             this._maxUpdate = Number.MIN_VALUE;
             /** @private */
             this._bufferState = new BufferState();
             /** @private */
             this._maxLineCount = 0;
             /** @private */
             this._lineCount = 0;
             var pointCount = maxLineCount * 2;
             this._owner = owner;
             this._maxLineCount = maxLineCount;
             this._vertices = new Float32Array(pointCount * this._floatCountPerVertices);
             this._vertexBuffer = new VertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride * pointCount, WebGLContext.STATIC_DRAW, false);
             this._vertexBuffer.vertexDeclaration = PixelLineVertex.vertexDeclaration;
             this._bufferState.bind();
             this._bufferState.applyVertexBuffer(this._vertexBuffer);
             this._bufferState.unBind();
         }
         /**
          *	{@inheritDoc PixelLineFilter._getType}
          *	@override
          */
         _getType() {
             return PixelLineFilter._type;
         }
         /**
          * @private
          */
         _resizeLineData(maxCount) {
             var pointCount = maxCount * 2;
             var lastVertices = this._vertices;
             this._vertexBuffer.destroy();
             this._maxLineCount = maxCount;
             var vertexCount = pointCount * this._floatCountPerVertices;
             this._vertices = new Float32Array(vertexCount);
             this._vertexBuffer = new VertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride * pointCount, WebGLContext.STATIC_DRAW, false);
             this._vertexBuffer.vertexDeclaration = PixelLineVertex.vertexDeclaration;
             if (vertexCount < lastVertices.length) { //取最小长度,拷贝旧数据
                 this._vertices.set(new Float32Array(lastVertices.buffer, 0, vertexCount));
                 this._vertexBuffer.setData(this._vertices, 0, 0, vertexCount);
             }
             else {
                 this._vertices.set(lastVertices);
                 this._vertexBuffer.setData(this._vertices, 0, 0, lastVertices.length);
             }
             this._bufferState.bind();
             this._bufferState.applyVertexBuffer(this._vertexBuffer);
             this._bufferState.unBind();
         }
         /**
          * @private
          */
         _updateLineVertices(offset, startPosition, endPosition, startColor, endColor) {
             if (startPosition) {
                 this._vertices[offset + 0] = startPosition.x;
                 this._vertices[offset + 1] = startPosition.y;
                 this._vertices[offset + 2] = startPosition.z;
             }
             if (startColor) {
                 this._vertices[offset + 3] = startColor.r;
                 this._vertices[offset + 4] = startColor.g;
                 this._vertices[offset + 5] = startColor.b;
                 this._vertices[offset + 6] = startColor.a;
             }
             if (endPosition) {
                 this._vertices[offset + 7] = endPosition.x;
                 this._vertices[offset + 8] = endPosition.y;
                 this._vertices[offset + 9] = endPosition.z;
             }
             if (endColor) {
                 this._vertices[offset + 10] = endColor.r;
                 this._vertices[offset + 11] = endColor.g;
                 this._vertices[offset + 12] = endColor.b;
                 this._vertices[offset + 13] = endColor.a;
             }
             this._minUpdate = Math.min(this._minUpdate, offset);
             this._maxUpdate = Math.max(this._maxUpdate, offset + this._floatCountPerVertices * 2);
         }
         /**
          * @private
          */
         _removeLineData(index) {
             var floatCount = this._floatCountPerVertices * 2;
             var nextIndex = index + 1;
             var offset = index * floatCount;
             var rightPartVertices = new Float32Array(this._vertices.buffer, nextIndex * floatCount * 4, (this._lineCount - nextIndex) * floatCount);
             this._vertices.set(rightPartVertices, offset);
             this._minUpdate = Math.min(this._minUpdate, offset);
             this._maxUpdate = Math.max(this._maxUpdate, offset + floatCount);
             this._lineCount--;
         }
         /**
          * @private
          */
         _updateLineData(index, startPosition, endPosition, startColor, endColor) {
             var floatCount = this._floatCountPerVertices * 2;
             var offset = index * floatCount;
             this._updateLineVertices(offset, startPosition, endPosition, startColor, endColor);
         }
         /**
          * @private
          */
         _updateLineDatas(index, data) {
             var floatCount = this._floatCountPerVertices * 2;
             var count = data.length;
             for (var i = 0; i < count; i++) {
                 var line = data[i];
                 this._updateLineVertices((index + i) * floatCount, line.startPosition, line.endPosition, line.startColor, line.endColor);
             }
         }
         /**
          * 获取线段数据
          * @return 线段数据。
          */
         _getLineData(index, out) {
             var startPosition = out.startPosition;
             var startColor = out.startColor;
             var endPosition = out.endPosition;
             var endColor = out.endColor;
             var vertices = this._vertices;
             var offset = index * this._floatCountPerVertices * 2;
             startPosition.x = vertices[offset + 0];
             startPosition.y = vertices[offset + 1];
             startPosition.z = vertices[offset + 2];
             startColor.r = vertices[offset + 3];
             startColor.g = vertices[offset + 4];
             startColor.b = vertices[offset + 5];
             startColor.a = vertices[offset + 6];
             endPosition.x = vertices[offset + 7];
             endPosition.y = vertices[offset + 8];
             endPosition.z = vertices[offset + 9];
             endColor.r = vertices[offset + 10];
             endColor.g = vertices[offset + 11];
             endColor.b = vertices[offset + 12];
             endColor.a = vertices[offset + 13];
         }
         /**
          * @inheritDoc
          * @override
          */
         _prepareRender(state) {
             return true;
         }
         /**
          * @inheritDoc
          * @override
          */
         _render(state) {
             if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE) {
                 this._vertexBuffer.setData(this._vertices, this._minUpdate, this._minUpdate, this._maxUpdate - this._minUpdate);
                 this._minUpdate = Number.MAX_VALUE;
                 this._maxUpdate = Number.MIN_VALUE;
             }
             if (this._lineCount > 0) {
                 this._bufferState.bind();
                 LayaGL.instance.drawArrays(WebGLContext.LINES, 0, this._lineCount * 2);
                 Stat.renderBatches++;
             }
         }
         /**
          * @inheritDoc
          * @override
          */
         destroy() {
             if (this._destroyed)
                 return;
             super.destroy();
             this._bufferState.destroy();
             this._vertexBuffer.destroy();
             this._bufferState = null;
             this._vertexBuffer = null;
             this._vertices = null;
         }
     }
     /**@private */
     PixelLineFilter._type = GeometryElement._typeCounter++;

     /**
      * <code>PixelLineRenderer</code> 类用于线渲染器。
      */
     class PixelLineRenderer extends BaseRender {
         constructor(owner) {
             super(owner);
             this._projectionViewWorldMatrix = new Matrix4x4();
             this._supportOctree = false;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _calculateBoundingBox() {
             var min = this._bounds.getMin();
             min.x = -Number.MAX_VALUE;
             min.y = -Number.MAX_VALUE;
             min.z = -Number.MAX_VALUE;
             this._bounds.setMin(min);
             var max = this._bounds.getMax();
             max.x = Number.MAX_VALUE;
             max.y = Number.MAX_VALUE;
             max.z = Number.MAX_VALUE;
             this._bounds.setMax(max);
             if (Render.supportWebGLPlusCulling) { //[NATIVE]
                 var min = this._bounds.getMin();
                 var max = this._bounds.getMax();
                 var buffer = FrustumCulling._cullingBuffer;
                 buffer[this._cullingBufferIndex + 1] = min.x;
                 buffer[this._cullingBufferIndex + 2] = min.y;
                 buffer[this._cullingBufferIndex + 3] = min.z;
                 buffer[this._cullingBufferIndex + 4] = max.x;
                 buffer[this._cullingBufferIndex + 5] = max.y;
                 buffer[this._cullingBufferIndex + 6] = max.z;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _renderUpdateWithCamera(context, transform) {
             var projectionView = context.projectionViewMatrix;
             var sv = this._shaderValues;
             if (transform) {
                 var worldMat = transform.worldMatrix;
                 sv.setMatrix4x4(Sprite3D.WORLDMATRIX, worldMat);
                 Matrix4x4.multiply(projectionView, worldMat, this._projectionViewWorldMatrix);
                 sv.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix);
             }
             else {
                 sv.setMatrix4x4(Sprite3D.WORLDMATRIX, Matrix4x4.DEFAULT);
                 sv.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView);
             }
         }
     }

     /**
      * <code>PixelLineSprite3D</code> 类用于像素线渲染精灵。
      */
     class PixelLineSprite3D extends RenderableSprite3D {
         /**
          * 获取最大线数量
          * @return  最大线数量。
          */
         get maxLineCount() {
             return this._geometryFilter._maxLineCount;
         }
         /**
          * 设置最大线数量
          * @param	value 最大线数量。
          */
         set maxLineCount(value) {
             this._geometryFilter._resizeLineData(value);
             this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, value);
         }
         /**
          * 获取线数量。
          * @return 线段数量。
          */
         get lineCount() {
             return this._geometryFilter._lineCount;
         }
         /**
          * 设置获取线数量。
          * @param	value 线段数量。
          */
         set lineCount(value) {
             if (value > this.maxLineCount)
                 throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
             else
                 this._geometryFilter._lineCount = value;
         }
         /**
          * 获取line渲染器。
          * @return  line渲染器。
          */
         get pixelLineRenderer() {
             return this._render;
         }
         /**
          * 创建一个 <code>PixelLineSprite3D</code> 实例。
          * @param maxCount 最大线段数量。
          * @param name 名字。
          */
         constructor(maxCount = 2, name = null) {
             super(name);
             this._geometryFilter = new PixelLineFilter(this, maxCount);
             this._render = new PixelLineRenderer(this);
             this._changeRenderObjects(this._render, 0, PixelLineMaterial.defaultMaterial);
         }
         /**
          * @inheritDoc
          */
         _changeRenderObjects(sender, index, material) {
             var renderObjects = this._render._renderElements;
             (material) || (material = PixelLineMaterial.defaultMaterial);
             var renderElement = renderObjects[index];
             (renderElement) || (renderElement = renderObjects[index] = new RenderElement());
             renderElement.setTransform(this._transform);
             renderElement.setGeometry(this._geometryFilter);
             renderElement.render = this._render;
             renderElement.material = material;
         }
         /**
          * 增加一条线。
          * @param	startPosition  初始点位置
          * @param	endPosition	   结束点位置
          * @param	startColor	   初始点颜色
          * @param	endColor	   结束点颜色
          */
         addLine(startPosition, endPosition, startColor, endColor) {
             if (this._geometryFilter._lineCount !== this._geometryFilter._maxLineCount)
                 this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, startPosition, endPosition, startColor, endColor);
             else
                 throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
         }
         /**
          * 添加多条线段。
          * @param	lines  线段数据
          */
         addLines(lines) {
             var lineCount = this._geometryFilter._lineCount;
             var addCount = lines.length;
             if (lineCount + addCount > this._geometryFilter._maxLineCount) {
                 throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
             }
             else {
                 this._geometryFilter._updateLineDatas(lineCount, lines);
                 this._geometryFilter._lineCount += addCount;
             }
         }
         /**
          * 移除一条线段。
          * @param index 索引。
          */
         removeLine(index) {
             if (index < this._geometryFilter._lineCount)
                 this._geometryFilter._removeLineData(index);
             else
                 throw "PixelLineSprite3D: index must less than lineCount.";
         }
         /**
          * 更新线
          * @param	index  		   索引
          * @param	startPosition  初始点位置
          * @param	endPosition	   结束点位置
          * @param	startColor	   初始点颜色
          * @param	endColor	   结束点颜色
          */
         setLine(index, startPosition, endPosition, startColor, endColor) {
             if (index < this._geometryFilter._lineCount)
                 this._geometryFilter._updateLineData(index, startPosition, endPosition, startColor, endColor);
             else
                 throw "PixelLineSprite3D: index must less than lineCount.";
         }
         /**
          * 获取线段数据
          * @param out 线段数据。
          */
         getLine(index, out) {
             if (index < this.lineCount)
                 this._geometryFilter._getLineData(index, out);
             else
                 throw "PixelLineSprite3D: index must less than lineCount.";
         }
         /**
          * 清除所有线段。
          */
         clear() {
             this._geometryFilter._lineCount = 0;
         }
         /**
          * @private
          */
         _create() {
             return new PixelLineSprite3D();
         }
     }

     /**
      * @private
      * <code>RenderQuene</code> 类用于实现渲染队列。
      */
     class RenderQueue {
         /**
          * 创建一个 <code>RenderQuene</code> 实例。
          */
         constructor(isTransparent = false) {
             /** @private [只读]*/
             this.isTransparent = false;
             /** @private */
             this.elements = new Array();
             /** @private */
             this.lastTransparentRenderElement = null;
             /** @private */
             this.lastTransparentBatched = false;
             this.isTransparent = isTransparent;
         }
         /**
          * @private
          */
         _compare(left, right) {
             var renderQueue = left.material.renderQueue - right.material.renderQueue;
             if (renderQueue === 0) {
                 var sort = this.isTransparent ? right.render._distanceForSort - left.render._distanceForSort : left.render._distanceForSort - right.render._distanceForSort;
                 return sort + right.render.sortingFudge - left.render.sortingFudge;
             }
             else {
                 return renderQueue;
             }
         }
         /**
          * @private
          */
         _partitionRenderObject(left, right) {
             var pivot = this.elements[Math.floor((right + left) / 2)];
             while (left <= right) {
                 while (this._compare(this.elements[left], pivot) < 0)
                     left++;
                 while (this._compare(this.elements[right], pivot) > 0)
                     right--;
                 if (left < right) {
                     var temp = this.elements[left];
                     this.elements[left] = this.elements[right];
                     this.elements[right] = temp;
                     left++;
                     right--;
                 }
                 else if (left === right) {
                     left++;
                     break;
                 }
             }
             return left;
         }
         /**
          * @private
          */
         _quickSort(left, right) {
             if (this.elements.length > 1) {
                 var index = this._partitionRenderObject(left, right);
                 var leftIndex = index - 1;
                 if (left < leftIndex)
                     this._quickSort(left, leftIndex);
                 if (index < right)
                     this._quickSort(index, right);
             }
         }
         /**
          * @private
          */
         _render(context, isTarget) {
             for (var i = 0, n = this.elements.length; i < n; i++)
                 this.elements[i]._render(context, isTarget);
         }
         /**
          * @private
          */
         clear() {
             this.elements.length = 0;
             this.lastTransparentRenderElement = null;
             this.lastTransparentBatched = false;
         }
     }

     /**
      * <code>BoundsOctreeNode</code> 类用于创建八叉树节点。
      */
     class BoundsOctreeNode {
         /**
          * 创建一个 <code>BoundsOctreeNode</code> 实例。
          * @param octree  所属八叉树。
          * @param parent  父节点。
          * @param baseLength  节点基本长度。
          * @param center  节点的中心位置。
          */
         constructor(octree, parent, baseLength, center) {
             /**@private AABB包围盒*/
             this._bounds = new BoundBox(new Vector3(), new Vector3());
             /**@private */
             this._objects = [];
             /**@private [Debug]*/
             this._isContaion = false;
             /**@private	[只读]*/
             this.center = new Vector3();
             /**@private	[只读]*/
             this.baseLength = 0.0;
             this._setValues(octree, parent, baseLength, center);
         }
         /**
          * @private
          */
         static _encapsulates(outerBound, innerBound) {
             return CollisionUtils.boxContainsBox(outerBound, innerBound) == ContainmentType.Contains;
         }
         /**
          * @private
          */
         _setValues(octree, parent, baseLength, center) {
             this._octree = octree;
             this._parent = parent;
             this.baseLength = baseLength;
             center.cloneTo(this.center); //避免引用错乱
             var min = this._bounds.min;
             var max = this._bounds.max;
             var halfSize = (octree._looseness * baseLength) / 2;
             min.setValue(center.x - halfSize, center.y - halfSize, center.z - halfSize);
             max.setValue(center.x + halfSize, center.y + halfSize, center.z + halfSize);
         }
         /**
          * @private
          */
         _getChildBound(index) {
             if (this._children != null && this._children[index]) {
                 return this._children[index]._bounds;
             }
             else {
                 var quarter = this.baseLength / 4;
                 var halfChildSize = ((this.baseLength / 2) * this._octree._looseness) / 2;
                 var bounds = BoundsOctreeNode._tempBoundBox;
                 var min = bounds.min;
                 var max = bounds.max;
                 switch (index) {
                     case 0:
                         min.x = this.center.x - quarter - halfChildSize;
                         min.y = this.center.y + quarter - halfChildSize;
                         min.z = this.center.z - quarter - halfChildSize;
                         max.x = this.center.x - quarter + halfChildSize;
                         max.y = this.center.y + quarter + halfChildSize;
                         max.z = this.center.z - quarter + halfChildSize;
                         break;
                     case 1:
                         min.x = this.center.x + quarter - halfChildSize;
                         min.y = this.center.y + quarter - halfChildSize;
                         min.z = this.center.z - quarter - halfChildSize;
                         max.x = this.center.x + quarter + halfChildSize;
                         max.y = this.center.y + quarter + halfChildSize;
                         max.z = this.center.z - quarter + halfChildSize;
                         break;
                     case 2:
                         min.x = this.center.x - quarter - halfChildSize;
                         min.y = this.center.y + quarter - halfChildSize;
                         min.z = this.center.z + quarter - halfChildSize;
                         max.x = this.center.x - quarter + halfChildSize;
                         max.y = this.center.y + quarter + halfChildSize;
                         max.z = this.center.z + quarter + halfChildSize;
                         break;
                     case 3:
                         min.x = this.center.x + quarter - halfChildSize;
                         min.y = this.center.y + quarter - halfChildSize;
                         min.z = this.center.z + quarter - halfChildSize;
                         max.x = this.center.x + quarter + halfChildSize;
                         max.y = this.center.y + quarter + halfChildSize;
                         max.z = this.center.z + quarter + halfChildSize;
                         break;
                     case 4:
                         min.x = this.center.x - quarter - halfChildSize;
                         min.y = this.center.y - quarter - halfChildSize;
                         min.z = this.center.z - quarter - halfChildSize;
                         max.x = this.center.x - quarter + halfChildSize;
                         max.y = this.center.y - quarter + halfChildSize;
                         max.z = this.center.z - quarter + halfChildSize;
                         break;
                     case 5:
                         min.x = this.center.x + quarter - halfChildSize;
                         min.y = this.center.y - quarter - halfChildSize;
                         min.z = this.center.z - quarter - halfChildSize;
                         max.x = this.center.x + quarter + halfChildSize;
                         max.y = this.center.y - quarter + halfChildSize;
                         max.z = this.center.z - quarter + halfChildSize;
                         break;
                     case 6:
                         min.x = this.center.x - quarter - halfChildSize;
                         min.y = this.center.y - quarter - halfChildSize;
                         min.z = this.center.z + quarter - halfChildSize;
                         max.x = this.center.x - quarter + halfChildSize;
                         max.y = this.center.y - quarter + halfChildSize;
                         max.z = this.center.z + quarter + halfChildSize;
                         break;
                     case 7:
                         min.x = this.center.x + quarter - halfChildSize;
                         min.y = this.center.y - quarter - halfChildSize;
                         min.z = this.center.z + quarter - halfChildSize;
                         max.x = this.center.x + quarter + halfChildSize;
                         max.y = this.center.y - quarter + halfChildSize;
                         max.z = this.center.z + quarter + halfChildSize;
                         break;
                     default:
                 }
                 return bounds;
             }
         }
         /**
          * @private
          */
         _getChildCenter(index) {
             if (this._children != null) {
                 return this._children[index].center;
             }
             else {
                 var quarter = this.baseLength / 4;
                 var childCenter = BoundsOctreeNode._tempVector30;
                 switch (index) {
                     case 0:
                         childCenter.x = this.center.x - quarter;
                         childCenter.y = this.center.y + quarter;
                         childCenter.z = this.center.z - quarter;
                         break;
                     case 1:
                         childCenter.x = this.center.x + quarter;
                         childCenter.y = this.center.y + quarter;
                         childCenter.z = this.center.z - quarter;
                         break;
                     case 2:
                         childCenter.x = this.center.x - quarter;
                         childCenter.y = this.center.y + quarter;
                         childCenter.z = this.center.z + quarter;
                         break;
                     case 3:
                         childCenter.x = this.center.x + quarter;
                         childCenter.y = this.center.y + quarter;
                         childCenter.z = this.center.z + quarter;
                         break;
                     case 4:
                         childCenter.x = this.center.x - quarter;
                         childCenter.y = this.center.y - quarter;
                         childCenter.z = this.center.z - quarter;
                         break;
                     case 5:
                         childCenter.x = this.center.x + quarter;
                         childCenter.y = this.center.y - quarter;
                         childCenter.z = this.center.z - quarter;
                         break;
                     case 6:
                         childCenter.x = this.center.x - quarter;
                         childCenter.y = this.center.y - quarter;
                         childCenter.z = this.center.z + quarter;
                         break;
                     case 7:
                         childCenter.x = this.center.x + quarter;
                         childCenter.y = this.center.y - quarter;
                         childCenter.z = this.center.z + quarter;
                         break;
                     default:
                 }
                 return childCenter;
             }
         }
         /**
          * @private
          */
         _getChild(index) {
             var quarter = this.baseLength / 4;
             this._children || (this._children = []);
             switch (index) {
                 case 0:
                     return this._children[0] || (this._children[0] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + -quarter, this.center.y + quarter, this.center.z - quarter)));
                 case 1:
                     return this._children[1] || (this._children[1] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + quarter, this.center.y + quarter, this.center.z - quarter)));
                 case 2:
                     return this._children[2] || (this._children[2] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x - quarter, this.center.y + quarter, this.center.z + quarter)));
                 case 3:
                     return this._children[3] || (this._children[3] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + quarter, this.center.y + quarter, this.center.z + quarter)));
                 case 4:
                     return this._children[4] || (this._children[4] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x - quarter, this.center.y - quarter, this.center.z - quarter)));
                 case 5:
                     return this._children[5] || (this._children[5] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + quarter, this.center.y - quarter, this.center.z - quarter)));
                 case 6:
                     return this._children[6] || (this._children[6] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x - quarter, this.center.y - quarter, this.center.z + quarter)));
                 case 7:
                     return this._children[7] || (this._children[7] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + quarter, this.center.y - quarter, this.center.z + quarter)));
                 default:
                     throw "BoundsOctreeNode: unknown index.";
             }
         }
         /**
          * @private
          * 是否合并判断(如果该节点和子节点包含的物体小于_NUM_OBJECTS_ALLOWED则应将子节点合并到该节点)
          */
         _shouldMerge() {
             var objectCount = this._objects.length;
             for (var i = 0; i < 8; i++) {
                 var child = this._children[i];
                 if (child) {
                     if (child._children != null) //有孙子节点不合并
                         return false;
                     objectCount += child._objects.length;
                 }
             }
             return objectCount <= BoundsOctreeNode._NUM_OBJECTS_ALLOWED;
         }
         /**
          * @private
          */
         _mergeChildren() {
             for (var i = 0; i < 8; i++) {
                 var child = this._children[i];
                 if (child) {
                     child._parent = null;
                     var childObjects = child._objects;
                     for (var j = childObjects.length - 1; j >= 0; j--) {
                         var childObject = childObjects[j];
                         this._objects.push(childObject);
                         childObject._setOctreeNode(this);
                     }
                 }
             }
             this._children = null;
         }
         /**
          * @private
          */
         _merge() {
             if (this._children === null) {
                 var parent = this._parent;
                 if (parent && parent._shouldMerge()) {
                     parent._mergeChildren();
                     parent._merge();
                 }
             }
         }
         /**
          * @private
          */
         _checkAddNode(object) {
             //始终将物体放入可能的最深层子节点，如果有子节点可以跳过检查
             if (this._children == null) {
                 //如果该节点当前为末级节点,包含物体小于_NUM_OBJECTS_ALLOWED数量或不能再创建子节点,则存入该节点
                 if (this._objects.length < BoundsOctreeNode._NUM_OBJECTS_ALLOWED || (this.baseLength / 2) < this._octree._minSize) {
                     return this;
                 }
                 for (var i = this._objects.length - 1; i >= 0; i--) { //已有新子节点,检查已经存在的物体是否更适合子节点
                     var existObject = this._objects[i];
                     var fitChildIndex = this._bestFitChild(existObject.bounds.getCenter());
                     if (BoundsOctreeNode._encapsulates(this._getChildBound(fitChildIndex), existObject.bounds._getBoundBox())) {
                         this._objects.splice(this._objects.indexOf(existObject), 1); //当前节点移除
                         this._getChild(fitChildIndex)._add(existObject); //加入更深层节点
                     }
                 }
             }
             var newFitChildIndex = this._bestFitChild(object.bounds.getCenter());
             if (BoundsOctreeNode._encapsulates(this._getChildBound(newFitChildIndex), object.bounds._getBoundBox()))
                 return this._getChild(newFitChildIndex)._checkAddNode(object);
             else
                 return this;
         }
         /**
          * @private
          */
         _add(object) {
             var addNode = this._checkAddNode(object);
             addNode._objects.push(object);
             object._setOctreeNode(addNode);
         }
         /**
          * @private
          */
         _remove(object) {
             var index = this._objects.indexOf(object);
             this._objects.splice(index, 1);
             object._setOctreeNode(null);
             this._merge();
         }
         /**
          * @private
          */
         _addUp(object) {
             if ((CollisionUtils.boxContainsBox(this._bounds, object.bounds._getBoundBox()) === ContainmentType.Contains)) {
                 this._add(object);
                 return true;
             }
             else {
                 if (this._parent)
                     return this._parent._addUp(object);
                 else
                     return false;
             }
         }
         /**
          * @private
          */
         _getCollidingWithFrustum(context, frustum, testVisible, camPos, customShader, replacementTag) {
             //if (_children === null && _objects.length == 0) {//无用末级节不需要检查，调试用
             //debugger;
             //return;
             //}
             if (testVisible) {
                 var type = frustum.containsBoundBox(this._bounds);
                 Stat.octreeNodeCulling++;
                 if (type === ContainmentType.Disjoint)
                     return;
                 testVisible = (type === ContainmentType.Intersects);
             }
             this._isContaion = !testVisible; //[Debug] 用于调试信息,末级无用子节点不渲染、脱节节点看不见,所以无需更新变量
             //检查节点中的对象
             var camera = context.camera;
             var scene = context.scene;
             for (var i = 0, n = this._objects.length; i < n; i++) {
                 var render = this._objects[i];
                 if (camera._isLayerVisible(render._owner.layer) && render._enable) {
                     if (testVisible) {
                         Stat.frustumCulling++;
                         if (!render._needRender(frustum))
                             continue;
                     }
                     render._distanceForSort = Vector3.distance(render.bounds.getCenter(), camPos); //TODO:合并计算浪费,或者合并后取平均值
                     var elements = render._renderElements;
                     for (var j = 0, m = elements.length; j < m; j++) {
                         var element = elements[j];
                         element._update(scene, context, customShader, replacementTag);
                     }
                 }
             }
             //检查子节点
             if (this._children != null) {
                 for (i = 0; i < 8; i++) {
                     var child = this._children[i];
                     child && child._getCollidingWithFrustum(context, frustum, testVisible, camPos, customShader, replacementTag);
                 }
             }
         }
         /**
          * @private
          */
         _getCollidingWithBoundBox(checkBound, testVisible, result) {
             //if (_children === null && _objects.length == 0){//无用末级节不需要检查，调试用
             //debugger;
             //return;
             //}
             //检查checkBound是否部分在_bounds中
             if (testVisible) {
                 var type = CollisionUtils.boxContainsBox(this._bounds, checkBound);
                 if (type === ContainmentType.Disjoint)
                     return;
                 testVisible = (type === ContainmentType.Intersects);
             }
             //检查节点中的对象
             if (testVisible) {
                 for (var i = 0, n = this._objects.length; i < n; i++) {
                     var object = this._objects[i];
                     if (CollisionUtils.intersectsBoxAndBox(object.bounds._getBoundBox(), checkBound)) {
                         result.push(object);
                     }
                 }
             }
             //检查子节点
             if (this._children != null) {
                 for (i = 0; i < 8; i++) {
                     var child = this._children[i];
                     child._getCollidingWithBoundBox(checkBound, testVisible, result);
                 }
             }
         }
         /**
          * @private
          */
         _bestFitChild(boundCenter) {
             return (boundCenter.x <= this.center.x ? 0 : 1) + (boundCenter.y >= this.center.y ? 0 : 4) + (boundCenter.z <= this.center.z ? 0 : 2);
         }
         /**
          * @private
          * @return 是否需要扩充根节点
          */
         _update(object) {
             if (CollisionUtils.boxContainsBox(this._bounds, object.bounds._getBoundBox()) === ContainmentType.Contains) { //addDown
                 var addNode = this._checkAddNode(object);
                 if (addNode !== object._getOctreeNode()) {
                     addNode._objects.push(object);
                     object._setOctreeNode(addNode);
                     var index = this._objects.indexOf(object);
                     this._objects.splice(index, 1);
                     this._merge();
                 }
                 return true;
             }
             else { //addUp
                 if (this._parent) {
                     var sucess = this._parent._addUp(object);
                     if (sucess) { //移除成功后才缩减节点,并且在最后移除否则可能造成节点层断裂
                         index = this._objects.indexOf(object);
                         this._objects.splice(index, 1);
                         this._merge();
                     }
                     return sucess;
                 }
                 else {
                     return false;
                 }
             }
         }
         /**
          * 添加指定物体。
          * @param	object 指定物体。
          */
         add(object) {
             if (!BoundsOctreeNode._encapsulates(this._bounds, object.bounds._getBoundBox())) //如果不包含,直接return false
                 return false;
             this._add(object);
             return true;
         }
         /**
          * 移除指定物体。
          * @param	obejct 指定物体。
          * @return 是否成功。
          */
         remove(object) {
             if (object._getOctreeNode() !== this)
                 return false;
             this._remove(object);
             return true;
         }
         /**
          * 更新制定物体，
          * @param	obejct 指定物体。
          * @return 是否成功。
          */
         update(object) {
             if (object._getOctreeNode() !== this)
                 return false;
             return this._update(object);
         }
         /**
          * 	收缩八叉树节点。
          *	-所有物体都在根节点的八分之一区域
          * 	-该节点无子节点或有子节点但1/8的子节点不包含物体
          *	@param minLength 最小尺寸。
          * 	@return 新的根节点。
          */
         shrinkIfPossible(minLength) {
             if (this.baseLength < minLength * 2) //该节点尺寸大于等于minLength*2才收缩
                 return this;
             //检查根节点的物体
             var bestFit = -1;
             for (var i = 0, n = this._objects.length; i < n; i++) {
                 var object = this._objects[i];
                 var newBestFit = this._bestFitChild(object.bounds.getCenter());
                 if (i == 0 || newBestFit == bestFit) { //判断所有的物理是否在同一个子节点中
                     var childBounds = this._getChildBound(newBestFit);
                     if (BoundsOctreeNode._encapsulates(childBounds, object.bounds._getBoundBox()))
                         (i == 0) && (bestFit = newBestFit);
                     else //不能缩减,适合位置的子节点不能全包
                         return this;
                 }
                 else { //不在同一个子节点不能缩减
                     return this;
                 }
             }
             // 检查子节点的物体是否在同一缩减区域
             if (this._children != null) {
                 var childHadContent = false;
                 for (i = 0, n = this._children.length; i < n; i++) {
                     var child = this._children[i];
                     if (child && child.hasAnyObjects()) {
                         if (childHadContent)
                             return this; // 大于等于两个子节点有物体,不能缩减
                         if (bestFit >= 0 && bestFit != i)
                             return this; //包含物体的子节点并非最佳索引,不能缩减
                         childHadContent = true;
                         bestFit = i;
                     }
                 }
             }
             else {
                 if (bestFit != -1) { //无子节点,直接缩减本节点
                     var childCenter = this._getChildCenter(bestFit);
                     this._setValues(this._octree, null, this.baseLength / 2, childCenter);
                 }
                 return this;
             }
             if (bestFit != -1) {
                 var newRoot = this._children[bestFit]; //用合适的子节点作为新的根节点,bestFit!=-1,_children[bestFit]一定有值
                 newRoot._parent = null; //根节点需要置空父节点
                 return newRoot;
             }
             else { // 整个节点包括子节点没有物体
                 return this;
             }
         }
         /**
          * 检查该节点和其子节点是否包含任意物体。
          * @return 是否包含任意物体。
          */
         hasAnyObjects() {
             if (this._objects.length > 0)
                 return true;
             if (this._children != null) {
                 for (var i = 0; i < 8; i++) {
                     var child = this._children[i];
                     if (child && child.hasAnyObjects())
                         return true;
                 }
             }
             return false;
         }
         /**
          * 获取与指定包围盒相交的物体列表。
          * @param checkBound AABB包围盒。
          * @param result 相交物体列表
          */
         getCollidingWithBoundBox(checkBound, result) {
             this._getCollidingWithBoundBox(checkBound, true, result);
         }
         /**
          *	获取与指定射线相交的的物理列表。
          * 	@param	ray 射线。
          * 	@param	result 相交物体列表。
          * 	@param	maxDistance 射线的最大距离。
          */
         getCollidingWithRay(ray, result, maxDistance = Number.MAX_VALUE) {
             var distance = CollisionUtils.intersectsRayAndBoxRD(ray, this._bounds);
             if (distance == -1 || distance > maxDistance)
                 return;
             //检查节点中的对象
             for (var i = 0, n = this._objects.length; i < n; i++) {
                 var object = this._objects[i];
                 distance = CollisionUtils.intersectsRayAndBoxRD(ray, object.bounds._getBoundBox());
                 if (distance !== -1 && distance <= maxDistance)
                     result.push(object);
             }
             //检查子节点
             if (this._children != null) {
                 for (i = 0; i < 8; i++) {
                     var child = this._children[i];
                     child.getCollidingWithRay(ray, result, maxDistance);
                 }
             }
         }
         /**
          *	获取与指定视锥相交的的物理列表。
          * 	@param	ray 射线。.
          * 	@param	result 相交物体列表。
          */
         getCollidingWithFrustum(context, customShader, replacementTag) {
             var cameraPos = context.camera.transform.position;
             var boundFrustum = context.camera.boundFrustum;
             this._getCollidingWithFrustum(context, boundFrustum, true, cameraPos, customShader, replacementTag);
         }
         /**
          * 获取是否与指定包围盒相交。
          * @param checkBound AABB包围盒。
          * @return 是否相交。
          */
         isCollidingWithBoundBox(checkBound) {
             //检查checkBound是否部分在_bounds中
             if (!(CollisionUtils.intersectsBoxAndBox(this._bounds, checkBound)))
                 return false;
             //检查节点中的对象
             for (var i = 0, n = this._objects.length; i < n; i++) {
                 var object = this._objects[i];
                 if (CollisionUtils.intersectsBoxAndBox(object.bounds._getBoundBox(), checkBound))
                     return true;
             }
             //检查子节点
             if (this._children != null) {
                 for (i = 0; i < 8; i++) {
                     var child = this._children[i];
                     if (child.isCollidingWithBoundBox(checkBound))
                         return true;
                 }
             }
             return false;
         }
         /**
          *	获取是否与指定射线相交。
          * 	@param	ray 射线。
          * 	@param	maxDistance 射线的最大距离。
          *  @return 是否相交。
          */
         isCollidingWithRay(ray, maxDistance = Number.MAX_VALUE) {
             var distance = CollisionUtils.intersectsRayAndBoxRD(ray, this._bounds);
             if (distance == -1 || distance > maxDistance)
                 return false;
             //检查节点中的对象
             for (var i = 0, n = this._objects.length; i < n; i++) {
                 var object = this._objects[i];
                 distance = CollisionUtils.intersectsRayAndBoxRD(ray, object.bounds._getBoundBox());
                 if (distance !== -1 && distance <= maxDistance)
                     return true;
             }
             //检查子节点
             if (this._children != null) {
                 for (i = 0; i < 8; i++) {
                     var child = this._children[i];
                     if (child.isCollidingWithRay(ray, maxDistance))
                         return true;
                 }
             }
             return false;
         }
         /**
          * 获取包围盒。
          */
         getBound() {
             return this._bounds;
         }
         /**
          * @private
          * [Debug]
          */
         drawAllBounds(debugLine, currentDepth, maxDepth) {
             if (this._children === null && this._objects.length == 0) //无用末级节不需要渲染
                 return;
             currentDepth++;
             var color = BoundsOctreeNode._tempColor0;
             if (this._isContaion) {
                 color.r = 0.0;
                 color.g = 0.0;
                 color.b = 1.0;
             }
             else {
                 var tint = maxDepth ? currentDepth / maxDepth : 0;
                 color.r = 1.0 - tint;
                 color.g = tint;
                 color.b = 0.0;
             }
             color.a = 0.3;
             Utils3D._drawBound(debugLine, this._bounds, color);
             if (this._children != null) {
                 for (var i = 0; i < 8; i++) {
                     var child = this._children[i];
                     child && child.drawAllBounds(debugLine, currentDepth, maxDepth);
                 }
             }
         }
         /**
          * @private
          * [Debug]
          */
         drawAllObjects(debugLine, currentDepth, maxDepth) {
             currentDepth++;
             var color = BoundsOctreeNode._tempColor0;
             if (this._isContaion) {
                 color.r = 0.0;
                 color.g = 0.0;
                 color.b = 1.0;
             }
             else {
                 var tint = maxDepth ? currentDepth / maxDepth : 0;
                 color.r = 1.0 - tint;
                 color.g = tint;
                 color.b = 0.0;
             }
             color.a = 1.0;
             for (var i = 0, n = this._objects.length; i < n; i++)
                 Utils3D._drawBound(debugLine, this._objects[i].bounds._getBoundBox(), color);
             if (this._children != null) {
                 for (i = 0; i < 8; i++) {
                     var child = this._children[i];
                     child && child.drawAllObjects(debugLine, currentDepth, maxDepth);
                 }
             }
         }
     }
     /**@private */
     BoundsOctreeNode._tempVector3 = new Vector3();
     /**@private */
     BoundsOctreeNode._tempVector30 = new Vector3();
     /**@private */
     BoundsOctreeNode._tempVector31 = new Vector3();
     /**@private */
     BoundsOctreeNode._tempColor0 = new Color();
     /**@private */
     BoundsOctreeNode._tempBoundBox = new BoundBox(new Vector3(), new Vector3());
     /**@private */
     BoundsOctreeNode._NUM_OBJECTS_ALLOWED = 8;

     /**
      * <code>OctreeMotionList</code> 类用于实现物理更新队列。
      */
     class OctreeMotionList extends SingletonList {
         /**
          * 创建一个新的 <code>OctreeMotionList</code> 实例。
          */
         constructor() {
             super();
         }
         /**
          * @private
          */
         add(element) {
             var index = element._getIndexInMotionList();
             if (index !== -1)
                 throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
             this._add(element);
             element._setIndexInMotionList(this.length++);
         }
         /**
          * @private
          */
         remove(element) {
             var index = element._getIndexInMotionList();
             this.length--;
             if (index !== this.length) {
                 var end = this.elements[this.length];
                 this.elements[index] = end;
                 end._setIndexInMotionList(index);
             }
             element._setIndexInMotionList(-1);
         }
     }

     /**
      * <code>BoundsOctree</code> 类用于创建八叉树。
      */
     class BoundsOctree {
         /**
          * 创建一个 <code>BoundsOctree</code> 实例。
          * @param	initialWorldSize 八叉树尺寸
          * @param	initialWorldPos 八叉树中心
          * @param	minNodeSize  节点最小尺寸
          * @param	loosenessVal 松散值
          */
         constructor(initialWorldSize, initialWorldPos, minNodeSize, looseness) {
             /**@private */
             this._motionObjects = new OctreeMotionList();
             /**@private [只读]*/
             this.count = 0;
             if (minNodeSize > initialWorldSize) {
                 console.warn("Minimum node size must be at least as big as the initial world size. Was: " + minNodeSize + " Adjusted to: " + initialWorldSize);
                 minNodeSize = initialWorldSize;
             }
             this._initialSize = initialWorldSize;
             this._minSize = minNodeSize;
             this._looseness = Math.min(Math.max(looseness, 1.0), 2.0);
             this._rootNode = new BoundsOctreeNode(this, null, initialWorldSize, initialWorldPos);
         }
         /**
          * @private
          */
         _getMaxDepth(node, depth) {
             depth++;
             var children = node._children;
             if (children != null) {
                 var curDepth = depth;
                 for (var i = 0, n = children.length; i < n; i++) {
                     var child = children[i];
                     child && (depth = Math.max(this._getMaxDepth(child, curDepth), depth));
                 }
             }
             return depth;
         }
         /**
          * @private
          */
         _grow(growObjectCenter) {
             var xDirection = growObjectCenter.x >= 0 ? 1 : -1;
             var yDirection = growObjectCenter.y >= 0 ? 1 : -1;
             var zDirection = growObjectCenter.z >= 0 ? 1 : -1;
             var oldRoot = this._rootNode;
             var half = this._rootNode.baseLength / 2;
             var newLength = this._rootNode.baseLength * 2;
             var rootCenter = this._rootNode.center;
             var newCenter = new Vector3(rootCenter.x + xDirection * half, rootCenter.y + yDirection * half, rootCenter.z + zDirection * half);
             //创建新的八叉树根节点
             this._rootNode = new BoundsOctreeNode(this, null, newLength, newCenter);
             if (oldRoot.hasAnyObjects()) {
                 var rootPos = this._rootNode._bestFitChild(oldRoot.center);
                 var children = [];
                 for (var i = 0; i < 8; i++) {
                     if (i == rootPos) {
                         oldRoot._parent = this._rootNode;
                         children[i] = oldRoot;
                     }
                 }
                 // Attach the new children to the new root node
                 this._rootNode._children = children;
             }
         }
         /**
          * 添加物体
          * @param	object
          */
         add(object) {
             var count = 0;
             while (!this._rootNode.add(object)) {
                 var growCenter = BoundsOctree._tempVector30;
                 Vector3.subtract(object.bounds.getCenter(), this._rootNode.center, growCenter);
                 this._grow(growCenter);
                 if (++count > 20) {
                     throw "Aborted Add operation as it seemed to be going on forever (" + (count - 1) + ") attempts at growing the octree.";
                 }
             }
             this.count++;
         }
         /**
          * 移除物体
          * @return 是否成功
          */
         remove(object) {
             var removed = object._getOctreeNode().remove(object);
             if (removed) {
                 this.count--;
             }
             return removed;
         }
         /**
          * 更新物体
          */
         update(object) {
             var count = 0;
             var octreeNode = object._getOctreeNode();
             if (octreeNode) {
                 while (!octreeNode._update(object)) {
                     var growCenter = BoundsOctree._tempVector30;
                     Vector3.subtract(object.bounds.getCenter(), this._rootNode.center, growCenter);
                     this._grow(growCenter);
                     if (++count > 20) {
                         throw "Aborted Add operation as it seemed to be going on forever (" + (count - 1) + ") attempts at growing the octree.";
                     }
                 }
                 return true;
             }
             else { //节点从场景中移除时octreeNode为空
                 return false;
             }
         }
         /**
          * 如果可能则收缩根节点。
          */
         shrinkRootIfPossible() {
             this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize);
         }
         /**
          * 添加运动物体。
          * @param 运动物体。
          */
         addMotionObject(object) {
             this._motionObjects.add(object);
         }
         /**
          * 移除运动物体。
          * @param 运动物体。
          */
         removeMotionObject(object) {
             this._motionObjects.remove(object);
         }
         /**
          * 更新所有运动物体。
          */
         updateMotionObjects() {
             var elements = this._motionObjects.elements;
             for (var i = 0, n = this._motionObjects.length; i < n; i++) {
                 var object = elements[i];
                 this.update(object);
                 object._setIndexInMotionList(-1);
             }
             this._motionObjects.length = 0;
         }
         /**
          * 获取是否与指定包围盒相交。
          * @param checkBound AABB包围盒。
          * @return 是否相交。
          */
         isCollidingWithBoundBox(checkBounds) {
             return this._rootNode.isCollidingWithBoundBox(checkBounds);
         }
         /**
          *	获取是否与指定射线相交。
          * 	@param	ray 射线。
          * 	@param	maxDistance 射线的最大距离。
          *  @return 是否相交。
          */
         isCollidingWithRay(ray, maxDistance = Number.MAX_VALUE) {
             return this._rootNode.isCollidingWithRay(ray, maxDistance);
         }
         /**
          * 获取与指定包围盒相交的物体列表。
          * @param checkBound AABB包围盒。
          * @param result 相交物体列表
          */
         getCollidingWithBoundBox(checkBound, result) {
             this._rootNode.getCollidingWithBoundBox(checkBound, result);
         }
         /**
          *	获取与指定射线相交的的物理列表。
          * 	@param	ray 射线。
          * 	@param	result 相交物体列表。
          * 	@param	maxDistance 射线的最大距离。
          */
         getCollidingWithRay(ray, result, maxDistance = Number.MAX_VALUE) {
             this._rootNode.getCollidingWithRay(ray, result, maxDistance);
         }
         /**
          *	获取与指定视锥相交的的物理列表。
          *  @param 渲染上下文。
          */
         getCollidingWithFrustum(context, shader, replacementTag) {
             this._rootNode.getCollidingWithFrustum(context, shader, replacementTag);
         }
         /**
          * 获取最大包围盒
          * @return 最大包围盒
          */
         getMaxBounds() {
             return this._rootNode.getBound();
         }
         /**
          * @private
          * [Debug]
          */
         drawAllBounds(pixelLine) {
             var maxDepth = this._getMaxDepth(this._rootNode, -1);
             this._rootNode.drawAllBounds(pixelLine, -1, maxDepth);
         }
         /**
          * @private
          * [Debug]
          */
         drawAllObjects(pixelLine) {
             var maxDepth = this._getMaxDepth(this._rootNode, -1);
             this._rootNode.drawAllObjects(pixelLine, -1, maxDepth);
         }
     }
     /**@private */
     BoundsOctree._tempVector30 = new Vector3();

     /**
      * <code>Scene3D</code> 类用于实现场景。
      */
     class Scene3D extends Sprite {
         /**
          * 创建一个 <code>Scene3D</code> 实例。
          */
         constructor() {
             super();
             /** @private */
             this._lights = [];
             /** @private */
             this._lightmaps = [];
             /** @private */
             this._skyRenderer = new SkyRenderer();
             /** @private */
             this._reflectionMode = 1;
             /** @private */
             this._enableLightCount = 3;
             /**@private */
             this._input = new Input3D();
             /**@private */
             this._timer = Laya.timer;
             /** @private 只读,不允许修改。*/
             this._collsionTestList = [];
             /** @private */
             this._renders = new SimpleSingletonList();
             /** @private */
             this._opaqueQueue = new RenderQueue(false);
             /** @private */
             this._transparentQueue = new RenderQueue(true);
             /** @private 相机的对象池*/
             this._cameraPool = [];
             /**@private */
             this._animatorPool = new SimpleSingletonList();
             /**@private */
             this._scriptPool = new Array();
             /**@private */
             this._tempScriptPool = new Array();
             /**@private */
             this._needClearScriptPool = false;
             /** @private */
             this._castShadowRenders = new CastShadowList();
             /** 当前创建精灵所属遮罩层。*/
             this.currentCreationLayer = Math.pow(2, 0);
             /** 是否启用灯光。*/
             this.enableLight = true;
             /**@private */
             this._key = new SubmitKey();
             this._time = 0;
             /**@private [Editer]*/
             this._pickIdToSprite = new Object();
             if (Physics._enbalePhysics)
                 this._physicsSimulation = new PhysicsSimulation(Scene3D.physicsSettings);
             this._shaderValues = new ShaderData(null);
             this.parallelSplitShadowMaps = [];
             this.enableFog = false;
             this.fogStart = 300;
             this.fogRange = 1000;
             this.fogColor = new Vector3(0.7, 0.7, 0.7);
             this.ambientColor = new Vector3(0.212, 0.227, 0.259);
             this.reflectionIntensity = 1.0;
             (WebGL.shaderHighPrecision) && (this._shaderValues.addDefine(Shader3D.SHADERDEFINE_HIGHPRECISION));
             if (Render.supportWebGLPlusCulling) { //[NATIVE]
                 this._cullingBufferIndices = new Int32Array(1024);
                 this._cullingBufferResult = new Int32Array(1024);
             }
             this._shaderValues.setTexture(Scene3D.RANGEATTENUATIONTEXTURE, ShaderInit3D._rangeAttenTex);
             //var angleAttenTex:Texture2D = Texture2D.buildTexture2D(64, 64, BaseTexture.FORMAT_Alpha8, TextureGenerator.haloTexture);
             //_shaderValues.setTexture(Scene3D.ANGLEATTENUATIONTEXTURE, angleAttenTex);
             this._scene = this;
             this._input.__init__(Render.canvas, this);
             if (Scene3D.octreeCulling) {
                 this._octree = new BoundsOctree(Scene3D.octreeInitialSize, Scene3D.octreeInitialCenter, Scene3D.octreeMinNodeSize, Scene3D.octreeLooseness);
             }
             if (FrustumCulling.debugFrustumCulling) {
                 this._debugTool = new PixelLineSprite3D();
                 var lineMaterial = new PixelLineMaterial();
                 lineMaterial.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT;
                 lineMaterial.alphaTest = false;
                 lineMaterial.depthWrite = false;
                 lineMaterial.cull = RenderState.CULL_BACK;
                 lineMaterial.blend = RenderState.BLEND_ENABLE_ALL;
                 lineMaterial.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                 lineMaterial.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                 lineMaterial.depthTest = RenderState.DEPTHTEST_LESS;
                 this._debugTool.pixelLineRenderer.sharedMaterial = lineMaterial;
             }
         }
         /**
          * @private
          */
         static __init__() {
             Scene3DShaderDeclaration.SHADERDEFINE_FOG = Shader3D.registerPublicDefine("FOG");
             Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT = Shader3D.registerPublicDefine("DIRECTIONLIGHT");
             Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT = Shader3D.registerPublicDefine("POINTLIGHT");
             Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT = Shader3D.registerPublicDefine("SPOTLIGHT");
             Scene3DShaderDeclaration.SHADERDEFINE_CAST_SHADOW = Shader3D.registerPublicDefine("CASTSHADOW");
             Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1 = Shader3D.registerPublicDefine("SHADOWMAP_PSSM1");
             Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2 = Shader3D.registerPublicDefine("SHADOWMAP_PSSM2");
             Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3 = Shader3D.registerPublicDefine("SHADOWMAP_PSSM3");
             Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO = Shader3D.registerPublicDefine("SHADOWMAP_PCF_NO");
             Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1 = Shader3D.registerPublicDefine("SHADOWMAP_PCF1");
             Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2 = Shader3D.registerPublicDefine("SHADOWMAP_PCF2");
             Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3 = Shader3D.registerPublicDefine("SHADOWMAP_PCF3");
             Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP = Shader3D.registerPublicDefine("REFLECTMAP");
         }
         /**
          * 加载场景,注意:不缓存。
          * @param url 模板地址。
          * @param complete 完成回调。
          */
         static load(url, complete) {
             Laya.loader.create(url, complete, null, Scene3D.HIERARCHY);
         }
         /**
          * @private
          * [Editer]
          */
         _allotPickColorByID(id, pickColor) {
             var pickColorR = Math.floor(id / (255 * 255));
             id -= pickColorR * 255 * 255;
             var pickColorG = Math.floor(id / 255);
             id -= pickColorG * 255;
             var pickColorB = id;
             pickColor.x = pickColorR / 255;
             pickColor.y = pickColorG / 255;
             pickColor.z = pickColorB / 255;
             pickColor.w = 1.0;
         }
         /**
          * @private
          * [Editer]
          */
         _searchIDByPickColor(pickColor) {
             var id = pickColor.x * 255 * 255 + pickColor.y * 255 + pickColor.z;
             return id;
         }
         /**
          * 获取资源的URL地址。
          * @return URL地址。
          */
         get url() {
             return this._url;
         }
         /**
          * 获取是否允许雾化。
          * @return 是否允许雾化。
          */
         get enableFog() {
             return this._enableFog;
         }
         /**
          * 设置是否允许雾化。
          * @param value 是否允许雾化。
          */
         set enableFog(value) {
             if (this._enableFog !== value) {
                 this._enableFog = value;
                 if (value) {
                     this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG);
                 }
                 else
                     this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG);
             }
         }
         /**
          * 获取雾化颜色。
          * @return 雾化颜色。
          */
         get fogColor() {
             return this._shaderValues.getVector3(Scene3D.FOGCOLOR);
         }
         /**
          * 设置雾化颜色。
          * @param value 雾化颜色。
          */
         set fogColor(value) {
             this._shaderValues.setVector3(Scene3D.FOGCOLOR, value);
         }
         /**
          * 获取雾化起始位置。
          * @return 雾化起始位置。
          */
         get fogStart() {
             return this._shaderValues.getNumber(Scene3D.FOGSTART);
         }
         /**
          * 设置雾化起始位置。
          * @param value 雾化起始位置。
          */
         set fogStart(value) {
             this._shaderValues.setNumber(Scene3D.FOGSTART, value);
         }
         /**
          * 获取雾化范围。
          * @return 雾化范围。
          */
         get fogRange() {
             return this._shaderValues.getNumber(Scene3D.FOGRANGE);
         }
         /**
          * 设置雾化范围。
          * @param value 雾化范围。
          */
         set fogRange(value) {
             this._shaderValues.setNumber(Scene3D.FOGRANGE, value);
         }
         /**
          * 获取环境光颜色。
          * @return 环境光颜色。
          */
         get ambientColor() {
             return this._shaderValues.getVector3(Scene3D.AMBIENTCOLOR);
         }
         /**
          * 设置环境光颜色。
          * @param value 环境光颜色。
          */
         set ambientColor(value) {
             this._shaderValues.setVector3(Scene3D.AMBIENTCOLOR, value);
         }
         /**
          * 获取天空渲染器。
          * @return 天空渲染器。
          */
         get skyRenderer() {
             return this._skyRenderer;
         }
         /**
          * 获取反射贴图。
          * @return 反射贴图。
          */
         get customReflection() {
             return this._shaderValues.getTexture(Scene3D.REFLECTIONTEXTURE);
         }
         /**
          * 设置反射贴图。
          * @param 反射贴图。
          */
         set customReflection(value) {
             this._shaderValues.setTexture(Scene3D.REFLECTIONTEXTURE, value);
             if (value)
                 this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP);
             else
                 this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP);
         }
         /**
          * 获取反射强度。
          * @return 反射强度。
          */
         get reflectionIntensity() {
             return this._shaderValues.getNumber(Scene3D.REFLETIONINTENSITY);
         }
         /**
          * 设置反射强度。
          * @param 反射强度。
          */
         set reflectionIntensity(value) {
             value = Math.max(Math.min(value, 1.0), 0.0);
             this._shaderValues.setNumber(Scene3D.REFLETIONINTENSITY, value);
         }
         /**
          * 获取物理模拟器。
          * @return 物理模拟器。
          */
         get physicsSimulation() {
             return this._physicsSimulation;
         }
         /**
          * 获取反射模式。
          * @return 反射模式。
          */
         get reflectionMode() {
             return this._reflectionMode;
         }
         /**
          * 设置反射模式。
          * @param value 反射模式。
          */
         set reflectionMode(value) {
             this._reflectionMode = value;
         }
         /**
          * 获取场景时钟。
          */
         /*override*/ get timer() {
             return this._timer;
         }
         /**
          * 设置场景时钟。
          */
         set timer(value) {
             this._timer = value;
         }
         /**
          *	获取输入。
          * 	@return  输入。
          */
         get input() {
             return this._input;
         }
         /**
          * @private
          */
         _setLightmapToChildNode(sprite) {
             if (sprite instanceof RenderableSprite3D)
                 sprite._render._applyLightMapParams();
             var children = sprite._children;
             for (var i = 0, n = children.length; i < n; i++)
                 this._setLightmapToChildNode(children[i]);
         }
         /**
          *@private
          */
         _update() {
             var delta = this.timer._delta / 1000;
             this._time += delta;
             this._shaderValues.setNumber(Scene3D.TIME, this._time);
             var simulation = this._physicsSimulation;
             if (Physics._enbalePhysics && !PhysicsSimulation.disableSimulation) {
                 simulation._updatePhysicsTransformFromRender();
                 PhysicsComponent._addUpdateList = false; //物理模拟器会触发_updateTransformComponent函数,不加入更新队列
                 //simulate physics
                 simulation._simulate(delta);
                 //update character sprite3D transforms from physics engine simulation
                 simulation._updateCharacters();
                 PhysicsComponent._addUpdateList = true;
                 //handle frame contacts
                 simulation._updateCollisions();
                 //send contact events
                 simulation._eventScripts();
             }
             this._input._update();
             this._clearScript();
             this._updateScript();
             Animator._update(this);
             this._lateUpdateScript();
         }
         /**
          * @private
          */
         _binarySearchIndexInCameraPool(camera) {
             var start = 0;
             var end = this._cameraPool.length - 1;
             var mid;
             while (start <= end) {
                 mid = Math.floor((start + end) / 2);
                 var midValue = this._cameraPool[mid]._renderingOrder;
                 if (midValue == camera._renderingOrder)
                     return mid;
                 else if (midValue > camera._renderingOrder)
                     end = mid - 1;
                 else
                     start = mid + 1;
             }
             return start;
         }
         /**
          * @private
          */
         _setCreateURL(url) {
             this._url = URL.formatURL(url);
         }
         /**
          * @private
          */
         _getGroup() {
             return this._group;
         }
         /**
          * @private
          */
         _setGroup(value) {
             this._group = value;
         }
         /**
          * @private
          */
         _clearScript() {
             if (this._needClearScriptPool) {
                 var scripts = this._scriptPool;
                 for (var i = 0, n = scripts.length; i < n; i++) {
                     var script = scripts[i];
                     if (script) {
                         script._indexInPool = this._tempScriptPool.length;
                         this._tempScriptPool.push(script);
                     }
                 }
                 this._scriptPool = this._tempScriptPool;
                 scripts.length = 0;
                 this._tempScriptPool = scripts;
                 this._needClearScriptPool = false;
             }
         }
         /**
          * @private
          */
         _updateScript() {
             var scripts = this._scriptPool;
             for (var i = 0, n = scripts.length; i < n; i++) {
                 var script = scripts[i];
                 (script && script.enabled) && (script.onUpdate());
             }
         }
         /**
          * @private
          */
         _lateUpdateScript() {
             var scripts = this._scriptPool;
             for (var i = 0, n = scripts.length; i < n; i++) {
                 var script = scripts[i];
                 (script && script.enabled) && (script.onLateUpdate());
             }
         }
         /**
          * @private
          */
         _addScript(script) {
             var scripts = this._scriptPool;
             script._indexInPool = scripts.length;
             scripts.push(script);
         }
         /**
          * @private
          */
         _removeScript(script) {
             this._scriptPool[script._indexInPool] = null;
             script._indexInPool = -1;
             this._needClearScriptPool = true;
         }
         /**
          * @private
          */
         _preRenderScript() {
             var scripts = this._scriptPool;
             for (var i = 0, n = scripts.length; i < n; i++) {
                 var script = scripts[i];
                 (script && script.enabled) && (script.onPreRender());
             }
         }
         /**
          * @private
          */
         _postRenderScript() {
             var scripts = this._scriptPool;
             for (var i = 0, n = scripts.length; i < n; i++) {
                 var script = scripts[i];
                 (script && script.enabled) && (script.onPostRender());
             }
         }
         /**
          * @private
          */
         _prepareSceneToRender() {
             var lightCount = this._lights.length;
             if (lightCount > 0) {
                 var renderLightCount = 0;
                 for (var i = 0; i < lightCount; i++) {
                     if (!this._lights[i]._prepareToScene()) //TODO:应该直接移除
                         continue;
                     renderLightCount++;
                     if (renderLightCount >= this._enableLightCount)
                         break;
                 }
             }
         }
         /**
          * @private
          */
         _addCamera(camera) {
             var index = this._binarySearchIndexInCameraPool(camera);
             var order = camera._renderingOrder;
             var count = this._cameraPool.length;
             while (index < count && this._cameraPool[index]._renderingOrder <= order)
                 index++;
             this._cameraPool.splice(index, 0, camera);
         }
         /**
          * @private
          */
         _removeCamera(camera) {
             this._cameraPool.splice(this._cameraPool.indexOf(camera), 1);
         }
         /**
          * @private
          */
         _preCulling(context, camera, shader, replacementTag) {
             FrustumCulling.renderObjectCulling(camera, this, context, this._renders, shader, replacementTag);
         }
         /**
          * @private
          */
         _clear(gl, state) {
             var viewport = state.viewport;
             var camera = state.camera;
             var renderTexture = camera._renderTexture || camera._offScreenRenderTexture;
             var vpW = viewport.width;
             var vpH = viewport.height;
             var vpX = viewport.x;
             var vpY = camera._getCanvasHeight() - viewport.y - vpH;
             gl.viewport(vpX, vpY, vpW, vpH);
             var flag;
             var clearFlag = camera.clearFlag;
             if (clearFlag === BaseCamera.CLEARFLAG_SKY && !(camera.skyRenderer._isAvailable() || this._skyRenderer._isAvailable()))
                 clearFlag = BaseCamera.CLEARFLAG_SOLIDCOLOR;
             switch (clearFlag) {
                 case BaseCamera.CLEARFLAG_SOLIDCOLOR:
                     var clearColor = camera.clearColor;
                     gl.enable(WebGLContext.SCISSOR_TEST);
                     gl.scissor(vpX, vpY, vpW, vpH);
                     if (clearColor)
                         gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                     else
                         gl.clearColor(0, 0, 0, 0);
                     if (renderTexture) {
                         flag = WebGLContext.COLOR_BUFFER_BIT;
                         switch (renderTexture.depthStencilFormat) {
                             case BaseTexture.FORMAT_DEPTH_16:
                                 flag |= WebGLContext.DEPTH_BUFFER_BIT;
                                 break;
                             case BaseTexture.FORMAT_STENCIL_8:
                                 flag |= WebGLContext.STENCIL_BUFFER_BIT;
                                 break;
                             case BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                                 flag |= WebGLContext.DEPTH_BUFFER_BIT;
                                 flag |= WebGLContext.STENCIL_BUFFER_BIT;
                                 break;
                         }
                     }
                     else {
                         flag = WebGLContext.COLOR_BUFFER_BIT | WebGLContext.DEPTH_BUFFER_BIT;
                     }
                     WebGLContext.setDepthMask(gl, true);
                     gl.clear(flag);
                     gl.disable(WebGLContext.SCISSOR_TEST);
                     break;
                 case BaseCamera.CLEARFLAG_SKY:
                 case BaseCamera.CLEARFLAG_DEPTHONLY:
                     gl.enable(WebGLContext.SCISSOR_TEST);
                     gl.scissor(vpX, vpY, vpW, vpH);
                     if (renderTexture) {
                         switch (renderTexture.depthStencilFormat) {
                             case BaseTexture.FORMAT_DEPTH_16:
                                 flag = WebGLContext.DEPTH_BUFFER_BIT;
                                 break;
                             case BaseTexture.FORMAT_STENCIL_8:
                                 flag = WebGLContext.STENCIL_BUFFER_BIT;
                                 break;
                             case BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                                 flag = WebGLContext.DEPTH_BUFFER_BIT | WebGLContext.STENCIL_BUFFER_BIT;
                                 break;
                         }
                     }
                     else {
                         flag = WebGLContext.DEPTH_BUFFER_BIT;
                     }
                     WebGLContext.setDepthMask(gl, true);
                     gl.clear(flag);
                     gl.disable(WebGLContext.SCISSOR_TEST);
                     break;
                 case BaseCamera.CLEARFLAG_NONE:
                     break;
                 default:
                     throw new Error("BaseScene:camera clearFlag invalid.");
             }
         }
         /**
          * @private
          */
         _renderScene(context) {
             var camera = context.camera;
             var renderTar = camera._renderTexture || camera._offScreenRenderTexture;
             renderTar ? this._opaqueQueue._render(context, true) : this._opaqueQueue._render(context, false); //非透明队列
             if (camera.clearFlag === BaseCamera.CLEARFLAG_SKY) {
                 if (camera.skyRenderer._isAvailable())
                     camera.skyRenderer._render(context);
                 else if (this._skyRenderer._isAvailable())
                     this._skyRenderer._render(context);
             }
             renderTar ? this._transparentQueue._render(context, true) : this._transparentQueue._render(context, false); //透明队列
             if (FrustumCulling.debugFrustumCulling) {
                 var renderElements = this._debugTool._render._renderElements;
                 for (var i = 0, n = renderElements.length; i < n; i++) {
                     renderElements[i]._update(this, context, null, null);
                     renderElements[i]._render(context, false);
                 }
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             var lightMapsData = data.lightmaps;
             if (lightMapsData) {
                 var lightMapCount = lightMapsData.length;
                 var lightmaps = [];
                 for (var i = 0; i < lightMapCount; i++)
                     lightmaps[i] = Loader.getRes(lightMapsData[i].path);
                 this.setlightmaps(lightmaps);
             }
             var ambientColorData = data.ambientColor;
             if (ambientColorData) {
                 var ambCol = this.ambientColor;
                 ambCol.fromArray(ambientColorData);
                 this.ambientColor = ambCol;
             }
             var skyData = data.sky;
             if (skyData) {
                 this._skyRenderer.material = Loader.getRes(skyData.material.path);
                 switch (skyData.mesh) {
                     case "SkyBox":
                         this._skyRenderer.mesh = SkyBox.instance;
                         break;
                     case "SkyDome":
                         this._skyRenderer.mesh = SkyDome.instance;
                         break;
                     default:
                         this.skyRenderer.mesh = SkyBox.instance;
                 }
             }
             var reflectionTextureData = data.reflectionTexture;
             reflectionTextureData && (this.customReflection = Loader.getRes(reflectionTextureData));
             this.enableFog = data.enableFog;
             this.fogStart = data.fogStart;
             this.fogRange = data.fogRange;
             var fogColorData = data.fogColor;
             if (fogColorData) {
                 var fogCol = this.fogColor;
                 fogCol.fromArray(fogColorData);
                 this.fogColor = fogCol;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onActive() {
             super._onActive();
             Laya.stage._scene3Ds.push(this);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onInActive() {
             super._onInActive();
             var scenes = Laya.stage._scene3Ds;
             scenes.splice(scenes.indexOf(this), 1);
         }
         /**
          * @private
          */
         _addLight(light) {
             if (this._lights.indexOf(light) < 0)
                 this._lights.push(light);
         }
         /**
          * @private
          */
         _removeLight(light) {
             var index = this._lights.indexOf(light);
             index >= 0 && (this._lights.splice(index, 1));
         }
         /**
          * @private
          */
         _addRenderObject(render) {
             if (this._octree && render._supportOctree) {
                 this._octree.add(render);
             }
             else {
                 this._renders.add(render);
                 if (Render.supportWebGLPlusCulling) { //[NATIVE]
                     var indexInList = render._getIndexInList();
                     var length = this._cullingBufferIndices.length;
                     if (indexInList >= length) {
                         var tempIndices = this._cullingBufferIndices;
                         var tempResult = this._cullingBufferResult;
                         this._cullingBufferIndices = new Int32Array(length + 1024);
                         this._cullingBufferResult = new Int32Array(length + 1024);
                         this._cullingBufferIndices.set(tempIndices, 0);
                         this._cullingBufferResult.set(tempResult, 0);
                     }
                     this._cullingBufferIndices[indexInList] = render._cullingBufferIndex;
                 }
             }
         }
         /**
          * @private
          */
         _removeRenderObject(render) {
             if (this._octree && render._supportOctree) {
                 this._octree.remove(render);
             }
             else {
                 var endRender;
                 if (Render.supportWebGLPlusCulling) { //[NATIVE]
                     endRender = this._renders.elements[this._renders.length - 1];
                 }
                 this._renders.remove(render);
                 if (Render.supportWebGLPlusCulling) { //[NATIVE]
                     this._cullingBufferIndices[endRender._getIndexInList()] = endRender._cullingBufferIndex;
                 }
             }
         }
         /**
          * @private
          */
         _addShadowCastRenderObject(render) {
             if (this._octree) ;
             else {
                 this._castShadowRenders.add(render);
             }
         }
         /**
          * @private
          */
         _removeShadowCastRenderObject(render) {
             if (this._octree) ;
             else {
                 this._castShadowRenders.remove(render);
             }
         }
         /**
          * @private
          */
         _getRenderQueue(index) {
             if (index <= 2500) //2500作为队列临界点
                 return this._opaqueQueue;
             else
                 return this._transparentQueue;
         }
         /**
          * 设置光照贴图。
          * @param value 光照贴图。
          */
         setlightmaps(value) {
             var maps = this._lightmaps;
             for (var i = 0, n = maps.length; i < n; i++)
                 maps[i]._removeReference();
             if (value) {
                 var count = value.length;
                 maps.length = count;
                 for (i = 0; i < count; i++) {
                     var lightMap = value[i];
                     lightMap._addReference();
                     maps[i] = lightMap;
                 }
             }
             else {
                 throw new Error("Scene3D: value value can't be null.");
             }
             for (i = 0, n = this._children.length; i < n; i++)
                 this._setLightmapToChildNode(this._children[i]);
         }
         /**
          * 获取光照贴图浅拷贝列表。
          * @return 获取光照贴图浅拷贝列表。
          */
         getlightmaps() {
             return this._lightmaps.slice(); //slice()防止修改数组内容
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy(destroyChild = true) {
             if (this.destroyed)
                 return;
             super.destroy(destroyChild);
             this._skyRenderer.destroy();
             this._skyRenderer = null;
             this._lights = null;
             this._lightmaps = null;
             this._renderTargetTexture = null;
             this._shaderValues = null;
             this._renders = null;
             this._castShadowRenders = null;
             this._cameraPool = null;
             this._octree = null;
             this.parallelSplitShadowMaps = null;
             this._physicsSimulation && this._physicsSimulation._destroy();
             Loader.clearRes(this.url);
         }
         /**
          * @inheritDoc
          */
         /*override*/ render(ctx, x, y) {
             //TODO:外层应该设计为接口调用
             ctx._curSubmit = SubmitBase.RENDERBASE; //打断2D合并的renderKey
             this._children.length > 0 && ctx.addRenderObject(this);
         }
         /**
          * @private
          */
         renderSubmit() {
             this._prepareSceneToRender();
             var i, n, n1;
             for (i = 0, n = this._cameraPool.length, n1 = n - 1; i < n; i++) {
                 if (Render.supportWebGLPlusRendering)
                     ShaderData.setRuntimeValueMode((i == n1) ? true : false);
                 var camera = this._cameraPool[i];
                 camera.enableRender && camera.render();
             }
             Context.set2DRenderConfig(); //还原2D配置
             return 1;
         }
         /**
          * @private
          */
         getRenderType() {
             return 0;
         }
         /**
          * @private
          */
         releaseRender() {
         }
         /**
          * @private
          */
         reUse(context, pos) {
             return 0;
         }
     }
     /**Hierarchy资源。*/
     Scene3D.HIERARCHY = "HIERARCHY";
     /**@private */
     Scene3D.physicsSettings = new PhysicsSettings();
     /** 是否开启八叉树裁剪。*/
     Scene3D.octreeCulling = false;
     /** 八叉树初始化尺寸。*/
     Scene3D.octreeInitialSize = 64.0;
     /** 八叉树初始化中心。*/
     Scene3D.octreeInitialCenter = new Vector3(0, 0, 0);
     /** 八叉树最小尺寸。*/
     Scene3D.octreeMinNodeSize = 2.0;
     /** 八叉树松散值。*/
     Scene3D.octreeLooseness = 1.25;
     /**@private */
     Scene3D.REFLECTIONMODE_SKYBOX = 0;
     /**@private */
     Scene3D.REFLECTIONMODE_CUSTOM = 1;
     Scene3D.FOGCOLOR = Shader3D.propertyNameToID("u_FogColor");
     Scene3D.FOGSTART = Shader3D.propertyNameToID("u_FogStart");
     Scene3D.FOGRANGE = Shader3D.propertyNameToID("u_FogRange");
     Scene3D.LIGHTDIRECTION = Shader3D.propertyNameToID("u_DirectionLight.Direction");
     Scene3D.LIGHTDIRCOLOR = Shader3D.propertyNameToID("u_DirectionLight.Color");
     Scene3D.POINTLIGHTPOS = Shader3D.propertyNameToID("u_PointLight.Position");
     Scene3D.POINTLIGHTRANGE = Shader3D.propertyNameToID("u_PointLight.Range");
     Scene3D.POINTLIGHTATTENUATION = Shader3D.propertyNameToID("u_PointLight.Attenuation");
     Scene3D.POINTLIGHTCOLOR = Shader3D.propertyNameToID("u_PointLight.Color");
     Scene3D.SPOTLIGHTPOS = Shader3D.propertyNameToID("u_SpotLight.Position");
     Scene3D.SPOTLIGHTDIRECTION = Shader3D.propertyNameToID("u_SpotLight.Direction");
     Scene3D.SPOTLIGHTSPOTANGLE = Shader3D.propertyNameToID("u_SpotLight.Spot");
     Scene3D.SPOTLIGHTRANGE = Shader3D.propertyNameToID("u_SpotLight.Range");
     Scene3D.SPOTLIGHTCOLOR = Shader3D.propertyNameToID("u_SpotLight.Color");
     Scene3D.SHADOWDISTANCE = Shader3D.propertyNameToID("u_shadowPSSMDistance");
     Scene3D.SHADOWLIGHTVIEWPROJECT = Shader3D.propertyNameToID("u_lightShadowVP");
     Scene3D.SHADOWMAPPCFOFFSET = Shader3D.propertyNameToID("u_shadowPCFoffset");
     Scene3D.SHADOWMAPTEXTURE1 = Shader3D.propertyNameToID("u_shadowMap1");
     Scene3D.SHADOWMAPTEXTURE2 = Shader3D.propertyNameToID("u_shadowMap2");
     Scene3D.SHADOWMAPTEXTURE3 = Shader3D.propertyNameToID("u_shadowMap3");
     Scene3D.AMBIENTCOLOR = Shader3D.propertyNameToID("u_AmbientColor");
     Scene3D.REFLECTIONTEXTURE = Shader3D.propertyNameToID("u_ReflectTexture");
     Scene3D.REFLETIONINTENSITY = Shader3D.propertyNameToID("u_ReflectIntensity");
     Scene3D.TIME = Shader3D.propertyNameToID("u_Time");
     Scene3D.ANGLEATTENUATIONTEXTURE = Shader3D.propertyNameToID("u_AngleTexture");
     Scene3D.RANGEATTENUATIONTEXTURE = Shader3D.propertyNameToID("u_RangeTexture");
     Scene3D.POINTLIGHTMATRIX = Shader3D.propertyNameToID("u_PointLightMatrix");
     Scene3D.SPOTLIGHTMATRIX = Shader3D.propertyNameToID("u_SpotLightMatrix");

     /**
      * <code>SubMesh</code> 类用于创建子网格数据模板。
      */
     class SubMesh extends GeometryElement {
         /**
          * 创建一个 <code>SubMesh</code> 实例。
          * @param	mesh  网格数据模板。
          */
         constructor(mesh) {
             super();
             this._id = ++SubMesh._uniqueIDCounter;
             this._mesh = mesh;
             this._boneIndicesList = [];
             this._subIndexBufferStart = [];
             this._subIndexBufferCount = [];
         }
         /**
          * @inheritDoc
          */
         /*override*/ _getType() {
             return SubMesh._type;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _render(state) {
             this._mesh._bufferState.bind();
             var skinnedDatas = state.renderElement.render._skinnedData;
             if (skinnedDatas) {
                 var subSkinnedDatas = skinnedDatas[this._indexInMesh];
                 var boneIndicesListCount = this._boneIndicesList.length;
                 for (var i = 0; i < boneIndicesListCount; i++) {
                     state.shader.uploadCustomUniform(SkinnedMeshSprite3D.BONES, subSkinnedDatas[i]);
                     LayaGL.instance.drawElements(WebGLContext.TRIANGLES, this._subIndexBufferCount[i], WebGLContext.UNSIGNED_SHORT, this._subIndexBufferStart[i] * 2);
                 }
             }
             else {
                 LayaGL.instance.drawElements(WebGLContext.TRIANGLES, this._indexCount, WebGLContext.UNSIGNED_SHORT, this._indexStart * 2);
             }
             Stat.trianglesFaces += this._indexCount / 3;
             Stat.renderBatches++;
         }
         /**
          * @private
          */
         getIndices() {
             return this._indices;
         }
         /**
          * @inheritDoc
          */
         /*override*/ destroy() {
             if (this._destroyed)
                 return;
             super.destroy();
             this._indexBuffer.destroy();
             this._indexBuffer = null;
             this._mesh = null;
             this._boneIndicesList = null;
             this._subIndexBufferStart = null;
             this._subIndexBufferCount = null;
             this._skinAnimationDatas = null;
         }
     }
     /** @private */
     SubMesh._uniqueIDCounter = 0;
     /**@private */
     SubMesh._type = GeometryElement._typeCounter++;

     /**
      * @private
      * <code>LoadModel</code> 类用于模型加载。
      */
     class LoadModelV04 {
         /**
          * @private
          */
         static parse(readData, version, mesh, subMeshes) {
             LoadModelV04._mesh = mesh;
             LoadModelV04._subMeshes = subMeshes;
             LoadModelV04._version = version;
             LoadModelV04._readData = readData;
             LoadModelV04.READ_DATA();
             LoadModelV04.READ_BLOCK();
             LoadModelV04.READ_STRINGS();
             for (var i = 0, n = LoadModelV04._BLOCK.count; i < n; i++) {
                 LoadModelV04._readData.pos = LoadModelV04._BLOCK.blockStarts[i];
                 var index = LoadModelV04._readData.getUint16();
                 var blockName = LoadModelV04._strings[index];
                 var fn = LoadModelV04["READ_" + blockName];
                 if (fn == null)
                     throw new Error("model file err,no this function:" + index + " " + blockName);
                 else
                     fn.call(null);
             }
             LoadModelV04._mesh._bindPoseIndices = new Uint16Array(LoadModelV04._bindPoseIndices);
             LoadModelV04._bindPoseIndices.length = 0;
             LoadModelV04._strings.length = 0;
             LoadModelV04._readData = null;
             LoadModelV04._version = null;
             LoadModelV04._mesh = null;
             LoadModelV04._subMeshes = null;
         }
         /**
          * @private
          */
         static _readString() {
             return LoadModelV04._strings[LoadModelV04._readData.getUint16()];
         }
         /**
          * @private
          */
         static READ_DATA() {
             LoadModelV04._DATA.offset = LoadModelV04._readData.getUint32();
             LoadModelV04._DATA.size = LoadModelV04._readData.getUint32();
         }
         /**
          * @private
          */
         static READ_BLOCK() {
             var count = LoadModelV04._BLOCK.count = LoadModelV04._readData.getUint16();
             var blockStarts = LoadModelV04._BLOCK.blockStarts = [];
             var blockLengths = LoadModelV04._BLOCK.blockLengths = [];
             for (var i = 0; i < count; i++) {
                 blockStarts.push(LoadModelV04._readData.getUint32());
                 blockLengths.push(LoadModelV04._readData.getUint32());
             }
         }
         /**
          * @private
          */
         static READ_STRINGS() {
             var offset = LoadModelV04._readData.getUint32();
             var count = LoadModelV04._readData.getUint16();
             var prePos = LoadModelV04._readData.pos;
             LoadModelV04._readData.pos = offset + LoadModelV04._DATA.offset;
             for (var i = 0; i < count; i++)
                 LoadModelV04._strings[i] = LoadModelV04._readData.readUTFString();
             LoadModelV04._readData.pos = prePos;
         }
         /**
          * @private
          */
         static READ_MESH() {
             var name = LoadModelV04._readString();
             var arrayBuffer = LoadModelV04._readData.__getBuffer();
             var i;
             var memorySize = 0;
             var vertexBufferCount = LoadModelV04._readData.getInt16();
             var offset = LoadModelV04._DATA.offset;
             for (i = 0; i < vertexBufferCount; i++) { //TODO:始终为1
                 var vbStart = offset + LoadModelV04._readData.getUint32();
                 var vbLength = LoadModelV04._readData.getUint32();
                 var vbDatas = new Float32Array(arrayBuffer.slice(vbStart, vbStart + vbLength));
                 var bufferAttribute = LoadModelV04._readString();
                 var vertexDeclaration;
                 switch (LoadModelV04._version) {
                     case "LAYAMODEL:0301":
                     case "LAYAMODEL:0400":
                         vertexDeclaration = VertexMesh.getVertexDeclaration(bufferAttribute);
                         break;
                     case "LAYAMODEL:0401":
                         vertexDeclaration = VertexMesh.getVertexDeclaration(bufferAttribute, false);
                         break;
                     default:
                         throw new Error("LoadModelV03: unknown version.");
                 }
                 if (!vertexDeclaration)
                     throw new Error("LoadModelV03: unknown vertexDeclaration.");
                 var vertexBuffer = new VertexBuffer3D(vbDatas.length * 4, WebGLContext.STATIC_DRAW, true);
                 vertexBuffer.vertexDeclaration = vertexDeclaration;
                 vertexBuffer.setData(vbDatas);
                 LoadModelV04._mesh._vertexBuffers.push(vertexBuffer);
                 LoadModelV04._mesh._vertexCount += vertexBuffer.vertexCount;
                 memorySize += vbDatas.length * 4;
             }
             var ibStart = offset + LoadModelV04._readData.getUint32();
             var ibLength = LoadModelV04._readData.getUint32();
             var ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
             var indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, ibLength / 2, WebGLContext.STATIC_DRAW, true);
             indexBuffer.setData(ibDatas);
             LoadModelV04._mesh._indexBuffer = indexBuffer;
             memorySize += indexBuffer.indexCount * 2;
             LoadModelV04._mesh._setBuffer(LoadModelV04._mesh._vertexBuffers, indexBuffer);
             LoadModelV04._mesh._setCPUMemory(memorySize);
             LoadModelV04._mesh._setGPUMemory(memorySize);
             var boneNames = LoadModelV04._mesh._boneNames = [];
             var boneCount = LoadModelV04._readData.getUint16();
             boneNames.length = boneCount;
             for (i = 0; i < boneCount; i++)
                 boneNames[i] = LoadModelV04._strings[LoadModelV04._readData.getUint16()];
             LoadModelV04._readData.pos += 8; //TODO:优化
             var bindPoseDataStart = LoadModelV04._readData.getUint32();
             var bindPoseDataLength = LoadModelV04._readData.getUint32();
             var bindPoseDatas = new Float32Array(arrayBuffer.slice(offset + bindPoseDataStart, offset + bindPoseDataStart + bindPoseDataLength));
             var bindPoseFloatCount = bindPoseDatas.length;
             var bindPoseBuffer = LoadModelV04._mesh._inverseBindPosesBuffer = new ArrayBuffer(bindPoseFloatCount * 4); //TODO:[NATIVE]临时
             LoadModelV04._mesh._inverseBindPoses = [];
             for (i = 0; i < bindPoseFloatCount; i += 16) {
                 var inverseGlobalBindPose = new Matrix4x4(bindPoseDatas[i + 0], bindPoseDatas[i + 1], bindPoseDatas[i + 2], bindPoseDatas[i + 3], bindPoseDatas[i + 4], bindPoseDatas[i + 5], bindPoseDatas[i + 6], bindPoseDatas[i + 7], bindPoseDatas[i + 8], bindPoseDatas[i + 9], bindPoseDatas[i + 10], bindPoseDatas[i + 11], bindPoseDatas[i + 12], bindPoseDatas[i + 13], bindPoseDatas[i + 14], bindPoseDatas[i + 15], new Float32Array(bindPoseBuffer, i * 4, 16));
                 LoadModelV04._mesh._inverseBindPoses[i / 16] = inverseGlobalBindPose;
             }
             return true;
         }
         /**
          * @private
          */
         static READ_SUBMESH() {
             var arrayBuffer = LoadModelV04._readData.__getBuffer();
             var submesh = new SubMesh(LoadModelV04._mesh);
             var vbIndex = LoadModelV04._readData.getInt16();
             LoadModelV04._readData.getUint32(); //TODO:vbStart
             LoadModelV04._readData.getUint32(); //TODO:vbLength
             var ibStart = LoadModelV04._readData.getUint32();
             var ibCount = LoadModelV04._readData.getUint32();
             var indexBuffer = LoadModelV04._mesh._indexBuffer;
             submesh._indexBuffer = indexBuffer;
             submesh._indexStart = ibStart;
             submesh._indexCount = ibCount;
             submesh._indices = new Uint16Array(indexBuffer.getData().buffer, ibStart * 2, ibCount);
             var vertexBuffer = LoadModelV04._mesh._vertexBuffers[vbIndex];
             submesh._vertexBuffer = vertexBuffer;
             var offset = LoadModelV04._DATA.offset;
             var subIndexBufferStart = submesh._subIndexBufferStart;
             var subIndexBufferCount = submesh._subIndexBufferCount;
             var boneIndicesList = submesh._boneIndicesList;
             var drawCount = LoadModelV04._readData.getUint16();
             subIndexBufferStart.length = drawCount;
             subIndexBufferCount.length = drawCount;
             boneIndicesList.length = drawCount;
             var pathMarks = LoadModelV04._mesh._skinDataPathMarks;
             var bindPoseIndices = LoadModelV04._bindPoseIndices;
             var subMeshIndex = LoadModelV04._subMeshes.length;
             for (var i = 0; i < drawCount; i++) {
                 subIndexBufferStart[i] = LoadModelV04._readData.getUint32();
                 subIndexBufferCount[i] = LoadModelV04._readData.getUint32();
                 var boneDicofs = LoadModelV04._readData.getUint32();
                 var boneDicCount = LoadModelV04._readData.getUint32();
                 var boneIndices = boneIndicesList[i] = new Uint16Array(arrayBuffer.slice(offset + boneDicofs, offset + boneDicofs + boneDicCount));
                 for (var j = 0, m = boneIndices.length; j < m; j++) {
                     var index = boneIndices[j];
                     var combineIndex = bindPoseIndices.indexOf(index);
                     if (combineIndex === -1) {
                         boneIndices[j] = bindPoseIndices.length;
                         bindPoseIndices.push(index);
                         pathMarks.push([subMeshIndex, i, j]);
                     }
                     else {
                         boneIndices[j] = combineIndex;
                     }
                 }
             }
             LoadModelV04._subMeshes.push(submesh);
             return true;
         }
     }
     /**@private */
     LoadModelV04._BLOCK = { count: 0 };
     /**@private */
     LoadModelV04._DATA = { offset: 0, size: 0 };
     /**@private */
     LoadModelV04._strings = [];
     /**@private */
     LoadModelV04._bindPoseIndices = [];

     /**
          * <code>HalfFloatUtils</code> 类用于创建HalfFloat工具。
          */
     class HalfFloatUtils {
         /**
          * @private
          */
         static __init__() {
             for (var i = 0; i < 256; ++i) {
                 var e = i - 127;
                 // very small number (0, -0)
                 if (e < -27) {
                     HalfFloatUtils._baseTable[i | 0x000] = 0x0000;
                     HalfFloatUtils._baseTable[i | 0x100] = 0x8000;
                     HalfFloatUtils._shiftTable[i | 0x000] = 24;
                     HalfFloatUtils._shiftTable[i | 0x100] = 24;
                     // small number (denorm)
                 }
                 else if (e < -14) {
                     HalfFloatUtils._baseTable[i | 0x000] = 0x0400 >> (-e - 14);
                     HalfFloatUtils._baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
                     HalfFloatUtils._shiftTable[i | 0x000] = -e - 1;
                     HalfFloatUtils._shiftTable[i | 0x100] = -e - 1;
                     // normal number
                 }
                 else if (e <= 15) {
                     HalfFloatUtils._baseTable[i | 0x000] = (e + 15) << 10;
                     HalfFloatUtils._baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
                     HalfFloatUtils._shiftTable[i | 0x000] = 13;
                     HalfFloatUtils._shiftTable[i | 0x100] = 13;
                     // large number (Infinity, -Infinity)
                 }
                 else if (e < 128) {
                     HalfFloatUtils._baseTable[i | 0x000] = 0x7c00;
                     HalfFloatUtils._baseTable[i | 0x100] = 0xfc00;
                     HalfFloatUtils._shiftTable[i | 0x000] = 24;
                     HalfFloatUtils._shiftTable[i | 0x100] = 24;
                     // stay (NaN, Infinity, -Infinity)
                 }
                 else {
                     HalfFloatUtils._baseTable[i | 0x000] = 0x7c00;
                     HalfFloatUtils._baseTable[i | 0x100] = 0xfc00;
                     HalfFloatUtils._shiftTable[i | 0x000] = 13;
                     HalfFloatUtils._shiftTable[i | 0x100] = 13;
                 }
             }
             HalfFloatUtils._mantissaTable[0] = 0;
             for (i = 1; i < 1024; ++i) {
                 var m = i << 13; // zero pad mantissa bits
                 e = 0; // zero exponent
                 // normalized
                 while ((m & 0x00800000) === 0) {
                     e -= 0x00800000; // decrement exponent
                     m <<= 1;
                 }
                 m &= ~0x00800000; // clear leading 1 bit
                 e += 0x38800000; // adjust bias
                 HalfFloatUtils._mantissaTable[i] = m | e;
             }
             for (i = 1024; i < 2048; ++i) {
                 HalfFloatUtils._mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
             }
             HalfFloatUtils._exponentTable[0] = 0;
             for (i = 1; i < 31; ++i) {
                 HalfFloatUtils._exponentTable[i] = i << 23;
             }
             HalfFloatUtils._exponentTable[31] = 0x47800000;
             HalfFloatUtils._exponentTable[32] = 0x80000000;
             for (i = 33; i < 63; ++i) {
                 HalfFloatUtils._exponentTable[i] = 0x80000000 + ((i - 32) << 23);
             }
             HalfFloatUtils._exponentTable[63] = 0xc7800000;
             HalfFloatUtils._offsetTable[0] = 0;
             for (i = 1; i < 64; ++i) {
                 if (i === 32) {
                     HalfFloatUtils._offsetTable[i] = 0;
                 }
                 else {
                     HalfFloatUtils._offsetTable[i] = 1024;
                 }
             }
         }
         /**
          * round a number to a half float number bits.
          * @param {number} num
          */
         static roundToFloat16Bits(num) {
             HalfFloatUtils._floatView[0] = num;
             var f = HalfFloatUtils._uint32View[0];
             var e = (f >> 23) & 0x1ff;
             return HalfFloatUtils._baseTable[e] + ((f & 0x007fffff) >> HalfFloatUtils._shiftTable[e]);
         }
         /**
          * convert a half float number bits to a number.
          * @param {number} float16bits - half float number bits
          */
         static convertToNumber(float16bits) {
             var m = float16bits >> 10;
             HalfFloatUtils._uint32View[0] = HalfFloatUtils._mantissaTable[HalfFloatUtils._offsetTable[m] + (float16bits & 0x3ff)] + HalfFloatUtils._exponentTable[m];
             return HalfFloatUtils._floatView[0];
         }
     }
     /**@private */
     HalfFloatUtils._buffer = new ArrayBuffer(4);
     /**@private */
     HalfFloatUtils._floatView = new Float32Array(HalfFloatUtils._buffer);
     /**@private */
     HalfFloatUtils._uint32View = new Uint32Array(HalfFloatUtils._buffer);
     /**@private */
     HalfFloatUtils._baseTable = new Uint32Array(512);
     /**@private */
     HalfFloatUtils._shiftTable = new Uint32Array(512);
     /**@private */
     HalfFloatUtils._mantissaTable = new Uint32Array(2048);
     /**@private */
     HalfFloatUtils._exponentTable = new Uint32Array(64);
     /**@private */
     HalfFloatUtils._offsetTable = new Uint32Array(64);

     /**
      * @private
      * <code>LoadModelV05</code> 类用于模型加载。
      */
     class LoadModelV05 {
         /**
          * @private
          */
         static parse(readData, version, mesh, subMeshes) {
             LoadModelV05._mesh = mesh;
             LoadModelV05._subMeshes = subMeshes;
             LoadModelV05._version = version;
             LoadModelV05._readData = readData;
             LoadModelV05.READ_DATA();
             LoadModelV05.READ_BLOCK();
             LoadModelV05.READ_STRINGS();
             for (var i = 0, n = LoadModelV05._BLOCK.count; i < n; i++) {
                 LoadModelV05._readData.pos = LoadModelV05._BLOCK.blockStarts[i];
                 var index = LoadModelV05._readData.getUint16();
                 var blockName = LoadModelV05._strings[index];
                 var fn = LoadModelV05["READ_" + blockName];
                 if (fn == null)
                     throw new Error("model file err,no this function:" + index + " " + blockName);
                 else
                     fn.call(null);
             }
             LoadModelV05._mesh._bindPoseIndices = new Uint16Array(LoadModelV05._bindPoseIndices);
             LoadModelV05._bindPoseIndices.length = 0;
             LoadModelV05._strings.length = 0;
             LoadModelV05._readData = null;
             LoadModelV05._version = null;
             LoadModelV05._mesh = null;
             LoadModelV05._subMeshes = null;
         }
         /**
          * @private
          */
         static _readString() {
             return LoadModelV05._strings[LoadModelV05._readData.getUint16()];
         }
         /**
          * @private
          */
         static READ_DATA() {
             LoadModelV05._DATA.offset = LoadModelV05._readData.getUint32();
             LoadModelV05._DATA.size = LoadModelV05._readData.getUint32();
         }
         /**
          * @private
          */
         static READ_BLOCK() {
             var count = LoadModelV05._BLOCK.count = LoadModelV05._readData.getUint16();
             var blockStarts = LoadModelV05._BLOCK.blockStarts = [];
             var blockLengths = LoadModelV05._BLOCK.blockLengths = [];
             for (var i = 0; i < count; i++) {
                 blockStarts.push(LoadModelV05._readData.getUint32());
                 blockLengths.push(LoadModelV05._readData.getUint32());
             }
         }
         /**
          * @private
          */
         static READ_STRINGS() {
             var offset = LoadModelV05._readData.getUint32();
             var count = LoadModelV05._readData.getUint16();
             var prePos = LoadModelV05._readData.pos;
             LoadModelV05._readData.pos = offset + LoadModelV05._DATA.offset;
             for (var i = 0; i < count; i++)
                 LoadModelV05._strings[i] = LoadModelV05._readData.readUTFString();
             LoadModelV05._readData.pos = prePos;
         }
         /**
          * @private
          */
         static READ_MESH() {
             var i;
             var memorySize = 0;
             var name = LoadModelV05._readString();
             var arrayBuffer = LoadModelV05._readData.__getBuffer();
             var vertexBufferCount = LoadModelV05._readData.getInt16();
             var offset = LoadModelV05._DATA.offset;
             for (i = 0; i < vertexBufferCount; i++) { //TODO:始终为1
                 var vbStart = offset + LoadModelV05._readData.getUint32();
                 var vertexCount = LoadModelV05._readData.getUint32();
                 var vertexFlag = LoadModelV05._readString();
                 var vertexDeclaration = VertexMesh.getVertexDeclaration(vertexFlag, false);
                 var vertexStride = vertexDeclaration.vertexStride;
                 var vertexData = new ArrayBuffer(vertexStride * vertexCount);
                 var floatData = new Float32Array(vertexData);
                 var subVertexFlags = vertexFlag.split(",");
                 var subVertexCount = subVertexFlags.length;
                 switch (LoadModelV05._version) {
                     case "LAYAMODEL:05":
                         floatData = new Float32Array(arrayBuffer.slice(vbStart, vbStart + vertexCount * vertexStride));
                         break;
                     case "LAYAMODEL:COMPRESSION_05":
                         var lastPosition = LoadModelV05._readData.pos;
                         floatData = new Float32Array(vertexData);
                         var uint8Data = new Uint8Array(vertexData);
                         LoadModelV05._readData.pos = vbStart;
                         for (var j = 0; j < vertexCount; j++) {
                             var subOffset;
                             var verOffset = j * vertexStride;
                             for (var k = 0; k < subVertexCount; k++) {
                                 switch (subVertexFlags[k]) {
                                     case "POSITION":
                                         subOffset = verOffset / 4;
                                         floatData[subOffset] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
                                         floatData[subOffset + 1] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
                                         floatData[subOffset + 2] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
                                         verOffset += 12;
                                         break;
                                     case "NORMAL":
                                         subOffset = verOffset / 4;
                                         floatData[subOffset] = LoadModelV05._readData.getUint8() / 127.5 - 1;
                                         floatData[subOffset + 1] = LoadModelV05._readData.getUint8() / 127.5 - 1;
                                         floatData[subOffset + 2] = LoadModelV05._readData.getUint8() / 127.5 - 1;
                                         verOffset += 12;
                                         break;
                                     case "COLOR":
                                         subOffset = verOffset / 4;
                                         floatData[subOffset] = LoadModelV05._readData.getUint8() / 255;
                                         floatData[subOffset + 1] = LoadModelV05._readData.getUint8() / 255;
                                         floatData[subOffset + 2] = LoadModelV05._readData.getUint8() / 255;
                                         floatData[subOffset + 3] = LoadModelV05._readData.getUint8() / 255;
                                         verOffset += 16;
                                         break;
                                     case "UV":
                                         subOffset = verOffset / 4;
                                         floatData[subOffset] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
                                         floatData[subOffset + 1] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
                                         verOffset += 8;
                                         break;
                                     case "UV1":
                                         subOffset = verOffset / 4;
                                         floatData[subOffset] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
                                         floatData[subOffset + 1] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
                                         verOffset += 8;
                                         break;
                                     case "BLENDWEIGHT":
                                         subOffset = verOffset / 4;
                                         floatData[subOffset] = LoadModelV05._readData.getUint8() / 255;
                                         floatData[subOffset + 1] = LoadModelV05._readData.getUint8() / 255;
                                         floatData[subOffset + 2] = LoadModelV05._readData.getUint8() / 255;
                                         floatData[subOffset + 3] = LoadModelV05._readData.getUint8() / 255;
                                         verOffset += 16;
                                         break;
                                     case "BLENDINDICES":
                                         uint8Data[verOffset] = LoadModelV05._readData.getUint8();
                                         uint8Data[verOffset + 1] = LoadModelV05._readData.getUint8();
                                         uint8Data[verOffset + 2] = LoadModelV05._readData.getUint8();
                                         uint8Data[verOffset + 3] = LoadModelV05._readData.getUint8();
                                         verOffset += 4;
                                         break;
                                     case "TANGENT":
                                         subOffset = verOffset / 4;
                                         floatData[subOffset] = LoadModelV05._readData.getUint8() / 127.5 - 1;
                                         floatData[subOffset + 1] = LoadModelV05._readData.getUint8() / 127.5 - 1;
                                         floatData[subOffset + 2] = LoadModelV05._readData.getUint8() / 127.5 - 1;
                                         floatData[subOffset + 3] = LoadModelV05._readData.getUint8() / 127.5 - 1;
                                         verOffset += 16;
                                         break;
                                 }
                             }
                         }
                         LoadModelV05._readData.pos = lastPosition;
                         break;
                 }
                 var vertexBuffer = new VertexBuffer3D(vertexData.byteLength, WebGLContext.STATIC_DRAW, true);
                 vertexBuffer.vertexDeclaration = vertexDeclaration;
                 vertexBuffer.setData(floatData);
                 LoadModelV05._mesh._vertexBuffers.push(vertexBuffer);
                 LoadModelV05._mesh._vertexCount += vertexBuffer.vertexCount;
                 memorySize += floatData.length * 4;
             }
             var ibStart = offset + LoadModelV05._readData.getUint32();
             var ibLength = LoadModelV05._readData.getUint32();
             var ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
             var indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, ibLength / 2, WebGLContext.STATIC_DRAW, true);
             indexBuffer.setData(ibDatas);
             LoadModelV05._mesh._indexBuffer = indexBuffer;
             LoadModelV05._mesh._setBuffer(LoadModelV05._mesh._vertexBuffers, indexBuffer);
             memorySize += indexBuffer.indexCount * 2;
             LoadModelV05._mesh._setCPUMemory(memorySize);
             LoadModelV05._mesh._setGPUMemory(memorySize);
             var boneNames = LoadModelV05._mesh._boneNames = [];
             var boneCount = LoadModelV05._readData.getUint16();
             boneNames.length = boneCount;
             for (i = 0; i < boneCount; i++)
                 boneNames[i] = LoadModelV05._strings[LoadModelV05._readData.getUint16()]; //[兼容性]
             var bindPoseDataStart = LoadModelV05._readData.getUint32();
             var bindPoseDataLength = LoadModelV05._readData.getUint32();
             var bindPoseDatas = new Float32Array(arrayBuffer.slice(offset + bindPoseDataStart, offset + bindPoseDataStart + bindPoseDataLength));
             var bindPoseFloatCount = bindPoseDatas.length;
             var bindPoseBuffer = LoadModelV05._mesh._inverseBindPosesBuffer = new ArrayBuffer(bindPoseFloatCount * 4); //TODO:[NATIVE]临时
             LoadModelV05._mesh._inverseBindPoses = [];
             for (i = 0; i < bindPoseFloatCount; i += 16) {
                 var inverseGlobalBindPose = new Matrix4x4(bindPoseDatas[i + 0], bindPoseDatas[i + 1], bindPoseDatas[i + 2], bindPoseDatas[i + 3], bindPoseDatas[i + 4], bindPoseDatas[i + 5], bindPoseDatas[i + 6], bindPoseDatas[i + 7], bindPoseDatas[i + 8], bindPoseDatas[i + 9], bindPoseDatas[i + 10], bindPoseDatas[i + 11], bindPoseDatas[i + 12], bindPoseDatas[i + 13], bindPoseDatas[i + 14], bindPoseDatas[i + 15], new Float32Array(bindPoseBuffer, i * 4, 16));
                 LoadModelV05._mesh._inverseBindPoses[i / 16] = inverseGlobalBindPose;
             }
             return true;
         }
         /**
          * @private
          */
         static READ_SUBMESH() {
             var arrayBuffer = LoadModelV05._readData.__getBuffer();
             var submesh = new SubMesh(LoadModelV05._mesh);
             var vbIndex = LoadModelV05._readData.getInt16();
             var ibStart = LoadModelV05._readData.getUint32();
             var ibCount = LoadModelV05._readData.getUint32();
             var indexBuffer = LoadModelV05._mesh._indexBuffer;
             submesh._indexBuffer = indexBuffer;
             submesh._indexStart = ibStart;
             submesh._indexCount = ibCount;
             submesh._indices = new Uint16Array(indexBuffer.getData().buffer, ibStart * 2, ibCount);
             var vertexBuffer = LoadModelV05._mesh._vertexBuffers[vbIndex];
             submesh._vertexBuffer = vertexBuffer;
             var offset = LoadModelV05._DATA.offset;
             var subIndexBufferStart = submesh._subIndexBufferStart;
             var subIndexBufferCount = submesh._subIndexBufferCount;
             var boneIndicesList = submesh._boneIndicesList;
             var drawCount = LoadModelV05._readData.getUint16();
             subIndexBufferStart.length = drawCount;
             subIndexBufferCount.length = drawCount;
             boneIndicesList.length = drawCount;
             var pathMarks = LoadModelV05._mesh._skinDataPathMarks;
             var bindPoseIndices = LoadModelV05._bindPoseIndices;
             var subMeshIndex = LoadModelV05._subMeshes.length;
             for (var i = 0; i < drawCount; i++) {
                 subIndexBufferStart[i] = LoadModelV05._readData.getUint32();
                 subIndexBufferCount[i] = LoadModelV05._readData.getUint32();
                 var boneDicofs = LoadModelV05._readData.getUint32();
                 var boneDicCount = LoadModelV05._readData.getUint32();
                 var boneIndices = boneIndicesList[i] = new Uint16Array(arrayBuffer.slice(offset + boneDicofs, offset + boneDicofs + boneDicCount));
                 for (var j = 0, m = boneIndices.length; j < m; j++) {
                     var index = boneIndices[j];
                     var combineIndex = bindPoseIndices.indexOf(index);
                     if (combineIndex === -1) {
                         boneIndices[j] = bindPoseIndices.length;
                         bindPoseIndices.push(index);
                         pathMarks.push([subMeshIndex, i, j]);
                     }
                     else {
                         boneIndices[j] = combineIndex;
                     }
                 }
             }
             LoadModelV05._subMeshes.push(submesh);
             return true;
         }
     }
     /**@private */
     LoadModelV05._BLOCK = { count: 0 };
     /**@private */
     LoadModelV05._DATA = { offset: 0, size: 0 };
     /**@private */
     LoadModelV05._strings = [];
     /**@private */
     LoadModelV05._bindPoseIndices = [];

     /**
      * ...
      * @author ...
      */
     class MeshReader {
         constructor() {
         }
         static read(data, mesh, subMeshes) {
             var readData = new Byte(data);
             readData.pos = 0;
             var version = readData.readUTFString();
             switch (version) {
                 case "LAYAMODEL:0301":
                 case "LAYAMODEL:0400":
                 case "LAYAMODEL:0401":
                     LoadModelV04.parse(readData, version, mesh, subMeshes);
                     break;
                 case "LAYAMODEL:05":
                 case "LAYAMODEL:COMPRESSION_05":
                     LoadModelV05.parse(readData, version, mesh, subMeshes);
                     break;
                 default:
                     throw new Error("MeshReader: unknown mesh version.");
             }
             mesh._setSubMeshes(subMeshes);
         }
     }

     /**
      * <code>Mesh</code> 类用于创建文件网格数据模板。
      */
     class Mesh extends Resource {
         /**
          * 创建一个 <code>Mesh</code> 实例,禁止使用。
          * @param url 文件地址。
          */
         constructor() {
             super();
             /** @private */
             this._tempVector30 = new Vector3();
             /** @private */
             this._tempVector31 = new Vector3();
             /** @private */
             this._tempVector32 = new Vector3();
             /** @private */
             this._bufferState = new BufferState();
             /** @private */
             this._instanceBufferState = new BufferState();
             /** @private */
             this._vertexCount = 0;
             this._subMeshes = [];
             this._vertexBuffers = [];
             this._skinDataPathMarks = [];
         }
         /**
         * @private
         */
         static __init__() {
             var physics3D = Physics._physics3D;
             if (physics3D) {
                 Mesh._nativeTempVector30 = new physics3D.btVector3(0, 0, 0);
                 Mesh._nativeTempVector31 = new physics3D.btVector3(0, 0, 0);
                 Mesh._nativeTempVector32 = new physics3D.btVector3(0, 0, 0);
             }
         }
         /**
          *@private
          */
         static _parse(data, propertyParams = null, constructParams = null) {
             var mesh = new Mesh();
             MeshReader.read(data, mesh, mesh._subMeshes);
             return mesh;
         }
         /**
          * 加载网格模板。
          * @param url 模板地址。
          * @param complete 完成回掉。
          */
         static load(url, complete) {
             Laya.loader.create(url, complete, null, Mesh.MESH);
         }
         /**
          * 获取网格的全局默认绑定动作逆矩阵。
          * @return  网格的全局默认绑定动作逆矩阵。
          */
         get inverseAbsoluteBindPoses() {
             return this._inverseBindPoses;
         }
         /**
          * 获取顶点个数
          */
         get vertexCount() {
             return this._vertexCount;
         }
         /**
          * 获取SubMesh的个数。
          * @return SubMesh的个数。
          */
         get subMeshCount() {
             return this._subMeshCount;
         }
         /**
          * 获取边界
          * @return 边界。
          */
         get bounds() {
             return this._bounds;
         }
         /**
          * @private
          */
         _getPositionElement(vertexBuffer) {
             var vertexElements = vertexBuffer.vertexDeclaration.vertexElements;
             for (var i = 0, n = vertexElements.length; i < n; i++) {
                 var vertexElement = vertexElements[i];
                 if (vertexElement.elementFormat === VertexElementFormat.Vector3 && vertexElement.elementUsage === VertexMesh.MESH_POSITION0)
                     return vertexElement;
             }
             return null;
         }
         /**
          * @private
          */
         _generateBoundingObject() {
             var min = this._tempVector30;
             var max = this._tempVector31;
             min.x = min.y = min.z = Number.MAX_VALUE;
             max.x = max.y = max.z = -Number.MAX_VALUE;
             var vertexBufferCount = this._vertexBuffers.length;
             for (var i = 0; i < vertexBufferCount; i++) {
                 var vertexBuffer = this._vertexBuffers[i];
                 var positionElement = this._getPositionElement(vertexBuffer);
                 var verticesData = vertexBuffer.getData();
                 var floatCount = vertexBuffer.vertexDeclaration.vertexStride / 4;
                 var posOffset = positionElement.offset / 4;
                 for (var j = 0, m = verticesData.length; j < m; j += floatCount) {
                     var ofset = j + posOffset;
                     var pX = verticesData[ofset];
                     var pY = verticesData[ofset + 1];
                     var pZ = verticesData[ofset + 2];
                     min.x = Math.min(min.x, pX);
                     min.y = Math.min(min.y, pY);
                     min.z = Math.min(min.z, pZ);
                     max.x = Math.max(max.x, pX);
                     max.y = Math.max(max.y, pY);
                     max.z = Math.max(max.z, pZ);
                 }
             }
             this._bounds = new Bounds(min, max);
         }
         /**
          *@private
          */
         _setSubMeshes(subMeshes) {
             this._subMeshes = subMeshes;
             this._subMeshCount = subMeshes.length;
             for (var i = 0; i < this._subMeshCount; i++)
                 subMeshes[i]._indexInMesh = i;
             this._generateBoundingObject();
         }
         /**
          * @inheritDoc
          */
         _getSubMesh(index) {
             return this._subMeshes[index];
         }
         /**
          * @private
          */
         _setBuffer(vertexBuffers, indexBuffer) {
             var bufferState = this._bufferState;
             bufferState.bind();
             bufferState.applyVertexBuffers(vertexBuffers);
             bufferState.applyIndexBuffer(indexBuffer);
             bufferState.unBind();
             var instanceBufferState = this._instanceBufferState;
             instanceBufferState.bind();
             instanceBufferState.applyVertexBuffers(vertexBuffers);
             instanceBufferState.applyInstanceVertexBuffer(SubMeshInstanceBatch.instance.instanceWorldMatrixBuffer);
             instanceBufferState.applyInstanceVertexBuffer(SubMeshInstanceBatch.instance.instanceMVPMatrixBuffer);
             instanceBufferState.applyIndexBuffer(indexBuffer);
             instanceBufferState.unBind();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _disposeResource() {
             for (var i = 0, n = this._subMeshes.length; i < n; i++)
                 this._subMeshes[i].destroy();
             this._nativeTriangleMesh && window.Physics3D.destroy(this._nativeTriangleMesh);
             for (i = 0, n = this._vertexBuffers.length; i < n; i++)
                 this._vertexBuffers[i].destroy();
             this._indexBuffer.destroy();
             this._setCPUMemory(0);
             this._setGPUMemory(0);
             this._bufferState.destroy();
             this._instanceBufferState.destroy();
             this._bufferState = null;
             this._instanceBufferState = null;
             this._vertexBuffers = null;
             this._indexBuffer = null;
             this._subMeshes = null;
             this._nativeTriangleMesh = null;
             this._vertexBuffers = null;
             this._indexBuffer = null;
             this._boneNames = null;
             this._inverseBindPoses = null;
         }
         /**
          * @private
          */
         _getPhysicMesh() {
             if (!this._nativeTriangleMesh) {
                 var physics3D = window.Physics3D;
                 var triangleMesh = new physics3D.btTriangleMesh(); //TODO:独立抽象btTriangleMesh,增加内存复用
                 var nativePositio0 = Mesh._nativeTempVector30;
                 var nativePositio1 = Mesh._nativeTempVector31;
                 var nativePositio2 = Mesh._nativeTempVector32;
                 var position0 = this._tempVector30;
                 var position1 = this._tempVector31;
                 var position2 = this._tempVector32;
                 var vertexBuffer = this._vertexBuffers[0]; //TODO:临时
                 var positionElement = this._getPositionElement(vertexBuffer);
                 var verticesData = vertexBuffer.getData();
                 var floatCount = vertexBuffer.vertexDeclaration.vertexStride / 4;
                 var posOffset = positionElement.offset / 4;
                 var indices = this._indexBuffer.getData(); //TODO:API修改问题
                 for (var i = 0, n = indices.length; i < n; i += 3) {
                     var p0Index = indices[i] * floatCount + posOffset;
                     var p1Index = indices[i + 1] * floatCount + posOffset;
                     var p2Index = indices[i + 2] * floatCount + posOffset;
                     position0.setValue(verticesData[p0Index], verticesData[p0Index + 1], verticesData[p0Index + 2]);
                     position1.setValue(verticesData[p1Index], verticesData[p1Index + 1], verticesData[p1Index + 2]);
                     position2.setValue(verticesData[p2Index], verticesData[p2Index + 1], verticesData[p2Index + 2]);
                     Utils3D._convertToBulletVec3(position0, nativePositio0, true);
                     Utils3D._convertToBulletVec3(position1, nativePositio1, true);
                     Utils3D._convertToBulletVec3(position2, nativePositio2, true);
                     triangleMesh.addTriangle(nativePositio0, nativePositio1, nativePositio2, true);
                 }
                 this._nativeTriangleMesh = triangleMesh;
             }
             return this._nativeTriangleMesh;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destMesh = destObject;
             for (var i = 0; i < this._vertexBuffers.length; i++) {
                 var vb = this._vertexBuffers[i];
                 var destVB = new VertexBuffer3D(vb._byteLength, vb.bufferUsage, vb.canRead);
                 destVB.vertexDeclaration = vb.vertexDeclaration;
                 destVB.setData(vb.getData().slice());
                 destMesh._vertexBuffers.push(destVB);
                 destMesh._vertexCount += destVB.vertexCount;
             }
             var ib = this._indexBuffer;
             var destIB = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, ib.indexCount, ib.bufferUsage, ib.canRead);
             destIB.setData(ib.getData().slice());
             destMesh._indexBuffer = destIB;
             destMesh._setBuffer(destMesh._vertexBuffers, destIB);
             destMesh._setCPUMemory(this.cpuMemory);
             destMesh._setGPUMemory(this.gpuMemory);
             var boneNames = this._boneNames;
             var destBoneNames = destMesh._boneNames = [];
             for (i = 0; i < boneNames.length; i++)
                 destBoneNames[i] = boneNames[i];
             var inverseBindPoses = this._inverseBindPoses;
             var destInverseBindPoses = destMesh._inverseBindPoses = [];
             for (i = 0; i < inverseBindPoses.length; i++)
                 destInverseBindPoses[i] = inverseBindPoses[i];
             destMesh._bindPoseIndices = new Uint16Array(this._bindPoseIndices);
             for (i = 0; i < this._skinDataPathMarks.length; i++)
                 destMesh._skinDataPathMarks[i] = this._skinDataPathMarks[i].slice();
             for (i = 0; i < this.subMeshCount; i++) {
                 var subMesh = this._subMeshes[i];
                 var subIndexBufferStart = subMesh._subIndexBufferStart;
                 var subIndexBufferCount = subMesh._subIndexBufferCount;
                 var boneIndicesList = subMesh._boneIndicesList;
                 var destSubmesh = new SubMesh(destMesh);
                 destSubmesh._subIndexBufferStart.length = subIndexBufferStart.length;
                 destSubmesh._subIndexBufferCount.length = subIndexBufferCount.length;
                 destSubmesh._boneIndicesList.length = boneIndicesList.length;
                 for (var j = 0; j < subIndexBufferStart.length; j++)
                     destSubmesh._subIndexBufferStart[j] = subIndexBufferStart[j];
                 for (j = 0; j < subIndexBufferCount.length; j++)
                     destSubmesh._subIndexBufferCount[j] = subIndexBufferCount[j];
                 for (j = 0; j < boneIndicesList.length; j++)
                     destSubmesh._boneIndicesList[j] = new Uint16Array(boneIndicesList[j]);
                 destSubmesh._indexBuffer = destIB;
                 destSubmesh._indexStart = subMesh._indexStart;
                 destSubmesh._indexCount = subMesh._indexCount;
                 destSubmesh._indices = new Uint16Array(destIB.getData().buffer, subMesh._indexStart * 2, subMesh._indexCount);
                 var vertexBuffer = destMesh._vertexBuffers[0];
                 destSubmesh._vertexBuffer = vertexBuffer;
                 destMesh._subMeshes.push(destSubmesh);
             }
             destMesh._setSubMeshes(destMesh._subMeshes);
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new Mesh();
             this.cloneTo(dest);
             return dest;
         }
     }
     /**Mesh资源。*/
     Mesh.MESH = "MESH";

     /**
      * <code>PrimitiveMesh</code> 类用于创建简单网格。
      */
     class PrimitiveMesh {
         /**
          * @private
          */
         static _createMesh(vertexDeclaration, vertices, indices) {
             var mesh = new Mesh();
             var subMesh = new SubMesh(mesh);
             var vertexBuffer = new VertexBuffer3D(vertices.length * 4, WebGLContext.STATIC_DRAW, true);
             vertexBuffer.vertexDeclaration = vertexDeclaration;
             vertexBuffer.setData(vertices);
             mesh._vertexBuffers.push(vertexBuffer);
             mesh._vertexCount += vertexBuffer.vertexCount;
             var indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, indices.length, WebGLContext.STATIC_DRAW, true);
             indexBuffer.setData(indices);
             mesh._indexBuffer = indexBuffer;
             var vertexBuffers = [];
             vertexBuffers[0] = vertexBuffer;
             mesh._setBuffer(vertexBuffers, indexBuffer);
             subMesh._vertexBuffer = vertexBuffer;
             subMesh._indexBuffer = indexBuffer;
             subMesh._indexStart = 0;
             subMesh._indexCount = indexBuffer.indexCount;
             var subIndexBufferStart = subMesh._subIndexBufferStart;
             var subIndexBufferCount = subMesh._subIndexBufferCount;
             var boneIndicesList = subMesh._boneIndicesList;
             subIndexBufferStart.length = 1;
             subIndexBufferCount.length = 1;
             boneIndicesList.length = 1;
             subIndexBufferStart[0] = 0;
             subIndexBufferCount[0] = indexBuffer.indexCount;
             var subMeshes = [];
             subMeshes.push(subMesh);
             mesh._setSubMeshes(subMeshes);
             var memorySize = vertexBuffer._byteLength + indexBuffer._byteLength;
             mesh._setCPUMemory(memorySize);
             mesh._setGPUMemory(memorySize);
             return mesh;
         }
         /**
          * 创建Box网格。
          * @param long 半径
          * @param height 垂直层数
          * @param width 水平层数
          * @return
          */
         static createBox(long = 1, height = 1, width = 1) {
             var vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
             var halfLong = long / 2;
             var halfHeight = height / 2;
             var halfWidth = width / 2;
             var vertices = new Float32Array([
                 //上
                 -halfLong, halfHeight, -halfWidth, 0, 1, 0, 0, 0, halfLong, halfHeight, -halfWidth, 0, 1, 0, 1, 0, halfLong, halfHeight, halfWidth, 0, 1, 0, 1, 1, -halfLong, halfHeight, halfWidth, 0, 1, 0, 0, 1,
                 //下
                 -halfLong, -halfHeight, -halfWidth, 0, -1, 0, 0, 1, halfLong, -halfHeight, -halfWidth, 0, -1, 0, 1, 1, halfLong, -halfHeight, halfWidth, 0, -1, 0, 1, 0, -halfLong, -halfHeight, halfWidth, 0, -1, 0, 0, 0,
                 //左
                 -halfLong, halfHeight, -halfWidth, -1, 0, 0, 0, 0, -halfLong, halfHeight, halfWidth, -1, 0, 0, 1, 0, -halfLong, -halfHeight, halfWidth, -1, 0, 0, 1, 1, -halfLong, -halfHeight, -halfWidth, -1, 0, 0, 0, 1,
                 //右
                 halfLong, halfHeight, -halfWidth, 1, 0, 0, 1, 0, halfLong, halfHeight, halfWidth, 1, 0, 0, 0, 0, halfLong, -halfHeight, halfWidth, 1, 0, 0, 0, 1, halfLong, -halfHeight, -halfWidth, 1, 0, 0, 1, 1,
                 //前
                 -halfLong, halfHeight, halfWidth, 0, 0, 1, 0, 0, halfLong, halfHeight, halfWidth, 0, 0, 1, 1, 0, halfLong, -halfHeight, halfWidth, 0, 0, 1, 1, 1, -halfLong, -halfHeight, halfWidth, 0, 0, 1, 0, 1,
                 //后
                 -halfLong, halfHeight, -halfWidth, 0, 0, -1, 1, 0, halfLong, halfHeight, -halfWidth, 0, 0, -1, 0, 0, halfLong, -halfHeight, -halfWidth, 0, 0, -1, 0, 1, -halfLong, -halfHeight, -halfWidth, 0, 0, -1, 1, 1
             ]);
             var indices = new Uint16Array([
                 //上
                 0, 1, 2, 2, 3, 0,
                 //下
                 4, 7, 6, 6, 5, 4,
                 //左
                 8, 9, 10, 10, 11, 8,
                 //右
                 12, 15, 14, 14, 13, 12,
                 //前
                 16, 17, 18, 18, 19, 16,
                 //后
                 20, 23, 22, 22, 21, 20
             ]);
             return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
         }
         /**
          * 创建一个胶囊体模型
          * @param radius 半径
          * @param height 高度
          * @param stacks 水平层数,一般设为垂直层数的一半
          * @param slices 垂直层数
          */
         static createCapsule(radius = 0.5, height = 2, stacks = 16, slices = 32) {
             var vertexCount = (stacks + 1) * (slices + 1) * 2 + (slices + 1) * 2;
             var indexCount = (3 * stacks * (slices + 1)) * 2 * 2 + 2 * slices * 3;
             //定义顶点数据结构
             var vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
             //单个顶点数据个数,总共字节数/单个字节数
             var vertexFloatStride = vertexDeclaration.vertexStride / 4;
             //顶点
             var vertices = new Float32Array(vertexCount * vertexFloatStride);
             //顶点索引
             var indices = new Uint16Array(indexCount);
             var stackAngle = (Math.PI / 2.0) / stacks;
             var sliceAngle = (Math.PI * 2.0) / slices;
             //圆柱体高度的一半
             var hcHeight = height / 2 - radius;
             var posX = 0;
             var posY = 0;
             var posZ = 0;
             var vc = 0;
             var ic = 0;
             var verticeCount = 0;
             var stack, slice;
             //顶部半球
             for (stack = 0; stack <= stacks; stack++) {
                 for (slice = 0; slice <= slices; slice++) {
                     posX = radius * Math.cos(stack * stackAngle) * Math.cos(slice * sliceAngle + Math.PI);
                     posY = radius * Math.sin(stack * stackAngle);
                     posZ = radius * Math.cos(stack * stackAngle) * Math.sin(slice * sliceAngle + Math.PI);
                     //pos
                     vertices[vc++] = posX;
                     vertices[vc++] = posY + hcHeight;
                     vertices[vc++] = posZ;
                     //normal
                     vertices[vc++] = posX;
                     vertices[vc++] = posY;
                     vertices[vc++] = posZ;
                     //uv
                     vertices[vc++] = 1 - slice / slices;
                     vertices[vc++] = (1 - stack / stacks) * ((Math.PI * radius / 2) / (height + Math.PI * radius));
                     if (stack < stacks) {
                         // First
                         indices[ic++] = (stack * (slices + 1)) + slice + (slices + 1);
                         indices[ic++] = (stack * (slices + 1)) + slice;
                         indices[ic++] = (stack * (slices + 1)) + slice + 1;
                         // Second
                         indices[ic++] = (stack * (slices + 1)) + slice + (slices);
                         indices[ic++] = (stack * (slices + 1)) + slice;
                         indices[ic++] = (stack * (slices + 1)) + slice + (slices + 1);
                     }
                 }
             }
             verticeCount += (stacks + 1) * (slices + 1);
             //底部半球
             for (stack = 0; stack <= stacks; stack++) {
                 for (slice = 0; slice <= slices; slice++) {
                     posX = radius * Math.cos(stack * stackAngle) * Math.cos(slice * sliceAngle + Math.PI);
                     posY = radius * Math.sin(-stack * stackAngle);
                     posZ = radius * Math.cos(stack * stackAngle) * Math.sin(slice * sliceAngle + Math.PI);
                     //pos
                     vertices[vc++] = posX;
                     vertices[vc++] = posY - hcHeight;
                     vertices[vc++] = posZ;
                     //normal
                     vertices[vc++] = posX;
                     vertices[vc++] = posY;
                     vertices[vc++] = posZ;
                     //uv
                     vertices[vc++] = 1 - slice / slices;
                     vertices[vc++] = ((stack / stacks) * (Math.PI * radius / 2) + (height + Math.PI * radius / 2)) / (height + Math.PI * radius);
                     if (stack < stacks) {
                         // First
                         indices[ic++] = verticeCount + (stack * (slices + 1)) + slice;
                         indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + (slices + 1);
                         indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + 1;
                         // Second
                         indices[ic++] = verticeCount + (stack * (slices + 1)) + slice;
                         indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + (slices);
                         indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + (slices + 1);
                     }
                 }
             }
             verticeCount += (stacks + 1) * (slices + 1);
             //侧壁
             for (slice = 0; slice <= slices; slice++) {
                 posX = radius * Math.cos(slice * sliceAngle + Math.PI);
                 posY = hcHeight;
                 posZ = radius * Math.sin(slice * sliceAngle + Math.PI);
                 //pos
                 vertices[vc++] = posX;
                 vertices[vc + (slices + 1) * 8 - 1] = posX;
                 vertices[vc++] = posY;
                 vertices[vc + (slices + 1) * 8 - 1] = -posY;
                 vertices[vc++] = posZ;
                 vertices[vc + (slices + 1) * 8 - 1] = posZ;
                 //normal
                 vertices[vc++] = posX;
                 vertices[vc + (slices + 1) * 8 - 1] = posX;
                 vertices[vc++] = 0;
                 vertices[vc + (slices + 1) * 8 - 1] = 0;
                 vertices[vc++] = posZ;
                 vertices[vc + (slices + 1) * 8 - 1] = posZ;
                 //uv    
                 vertices[vc++] = 1 - slice * 1 / slices;
                 vertices[vc + (slices + 1) * 8 - 1] = 1 - slice * 1 / slices;
                 vertices[vc++] = (Math.PI * radius / 2) / (height + Math.PI * radius);
                 vertices[vc + (slices + 1) * 8 - 1] = (Math.PI * radius / 2 + height) / (height + Math.PI * radius);
             }
             for (slice = 0; slice < slices; slice++) {
                 indices[ic++] = slice + verticeCount + (slices + 1);
                 indices[ic++] = slice + verticeCount + 1;
                 indices[ic++] = slice + verticeCount;
                 indices[ic++] = slice + verticeCount + (slices + 1);
                 indices[ic++] = slice + verticeCount + (slices + 1) + 1;
                 indices[ic++] = slice + verticeCount + 1;
             }
             verticeCount += 2 * (slices + 1);
             return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
         }
         /**
          * 创建一个圆锥体模型
          * @param radius 半径
          * @param height 高度
          * @param slices 分段数
          */
         static createCone(radius = 0.5, height = 1, slices = 32) {
             //(this._released) || (dispose());//如果已存在，则释放资源
             var vertexCount = (slices + 1 + 1) + (slices + 1) * 2;
             var indexCount = 6 * slices + 3 * slices;
             //定义顶点数据结构
             var vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
             //单个顶点数据个数,总共字节数/单个字节数
             var vertexFloatStride = vertexDeclaration.vertexStride / 4;
             //顶点
             var vertices = new Float32Array(vertexCount * vertexFloatStride);
             //顶点索引
             var indices = new Uint16Array(indexCount);
             var sliceAngle = (Math.PI * 2.0) / slices;
             var halfHeight = height / 2;
             var curAngle = 0;
             var verticeCount = 0;
             var posX = 0;
             var posY = 0;
             var posZ = 0;
             var normal = new Vector3();
             var downV3 = new Vector3(0, -1, 0);
             var upPoint = new Vector3(0, halfHeight, 0);
             var downPoint = new Vector3();
             var v3 = new Vector3();
             var q4 = new Quaternion();
             var rotateAxis = new Vector3();
             var rotateRadius;
             var vc = 0;
             var ic = 0;
             //壁
             for (var rv = 0; rv <= slices; rv++) {
                 curAngle = rv * sliceAngle;
                 posX = Math.cos(curAngle + Math.PI) * radius;
                 posY = halfHeight;
                 posZ = Math.sin(curAngle + Math.PI) * radius;
                 //pos
                 vertices[vc++] = 0;
                 vertices[vc + (slices + 1) * 8 - 1] = posX;
                 vertices[vc++] = posY;
                 vertices[vc + (slices + 1) * 8 - 1] = -posY;
                 vertices[vc++] = 0;
                 vertices[vc + (slices + 1) * 8 - 1] = posZ;
                 normal.x = posX;
                 normal.y = 0;
                 normal.z = posZ;
                 downPoint.x = posX;
                 downPoint.y = -posY;
                 downPoint.z = posZ;
                 Vector3.subtract(downPoint, upPoint, v3);
                 Vector3.normalize(v3, v3);
                 rotateRadius = Math.acos(Vector3.dot(downV3, v3));
                 Vector3.cross(downV3, v3, rotateAxis);
                 Vector3.normalize(rotateAxis, rotateAxis);
                 Quaternion.createFromAxisAngle(rotateAxis, rotateRadius, q4);
                 Vector3.normalize(normal, normal);
                 Vector3.transformQuat(normal, q4, normal);
                 Vector3.normalize(normal, normal);
                 //normal
                 vertices[vc++] = normal.x;
                 vertices[vc + (slices + 1) * 8 - 1] = normal.x;
                 vertices[vc++] = normal.y;
                 vertices[vc + (slices + 1) * 8 - 1] = normal.y;
                 vertices[vc++] = normal.z;
                 vertices[vc + (slices + 1) * 8 - 1] = normal.z;
                 //uv    
                 vertices[vc++] = 1 - rv * 1 / slices;
                 vertices[vc + (slices + 1) * 8 - 1] = 1 - rv * 1 / slices;
                 vertices[vc++] = 0;
                 vertices[vc + (slices + 1) * 8 - 1] = 1;
             }
             vc += (slices + 1) * 8;
             for (var ri = 0; ri < slices; ri++) {
                 indices[ic++] = ri + verticeCount + (slices + 1);
                 indices[ic++] = ri + verticeCount + 1;
                 indices[ic++] = ri + verticeCount;
                 indices[ic++] = ri + verticeCount + (slices + 1);
                 indices[ic++] = ri + verticeCount + (slices + 1) + 1;
                 indices[ic++] = ri + verticeCount + 1;
             }
             verticeCount += 2 * (slices + 1);
             //底
             for (var bv = 0; bv <= slices; bv++) {
                 if (bv === 0) {
                     //pos
                     vertices[vc++] = 0;
                     vertices[vc++] = -halfHeight;
                     vertices[vc++] = 0;
                     //normal
                     vertices[vc++] = 0;
                     vertices[vc++] = -1;
                     vertices[vc++] = 0;
                     //uv
                     vertices[vc++] = 0.5;
                     vertices[vc++] = 0.5;
                 }
                 curAngle = bv * sliceAngle;
                 posX = Math.cos(curAngle + Math.PI) * radius;
                 posY = -halfHeight;
                 posZ = Math.sin(curAngle + Math.PI) * radius;
                 //pos
                 vertices[vc++] = posX;
                 vertices[vc++] = posY;
                 vertices[vc++] = posZ;
                 //normal
                 vertices[vc++] = 0;
                 vertices[vc++] = -1;
                 vertices[vc++] = 0;
                 //uv
                 vertices[vc++] = 0.5 + Math.cos(curAngle) * 0.5;
                 vertices[vc++] = 0.5 + Math.sin(curAngle) * 0.5;
             }
             for (var bi = 0; bi < slices; bi++) {
                 indices[ic++] = 0 + verticeCount;
                 indices[ic++] = bi + 2 + verticeCount;
                 indices[ic++] = bi + 1 + verticeCount;
             }
             verticeCount += slices + 1 + 1;
             return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
         }
         /**
          * 创建一个圆柱体模型
          * @param radius 半径
          * @param height 高度
          * @param slices 垂直层数
          */
         static createCylinder(radius = 0.5, height = 2, slices = 32) {
             //(this._released) || (dispose());//如果已存在，则释放资源
             var vertexCount = (slices + 1 + 1) + (slices + 1) * 2 + (slices + 1 + 1);
             var indexCount = 3 * slices + 6 * slices + 3 * slices;
             //定义顶点数据结构
             var vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
             //单个顶点数据个数,总共字节数/单个字节数
             var vertexFloatStride = vertexDeclaration.vertexStride / 4;
             //顶点
             var vertices = new Float32Array(vertexCount * vertexFloatStride);
             //顶点索引
             var indices = new Uint16Array(indexCount);
             var sliceAngle = (Math.PI * 2.0) / slices;
             var halfHeight = height / 2;
             var curAngle = 0;
             var verticeCount = 0;
             var posX = 0;
             var posY = 0;
             var posZ = 0;
             var vc = 0;
             var ic = 0;
             //顶
             for (var tv = 0; tv <= slices; tv++) {
                 if (tv === 0) {
                     //pos
                     vertices[vc++] = 0;
                     vertices[vc++] = halfHeight;
                     vertices[vc++] = 0;
                     //normal
                     vertices[vc++] = 0;
                     vertices[vc++] = 1;
                     vertices[vc++] = 0;
                     //uv
                     vertices[vc++] = 0.5;
                     vertices[vc++] = 0.5;
                 }
                 curAngle = tv * sliceAngle;
                 posX = Math.cos(curAngle) * radius;
                 posY = halfHeight;
                 posZ = Math.sin(curAngle) * radius;
                 //pos
                 vertices[vc++] = posX;
                 vertices[vc++] = posY;
                 vertices[vc++] = posZ;
                 //normal
                 vertices[vc++] = 0;
                 vertices[vc++] = 1;
                 vertices[vc++] = 0;
                 //uv
                 vertices[vc++] = 0.5 + Math.cos(curAngle) * 0.5;
                 vertices[vc++] = 0.5 + Math.sin(curAngle) * 0.5;
             }
             for (var ti = 0; ti < slices; ti++) {
                 indices[ic++] = 0;
                 indices[ic++] = ti + 1;
                 indices[ic++] = ti + 2;
             }
             verticeCount += slices + 1 + 1;
             //壁
             for (var rv = 0; rv <= slices; rv++) {
                 curAngle = rv * sliceAngle;
                 posX = Math.cos(curAngle + Math.PI) * radius;
                 posY = halfHeight;
                 posZ = Math.sin(curAngle + Math.PI) * radius;
                 //pos
                 vertices[vc++] = posX;
                 vertices[vc + (slices + 1) * 8 - 1] = posX;
                 vertices[vc++] = posY;
                 vertices[vc + (slices + 1) * 8 - 1] = -posY;
                 vertices[vc++] = posZ;
                 vertices[vc + (slices + 1) * 8 - 1] = posZ;
                 //normal
                 vertices[vc++] = posX;
                 vertices[vc + (slices + 1) * 8 - 1] = posX;
                 vertices[vc++] = 0;
                 vertices[vc + (slices + 1) * 8 - 1] = 0;
                 vertices[vc++] = posZ;
                 vertices[vc + (slices + 1) * 8 - 1] = posZ;
                 //uv    
                 vertices[vc++] = 1 - rv * 1 / slices;
                 vertices[vc + (slices + 1) * 8 - 1] = 1 - rv * 1 / slices;
                 vertices[vc++] = 0;
                 vertices[vc + (slices + 1) * 8 - 1] = 1;
             }
             vc += (slices + 1) * 8;
             for (var ri = 0; ri < slices; ri++) {
                 indices[ic++] = ri + verticeCount + (slices + 1);
                 indices[ic++] = ri + verticeCount + 1;
                 indices[ic++] = ri + verticeCount;
                 indices[ic++] = ri + verticeCount + (slices + 1);
                 indices[ic++] = ri + verticeCount + (slices + 1) + 1;
                 indices[ic++] = ri + verticeCount + 1;
             }
             verticeCount += 2 * (slices + 1);
             //底
             for (var bv = 0; bv <= slices; bv++) {
                 if (bv === 0) {
                     //pos
                     vertices[vc++] = 0;
                     vertices[vc++] = -halfHeight;
                     vertices[vc++] = 0;
                     //normal
                     vertices[vc++] = 0;
                     vertices[vc++] = -1;
                     vertices[vc++] = 0;
                     //uv
                     vertices[vc++] = 0.5;
                     vertices[vc++] = 0.5;
                 }
                 curAngle = bv * sliceAngle;
                 posX = Math.cos(curAngle + Math.PI) * radius;
                 posY = -halfHeight;
                 posZ = Math.sin(curAngle + Math.PI) * radius;
                 //pos
                 vertices[vc++] = posX;
                 vertices[vc++] = posY;
                 vertices[vc++] = posZ;
                 //normal
                 vertices[vc++] = 0;
                 vertices[vc++] = -1;
                 vertices[vc++] = 0;
                 //uv
                 vertices[vc++] = 0.5 + Math.cos(curAngle) * 0.5;
                 vertices[vc++] = 0.5 + Math.sin(curAngle) * 0.5;
             }
             for (var bi = 0; bi < slices; bi++) {
                 indices[ic++] = 0 + verticeCount;
                 indices[ic++] = bi + 2 + verticeCount;
                 indices[ic++] = bi + 1 + verticeCount;
             }
             verticeCount += slices + 1 + 1;
             return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
         }
         /**
          * 创建一个平面模型
          * @param long  长
          * @param width 宽
          */
         static createPlane(long = 10, width = 10, stacks = 10, slices = 10) {
             var vertexCount = (stacks + 1) * (slices + 1);
             var indexCount = stacks * slices * 2 * 3;
             var indices = new Uint16Array(indexCount);
             //定义顶点数据结构
             var vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
             //单个顶点数据个数,总共字节数/单个字节数
             var vertexFloatStride = vertexDeclaration.vertexStride / 4;
             //顶点数组长度
             var vertices = new Float32Array(vertexCount * vertexFloatStride);
             var halfLong = long / 2;
             var halfWidth = width / 2;
             var stacksLong = long / stacks;
             var slicesWidth = width / slices;
             var verticeCount = 0;
             for (var i = 0; i <= slices; i++) {
                 for (var j = 0; j <= stacks; j++) {
                     vertices[verticeCount++] = j * stacksLong - halfLong;
                     vertices[verticeCount++] = 0;
                     vertices[verticeCount++] = i * slicesWidth - halfWidth;
                     vertices[verticeCount++] = 0;
                     vertices[verticeCount++] = 1;
                     vertices[verticeCount++] = 0;
                     vertices[verticeCount++] = j * 1 / stacks;
                     vertices[verticeCount++] = i * 1 / slices;
                 }
             }
             var indiceIndex = 0;
             for (i = 0; i < slices; i++) {
                 for (j = 0; j < stacks; j++) {
                     indices[indiceIndex++] = (i + 1) * (stacks + 1) + j;
                     indices[indiceIndex++] = i * (stacks + 1) + j;
                     indices[indiceIndex++] = (i + 1) * (stacks + 1) + j + 1;
                     indices[indiceIndex++] = i * (stacks + 1) + j;
                     indices[indiceIndex++] = i * (stacks + 1) + j + 1;
                     indices[indiceIndex++] = (i + 1) * (stacks + 1) + j + 1;
                 }
             }
             return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
         }
         /**
          * 创建一个四边形模型
          * @param long  长
          * @param width 宽
          */
         static createQuad(long = 1, width = 1) {
             //定义顶点数据结构
             var vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
             //单个顶点数据个数,总共字节数/单个字节数
             var vertexFloatStride = vertexDeclaration.vertexStride / 4;
             var halfLong = long / 2;
             var halfWidth = width / 2;
             var vertices = new Float32Array([halfLong, halfWidth, 0, 0, 0, 1, 0, 0, halfLong, halfWidth, 0, 0, 0, 1, 1, 0, -halfLong, -halfWidth, 0, 0, 0, 1, 0, 1, halfLong, -halfWidth, 0, 0, 0, 1, 1, 1]);
             var indices = new Uint16Array([0, 1, 2, 3, 2, 1]);
             return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
         }
         /**
          * 创建一个球体模型
          * @param radius 半径
          * @param stacks 水平层数
          * @param slices 垂直层数
          */
         static createSphere(radius = 0.5, stacks = 32, slices = 32) {
             var vertexCount = (stacks + 1) * (slices + 1);
             var indexCount = (3 * stacks * (slices + 1)) * 2;
             var indices = new Uint16Array(indexCount);
             var vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
             var vertexFloatStride = vertexDeclaration.vertexStride / 4;
             var vertices = new Float32Array(vertexCount * vertexFloatStride);
             var stackAngle = Math.PI / stacks;
             var sliceAngle = (Math.PI * 2.0) / slices;
             // Generate the group of Stacks for the sphere  
             var vertexIndex = 0;
             vertexCount = 0;
             indexCount = 0;
             for (var stack = 0; stack < (stacks + 1); stack++) {
                 var r = Math.sin(stack * stackAngle);
                 var y = Math.cos(stack * stackAngle);
                 // Generate the group of segments for the current Stack  
                 for (var slice = 0; slice < (slices + 1); slice++) {
                     var x = r * Math.sin(slice * sliceAngle + Math.PI * 1 / 2);
                     var z = r * Math.cos(slice * sliceAngle + Math.PI * 1 / 2);
                     vertices[vertexCount + 0] = x * radius;
                     vertices[vertexCount + 1] = y * radius;
                     vertices[vertexCount + 2] = z * radius;
                     vertices[vertexCount + 3] = x;
                     vertices[vertexCount + 4] = y;
                     vertices[vertexCount + 5] = z;
                     vertices[vertexCount + 6] = slice / slices;
                     vertices[vertexCount + 7] = stack / stacks;
                     vertexCount += vertexFloatStride;
                     if (stack != (stacks - 1)) {
                         // First Face
                         indices[indexCount++] = vertexIndex + (slices + 1);
                         indices[indexCount++] = vertexIndex;
                         indices[indexCount++] = vertexIndex + 1;
                         // Second 
                         indices[indexCount++] = vertexIndex + (slices);
                         indices[indexCount++] = vertexIndex;
                         indices[indexCount++] = vertexIndex + (slices + 1);
                         vertexIndex++;
                     }
                 }
             }
             return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
         }
     }

     /**
      * 相对布局插件
      */
     class Widget extends Component {
         constructor() {
             super(...arguments);
             this._top = NaN;
             this._bottom = NaN;
             this._left = NaN;
             this._right = NaN;
             this._centerX = NaN;
             this._centerY = NaN;
         }
         /*override*/ onReset() {
             this._top = this._bottom = this._left = this._right = this._centerX = this._centerY = NaN;
         }
         /*override*/ _onEnable() {
             if (this.owner.parent)
                 this._onAdded();
             else
                 this.owner.once(Event.ADDED, this, this._onAdded);
         }
         /*override*/ _onDisable() {
             this.owner.off(Event.ADDED, this, this._onAdded);
             if (this.owner.parent)
                 this.owner.parent.off(Event.RESIZE, this, this._onParentResize);
         }
         /**
          * 对象被添加到显示列表的事件侦听处理函数。
          */
         /*override*/ _onAdded() {
             if (this.owner.parent)
                 this.owner.parent.on(Event.RESIZE, this, this._onParentResize);
             this.resetLayoutX();
             this.resetLayoutY();
         }
         /**
          * 父容器的 <code>Event.RESIZE</code> 事件侦听处理函数。
          */
         _onParentResize() {
             if (this.resetLayoutX() || this.resetLayoutY())
                 this.owner.event(Event.RESIZE);
         }
         /**
          * <p>重置对象的 <code>X</code> 轴（水平方向）布局。</p>
          * @private
          */
         resetLayoutX() {
             var owner = this.owner;
             if (!owner)
                 return false;
             var parent = owner.parent;
             if (parent) {
                 if (!isNaN(this.centerX)) {
                     owner.x = Math.round((parent.width - owner.displayWidth) * 0.5 + this.centerX + owner.pivotX * owner.scaleX);
                 }
                 else if (!isNaN(this.left)) {
                     owner.x = Math.round(this.left + owner.pivotX * owner.scaleX);
                     if (!isNaN(this.right)) {
                         //TODO:如果用width，会死循环
                         var temp = (parent._width - this.left - this.right) / (owner.scaleX || 0.01);
                         if (temp != owner.width) {
                             owner.width = temp;
                             return true;
                         }
                     }
                 }
                 else if (!isNaN(this.right)) {
                     owner.x = Math.round(parent.width - owner.displayWidth - this.right + owner.pivotX * owner.scaleX);
                 }
             }
             return false;
         }
         /**
          * <p>重置对象的 <code>Y</code> 轴（垂直方向）布局。</p>
          * @private
          */
         resetLayoutY() {
             var owner = this.owner;
             if (!owner)
                 return false;
             var parent = owner.parent;
             if (parent) {
                 if (!isNaN(this.centerY)) {
                     owner.y = Math.round((parent.height - owner.displayHeight) * 0.5 + this.centerY + owner.pivotY * owner.scaleY);
                 }
                 else if (!isNaN(this.top)) {
                     owner.y = Math.round(this.top + owner.pivotY * owner.scaleY);
                     if (!isNaN(this.bottom)) {
                         //TODO:
                         var temp = (parent._height - this.top - this.bottom) / (owner.scaleY || 0.01);
                         if (temp != owner.height) {
                             owner.height = temp;
                             return true;
                         }
                     }
                 }
                 else if (!isNaN(this.bottom)) {
                     owner.y = Math.round(parent.height - owner.displayHeight - this.bottom + owner.pivotY * owner.scaleY);
                 }
             }
             return false;
         }
         /**
          * 重新计算布局
          */
         resetLayout() {
             if (this.owner) {
                 this.resetLayoutX();
                 this.resetLayoutY();
             }
         }
         /**表示距顶边的距离（以像素为单位）。*/
         get top() {
             return this._top;
         }
         set top(value) {
             if (this._top != value) {
                 this._top = value;
                 this.resetLayoutY();
             }
         }
         /**表示距底边的距离（以像素为单位）。*/
         get bottom() {
             return this._bottom;
         }
         set bottom(value) {
             if (this._bottom != value) {
                 this._bottom = value;
                 this.resetLayoutY();
             }
         }
         /**表示距左边的距离（以像素为单位）。*/
         get left() {
             return this._left;
         }
         set left(value) {
             if (this._left != value) {
                 this._left = value;
                 this.resetLayoutX();
             }
         }
         /**表示距右边的距离（以像素为单位）。*/
         get right() {
             return this._right;
         }
         set right(value) {
             if (this._right != value) {
                 this._right = value;
                 this.resetLayoutX();
             }
         }
         /**表示距水平方向中心轴的距离（以像素为单位）。*/
         get centerX() {
             return this._centerX;
         }
         set centerX(value) {
             if (this._centerX != value) {
                 this._centerX = value;
                 this.resetLayoutX();
             }
         }
         /**表示距垂直方向中心轴的距离（以像素为单位）。*/
         get centerY() {
             return this._centerY;
         }
         set centerY(value) {
             if (this._centerY != value) {
                 this._centerY = value;
                 this.resetLayoutY();
             }
         }
     }
     /**一个已初始化的 <code>Widget</code> 实例。*/
     Widget.EMPTY = null; // new Widget();
     ILaya.regClass(Widget);
     Widget.EMPTY = new Widget();

     /**
      * <code>UIEvent</code> 类用来定义UI组件类的事件类型。
      */
     class UIEvent extends Event {
     }
     /**
      * 显示提示信息。
      */
     UIEvent.SHOW_TIP = "showtip";
     /**
      * 隐藏提示信息。
      */
     UIEvent.HIDE_TIP = "hidetip";
     ILaya.regClass(UIEvent);

     /**
      * <code>UIUtils</code> 是文本工具集。
      */
     class UIUtils {
         /**
          * 用字符串填充数组，并返回数组副本。
          * @param	arr 源数组对象。
          * @param	str 用逗号连接的字符串。如"p1,p2,p3,p4"。
          * @param	type 如果值不为null，则填充的是新增值得类型。
          * @return 填充后的数组。
          */
         static fillArray(arr, str, type = null) {
             var temp = arr.concat();
             if (str) {
                 var a = str.split(",");
                 for (var i = 0, n = Math.min(temp.length, a.length); i < n; i++) {
                     var value = a[i];
                     temp[i] = (value == "true" ? true : (value == "false" ? false : value));
                     if (type != null)
                         temp[i] = type(value);
                 }
             }
             return temp;
         }
         /**
          * 转换uint类型颜色值为字符型颜色值。
          * @param color uint颜色值。
          * @return 字符型颜色值。
          */
         static toColor(color) {
             return Utils.toHexColor(color);
         }
         /**
          * 给指定的目标显示对象添加或移除灰度滤镜。
          * @param	traget 目标显示对象。
          * @param	isGray 如果值true，则添加灰度滤镜，否则移除灰度滤镜。
          */
         //TODO:coverage
         static gray(traget, isGray = true) {
             if (isGray) {
                 UIUtils.addFilter(traget, UIUtils.grayFilter);
             }
             else {
                 UIUtils.clearFilter(traget, ColorFilter);
             }
         }
         /**
          * 给指定的目标显示对象添加滤镜。
          * @param	target 目标显示对象。
          * @param	filter 滤镜对象。
          */
         //TODO:coverage
         static addFilter(target, filter) {
             var filters = target.filters || [];
             filters.push(filter);
             target.filters = filters;
         }
         /**
          * 移除目标显示对象的指定类型滤镜。
          * @param	target 目标显示对象。
          * @param	filterType 滤镜类型。
          */
         //TODO:coverage
         static clearFilter(target, filterType) {
             var filters = target.filters;
             if (filters != null && filters.length > 0) {
                 for (var i = filters.length - 1; i > -1; i--) {
                     var filter = filters[i];
                     if (filter instanceof filterType)
                         filters.splice(i, 1);
                 }
                 target.filters = filters;
             }
         }
         /**
          * 获取当前要替换的转移字符
          * @param word
          * @return
          *
          */
         //TODO:coverage
         static _getReplaceStr(word) {
             return UIUtils.escapeSequence[word];
         }
         /**
          * 替换字符串中的转义字符
          * @param str
          */
         static adptString(str) {
             return str.replace(/\\(\w)/g, UIUtils._getReplaceStr);
         }
         /**
          * @private 根据字符串，返回函数表达式
          */
         //TODO:coverage
         static getBindFun(value) {
             var fun = UIUtils._funMap.get(value);
             if (fun == null) {
                 var temp = "\"" + value + "\"";
                 temp = temp.replace(/^"\${|}"$/g, "").replace(/\${/g, "\"+").replace(/}/g, "+\"");
                 var str = "(function(data){if(data==null)return;with(data){try{\nreturn " + temp + "\n}catch(e){}}})";
                 fun = window.Laya._runScript(str);
                 UIUtils._funMap.set(value, fun);
             }
             return fun;
         }
     }
     UIUtils.grayFilter = new ColorFilter([0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0, 0, 0, 1, 0]);
     /**
      * 需要替换的转义字符表
      */
     UIUtils.escapeSequence = { "\\n": "\n", "\\t": "\t" };
     /**@private */
     UIUtils._funMap = new WeakObject();

     /**
      * <code>Component</code> 是ui控件类的基类。
      * <p>生命周期：preinitialize > createChildren > initialize > 组件构造函数</p>
      */
     class UIComponent extends Sprite {
         /**
          * <p>创建一个新的 <code>Component</code> 实例。</p>
          */
         constructor() {
             super();
             /**X锚点，值为0-1，设置anchorX值最终通过pivotX值来改变节点轴心点。*/
             this._anchorX = NaN;
             /**Y锚点，值为0-1，设置anchorY值最终通过pivotY值来改变节点轴心点。*/
             this._anchorY = NaN;
             /**@private 相对布局组件*/
             this._widget = Widget.EMPTY;
             this.preinitialize();
             this.createChildren();
             this.initialize();
         }
         /**@inheritDoc */
         /*override*/ destroy(destroyChild = true) {
             super.destroy(destroyChild);
             this._dataSource = null;
             this._tag = null;
             this._toolTip = null;
         }
         /**
          * <p>预初始化。</p>
          * @internal 子类可在此函数内设置、修改属性默认值
          */
         preinitialize() {
         }
         /**
          * <p>创建并添加控件子节点。</p>
          * @internal 子类可在此函数内创建并添加子节点。
          */
         createChildren() {
         }
         /**
          * <p>控件初始化。</p>
          * @internal 在此子对象已被创建，可以对子对象进行修改。
          */
         initialize() {
         }
         /**
          * <p>表示显示对象的宽度，以像素为单位。</p>
          * <p><b>注：</b>当值为0时，宽度为自适应大小。</p>
          */
         /*override*/ get width() {
             return this.get_width();
         }
         get_width() {
             if (this._width)
                 return this._width;
             return this.measureWidth();
         }
         /**
          * <p>显示对象的实际显示区域宽度（以像素为单位）。</p>
          */
         measureWidth() {
             var max = 0;
             this.commitMeasure();
             for (var i = this.numChildren - 1; i > -1; i--) {
                 var comp = this.getChildAt(i);
                 if (comp._visible) {
                     max = Math.max(comp._x + comp.width * comp.scaleX, max);
                 }
             }
             return max;
         }
         /**
          * <p>立即执行影响宽高度量的延迟调用函数。</p>
          * @internal <p>使用 <code>runCallLater</code> 函数，立即执行影响宽高度量的延迟运行函数(使用 <code>callLater</code> 设置延迟执行函数)。</p>
          * @see #callLater()
          * @see #runCallLater()
          */
         commitMeasure() {
         }
         /**
          * <p>表示显示对象的高度，以像素为单位。</p>
          * <p><b>注：</b>当值为0时，高度为自适应大小。</p>
          */
         /*override*/ get height() {
             return this.get_height();
         }
         get_height() {
             if (this._height)
                 return this._height;
             return this.measureHeight();
         }
         /**
          * <p>显示对象的实际显示区域高度（以像素为单位）。</p>
          */
         measureHeight() {
             var max = 0;
             this.commitMeasure();
             for (var i = this.numChildren - 1; i > -1; i--) {
                 var comp = this.getChildAt(i);
                 if (comp._visible) {
                     max = Math.max(comp._y + comp.height * comp.scaleY, max);
                 }
             }
             return max;
         }
         /**
          * <p>数据赋值，通过对UI赋值来控制UI显示逻辑。</p>
          * <p>简单赋值会更改组件的默认属性，使用大括号可以指定组件的任意属性进行赋值。</p>
          * @example
            //默认属性赋值
            dataSource = {label1: "改变了label", checkbox1: true};//(更改了label1的text属性值，更改checkbox1的selected属性)。
            //任意属性赋值
            dataSource = {label2: {text:"改变了label",size:14}, checkbox2: {selected:true,x:10}};
          */
         get dataSource() {
             return this.get_dataSource();
         }
         get_dataSource() {
             return this._dataSource;
         }
         set dataSource(value) {
             this.set_dataSource(value);
         }
         set_dataSource(value) {
             this._dataSource = value;
             for (var prop in this._dataSource) {
                 if (prop in this && !(typeof (this[prop]) == 'function')) {
                     this[prop] = this._dataSource[prop];
                 }
             }
         }
         /**
          * <p>从组件顶边到其内容区域顶边之间的垂直距离（以像素为单位）。</p>
          */
         get top() {
             return this.get_top();
         }
         get_top() {
             return this._widget.top;
         }
         set top(value) {
             this.set_top(value);
         }
         set_top(value) {
             if (value != this._widget.top) {
                 this._getWidget().top = value;
             }
         }
         /**
          * <p>从组件底边到其内容区域底边之间的垂直距离（以像素为单位）。</p>
          */
         get bottom() {
             return this.get_bottom();
         }
         get_bottom() {
             return this._widget.bottom;
         }
         set bottom(value) {
             this.set_bottom(value);
         }
         set_bottom(value) {
             if (value != this._widget.bottom) {
                 this._getWidget().bottom = value;
             }
         }
         /**
          * <p>从组件左边到其内容区域左边之间的水平距离（以像素为单位）。</p>
          */
         get left() {
             return this._widget.left;
         }
         set left(value) {
             if (value != this._widget.left) {
                 this._getWidget().left = value;
             }
         }
         /**
          * <p>从组件右边到其内容区域右边之间的水平距离（以像素为单位）。</p>
          */
         get right() {
             return this._widget.right;
         }
         set right(value) {
             if (value != this._widget.right) {
                 this._getWidget().right = value;
             }
         }
         /**
          * <p>在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。</p>
          */
         get centerX() {
             return this._widget.centerX;
         }
         set centerX(value) {
             if (value != this._widget.centerX) {
                 this._getWidget().centerX = value;
             }
         }
         /**
          * <p>在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。</p>
          */
         get centerY() {
             return this._widget.centerY;
         }
         set centerY(value) {
             if (value != this._widget.centerY) {
                 this._getWidget().centerY = value;
             }
         }
         _sizeChanged() {
             if (!isNaN(this._anchorX))
                 this.pivotX = this.anchorX * this.width;
             if (!isNaN(this._anchorY))
                 this.pivotY = this.anchorY * this.height;
             this.event(Event.RESIZE);
             if (this._widget !== Widget.EMPTY)
                 this._widget.resetLayout();
         }
         /**
          * <p>对象的标签。</p>
          * @internal 冗余字段，可以用来储存数据。
          */
         get tag() {
             return this._tag;
         }
         set tag(value) {
             this._tag = value;
         }
         /**
          * <p>鼠标悬停提示。</p>
          * <p>可以赋值为文本 <code>String</code> 或函数 <code>Handler</code> ，用来实现自定义样式的鼠标提示和参数携带等。</p>
          * @example
          * private var _testTips:TestTipsUI = new TestTipsUI();
          * private function testTips():void {
            //简单鼠标提示
          * btn2.toolTip = "这里是鼠标提示&lt;b&gt;粗体&lt;/b&gt;&lt;br&gt;换行";
            //自定义的鼠标提示
          * btn1.toolTip = showTips1;
            //带参数的自定义鼠标提示
          * clip.toolTip = new Handler(this,showTips2, ["clip"]);
          * }
          * private function showTips1():void {
          * _testTips.label.text = "这里是按钮[" + btn1.label + "]";
          * tip.addChild(_testTips);
          * }
          * private function showTips2(name:String):void {
          * _testTips.label.text = "这里是" + name;
          * tip.addChild(_testTips);
          * }
          */
         get toolTip() {
             return this._toolTip;
         }
         set toolTip(value) {
             if (this._toolTip != value) {
                 this._toolTip = value;
                 if (value != null) {
                     this.on(Event.MOUSE_OVER, this, this.onMouseOver);
                     this.on(Event.MOUSE_OUT, this, this.onMouseOut);
                 }
                 else {
                     this.off(Event.MOUSE_OVER, this, this.onMouseOver);
                     this.off(Event.MOUSE_OUT, this, this.onMouseOut);
                 }
             }
         }
         /**
          * 对象的 <code>Event.MOUSE_OVER</code> 事件侦听处理函数。
          */
         onMouseOver(e) {
             window.Laya.stage.event(UIEvent.SHOW_TIP, this._toolTip);
         }
         /**
          * 对象的 <code>Event.MOUSE_OUT</code> 事件侦听处理函数。
          */
         onMouseOut(e) {
             window.Laya.stage.event(UIEvent.HIDE_TIP, this._toolTip);
         }
         /** 是否变灰。*/
         get gray() {
             return this._gray;
         }
         set gray(value) {
             if (value !== this._gray) {
                 this._gray = value;
                 UIUtils.gray(this, value);
             }
         }
         /** 是否禁用页面，设置为true后，会变灰并且禁用鼠标。*/
         get disabled() {
             return this._disabled;
         }
         set disabled(value) {
             if (value !== this._disabled) {
                 this.gray = this._disabled = value;
                 this.mouseEnabled = !value;
             }
         }
         /**
          * @private
          * <p>获取对象的布局样式。请不要直接修改此对象</p>
          */
         _getWidget() {
             this._widget === Widget.EMPTY && (this._widget = this.addComponent(Widget));
             return this._widget;
         }
         /**@inheritDoc */
         /*override*/ set scaleX(value) {
             this.set_scaleX(value);
         }
         set_scaleX(value) {
             if (super.get_scaleX() == value)
                 return;
             super.set_scaleX(value);
             this.event(Event.RESIZE);
         }
         get scaleX() {
             return super.scaleX;
         }
         /**@inheritDoc */
         /*override*/ set scaleY(value) {
             this.set_scaleY(value);
         }
         set_scaleY(value) {
             if (super.get_scaleY() == value)
                 return;
             super.set_scaleY(value);
             this.event(Event.RESIZE);
         }
         get scaleY() {
             return super.scaleY;
         }
         /**@private */
         onCompResize() {
             this._sizeChanged();
         }
         /**@inheritDoc */
         /*override*/ set width(value) {
             this.set_width(value);
         }
         set_width(value) {
             if (super.get_width() == value)
                 return;
             super.set_width(value);
             this.callLater(this._sizeChanged);
         }
         /**@inheritDoc */
         /*override*/ set height(value) {
             this.set_height(value);
         }
         set_height(value) {
             if (super.get_height() == value)
                 return;
             super.set_height(value);
             this.callLater(this._sizeChanged);
         }
         /**X锚点，值为0-1，设置anchorX值最终通过pivotX值来改变节点轴心点。*/
         get anchorX() {
             return this.get_anchorX();
         }
         get_anchorX() {
             return this._anchorX;
         }
         set anchorX(value) {
             this.set_anchorX(value);
         }
         set_anchorX(value) {
             if (this._anchorX != value) {
                 this._anchorX = value;
                 this.callLater(this._sizeChanged);
             }
         }
         /**Y锚点，值为0-1，设置anchorY值最终通过pivotY值来改变节点轴心点。*/
         get anchorY() {
             return this.get_anchorY();
         }
         get_anchorY() {
             return this._anchorY;
         }
         set anchorY(value) {
             this.set_anchorY(value);
         }
         set_anchorY(value) {
             if (this._anchorY != value) {
                 this._anchorY = value;
                 this.callLater(this._sizeChanged);
             }
         }
         /*override*/ _childChanged(child = null) {
             this.callLater(this._sizeChanged);
             super._childChanged(child);
         }
     }
     ILaya.regClass(UIComponent);

     /**
          * <code>Styles</code> 定义了组件常用的样式属性。
          */
     class Styles {
     }
     /**
      * 默认九宫格信息。
      * @see laya.ui.AutoBitmap#sizeGrid
      */
     Styles.defaultSizeGrid = [4, 4, 4, 4, 0];
     //-----------------Label-----------------
     /**
      * 标签颜色。
      */
     Styles.labelColor = "#000000";
     /**
      * 标签的边距。
      * <p><b>格式：</b>[上边距，右边距，下边距，左边距]。</p>
      */
     Styles.labelPadding = [2, 2, 2, 2];
     /**
      * 标签的边距。
      * <p><b>格式：</b>[上边距，右边距，下边距，左边距]。</p>
      */
     Styles.inputLabelPadding = [1, 1, 1, 3];
     //-----------------Button-----------------
     /**
      * 按钮皮肤的状态数，支持1,2,3三种状态值。
      */
     Styles.buttonStateNum = 3;
     /**
      * 按钮标签颜色。
      * <p><b>格式：</b>[upColor,overColor,downColor,disableColor]。</p>
      */
     Styles.buttonLabelColors = ["#32556b", "#32cc6b", "#ff0000", "#C0C0C0"];
     //-----------------ComboBox-----------------
     /**
      * 下拉框项颜色。
      * <p><b>格式：</b>[overBgColor,overLabelColor,outLabelColor,borderColor,bgColor]。</p>
      */
     Styles.comboBoxItemColors = ["#5e95b6", "#ffffff", "#000000", "#8fa4b1", "#ffffff"];
     //-----------------ScrollBar-----------------
     /**
      * 滚动条的最小值。
      */
     Styles.scrollBarMinNum = 15;
     /**
      * 长按按钮，等待时间，使其可激活连续滚动。
      */
     Styles.scrollBarDelayTime = 500;
     ILaya.regClass(Styles);

     /**
      * <code>AutoBitmap</code> 类是用于表示位图图像或绘制图形的显示对象。
      * <p>封装了位置，宽高及九宫格的处理，供UI组件使用。</p>
      */
     class AutoBitmap extends Graphics {
         constructor() {
             super(...arguments);
             /**@private 是否自动缓存命令*/
             this.autoCacheCmd = true;
             /**@private 宽度*/
             this._width = 0;
             /**@private 高度*/
             this._height = 0;
             //override public function clear(recoverCmds:Boolean = true):void {
             ////重写clear，防止缓存被清理
             //super.clear(recoverCmds);
             //_key && WeakObject.I.del(_key);
             //}
         }
         ///**@private */
         //private var _key:String;
         /**@inheritDoc */
         /*override*/ destroy() {
             super.destroy();
             this._source = null;
             this._sizeGrid = null;
             this._offset = null;
         }
         /**
          * 当前实例的有效缩放网格数据。
          * <p>如果设置为null,则在应用任何缩放转换时，将正常缩放整个显示对象。</p>
          * <p>数据格式：[上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)]。
          * <ul><li>例如：[4,4,4,4,1]</li></ul></p>
          * <p> <code>sizeGrid</code> 的值如下所示：
          * <ol>
          * <li>上边距</li>
          * <li>右边距</li>
          * <li>下边距</li>
          * <li>左边距</li>
          * <li>是否重复填充(值为0：不重复填充，1：重复填充)</li>
          * </ol></p>
          * <p>当定义 <code>sizeGrid</code> 属性时，该显示对象被分割到以 <code>sizeGrid</code> 数据中的"上边距,右边距,下边距,左边距" 组成的矩形为基础的具有九个区域的网格中，该矩形定义网格的中心区域。网格的其它八个区域如下所示：
          * <ul>
          * <li>矩形上方的区域</li>
          * <li>矩形外的右上角</li>
          * <li>矩形左侧的区域</li>
          * <li>矩形右侧的区域</li>
          * <li>矩形外的左下角</li>
          * <li>矩形下方的区域</li>
          * <li>矩形外的右下角</li>
          * <li>矩形外的左上角</li>
          * </ul>
          * 同时也支持3宫格，比如0,4,0,4,1为水平3宫格，4,0,4,0,1为垂直3宫格，3宫格性能比9宫格高。
          * </p>
          */
         get sizeGrid() {
             return this._sizeGrid;
         }
         set sizeGrid(value) {
             this._sizeGrid = value.map((v) => { return +v; });
             this._setChanged();
         }
         /**
          * 表示显示对象的宽度，以像素为单位。
          */
         get width() {
             if (this._width)
                 return this._width;
             if (this._source)
                 return this._source.sourceWidth;
             return 0;
         }
         set width(value) {
             if (this._width != value) {
                 this._width = value;
                 this._setChanged();
             }
         }
         /**
          * 表示显示对象的高度，以像素为单位。
          */
         get height() {
             if (this._height)
                 return this._height;
             if (this._source)
                 return this._source.sourceHeight;
             return 0;
         }
         set height(value) {
             if (this._height != value) {
                 this._height = value;
                 this._setChanged();
             }
         }
         /**
          * 对象的纹理资源。
          * @see laya.resource.Texture
          */
         get source() {
             return this._source;
         }
         set source(value) {
             if (value) {
                 this._source = value;
                 this._setChanged();
             }
             else {
                 this._source = null;
                 this.clear();
             }
         }
         /** @private */
         _setChanged() {
             if (!this._isChanged) {
                 this._isChanged = true;
                 window.Laya.timer.callLater(this, this.changeSource);
             }
         }
         /**
          * @private
          * 修改纹理资源。
          */
         changeSource() {
             this._isChanged = false;
             var source = this._source;
             if (!source || !source.bitmap)
                 return;
             var width = this.width;
             var height = this.height;
             var sizeGrid = this._sizeGrid;
             var sw = source.sourceWidth;
             var sh = source.sourceHeight;
             //如果没有设置9宫格，或大小未改变，则直接用原图绘制
             if (!sizeGrid || (sw === width && sh === height)) {
                 this.clear();
                 this.drawTexture(source, this._offset ? this._offset[0] : 0, this._offset ? this._offset[1] : 0, width, height);
             }
             else {
                 //从缓存中读取渲染命令(和回收冲突，暂时去掉)
                 //source.$_GID || (source.$_GID = Utils.getGID());
                 //_key = source.$_GID + "." + width + "." + height + "." + sizeGrid.join(".");
                 //if (Utils.isOKCmdList(WeakObject.I.get(_key))) {
                 //this.cmds = WeakObject.I.get(_key);
                 //return;
                 //}
                 this.clear();
                 var top = sizeGrid[0];
                 var right = sizeGrid[1];
                 var bottom = sizeGrid[2];
                 var left = sizeGrid[3];
                 var repeat = sizeGrid[4];
                 var needClip = false;
                 if (width == sw) {
                     left = right = 0;
                 }
                 if (height == sh) {
                     top = bottom = 0;
                 }
                 //处理进度条不好看的问题
                 if (left + right > width) {
                     var clipWidth = width;
                     needClip = true;
                     width = left + right;
                     this.save();
                     this.clipRect(0, 0, clipWidth, height);
                 }
                 //绘制四个角
                 left && top && this.drawImage(AutoBitmap.getTexture(source, 0, 0, left, top), 0, 0, left, top);
                 right && top && this.drawImage(AutoBitmap.getTexture(source, sw - right, 0, right, top), width - right, 0, right, top);
                 left && bottom && this.drawImage(AutoBitmap.getTexture(source, 0, sh - bottom, left, bottom), 0, height - bottom, left, bottom);
                 right && bottom && this.drawImage(AutoBitmap.getTexture(source, sw - right, sh - bottom, right, bottom), width - right, height - bottom, right, bottom);
                 //绘制上下两个边
                 top && this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, 0, sw - left - right, top), left, 0, width - left - right, top);
                 bottom && this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, sh - bottom, sw - left - right, bottom), left, height - bottom, width - left - right, bottom);
                 //绘制左右两边
                 left && this.drawBitmap(repeat, AutoBitmap.getTexture(source, 0, top, left, sh - top - bottom), 0, top, left, height - top - bottom);
                 right && this.drawBitmap(repeat, AutoBitmap.getTexture(source, sw - right, top, right, sh - top - bottom), width - right, top, right, height - top - bottom);
                 //绘制中间
                 this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, top, sw - left - right, sh - top - bottom), left, top, width - left - right, height - top - bottom);
                 if (needClip)
                     this.restore();
                 //缓存命令
                 //if (autoCacheCmd) WeakObject.I.set(_key, this.cmds);
             }
             this._repaint();
         }
         drawBitmap(repeat, tex, x, y, width = 0, height = 0) {
             if (width < 0.1 || height < 0.1)
                 return;
             if (repeat && (tex.width != width || tex.height != height))
                 this.fillTexture(tex, x, y, width, height);
             else
                 this.drawImage(tex, x, y, width, height);
         }
         static getTexture(tex, x, y, width, height) {
             if (width <= 0)
                 width = 1;
             if (height <= 0)
                 height = 1;
             tex.$_GID || (tex.$_GID = Utils.getGID());
             //var key:String = tex.$_GID + "." + x + "." + y + "." + width + "." + height;
             //var texture:Texture = WeakObject.I.get(key);
             var texture;
             if (!texture || !texture._getSource()) {
                 texture = Texture.createFromTexture(tex, x, y, width, height);
                 //WeakObject.I.set(key, texture);
             }
             return texture;
         }
     }

     /**
      * 当按钮的选中状态（ <code>selected</code> 属性）发生改变时调度。
      * @eventType laya.events.Event
      */
     /*[Event(name = "change", type = "laya.events.Event")]*/
     /**
      * <code>Button</code> 组件用来表示常用的多态按钮。 <code>Button</code> 组件可显示文本标签、图标或同时显示两者。	 *
      * <p>可以是单态，两态和三态，默认三态(up,over,down)。</p>
      *
      * @example <caption>以下示例代码，创建了一个 <code>Button</code> 实例。</caption>
      * package
      *	{
      *		import laya.ui.Button;
      *		import laya.utils.Handler;
      *		public class Button_Example
      *		{
      *			public function Button_Example()
      *			{
      *				Laya.init(640, 800);//设置游戏画布宽高。
      *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
      *				Laya.loader.load("resource/ui/button.png", Handler.create(this,onLoadComplete));//加载资源。
      *			}
      *			private function onLoadComplete():void
      *			{
      *				trace("资源加载完成！");
      *				var button:Button = new Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,并传入它的皮肤。
      *				button.x = 100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
      *				button.y = 100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
      *				button.clickHandler = new Handler(this, onClickButton,[button]);//设置 button 的点击事件处理器。
      *				Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
      *			}
      *			private function onClickButton(button:Button):void
      *			{
      *				trace("按钮button被点击了！");
      *			}
      *		}
      *	}
      * @example
      * Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
      * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
      * Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
      * function loadComplete()
      * {
      *     console.log("资源加载完成！");
      *     var button = new laya.ui.Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
      *     button.x =100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
      *     button.y =100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
      *     button.clickHandler = laya.utils.Handler.create(this,onClickButton,[button],false);//设置 button 的点击事件处理函数。
      *     Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
      * }
      * function onClickButton(button)
      * {
      *     console.log("按钮被点击了。",button);
      * }
      * @example
      * import Button=laya.ui.Button;
      * import Handler=laya.utils.Handler;
      * class Button_Example{
      *     constructor()
      *     {
      *         Laya.init(640, 800);
      *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
      *         Laya.loader.load("resource/ui/button.png", laya.utils.Handler.create(this,this.onLoadComplete));//加载资源。
      *     }
      *     private onLoadComplete()
      *     {
      *         var button:Button = new Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,并传入它的皮肤。
      *         button.x = 100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
      *         button.y = 100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
      *         button.clickHandler = new Handler(this, this.onClickButton,[button]);//设置 button 的点击事件处理器。
      *         Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
      *     }
      *     private onClickButton(button:Button):void
      *     {
      *         console.log("按钮button被点击了！")
      *     }
      * }
      */
     class Button extends UIComponent {
         /**
          * 创建一个新的 <code>Button</code> 类实例。
          * @param skin 皮肤资源地址。
          * @param label 按钮的文本内容。
          */
         constructor(skin = null, label = "") {
             super();
             /**
              * @private
              * 按钮文本标签的颜色值。
              */
             this._labelColors = Styles.buttonLabelColors;
             /**
              * @private
              * 按钮的状态值。
              */
             this._state = 0;
             /**
              * @private
              * 指定此显示对象是否自动计算并改变大小等属性。
              */
             this._autoSize = true; // 注意 由于构造函数执行顺序的区别，这里设置为true真的会导致ts的值为true，as的为false （as的 后调用super）
             /**
              * @private
              * 按钮的状态数。
              */
             this._stateNum = Styles.buttonStateNum;
             /**
              * @private
              */
             this._stateChanged = false;
             this.skin = skin;
             this.label = label;
         }
         /**@inheritDoc */
         /*override*/ destroy(destroyChild = true) {
             super.destroy(destroyChild);
             this._bitmap && this._bitmap.destroy();
             this._text && this._text.destroy(destroyChild);
             this._bitmap = null;
             this._text = null;
             this._clickHandler = null;
             this._labelColors = this._sources = this._strokeColors = null;
         }
         /**@inheritDoc */
         /*override*/ createChildren() {
             this.graphics = this._bitmap = new AutoBitmap();
         }
         /**@private */
         createText() {
             if (!this._text) {
                 this._text = new Text();
                 this._text.overflow = Text.HIDDEN;
                 this._text.align = "center";
                 this._text.valign = "middle";
                 this._text.width = this._width;
                 this._text.height = this._height;
             }
         }
         /**@inheritDoc */
         /*override*/ initialize() {
             if (this._mouseState !== 1) {
                 this.mouseEnabled = true;
                 this._setBit(Const.HAS_MOUSE, true);
             }
             this._createListener(Event.MOUSE_OVER, this, this.onMouse, null, false, false);
             this._createListener(Event.MOUSE_OUT, this, this.onMouse, null, false, false);
             this._createListener(Event.MOUSE_DOWN, this, this.onMouse, null, false, false);
             this._createListener(Event.MOUSE_UP, this, this.onMouse, null, false, false);
             this._createListener(Event.CLICK, this, this.onMouse, null, false, false);
         }
         /**
          * 对象的 <code>Event.MOUSE_OVER、Event.MOUSE_OUT、Event.MOUSE_DOWN、Event.MOUSE_UP、Event.CLICK</code> 事件侦听处理函数。
          * @param e Event 对象。
          */
         onMouse(e) {
             if (this.toggle === false && this._selected)
                 return;
             if (e.type === Event.CLICK) {
                 this.toggle && (this.selected = !this._selected);
                 this._clickHandler && this._clickHandler.run();
                 return;
             }
             !this._selected && (this.state = Button.stateMap[e.type]);
         }
         /**
          * <p>对象的皮肤资源地址。</p>
          * 支持单态，两态和三态，用 <code>stateNum</code> 属性设置
          * <p>对象的皮肤地址，以字符串表示。</p>
          * @see #stateNum
          */
         get skin() {
             return this._skin;
         }
         set skin(value) {
             if (this._skin != value) {
                 this._skin = value;
                 if (value) {
                     if (!Loader.getRes(value)) {
                         window.Laya.loader.load(this._skin, Handler.create(this, this._skinLoaded), null, Loader.IMAGE, 1); //TODO 
                     }
                     else {
                         this._skinLoaded();
                     }
                 }
                 else {
                     this._skinLoaded();
                 }
             }
         }
         _skinLoaded() {
             this.callLater(this.changeClips);
             this._setStateChanged();
             this._sizeChanged();
             this.event(Event.LOADED);
         }
         /**
          * <p>指定对象的状态值，以数字表示。</p>
          * <p>默认值为3。此值决定皮肤资源图片的切割方式。</p>
          * <p><b>取值：</b>
          * <li>1：单态。图片不做切割，按钮的皮肤状态只有一种。</li>
          * <li>2：两态。图片将以竖直方向被等比切割为2部分，从上向下，依次为
          * 弹起状态皮肤、
          * 按下和经过及选中状态皮肤。</li>
          * <li>3：三态。图片将以竖直方向被等比切割为3部分，从上向下，依次为
          * 弹起状态皮肤、
          * 经过状态皮肤、
          * 按下和选中状态皮肤</li>
          * </p>
          */
         get stateNum() {
             return this._stateNum;
         }
         set stateNum(value) {
             if (typeof value == 'string') {
                 value = parseInt(value);
             }
             if (this._stateNum != value) {
                 this._stateNum = value < 1 ? 1 : value > 3 ? 3 : value;
                 this.callLater(this.changeClips);
             }
         }
         /**
          * @private
          * 对象的资源切片发生改变。
          */
         changeClips() {
             var img = Loader.getRes(this._skin);
             if (!img) {
                 console.log("lose skin", this._skin);
                 return;
             }
             var width = img.sourceWidth;
             var height = img.sourceHeight / this._stateNum;
             img.$_GID || (img.$_GID = Utils.getGID());
             var key = img.$_GID + "-" + this._stateNum;
             var clips = WeakObject.I.get(key);
             if (!Utils.isOkTextureList(clips)) {
                 clips = null;
             }
             if (clips)
                 this._sources = clips;
             else {
                 this._sources = [];
                 if (this._stateNum === 1) {
                     this._sources.push(img);
                 }
                 else {
                     for (var i = 0; i < this._stateNum; i++) {
                         this._sources.push(Texture.createFromTexture(img, 0, height * i, width, height));
                     }
                 }
                 WeakObject.I.set(key, this._sources);
             }
             if (this._autoSize) {
                 this._bitmap.width = this._width || width;
                 this._bitmap.height = this._height || height;
                 if (this._text) {
                     this._text.width = this._bitmap.width;
                     this._text.height = this._bitmap.height;
                 }
             }
             else {
                 this._text && (this._text.x = width);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ measureWidth() {
             this.runCallLater(this.changeClips);
             if (this._autoSize)
                 return this._bitmap.width;
             this.runCallLater(this.changeState);
             return this._bitmap.width + (this._text ? this._text.width : 0);
         }
         /**
          * @inheritDoc
          */
         /*override*/ measureHeight() {
             this.runCallLater(this.changeClips);
             return this._text ? Math.max(this._bitmap.height, this._text.height) : this._bitmap.height;
         }
         /**
          * 按钮的文本内容。
          */
         get label() {
             return this._text ? this._text.text : null;
         }
         set label(value) {
             if (!this._text && !value)
                 return;
             this.createText();
             if (this._text.text != value) {
                 value && !this._text.parent && this.addChild(this._text);
                 this._text.text = (value + "").replace(/\\n/g, "\n");
                 this._setStateChanged();
             }
         }
         /**
          * 表示按钮的选中状态。
          * <p>如果值为true，表示该对象处于选中状态。否则该对象处于未选中状态。</p>
          */
         get selected() {
             return this._selected;
         }
         set selected(value) {
             if (this._selected != value) {
                 this._selected = value;
                 this.state = this._selected ? 2 : 0;
                 this.event(Event.CHANGE);
             }
         }
         /**
          * 对象的状态值。
          * @see #stateMap
          */
         get state() {
             return this._state;
         }
         set state(value) {
             if (this._state != value) {
                 this._state = value;
                 this._setStateChanged();
             }
         }
         /**
          * @private
          * 改变对象的状态。
          */
         changeState() {
             this._stateChanged = false;
             this.runCallLater(this.changeClips);
             var index = this._state < this._stateNum ? this._state : this._stateNum - 1;
             this._sources && (this._bitmap.source = this._sources[index]);
             if (this.label) {
                 this._text.color = this._labelColors[index];
                 if (this._strokeColors)
                     this._text.strokeColor = this._strokeColors[index];
             }
         }
         /**
          * 表示按钮各个状态下的文本颜色。
          * <p><b>格式:</b> "upColor,overColor,downColor,disableColor"。</p>
          */
         get labelColors() {
             return this._labelColors.join(",");
         }
         set labelColors(value) {
             this._labelColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String);
             this._setStateChanged();
         }
         /**
          * 表示按钮各个状态下的描边颜色。
          * <p><b>格式:</b> "upColor,overColor,downColor,disableColor"。</p>
          */
         get strokeColors() {
             return this._strokeColors ? this._strokeColors.join(",") : "";
         }
         set strokeColors(value) {
             this._strokeColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String);
             this._setStateChanged();
         }
         /**
          * 表示按钮文本标签的边距。
          * <p><b>格式：</b>"上边距,右边距,下边距,左边距"。</p>
          */
         get labelPadding() {
             this.createText();
             return this._text.padding.join(",");
         }
         set labelPadding(value) {
             this.createText();
             this._text.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
         }
         /**
          * 表示按钮文本标签的字体大小。
          * @see laya.display.Text.fontSize()
          */
         get labelSize() {
             this.createText();
             return this._text.fontSize;
         }
         set labelSize(value) {
             this.createText();
             this._text.fontSize = value;
         }
         /**
          * <p>描边宽度（以像素为单位）。</p>
          * 默认值0，表示不描边。
          * @see laya.display.Text.stroke()
          */
         get labelStroke() {
             this.createText();
             return this._text.stroke;
         }
         set labelStroke(value) {
             this.createText();
             this._text.stroke = value;
         }
         /**
          * <p>描边颜色，以字符串表示。</p>
          * 默认值为 "#000000"（黑色）;
          * @see laya.display.Text.strokeColor()
          */
         get labelStrokeColor() {
             this.createText();
             return this._text.strokeColor;
         }
         set labelStrokeColor(value) {
             this.createText();
             this._text.strokeColor = value;
         }
         /**
          * 表示按钮文本标签是否为粗体字。
          * @see laya.display.Text.bold()
          */
         get labelBold() {
             this.createText();
             return this._text.bold;
         }
         set labelBold(value) {
             this.createText();
             this._text.bold = value;
         }
         /**
          * 表示按钮文本标签的字体名称，以字符串形式表示。
          * @see laya.display.Text.font()
          */
         get labelFont() {
             this.createText();
             return this._text.font;
         }
         set labelFont(value) {
             this.createText();
             this._text.font = value;
         }
         /**标签对齐模式，默认为居中对齐。*/
         get labelAlign() {
             this.createText();
             return this._text.align;
         }
         set labelAlign(value) {
             this.createText();
             this._text.align = value;
         }
         /**
          * 对象的点击事件处理器函数（无默认参数）。
          */
         get clickHandler() {
             return this._clickHandler;
         }
         set clickHandler(value) {
             this._clickHandler = value;
         }
         /**
          * 按钮文本标签 <code>Text</code> 控件。
          */
         get text() {
             this.createText();
             return this._text;
         }
         /**
          * <p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
          * <p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
          * <ul><li>例如："4,4,4,4,1"</li></ul></p>
          * @see laya.ui.AutoBitmap.sizeGrid
          */
         get sizeGrid() {
             if (this._bitmap.sizeGrid)
                 return this._bitmap.sizeGrid.join(",");
             return null;
         }
         set sizeGrid(value) {
             this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
         }
         /**@inheritDoc */
         /*override*/ set width(value) {
             super.set_width(value);
             if (this._autoSize) {
                 this._bitmap.width = value;
                 this._text && (this._text.width = value);
             }
         }
         get width() {
             return super.get_width();
         }
         /**@inheritDoc */
         /*override*/ set height(value) {
             super.set_height(value);
             if (this._autoSize) {
                 this._bitmap.height = value;
                 this._text && (this._text.height = value);
             }
         }
         get height() {
             return super.get_height();
         }
         /**@inheritDoc */
         /*override*/ set dataSource(value) {
             this._dataSource = value;
             if (typeof (value) == 'number' || typeof (value) == 'string')
                 this.label = value + "";
             else
                 super.set_dataSource(value);
         }
         get dataSource() {
             return super.get_dataSource();
         }
         /**图标x,y偏移，格式：100,100*/
         get iconOffset() {
             return this._bitmap._offset ? this._bitmap._offset.join(",") : null;
         }
         set iconOffset(value) {
             if (value)
                 this._bitmap._offset = UIUtils.fillArray([1, 1], value, Number);
             else
                 this._bitmap._offset = [];
         }
         /**@private */
         _setStateChanged() {
             if (!this._stateChanged) {
                 this._stateChanged = true;
                 this.callLater(this.changeState);
             }
         }
     }
     /**
      * 按钮状态集。
      */
     Button.stateMap = { "mouseup": 0, "mouseover": 1, "mousedown": 2, "mouseout": 0 };
     ILaya.regClass(Button);

     /**
      * <code>Config3D</code> 类用于创建3D初始化配置。
      */
     class Config3D {
         /**
          * 创建一个 <code>Config3D</code> 实例。
          */
         constructor() {
             /**@private	*/
             this._defaultPhysicsMemory = 16;
             /**@private	*/
             this._editerEnvironment = false;
             /** 是否开启抗锯齿。*/
             this.isAntialias = true;
             /** 设置画布是否透明。*/
             this.isAlpha = false;
             /** 设置画布是否预乘。*/
             this.premultipliedAlpha = true;
             /** 设置画布的是否开启模板缓冲。*/
             this.isStencil = true;
             /** 是否开启八叉树裁剪。*/
             this.octreeCulling = false;
             /** 八叉树初始化尺寸。*/
             this.octreeInitialSize = 64.0;
             /** 八叉树初始化中心。*/
             this.octreeInitialCenter = new Vector3(0, 0, 0);
             /** 八叉树最小尺寸。*/
             this.octreeMinNodeSize = 2.0;
             /** 八叉树松散值。*/
             this.octreeLooseness = 1.25;
             /**
              * 是否开启视锥裁剪调试。
              * 如果开启八叉树裁剪,使用红色绘制高层次八叉树节点包围盒,使用蓝色绘制低层次八叉节点包围盒,精灵包围盒和八叉树节点包围盒颜色一致,但Alpha为半透明。如果视锥完全包含八叉树节点,八叉树节点包围盒和精灵包围盒变为蓝色,同样精灵包围盒的Alpha为半透明。
              * 如果不开启八叉树裁剪,使用绿色像素线绘制精灵包围盒。
              */
             this.debugFrustumCulling = false;
         }
         /**
          * 获取默认物理功能初始化内存，单位为M。
          * @return 默认物理功能初始化内存。
          */
         get defaultPhysicsMemory() {
             return this._defaultPhysicsMemory;
         }
         /**
          * 设置默认物理功能初始化内存，单位为M。
          * @param value 默认物理功能初始化内存。
          */
         set defaultPhysicsMemory(value) {
             if (value < 16) //必须大于16M
                 throw "defaultPhysicsMemory must large than 16M";
             this._defaultPhysicsMemory = value;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(dest) {
             var destConfig3D = dest;
             destConfig3D._defaultPhysicsMemory = this._defaultPhysicsMemory;
             destConfig3D._editerEnvironment = this._editerEnvironment;
             destConfig3D.isAntialias = this.isAntialias;
             destConfig3D.isAlpha = this.isAlpha;
             destConfig3D.premultipliedAlpha = this.premultipliedAlpha;
             destConfig3D.isStencil = this.isStencil;
             destConfig3D.octreeCulling = this.octreeCulling;
             this.octreeInitialCenter.cloneTo(destConfig3D.octreeInitialCenter);
             destConfig3D.octreeMinNodeSize = this.octreeMinNodeSize;
             destConfig3D.octreeLooseness = this.octreeLooseness;
             destConfig3D.debugFrustumCulling = this.debugFrustumCulling;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new Config3D();
             this.cloneTo(dest);
             return dest;
         }
     }
     /**@private	*/
     Config3D._default = new Config3D();

     /**
      * <code>PointLight</code> 类用于创建点光。
      */
     class PointLight extends LightSprite {
         /**
          * 创建一个 <code>PointLight</code> 实例。
          */
         constructor() {
             super();
             /** @private */
             this._lightMatrix = new Matrix4x4();
             this._range = 6.0;
         }
         /**
          * 获取点光的范围。
          * @return 点光的范围。
          */
         get range() {
             return this._range;
         }
         /**
          * 设置点光的范围。
          * @param  value 点光的范围。
          */
         set range(value) {
             this._range = value;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onActive() {
             super._onActive();
             (this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED) && (this._scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT));
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onInActive() {
             super._onInActive();
             (this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED) && (this._scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT));
         }
         /**
          * 更新点光相关渲染状态参数。
          * @param state 渲染状态参数。
          */
         /*override*/ _prepareToScene() {
             var scene = this._scene;
             if (scene.enableLight && this.activeInHierarchy) {
                 var shaderValue = scene._shaderValues;
                 Vector3.scale(this.color, this._intensity, this._intensityColor);
                 shaderValue.setVector3(ILaya3D.Scene3D.POINTLIGHTCOLOR, this._intensityColor);
                 shaderValue.setVector3(ILaya3D.Scene3D.POINTLIGHTPOS, this.transform.position);
                 shaderValue.setNumber(ILaya3D.Scene3D.POINTLIGHTRANGE, this.range);
                 var lightMatrix = this._lightMatrix;
                 var lightMatrixE = lightMatrix.elements;
                 lightMatrix.identity();
                 lightMatrixE[0] = lightMatrixE[5] = lightMatrixE[10] = 1.0 / this._range;
                 var toLightMatrix = PointLight._tempMatrix0;
                 this.transform.worldMatrix.invert(toLightMatrix);
                 Matrix4x4.multiply(lightMatrix, toLightMatrix, lightMatrix);
                 shaderValue.setMatrix4x4(ILaya3D.Scene3D.POINTLIGHTMATRIX, lightMatrix);
                 return true;
             }
             else {
                 return false;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             super._parse(data, spriteMap);
             this.range = data.range;
         }
     }
     /** @private */
     PointLight._tempMatrix0 = new Matrix4x4();

     /**
      * <code>SpotLight</code> 类用于创建聚光。
      */
     class SpotLight extends LightSprite {
         /** @private */
         //private var _tempMatrix:Matrix4x4 = new Matrix4x4();
         /**
          * 创建一个 <code>SpotLight</code> 实例。
          */
         constructor() {
             super();
             this._spotAngle = 30.0;
             this._range = 10.0;
             this._direction = new Vector3();
         }
         /**
          * 获取聚光灯的锥形角度。
          * @return 聚光灯的锥形角度。
          */
         get spotAngle() {
             return this._spotAngle;
         }
         /**
          * 设置聚光灯的锥形角度。
          * @param value 聚光灯的锥形角度。
          */
         set spotAngle(value) {
             this._spotAngle = Math.max(Math.min(value, 180), 0);
         }
         /**
          * 获取聚光的范围。
          * @return 聚光的范围值。
          */
         get range() {
             return this._range;
         }
         /**
          * 设置聚光的范围。
          * @param value 聚光的范围值。
          */
         set range(value) {
             this._range = value;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onActive() {
             super._onActive();
             (this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED) && (this.scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT));
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onInActive() {
             super._onInActive();
             (this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED) && (this.scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT));
         }
         /**
          * 更新聚光相关渲染状态参数。
          * @param state 渲染状态参数。
          */
         /*override*/ _prepareToScene() {
             var scene = this._scene;
             if (scene.enableLight && this.activeInHierarchy) {
                 var shaderValue = scene._shaderValues;
                 Vector3.scale(this.color, this._intensity, this._intensityColor);
                 shaderValue.setVector3(ILaya3D.Scene3D.SPOTLIGHTCOLOR, this._intensityColor);
                 shaderValue.setVector3(ILaya3D.Scene3D.SPOTLIGHTPOS, this.transform.position);
                 this.transform.worldMatrix.getForward(this._direction);
                 Vector3.normalize(this._direction, this._direction);
                 shaderValue.setVector3(ILaya3D.Scene3D.SPOTLIGHTDIRECTION, this._direction);
                 shaderValue.setNumber(ILaya3D.Scene3D.SPOTLIGHTRANGE, this.range);
                 shaderValue.setNumber(ILaya3D.Scene3D.SPOTLIGHTSPOTANGLE, this.spotAngle * Math.PI / 180);
                 //----------------------------------To do SpotLight Attenuate----------------------------------
                 //var tempMatrix:Matrix4x4 = _tempMatrix0;
                 //var tempMatrixE:Float32Array = tempMatrix.elements;
                 //tempMatrix.identity();
                 //var halfRad:Number = (spotAngle / 2) * Math.PI / 180;
                 //var cotanHalfSpotAngle:Number = 1 / Math.tan(halfRad);
                 //tempMatrixE[14] = 2.0 / cotanHalfSpotAngle;
                 //tempMatrixE[15] = 0.0;
                 //
                 //var lightMatrix:Matrix4x4 = _lightMatrix;
                 //var lightMatrixE:Float32Array = lightMatrix.elements;
                 //lightMatrix.identity();
                 //lightMatrixE[0] = lightMatrixE[5] = lightMatrixE[10] = 1.0 / _range;
                 //Matrix4x4.multiply(lightMatrix, tempMatrix, lightMatrix);
                 //
                 //var toLightMatrix:Matrix4x4 = _tempMatrix1;
                 //transform.worldMatrix.invert(toLightMatrix);
                 //Matrix4x4.multiply(lightMatrix, toLightMatrix, lightMatrix);
                 //shaderValue.setMatrix4x4(Scene3D.SPOTLIGHTMATRIX, lightMatrix);
                 //----------------------------------To do SpotLight Attenuate----------------------------------
                 return true;
             }
             else {
                 return false;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data, spriteMap) {
             super._parse(data, spriteMap);
             this.range = data.range;
             this.spotAngle = data.spotAngle;
         }
     }
     /** @private */
     SpotLight._tempMatrix0 = new Matrix4x4();
     /** @private */
     SpotLight._tempMatrix1 = new Matrix4x4();

     /**
      * <code>Utils3D</code> 类用于创建3D工具。
      */
     class Scene3DUtils {
         /**
     * @private
     */
         static _createSprite3DInstance(nodeData, spriteMap, outBatchSprites) {
             var node;
             switch (nodeData.type) {
                 case "Scene3D":
                     node = new Scene3D();
                     break;
                 case "Sprite3D":
                     node = new Sprite3D();
                     break;
                 case "MeshSprite3D":
                     node = new MeshSprite3D();
                     (outBatchSprites) && (outBatchSprites.push(node));
                     break;
                 case "SkinnedMeshSprite3D":
                     node = new SkinnedMeshSprite3D();
                     break;
                 case "ShuriKenParticle3D":
                     node = new ShuriKenParticle3D();
                     break;
                 case "Camera":
                     node = new Camera();
                     break;
                 case "DirectionLight":
                     node = new DirectionLight();
                     break;
                 case "PointLight":
                     node = new PointLight();
                     break;
                 case "SpotLight":
                     node = new SpotLight();
                     break;
                 case "TrailSprite3D":
                     node = new TrailSprite3D();
                     break;
                 default:
                     throw new Error("Utils3D:unidentified class type in (.lh) file.");
             }
             var childData = nodeData.child;
             if (childData) {
                 for (var i = 0, n = childData.length; i < n; i++) {
                     var child = Scene3DUtils._createSprite3DInstance(childData[i], spriteMap, outBatchSprites);
                     node.addChild(child);
                 }
             }
             spriteMap[nodeData.instanceID] = node;
             return node;
         }
         /**
          * @private
          */
         static _createComponentInstance(nodeData, spriteMap) {
             var node = spriteMap[nodeData.instanceID];
             node._parse(nodeData.props, spriteMap);
             var childData = nodeData.child;
             if (childData) {
                 for (var i = 0, n = childData.length; i < n; i++)
                     Scene3DUtils._createComponentInstance(childData[i], spriteMap);
             }
             var componentsData = nodeData.components;
             if (componentsData) {
                 for (var j = 0, m = componentsData.length; j < m; j++) {
                     var data = componentsData[j];
                     var clas = ClassUtils.getRegClass(data.type);
                     if (clas) {
                         var component = node.addComponent(clas);
                         component._parse(data);
                     }
                     else {
                         console.warn("Unkown component type.");
                     }
                 }
             }
         }
         /**
          * @private
          */
         static _createNodeByJson02(nodeData, outBatchSprites) {
             var spriteMap = {};
             var node = Scene3DUtils._createSprite3DInstance(nodeData, spriteMap, outBatchSprites);
             Scene3DUtils._createComponentInstance(nodeData, spriteMap);
             return node;
         }
         /**
          *@private
          */
         static _parse(data, propertyParams = null, constructParams = null) {
             var json = data.data;
             var outBatchSprits = [];
             var sprite;
             switch (data.version) {
                 case "LAYAHIERARCHY:02":
                     sprite = Scene3DUtils._createNodeByJson02(json, outBatchSprits);
                     break;
                 default:
                     sprite = Scene3DUtils._createNodeByJson(json, outBatchSprits);
             }
             StaticBatchManager.combine(sprite, outBatchSprits);
             return sprite;
         }
         /**
          *@private
          */
         static _parseScene(data, propertyParams = null, constructParams = null) {
             var json = data.data;
             var outBatchSprits = [];
             var scene;
             switch (data.version) {
                 case "LAYASCENE3D:02":
                     scene = Scene3DUtils._createNodeByJson02(json, outBatchSprits);
                     break;
                 default:
                     scene = Scene3DUtils._createNodeByJson(json, outBatchSprits);
             }
             StaticBatchManager.combine(null, outBatchSprits);
             return scene;
         }
         //--------------------------------------------------------------------------------------------------------------------------------
         /**
          * @private
          */
         static _createNodeByJson(nodeData, outBatchSprites) {
             var node;
             switch (nodeData.type) {
                 case "Scene3D":
                     node = new Scene3D();
                     break;
                 case "Sprite3D":
                     node = new Sprite3D();
                     break;
                 case "MeshSprite3D":
                     node = new MeshSprite3D();
                     (outBatchSprites) && (outBatchSprites.push(node));
                     break;
                 case "SkinnedMeshSprite3D":
                     node = new SkinnedMeshSprite3D();
                     break;
                 case "ShuriKenParticle3D":
                     node = new ShuriKenParticle3D();
                     break;
                 case "Camera":
                     node = new Camera();
                     break;
                 case "DirectionLight":
                     node = new DirectionLight();
                     break;
                 case "PointLight":
                     node = new PointLight();
                     break;
                 case "SpotLight":
                     node = new SpotLight();
                     break;
                 case "TrailSprite3D":
                     node = new TrailSprite3D();
                     break;
                 default:
                     throw new Error("Utils3D:unidentified class type in (.lh) file.");
             }
             var childData = nodeData.child;
             if (childData) {
                 for (var i = 0, n = childData.length; i < n; i++) {
                     var child = Scene3DUtils._createNodeByJson(childData[i], outBatchSprites);
                     node.addChild(child);
                 }
             }
             var componentsData = nodeData.components;
             if (componentsData) {
                 for (var j = 0, m = componentsData.length; j < m; j++) {
                     var data = componentsData[j];
                     var clas = ClassUtils.getRegClass(data.type);
                     if (clas) {
                         var component = node.addComponent(clas);
                         component._parse(data);
                     }
                     else {
                         console.warn("Unkown component type.");
                     }
                 }
             }
             node._parse(nodeData.props, null);
             return node;
         }
     }

     /**
      * @private
      */
     class KeyframeNode {
         constructor() {
             /**@private */
             this._ownerPath = [];
             /**@private */
             this._propertys = [];
             /**@private */
             this._keyFrames = [];
         }
         /**
          * 获取精灵路径个数。
          * @return 精灵路径个数。
          */
         get ownerPathCount() {
             return this._ownerPath.length;
         }
         /**
          * 获取属性路径个数。
          * @return 数量路径个数。
          */
         get propertyCount() {
             return this._propertys.length;
         }
         /**
          * 获取帧个数。
          * 帧个数。
          */
         get keyFramesCount() {
             return this._keyFrames.length;
         }
         /**
          * @private
          */
         _setOwnerPathCount(value) {
             this._ownerPath.length = value;
         }
         /**
          * @private
          */
         _setOwnerPathByIndex(index, value) {
             this._ownerPath[index] = value;
         }
         /**
          * @private
          */
         _joinOwnerPath(sep) {
             return this._ownerPath.join(sep);
         }
         /**
          * @private
          */
         _setPropertyCount(value) {
             this._propertys.length = value;
         }
         /**
          * @private
          */
         _setPropertyByIndex(index, value) {
             this._propertys[index] = value;
         }
         /**
          * @private
          */
         _joinProperty(sep) {
             return this._propertys.join(sep);
         }
         /**
          * @private
          */
         _setKeyframeCount(value) {
             this._keyFrames.length = value;
         }
         /**
          * @private
          */
         _setKeyframeByIndex(index, value) {
             this._keyFrames[index] = value;
         }
         /**
          * 通过索引获取精灵路径。
          * @param index 索引。
          */
         getOwnerPathByIndex(index) {
             return this._ownerPath[index];
         }
         /**
          * 通过索引获取属性路径。
          * @param index 索引。
          */
         getPropertyByIndex(index) {
             return this._propertys[index];
         }
         /**
          * 通过索引获取帧。
          * @param index 索引。
          */
         getKeyframeByIndex(index) {
             return this._keyFrames[index];
         }
     }

     /**
      * <code>AnimationEvent</code> 类用于实现动画事件。
      */
     class AnimationEvent {
         /**
          * 创建一个 <code>AnimationEvent</code> 实例。
          */
         constructor() {
         }
     }

     /**
      * <code>QuaternionKeyframe</code> 类用于创建四元数关键帧实例。
      */
     class QuaternionKeyframe extends Keyframe {
         /**
          * 创建一个 <code>QuaternionKeyframe</code> 实例。
          */
         constructor() {
             super();
             this.inTangent = new Vector4();
             this.outTangent = new Vector4();
             this.value = new Quaternion();
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         /*override*/ cloneTo(dest) {
             super.cloneTo(dest);
             var destKeyFarme = dest;
             this.inTangent.cloneTo(destKeyFarme.inTangent);
             this.outTangent.cloneTo(destKeyFarme.outTangent);
             this.value.cloneTo(destKeyFarme.value);
         }
     }

     /**
      * <code>Vector3Keyframe</code> 类用于创建三维向量关键帧实例。
      */
     class Vector3Keyframe extends Keyframe {
         /**
          * 创建一个 <code>Vector3Keyframe</code> 实例。
          */
         constructor() {
             super();
             this.inTangent = new Vector3();
             this.outTangent = new Vector3();
             this.value = new Vector3();
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         /*override*/ cloneTo(dest) {
             super.cloneTo(dest);
             var destKeyFarme = dest;
             this.inTangent.cloneTo(destKeyFarme.inTangent);
             this.outTangent.cloneTo(destKeyFarme.outTangent);
             this.value.cloneTo(destKeyFarme.value);
         }
     }

     /**
      * <code>Vector4</code> 类用于创建四维向量。
      */
     class ConchVector4 {
         /**
          * 创建一个 <code>Vector4</code> 实例。
          * @param	x  X轴坐标。
          * @param	y  Y轴坐标。
          * @param	z  Z轴坐标。
          * @param	w  W轴坐标。
          */
         constructor(x = 0, y = 0, z = 0, w = 0) {
             var v = this.elements = new Float32Array(4);
             v[0] = x;
             v[1] = y;
             v[2] = z;
             v[3] = w;
         }
         /**
          * 获取X轴坐标。
          * @return  X轴坐标。
          */
         get x() {
             return this.elements[0];
         }
         /**
          * 设置X轴坐标。
          * @param value X轴坐标。
          */
         set x(value) {
             this.elements[0] = value;
         }
         /**
          * 获取Y轴坐标。
          * @return	Y轴坐标。
          */
         get y() {
             return this.elements[1];
         }
         /**
          * 设置Y轴坐标。
          * @param	value  Y轴坐标。
          */
         set y(value) {
             this.elements[1] = value;
         }
         /**
          * 获取Z轴坐标。
          * @return	 Z轴坐标。
          */
         get z() {
             return this.elements[2];
         }
         /**
          * 设置Z轴坐标。
          * @param	value  Z轴坐标。
          */
         set z(value) {
             this.elements[2] = value;
         }
         /**
          * 获取W轴坐标。
          * @return	W轴坐标。
          */
         get w() {
             return this.elements[3];
         }
         /**
          * 设置W轴坐标。
          * @param value	W轴坐标。
          */
         set w(value) {
             this.elements[3] = value;
         }
         /**
          * 从Array数组拷贝值。
          * @param  array 数组。
          * @param  offset 数组偏移。
          */
         fromArray(array, offset = 0) {
             this.elements[0] = array[offset + 0];
             this.elements[1] = array[offset + 1];
             this.elements[2] = array[offset + 2];
             this.elements[3] = array[offset + 3];
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destVector4 = destObject;
             var destE = destVector4.elements;
             var s = this.elements;
             destE[0] = s[0];
             destE[1] = s[1];
             destE[2] = s[2];
             destE[3] = s[3];
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destVector4 = new ConchVector4();
             this.cloneTo(destVector4);
             return destVector4;
         }
         /**
          * 插值四维向量。
          * @param	a left向量。
          * @param	b right向量。
          * @param	t 插值比例。
          * @param	out 输出向量。
          */
         static lerp(a, b, t, out) {
             var e = out.elements;
             var f = a.elements;
             var g = b.elements;
             var ax = f[0], ay = f[1], az = f[2], aw = f[3];
             e[0] = ax + t * (g[0] - ax);
             e[1] = ay + t * (g[1] - ay);
             e[2] = az + t * (g[2] - az);
             e[3] = aw + t * (g[3] - aw);
         }
         /**
          * 通过4x4矩阵把一个四维向量转换为另一个四维向量
          * @param	vector4 带转换四维向量。
          * @param	M4x4    4x4矩阵。
          * @param	out     转换后四维向量。
          */
         static transformByM4x4(vector4, m4x4, out) {
             var ve = vector4.elements;
             var vx = ve[0];
             var vy = ve[1];
             var vz = ve[2];
             var vw = ve[3];
             var me = m4x4.elements;
             var oe = out.elements;
             oe[0] = vx * me[0] + vy * me[4] + vz * me[8] + vw * me[12];
             oe[1] = vx * me[1] + vy * me[5] + vz * me[9] + vw * me[13];
             oe[2] = vx * me[2] + vy * me[6] + vz * me[10] + vw * me[14];
             oe[3] = vx * me[3] + vy * me[7] + vz * me[11] + vw * me[15];
         }
         /**
          * 判断两个四维向量是否相等。
          * @param	a 四维向量。
          * @param	b 四维向量。
          * @return  是否相等。
          */
         static equals(a, b) {
             var ae = a.elements;
             var be = b.elements;
             return MathUtils3D.nearEqual(Math.abs(ae[0]), Math.abs(be[0])) && MathUtils3D.nearEqual(Math.abs(ae[1]), Math.abs(be[1])) && MathUtils3D.nearEqual(Math.abs(ae[2]), Math.abs(be[2])) && MathUtils3D.nearEqual(Math.abs(ae[3]), Math.abs(be[3]));
         }
         /**
          * 求四维向量的长度。
          * @return  长度。
          */
         length() {
             return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
         }
         /**
          * 求四维向量长度的平方。
          * @return  长度的平方。
          */
         lengthSquared() {
             return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
         }
         /**
          * 归一化四维向量。
          * @param	s   源四维向量。
          * @param	out 输出四维向量。
          */
         static normalize(s, out) {
             var se = s.elements;
             var oe = out.elements;
             var len = s.length();
             if (len > 0) {
                 oe[0] = se[0] * len;
                 oe[1] = se[1] * len;
                 oe[2] = se[2] * len;
                 oe[3] = se[3] * len;
             }
         }
         /**
          * 求两个四维向量的和。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 输出向量。
          */
         static add(a, b, out) {
             var oe = out.elements;
             var ae = a.elements;
             var be = b.elements;
             oe[0] = ae[0] + be[0];
             oe[1] = ae[1] + be[1];
             oe[2] = ae[2] + be[2];
             oe[3] = ae[3] + be[3];
         }
         /**
          * 求两个四维向量的差。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 输出向量。
          */
         static subtract(a, b, out) {
             var oe = out.elements;
             var ae = a.elements;
             var be = b.elements;
             oe[0] = ae[0] - be[0];
             oe[1] = ae[1] - be[1];
             oe[2] = ae[2] - be[2];
             oe[3] = ae[3] - be[3];
         }
         /**
          * 计算两个四维向量的乘积。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 输出向量。
          */
         static multiply(a, b, out) {
             var oe = out.elements;
             var ae = a.elements;
             var be = b.elements;
             oe[0] = ae[0] * be[0];
             oe[1] = ae[1] * be[1];
             oe[2] = ae[2] * be[2];
             oe[3] = ae[3] * be[3];
         }
         /**
          * 缩放四维向量。
          * @param	a   源四维向量。
          * @param	b   缩放值。
          * @param	out 输出四维向量。
          */
         static scale(a, b, out) {
             var oe = out.elements;
             var ae = a.elements;
             oe[0] = ae[0] * b;
             oe[1] = ae[1] * b;
             oe[2] = ae[2] * b;
             oe[3] = ae[3] * b;
         }
         /**
          * 求一个指定范围的四维向量
          * @param	value clamp向量
          * @param	min   最小
          * @param	max   最大
          * @param   out   输出向量
          */
         static Clamp(value, min, max, out) {
             var valuee = value.elements;
             var x = valuee[0];
             var y = valuee[1];
             var z = valuee[2];
             var w = valuee[3];
             var mine = min.elements;
             var mineX = mine[0];
             var mineY = mine[1];
             var mineZ = mine[2];
             var mineW = mine[3];
             var maxe = max.elements;
             var maxeX = maxe[0];
             var maxeY = maxe[1];
             var maxeZ = maxe[2];
             var maxeW = maxe[3];
             var oute = out.elements;
             x = (x > maxeX) ? maxeX : x;
             x = (x < mineX) ? mineX : x;
             y = (y > maxeY) ? maxeY : y;
             y = (y < mineY) ? mineY : y;
             z = (z > maxeZ) ? maxeZ : z;
             z = (z < mineZ) ? mineZ : z;
             w = (w > maxeW) ? maxeW : w;
             w = (w < mineW) ? mineW : w;
             oute[0] = x;
             oute[1] = y;
             oute[2] = z;
             oute[3] = w;
         }
         /**
          * 两个四维向量距离的平方。
          * @param	value1 向量1。
          * @param	value2 向量2。
          * @return	距离的平方。
          */
         static distanceSquared(value1, value2) {
             var value1e = value1.elements;
             var value2e = value2.elements;
             var x = value1e[0] - value2e[0];
             var y = value1e[1] - value2e[1];
             var z = value1e[2] - value2e[2];
             var w = value1e[3] - value2e[3];
             return (x * x) + (y * y) + (z * z) + (w * w);
         }
         /**
          * 两个四维向量距离。
          * @param	value1 向量1。
          * @param	value2 向量2。
          * @return	距离。
          */
         static distance(value1, value2) {
             var value1e = value1.elements;
             var value2e = value2.elements;
             var x = value1e[0] - value2e[0];
             var y = value1e[1] - value2e[1];
             var z = value1e[2] - value2e[2];
             var w = value1e[3] - value2e[3];
             return Math.sqrt((x * x) + (y * y) + (z * z) + (w * w));
         }
         /**
          * 求两个四维向量的点积。
          * @param	a 向量。
          * @param	b 向量。
          * @return  点积。
          */
         static dot(a, b) {
             var ae = a.elements;
             var be = b.elements;
             var r = (ae[0] * be[0]) + (ae[1] * be[1]) + (ae[2] * be[2]) + (ae[3] * be[3]);
             return r;
         }
         /**
          * 分别取两个四维向量x、y、z的最小值计算新的四维向量。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 结果三维向量。
          */
         static min(a, b, out) {
             var e = out.elements;
             var f = a.elements;
             var g = b.elements;
             e[0] = Math.min(f[0], g[0]);
             e[1] = Math.min(f[1], g[1]);
             e[2] = Math.min(f[2], g[2]);
             e[3] = Math.min(f[3], g[3]);
         }
         /**
          * 分别取两个四维向量x、y、z的最大值计算新的四维向量。
          * @param	a   四维向量。
          * @param	b   四维向量。
          * @param	out 结果三维向量。
          */
         static max(a, b, out) {
             var e = out.elements;
             var f = a.elements;
             var g = b.elements;
             e[0] = Math.max(f[0], g[0]);
             e[1] = Math.max(f[1], g[1]);
             e[2] = Math.max(f[2], g[2]);
             e[3] = Math.max(f[3], g[3]);
         }
     }
     /*[FILEINDEX:10000]*/
     /**零向量，禁止修改*/
     ConchVector4.ZERO = new ConchVector4();
     /*一向量，禁止修改*/
     ConchVector4.ONE = new ConchVector4(1.0, 1.0, 1.0, 1.0);
     /*X单位向量，禁止修改*/
     ConchVector4.UnitX = new ConchVector4(1.0, 0.0, 0.0, 0.0);
     /*Y单位向量，禁止修改*/
     ConchVector4.UnitY = new ConchVector4(0.0, 1.0, 0.0, 0.0);
     /*Z单位向量，禁止修改*/
     ConchVector4.UnitZ = new ConchVector4(0.0, 0.0, 1.0, 0.0);
     /*W单位向量，禁止修改*/
     ConchVector4.UnitW = new ConchVector4(0.0, 0.0, 0.0, 1.0);

     /**
      * <code>Vector3</code> 类用于创建三维向量。
      */
     class ConchVector3 {
         /**
          * 创建一个 <code>Vector3</code> 实例。
          * @param	x  X轴坐标。
          * @param	y  Y轴坐标。
          * @param	z  Z轴坐标。
          */
         constructor(x = 0, y = 0, z = 0, nativeElements = null /*[NATIVE]*/) {
             var v;
             if (nativeElements) { ///*[NATIVE]*/
                 v = nativeElements;
             }
             else {
                 v = new Float32Array(3);
             }
             this.elements = v;
             v[0] = x;
             v[1] = y;
             v[2] = z;
         }
         /**
          * 两个三维向量距离的平方。
          * @param	value1 向量1。
          * @param	value2 向量2。
          * @return	距离的平方。
          */
         static distanceSquared(value1, value2) {
             var value1e = value1.elements;
             var value2e = value2.elements;
             var x = value1e[0] - value2e[0];
             var y = value1e[1] - value2e[1];
             var z = value1e[2] - value2e[2];
             return (x * x) + (y * y) + (z * z);
         }
         /**
          * 两个三维向量距离。
          * @param	value1 向量1。
          * @param	value2 向量2。
          * @return	距离。
          */
         static distance(value1, value2) {
             var value1e = value1.elements;
             var value2e = value2.elements;
             var x = value1e[0] - value2e[0];
             var y = value1e[1] - value2e[1];
             var z = value1e[2] - value2e[2];
             return Math.sqrt((x * x) + (y * y) + (z * z));
         }
         /**
          * 分别取两个三维向量x、y、z的最小值计算新的三维向量。
          * @param	a。
          * @param	b。
          * @param	out。
          */
         static min(a, b, out) {
             var e = out.elements;
             var f = a.elements;
             var g = b.elements;
             e[0] = Math.min(f[0], g[0]);
             e[1] = Math.min(f[1], g[1]);
             e[2] = Math.min(f[2], g[2]);
         }
         /**
          * 分别取两个三维向量x、y、z的最大值计算新的三维向量。
          * @param	a a三维向量。
          * @param	b b三维向量。
          * @param	out 结果三维向量。
          */
         static max(a, b, out) {
             var e = out.elements;
             var f = a.elements;
             var g = b.elements;
             e[0] = Math.max(f[0], g[0]);
             e[1] = Math.max(f[1], g[1]);
             e[2] = Math.max(f[2], g[2]);
         }
         /**
          * 根据四元数旋转三维向量。
          * @param	source 源三维向量。
          * @param	rotation 旋转四元数。
          * @param	out 输出三维向量。
          */
         static transformQuat(source, rotation, out) {
             var destination = out.elements;
             var se = source.elements;
             var re = rotation.elements;
             var x = se[0], y = se[1], z = se[2], qx = re[0], qy = re[1], qz = re[2], qw = re[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
             destination[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
             destination[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
             destination[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
         }
         /**
          * 计算标量长度。
          * @param	a 源三维向量。
          * @return 标量长度。
          */
         static scalarLength(a) {
             var f = a.elements;
             var x = f[0], y = f[1], z = f[2];
             return Math.sqrt(x * x + y * y + z * z);
         }
         /**
          * 计算标量长度的平方。
          * @param	a 源三维向量。
          * @return 标量长度的平方。
          */
         static scalarLengthSquared(a) {
             var f = a.elements;
             var x = f[0], y = f[1], z = f[2];
             return x * x + y * y + z * z;
         }
         /**
          * 归一化三维向量。
          * @param	s 源三维向量。
          * @param	out 输出三维向量。
          */
         static normalize(s, out) {
             var se = s.elements;
             var oe = out.elements;
             var x = se[0], y = se[1], z = se[2];
             var len = x * x + y * y + z * z;
             if (len > 0) {
                 len = 1 / Math.sqrt(len);
                 oe[0] = se[0] * len;
                 oe[1] = se[1] * len;
                 oe[2] = se[2] * len;
             }
         }
         /**
          * 计算两个三维向量的乘积。
          * @param	a left三维向量。
          * @param	b right三维向量。
          * @param	out 输出三维向量。
          */
         static multiply(a, b, out) {
             var e = out.elements;
             var f = a.elements;
             var g = b.elements;
             e[0] = f[0] * g[0];
             e[1] = f[1] * g[1];
             e[2] = f[2] * g[2];
         }
         /**
          * 缩放三维向量。
          * @param	a 源三维向量。
          * @param	b 缩放值。
          * @param	out 输出三维向量。
          */
         static scale(a, b, out) {
             var e = out.elements;
             var f = a.elements;
             e[0] = f[0] * b;
             e[1] = f[1] * b;
             e[2] = f[2] * b;
         }
         /**
          * 插值三维向量。
          * @param	a left向量。
          * @param	b right向量。
          * @param	t 插值比例。
          * @param	out 输出向量。
          */
         static lerp(a, b, t, out) {
             var e = out.elements;
             var f = a.elements;
             var g = b.elements;
             var ax = f[0], ay = f[1], az = f[2];
             e[0] = ax + t * (g[0] - ax);
             e[1] = ay + t * (g[1] - ay);
             e[2] = az + t * (g[2] - az);
         }
         /**
          * 通过矩阵转换一个三维向量到另外一个三维向量。
          * @param	vector 源三维向量。
          * @param	transform  变换矩阵。
          * @param	result 输出三维向量。
          */
         static transformV3ToV3(vector, transform, result) {
             var intermediate = ConchVector3._tempVector4;
             ConchVector3.transformV3ToV4(vector, transform, intermediate);
             var intermediateElem = intermediate.elements;
             var resultElem = result.elements;
             resultElem[0] = intermediateElem[0];
             resultElem[1] = intermediateElem[1];
             resultElem[2] = intermediateElem[2];
         }
         /**
          * 通过矩阵转换一个三维向量到另外一个四维向量。
          * @param	vector 源三维向量。
          * @param	transform  变换矩阵。
          * @param	result 输出四维向量。
          */
         static transformV3ToV4(vector, transform, result) {
             var vectorElem = vector.elements;
             var vectorX = vectorElem[0];
             var vectorY = vectorElem[1];
             var vectorZ = vectorElem[2];
             var transformElem = transform.elements;
             var resultElem = result.elements;
             resultElem[0] = (vectorX * transformElem[0]) + (vectorY * transformElem[4]) + (vectorZ * transformElem[8]) + transformElem[12];
             resultElem[1] = (vectorX * transformElem[1]) + (vectorY * transformElem[5]) + (vectorZ * transformElem[9]) + transformElem[13];
             resultElem[2] = (vectorX * transformElem[2]) + (vectorY * transformElem[6]) + (vectorZ * transformElem[10]) + transformElem[14];
             resultElem[3] = (vectorX * transformElem[3]) + (vectorY * transformElem[7]) + (vectorZ * transformElem[11]) + transformElem[15];
         }
         /**
          * 通过法线矩阵转换一个法线三维向量到另外一个三维向量。
          * @param	normal 源法线三维向量。
          * @param	transform  法线变换矩阵。
          * @param	result 输出法线三维向量。
          */
         static TransformNormal(normal, transform, result) {
             var normalElem = normal.elements;
             var normalX = normalElem[0];
             var normalY = normalElem[1];
             var normalZ = normalElem[2];
             var transformElem = transform.elements;
             var resultElem = result.elements;
             resultElem[0] = (normalX * transformElem[0]) + (normalY * transformElem[4]) + (normalZ * transformElem[8]);
             resultElem[1] = (normalX * transformElem[1]) + (normalY * transformElem[5]) + (normalZ * transformElem[9]);
             resultElem[2] = (normalX * transformElem[2]) + (normalY * transformElem[6]) + (normalZ * transformElem[10]);
         }
         /**
          * 通过矩阵转换一个三维向量到另外一个归一化的三维向量。
          * @param	vector 源三维向量。
          * @param	transform  变换矩阵。
          * @param	result 输出三维向量。
          */
         static transformCoordinate(coordinate, transform, result) {
             var coordinateElem = coordinate.elements;
             var coordinateX = coordinateElem[0];
             var coordinateY = coordinateElem[1];
             var coordinateZ = coordinateElem[2];
             var transformElem = transform.elements;
             var w = ((coordinateX * transformElem[3]) + (coordinateY * transformElem[7]) + (coordinateZ * transformElem[11]) + transformElem[15]);
             var resultElem = result.elements;
             resultElem[0] = (coordinateX * transformElem[0]) + (coordinateY * transformElem[4]) + (coordinateZ * transformElem[8]) + transformElem[12] / w;
             resultElem[1] = (coordinateX * transformElem[1]) + (coordinateY * transformElem[5]) + (coordinateZ * transformElem[9]) + transformElem[13] / w;
             resultElem[2] = (coordinateX * transformElem[2]) + (coordinateY * transformElem[6]) + (coordinateZ * transformElem[10]) + transformElem[14] / w;
         }
         /**
          * 求一个指定范围的向量
          * @param	value clamp向量
          * @param	min  最小
          * @param	max  最大
          * @param   out 输出向量
          */
         static Clamp(value, min, max, out) {
             var valuee = value.elements;
             var x = valuee[0];
             var y = valuee[1];
             var z = valuee[2];
             var mine = min.elements;
             var mineX = mine[0];
             var mineY = mine[1];
             var mineZ = mine[2];
             var maxe = max.elements;
             var maxeX = maxe[0];
             var maxeY = maxe[1];
             var maxeZ = maxe[2];
             var oute = out.elements;
             x = (x > maxeX) ? maxeX : x;
             x = (x < mineX) ? mineX : x;
             y = (y > maxeY) ? maxeY : y;
             y = (y < mineY) ? mineY : y;
             z = (z > maxeZ) ? maxeZ : z;
             z = (z < mineZ) ? mineZ : z;
             oute[0] = x;
             oute[1] = y;
             oute[2] = z;
         }
         /**
          * 求两个三维向量的和。
          * @param	a left三维向量。
          * @param	b right三维向量。
          * @param	out 输出向量。
          */
         static add(a, b, out) {
             var e = out.elements;
             var f = a.elements;
             var g = b.elements;
             e[0] = f[0] + g[0];
             e[1] = f[1] + g[1];
             e[2] = f[2] + g[2];
         }
         /**
          * 求两个三维向量的差。
          * @param	a  left三维向量。
          * @param	b  right三维向量。
          * @param	o out 输出向量。
          */
         static subtract(a, b, o) {
             var oe = o.elements;
             var ae = a.elements;
             var be = b.elements;
             oe[0] = ae[0] - be[0];
             oe[1] = ae[1] - be[1];
             oe[2] = ae[2] - be[2];
         }
         /**
          * 求两个三维向量的叉乘。
          * @param	a left向量。
          * @param	b right向量。
          * @param	o 输出向量。
          */
         static cross(a, b, o) {
             var ae = a.elements;
             var be = b.elements;
             var oe = o.elements;
             var ax = ae[0], ay = ae[1], az = ae[2], bx = be[0], by = be[1], bz = be[2];
             oe[0] = ay * bz - az * by;
             oe[1] = az * bx - ax * bz;
             oe[2] = ax * by - ay * bx;
         }
         /**
          * 求两个三维向量的点积。
          * @param	a left向量。
          * @param	b right向量。
          * @return   点积。
          */
         static dot(a, b) {
             var ae = a.elements;
             var be = b.elements;
             var r = (ae[0] * be[0]) + (ae[1] * be[1]) + (ae[2] * be[2]);
             return r;
         }
         /**
          * 判断两个三维向量是否相等。
          * @param	a 三维向量。
          * @param	b 三维向量。
          * @return  是否相等。
          */
         static equals(a, b) {
             var ae = a.elements;
             var be = b.elements;
             return MathUtils3D.nearEqual(ae[0], be[0]) && MathUtils3D.nearEqual(ae[1], be[1]) && MathUtils3D.nearEqual(ae[2], be[2]);
         }
         /**
          * 获取X轴坐标。
          * @return	X轴坐标。
          */
         get x() {
             return this.elements[0];
         }
         /**
          * 设置X轴坐标。
          * @param	value  X轴坐标。
          */
         set x(value) {
             this.elements[0] = value;
         }
         /**
          * 获取Y轴坐标。
          * @return	Y轴坐标。
          */
         get y() {
             return this.elements[1];
         }
         /**
          * 设置Y轴坐标。
          * @param	value  Y轴坐标。
          */
         set y(value) {
             this.elements[1] = value;
         }
         /**
          * 获取Z轴坐标。
          * @return	Z轴坐标。
          */
         get z() {
             return this.elements[2];
         }
         /**
          * 设置Z轴坐标。
          * @param	value  Z轴坐标。
          */
         set z(value) {
             this.elements[2] = value;
         }
         /**
          * 设置xyz值。
          * @param	x X值。
          * @param	y Y值。
          * @param	z Z值。
          */
         setValue(x, y, z) {
             this.elements[0] = x;
             this.elements[1] = y;
             this.elements[2] = z;
         }
         /**
          * 从Array数组拷贝值。
          * @param  array 数组。
          * @param  offset 数组偏移。
          */
         fromArray(array, offset = 0) {
             this.elements[0] = array[offset + 0];
             this.elements[1] = array[offset + 1];
             this.elements[2] = array[offset + 2];
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destVector3 = destObject;
             var destE = destVector3.elements;
             var s = this.elements;
             destE[0] = s[0];
             destE[1] = s[1];
             destE[2] = s[2];
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var destVector3 = new ConchVector3();
             this.cloneTo(destVector3);
             return destVector3;
         }
         toDefault() {
             this.elements[0] = 0;
             this.elements[1] = 0;
             this.elements[2] = 0;
         }
     }
     /*[FILEINDEX:10000]*/
     /**@private	*/
     ConchVector3._tempVector4 = new ConchVector4();
     /**零向量，禁止修改*/
     ConchVector3.ZERO = new ConchVector3(0.0, 0.0, 0.0);
     /**一向量，禁止修改*/
     ConchVector3.ONE = new ConchVector3(1.0, 1.0, 1.0);
     /**X轴单位向量，禁止修改*/
     ConchVector3.NegativeUnitX = new ConchVector3(-1, 0, 0);
     /**X轴单位向量，禁止修改*/
     ConchVector3.UnitX = new ConchVector3(1, 0, 0);
     /**Y轴单位向量，禁止修改*/
     ConchVector3.UnitY = new ConchVector3(0, 1, 0);
     /**Z轴单位向量，禁止修改*/
     ConchVector3.UnitZ = new ConchVector3(0, 0, 1);
     /**右手坐标系统前向量，禁止修改*/
     ConchVector3.ForwardRH = new ConchVector3(0, 0, -1);
     /**左手坐标系统前向量,禁止修改*/
     ConchVector3.ForwardLH = new ConchVector3(0, 0, 1);
     /**上向量,禁止修改*/
     ConchVector3.Up = new ConchVector3(0, 1, 0);
     /**无效矩阵,禁止修改*/
     ConchVector3.NAN = new ConchVector3(NaN, NaN, NaN);

     /**
      * <code>Quaternion</code> 类用于创建四元数。
      */
     class ConchQuaternion {
         /**
          * 创建一个 <code>Quaternion</code> 实例。
          * @param	x 四元数的x值
          * @param	y 四元数的y值
          * @param	z 四元数的z值
          * @param	w 四元数的w值
          */
         constructor(x = 0, y = 0, z = 0, w = 1, nativeElements = null /*[NATIVE]*/) {
             var v;
             if (nativeElements) { ///*[NATIVE]*/
                 v = nativeElements;
             }
             else {
                 v = new Float32Array(4);
             }
             v[0] = x;
             v[1] = y;
             v[2] = z;
             v[3] = w;
             this.elements = v;
         }
         /**
          * @private
          */
         static _dotArray(l, r) {
             return l[0] * r[0] + l[1] * r[1] + l[2] * r[2] + l[3] * r[3];
         }
         /**
          * @private
          */
         static _normalizeArray(f, o) {
             var x = f[0], y = f[1], z = f[2], w = f[3];
             var len = x * x + y * y + z * z + w * w;
             if (len > 0) {
                 len = 1 / Math.sqrt(len);
                 o[0] = x * len;
                 o[1] = y * len;
                 o[2] = z * len;
                 o[3] = w * len;
             }
         }
         /**
          * @private
          */
         static _lerpArray(l, r, amount, o) {
             var inverse = 1.0 - amount;
             if (ConchQuaternion._dotArray(l, r) >= 0) {
                 o[0] = (inverse * l[0]) + (amount * r[0]);
                 o[1] = (inverse * l[1]) + (amount * r[1]);
                 o[2] = (inverse * l[2]) + (amount * r[2]);
                 o[3] = (inverse * l[3]) + (amount * r[3]);
             }
             else {
                 o[0] = (inverse * l[0]) - (amount * r[0]);
                 o[1] = (inverse * l[1]) - (amount * r[1]);
                 o[2] = (inverse * l[2]) - (amount * r[2]);
                 o[3] = (inverse * l[3]) - (amount * r[3]);
             }
             ConchQuaternion._normalizeArray(o, o);
         }
         /**
          *  从欧拉角生成四元数（顺序为Yaw、Pitch、Roll）
          * @param	yaw yaw值
          * @param	pitch pitch值
          * @param	roll roll值
          * @param	out 输出四元数
          */
         static createFromYawPitchRoll(yaw, pitch, roll, out) {
             var halfRoll = roll * 0.5;
             var halfPitch = pitch * 0.5;
             var halfYaw = yaw * 0.5;
             var sinRoll = Math.sin(halfRoll);
             var cosRoll = Math.cos(halfRoll);
             var sinPitch = Math.sin(halfPitch);
             var cosPitch = Math.cos(halfPitch);
             var sinYaw = Math.sin(halfYaw);
             var cosYaw = Math.cos(halfYaw);
             var oe = out.elements;
             oe[0] = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
             oe[1] = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
             oe[2] = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
             oe[3] = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
         }
         /**
          * 计算两个四元数相乘
          * @param	left left四元数
          * @param	right  right四元数
          * @param	out 输出四元数
          */
         static multiply(left, right, out) {
             var le = left.elements;
             var re = right.elements;
             var oe = out.elements;
             var lx = le[0];
             var ly = le[1];
             var lz = le[2];
             var lw = le[3];
             var rx = re[0];
             var ry = re[1];
             var rz = re[2];
             var rw = re[3];
             var a = (ly * rz - lz * ry);
             var b = (lz * rx - lx * rz);
             var c = (lx * ry - ly * rx);
             var d = (lx * rx + ly * ry + lz * rz);
             oe[0] = (lx * rw + rx * lw) + a;
             oe[1] = (ly * rw + ry * lw) + b;
             oe[2] = (lz * rw + rz * lw) + c;
             oe[3] = lw * rw - d;
         }
         static arcTanAngle(x, y) {
             if (x == 0) {
                 if (y == 1)
                     return Math.PI / 2;
                 return -Math.PI / 2;
             }
             if (x > 0)
                 return Math.atan(y / x);
             if (x < 0) {
                 if (y > 0)
                     return Math.atan(y / x) + Math.PI;
                 return Math.atan(y / x) - Math.PI;
             }
             return 0;
         }
         static angleTo(from, location, angle) {
             ConchVector3.subtract(location, from, ConchQuaternion.TEMPVector30);
             ConchVector3.normalize(ConchQuaternion.TEMPVector30, ConchQuaternion.TEMPVector30);
             angle.elements[0] = Math.asin(ConchQuaternion.TEMPVector30.y);
             angle.elements[1] = ConchQuaternion.arcTanAngle(-ConchQuaternion.TEMPVector30.z, -ConchQuaternion.TEMPVector30.x);
         }
         /**
          * 从指定的轴和角度计算四元数
          * @param	axis  轴
          * @param	rad  角度
          * @param	out  输出四元数
          */
         static createFromAxisAngle(axis, rad, out) {
             var e = out.elements;
             var f = axis.elements;
             rad = rad * 0.5;
             var s = Math.sin(rad);
             e[0] = s * f[0];
             e[1] = s * f[1];
             e[2] = s * f[2];
             e[3] = Math.cos(rad);
         }
         /**
          * 根据3x3矩阵计算四元数
          * @param	sou 源矩阵
          * @param	out 输出四元数
          */
         static createFromMatrix3x3(sou, out) {
             var e = out.elements;
             var f = sou.elements;
             var fTrace = f[0] + f[4] + f[8];
             var fRoot;
             if (fTrace > 0.0) {
                 // |w| > 1/2, may as well choose w > 1/2
                 fRoot = Math.sqrt(fTrace + 1.0); // 2w
                 e[3] = 0.5 * fRoot;
                 fRoot = 0.5 / fRoot; // 1/(4w)
                 e[0] = (f[5] - f[7]) * fRoot;
                 e[1] = (f[6] - f[2]) * fRoot;
                 e[2] = (f[1] - f[3]) * fRoot;
             }
             else {
                 // |w| <= 1/2
                 var i = 0;
                 if (f[4] > f[0])
                     i = 1;
                 if (f[8] > f[i * 3 + i])
                     i = 2;
                 var j = (i + 1) % 3;
                 var k = (i + 2) % 3;
                 fRoot = Math.sqrt(f[i * 3 + i] - f[j * 3 + j] - f[k * 3 + k] + 1.0);
                 e[i] = 0.5 * fRoot;
                 fRoot = 0.5 / fRoot;
                 e[3] = (f[j * 3 + k] - f[k * 3 + j]) * fRoot;
                 e[j] = (f[j * 3 + i] + f[i * 3 + j]) * fRoot;
                 e[k] = (f[k * 3 + i] + f[i * 3 + k]) * fRoot;
             }
             return;
         }
         /**
          *  从旋转矩阵计算四元数
          * @param	mat 旋转矩阵
          * @param	out  输出四元数
          */
         static createFromMatrix4x4(mat, out) {
             var me = mat.elements;
             var oe = out.elements;
             var sqrt;
             var half;
             var scale = me[0] + me[5] + me[10];
             if (scale > 0.0) {
                 sqrt = Math.sqrt(scale + 1.0);
                 oe[3] = sqrt * 0.5;
                 sqrt = 0.5 / sqrt;
                 oe[0] = (me[6] - me[9]) * sqrt;
                 oe[1] = (me[8] - me[2]) * sqrt;
                 oe[2] = (me[1] - me[4]) * sqrt;
             }
             else if ((me[0] >= me[5]) && (me[0] >= me[10])) {
                 sqrt = Math.sqrt(1.0 + me[0] - me[5] - me[10]);
                 half = 0.5 / sqrt;
                 oe[0] = 0.5 * sqrt;
                 oe[1] = (me[1] + me[4]) * half;
                 oe[2] = (me[2] + me[8]) * half;
                 oe[3] = (me[6] - me[9]) * half;
             }
             else if (me[5] > me[10]) {
                 sqrt = Math.sqrt(1.0 + me[5] - me[0] - me[10]);
                 half = 0.5 / sqrt;
                 oe[0] = (me[4] + me[1]) * half;
                 oe[1] = 0.5 * sqrt;
                 oe[2] = (me[9] + me[6]) * half;
                 oe[3] = (me[8] - me[2]) * half;
             }
             else {
                 sqrt = Math.sqrt(1.0 + me[10] - me[0] - me[5]);
                 half = 0.5 / sqrt;
                 oe[0] = (me[8] + me[2]) * half;
                 oe[1] = (me[9] + me[6]) * half;
                 oe[2] = 0.5 * sqrt;
                 oe[3] = (me[1] - me[4]) * half;
             }
         }
         /**
          * 球面插值
          * @param	left left四元数
          * @param	right  right四元数
          * @param	a 插值比例
          * @param	out 输出四元数
          * @return   输出Float32Array
          */
         static slerp(left, right, t, out) {
             var a = left.elements;
             var b = right.elements;
             var oe = out.elements;
             var ax = a[0], ay = a[1], az = a[2], aw = a[3], bx = b[0], by = b[1], bz = b[2], bw = b[3];
             var omega, cosom, sinom, scale0, scale1;
             // calc cosine 
             cosom = ax * bx + ay * by + az * bz + aw * bw;
             // adjust signs (if necessary) 
             if (cosom < 0.0) {
                 cosom = -cosom;
                 bx = -bx;
                 by = -by;
                 bz = -bz;
                 bw = -bw;
             }
             // calculate coefficients 
             if ((1.0 - cosom) > 0.000001) {
                 // standard case (slerp) 
                 omega = Math.acos(cosom);
                 sinom = Math.sin(omega);
                 scale0 = Math.sin((1.0 - t) * omega) / sinom;
                 scale1 = Math.sin(t * omega) / sinom;
             }
             else {
                 // "from" and "to" quaternions are very close  
                 //  ... so we can do a linear interpolation 
                 scale0 = 1.0 - t;
                 scale1 = t;
             }
             // calculate final values 
             oe[0] = scale0 * ax + scale1 * bx;
             oe[1] = scale0 * ay + scale1 * by;
             oe[2] = scale0 * az + scale1 * bz;
             oe[3] = scale0 * aw + scale1 * bw;
             return oe;
         }
         /**
          * 计算两个四元数的线性插值
          * @param	left left四元数
          * @param	right right四元数b
          * @param	t 插值比例
          * @param	out 输出四元数
          */
         static lerp(left, right, amount, out) {
             ConchQuaternion._lerpArray(left.elements, right.elements, amount, out.elements);
         }
         /**
          * 计算两个四元数的和
          * @param	left  left四元数
          * @param	right right 四元数
          * @param	out 输出四元数
          */
         static add(left, right, out) {
             var e = out.elements;
             var f = left.elements;
             var g = right.elements;
             e[0] = f[0] + g[0];
             e[1] = f[1] + g[1];
             e[2] = f[2] + g[2];
             e[3] = f[3] + g[3];
         }
         /**
          * 计算两个四元数的点积
          * @param	left left四元数
          * @param	right right四元数
          * @return  点积
          */
         static dot(left, right) {
             return ConchQuaternion._dotArray(left.elements, right.elements);
         }
         /**
          * 获取四元数的x值
          */
         get x() {
             return this.elements[0];
         }
         /**
          * 设置四元数的x值
          */
         set x(value) {
             this.elements[0] = value;
         }
         /**
          * 获取四元数的y值
          */
         get y() {
             return this.elements[1];
         }
         /**
          * 设置四元数的y值
          */
         set y(value) {
             this.elements[1] = value;
         }
         /**
          * 获取四元数的z值
          */
         get z() {
             return this.elements[2];
         }
         /**
          * 设置四元数的z值
          */
         set z(value) {
             this.elements[2] = value;
         }
         /**
          * 获取四元数的w值
          */
         get w() {
             return this.elements[3];
         }
         /**
          * 设置四元数的w值
          */
         set w(value) {
             this.elements[3] = value;
         }
         /**
          * 根据缩放值缩放四元数
          * @param	scale 缩放值
          * @param	out 输出四元数
          */
         scaling(scaling, out) {
             var e = out.elements;
             var f = this.elements;
             e[0] = f[0] * scaling;
             e[1] = f[1] * scaling;
             e[2] = f[2] * scaling;
             e[3] = f[3] * scaling;
         }
         /**
          * 归一化四元数
          * @param	out 输出四元数
          */
         normalize(out) {
             ConchQuaternion._normalizeArray(this.elements, out.elements);
         }
         /**
          * 计算四元数的长度
          * @return  长度
          */
         length() {
             var f = this.elements;
             var x = f[0], y = f[1], z = f[2], w = f[3];
             return Math.sqrt(x * x + y * y + z * z + w * w);
         }
         /**
          * 根据绕X轴的角度旋转四元数
          * @param	rad 角度
          * @param	out 输出四元数
          */
         rotateX(rad, out) {
             var e = out.elements;
             var f = this.elements;
             rad *= 0.5;
             var ax = f[0], ay = f[1], az = f[2], aw = f[3];
             var bx = Math.sin(rad), bw = Math.cos(rad);
             e[0] = ax * bw + aw * bx;
             e[1] = ay * bw + az * bx;
             e[2] = az * bw - ay * bx;
             e[3] = aw * bw - ax * bx;
         }
         /**
          * 根据绕Y轴的制定角度旋转四元数
          * @param	rad 角度
          * @param	out 输出四元数
          */
         rotateY(rad, out) {
             var e = out.elements;
             var f = this.elements;
             rad *= 0.5;
             var ax = f[0], ay = f[1], az = f[2], aw = f[3], by = Math.sin(rad), bw = Math.cos(rad);
             e[0] = ax * bw - az * by;
             e[1] = ay * bw + aw * by;
             e[2] = az * bw + ax * by;
             e[3] = aw * bw - ay * by;
         }
         /**
          * 根据绕Z轴的制定角度旋转四元数
          * @param	rad 角度
          * @param	out 输出四元数
          */
         rotateZ(rad, out) {
             var e = out.elements;
             var f = this.elements;
             rad *= 0.5;
             var ax = f[0], ay = f[1], az = f[2], aw = f[3], bz = Math.sin(rad), bw = Math.cos(rad);
             e[0] = ax * bw + ay * bz;
             e[1] = ay * bw - ax * bz;
             e[2] = az * bw + aw * bz;
             e[3] = aw * bw - az * bz;
         }
         /**
          * 分解四元数到欧拉角（顺序为Yaw、Pitch、Roll），参考自http://xboxforums.create.msdn.com/forums/p/4574/23988.aspx#23988,问题绕X轴翻转超过±90度时有，会产生瞬间反转
          * @param	quaternion 源四元数
          * @param	out 欧拉角值
          */
         getYawPitchRoll(out) {
             ConchVector3.transformQuat(ConchVector3.ForwardRH, this, ConchQuaternion.TEMPVector31 /*forwarldRH*/);
             ConchVector3.transformQuat(ConchVector3.Up, this, ConchQuaternion.TEMPVector32 /*up*/);
             var upe = ConchQuaternion.TEMPVector32.elements;
             ConchQuaternion.angleTo(ConchVector3.ZERO, ConchQuaternion.TEMPVector31, ConchQuaternion.TEMPVector33 /*angle*/);
             var anglee = ConchQuaternion.TEMPVector33.elements;
             if (anglee[0] == Math.PI / 2) {
                 anglee[1] = ConchQuaternion.arcTanAngle(upe[2], upe[0]);
                 anglee[2] = 0;
             }
             else if (anglee[0] == -Math.PI / 2) {
                 anglee[1] = ConchQuaternion.arcTanAngle(-upe[2], -upe[0]);
                 anglee[2] = 0;
             }
             else {
                 Matrix4x4.createRotationY(-anglee[1], ConchQuaternion.TEMPMatrix0);
                 Matrix4x4.createRotationX(-anglee[0], ConchQuaternion.TEMPMatrix1);
                 ConchVector3.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix0, ConchQuaternion.TEMPVector32);
                 ConchVector3.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix1, ConchQuaternion.TEMPVector32);
                 anglee[2] = ConchQuaternion.arcTanAngle(upe[1], -upe[0]);
             }
             // Special cases.
             if (anglee[1] <= -Math.PI)
                 anglee[1] = Math.PI;
             if (anglee[2] <= -Math.PI)
                 anglee[2] = Math.PI;
             if (anglee[1] >= Math.PI && anglee[2] >= Math.PI) {
                 anglee[1] = 0;
                 anglee[2] = 0;
                 anglee[0] = Math.PI - anglee[0];
             }
             var oe = out.elements;
             oe[0] = anglee[1];
             oe[1] = anglee[0];
             oe[2] = anglee[2];
         }
         /**
          * 求四元数的逆
          * @param	out  输出四元数
          */
         invert(out) {
             var e = out.elements;
             var f = this.elements;
             var a0 = f[0], a1 = f[1], a2 = f[2], a3 = f[3];
             var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
             var invDot = dot ? 1.0 / dot : 0;
             // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
             e[0] = -a0 * invDot;
             e[1] = -a1 * invDot;
             e[2] = -a2 * invDot;
             e[3] = a3 * invDot;
         }
         /**
          *设置四元数为单位算数
          * @param out  输出四元数
          */
         identity() {
             var e = this.elements;
             e[0] = 0;
             e[1] = 0;
             e[2] = 0;
             e[3] = 1;
         }
         /**
          * 从Array数组拷贝值。
          * @param  array 数组。
          * @param  offset 数组偏移。
          */
         fromArray(array, offset = 0) {
             this.elements[0] = array[offset + 0];
             this.elements[1] = array[offset + 1];
             this.elements[2] = array[offset + 2];
             this.elements[3] = array[offset + 3];
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var i, s, d;
             s = this.elements;
             d = destObject.elements;
             if (s === d) {
                 return;
             }
             for (i = 0; i < 4; ++i) {
                 d[i] = s[i];
             }
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new ConchQuaternion();
             this.cloneTo(dest);
             return dest;
         }
         equals(b) {
             var ae = this.elements;
             var be = b.elements;
             return MathUtils3D.nearEqual(ae[0], be[0]) && MathUtils3D.nearEqual(ae[1], be[1]) && MathUtils3D.nearEqual(ae[2], be[2]) && MathUtils3D.nearEqual(ae[3], be[3]);
         }
         /**
          * 计算旋转观察四元数
          * @param	forward 方向
          * @param	up     上向量
          * @param	out    输出四元数
          */
         static rotationLookAt(forward, up, out) {
             ConchQuaternion.lookAt(ConchVector3.ZERO, forward, up, out);
         }
         /**
          * 计算观察四元数
          * @param	eye    观察者位置
          * @param	target 目标位置
          * @param	up     上向量
          * @param	out    输出四元数
          */
         static lookAt(eye, target, up, out) {
             Matrix3x3.lookAt(eye, target, up, ConchQuaternion._tempMatrix3x3);
             ConchQuaternion.rotationMatrix(ConchQuaternion._tempMatrix3x3, out);
         }
         /**
          * 计算长度的平方。
          * @return 长度的平方。
          */
         lengthSquared() {
             var x = this.elements[0];
             var y = this.elements[1];
             var z = this.elements[2];
             var w = this.elements[3];
             return (x * x) + (y * y) + (z * z) + (w * w);
         }
         /**
          * 计算四元数的逆四元数。
          * @param	value 四元数。
          * @param	out 逆四元数。
          */
         static invert(value, out) {
             var vE = value.elements;
             var oE = out.elements;
             var lengthSq = value.lengthSquared();
             if (!MathUtils3D.isZero(lengthSq)) {
                 lengthSq = 1.0 / lengthSq;
                 oE[0] = -vE[0] * lengthSq;
                 oE[1] = -vE[1] * lengthSq;
                 oE[2] = -vE[2] * lengthSq;
                 oE[3] = vE[3] * lengthSq;
             }
         }
         /**
          * 通过一个3x3矩阵创建一个四元数
          * @param	matrix3x3  3x3矩阵
          * @param	out        四元数
          */
         static rotationMatrix(matrix3x3, out) {
             var me = matrix3x3.elements;
             var m11 = me[0];
             var m12 = me[1];
             var m13 = me[2];
             var m21 = me[3];
             var m22 = me[4];
             var m23 = me[5];
             var m31 = me[6];
             var m32 = me[7];
             var m33 = me[8];
             var oe = out.elements;
             var sqrt, half;
             var scale = m11 + m22 + m33;
             if (scale > 0) {
                 sqrt = Math.sqrt(scale + 1);
                 oe[3] = sqrt * 0.5;
                 sqrt = 0.5 / sqrt;
                 oe[0] = (m23 - m32) * sqrt;
                 oe[1] = (m31 - m13) * sqrt;
                 oe[2] = (m12 - m21) * sqrt;
             }
             else if ((m11 >= m22) && (m11 >= m33)) {
                 sqrt = Math.sqrt(1 + m11 - m22 - m33);
                 half = 0.5 / sqrt;
                 oe[0] = 0.5 * sqrt;
                 oe[1] = (m12 + m21) * half;
                 oe[2] = (m13 + m31) * half;
                 oe[3] = (m23 - m32) * half;
             }
             else if (m22 > m33) {
                 sqrt = Math.sqrt(1 + m22 - m11 - m33);
                 half = 0.5 / sqrt;
                 oe[0] = (m21 + m12) * half;
                 oe[1] = 0.5 * sqrt;
                 oe[2] = (m32 + m23) * half;
                 oe[3] = (m31 - m13) * half;
             }
             else {
                 sqrt = Math.sqrt(1 + m33 - m11 - m22);
                 half = 0.5 / sqrt;
                 oe[0] = (m31 + m13) * half;
                 oe[1] = (m32 + m23) * half;
                 oe[2] = 0.5 * sqrt;
                 oe[3] = (m12 - m21) * half;
             }
         }
     }
     /*[FILEINDEX:10000]*/
     /**@private */
     ConchQuaternion.TEMPVector30 = new ConchVector3();
     /**@private */
     ConchQuaternion.TEMPVector31 = new ConchVector3();
     /**@private */
     ConchQuaternion.TEMPVector32 = new ConchVector3();
     /**@private */
     ConchQuaternion.TEMPVector33 = new ConchVector3();
     /**@private */
     ConchQuaternion.TEMPMatrix0 = new Matrix4x4();
     /**@private */
     ConchQuaternion.TEMPMatrix1 = new Matrix4x4();
     /**@private */
     ConchQuaternion._tempMatrix3x3 = new Matrix3x3();
     /**默认矩阵,禁止修改*/
     ConchQuaternion.DEFAULT = new ConchQuaternion();
     /**无效矩阵,禁止修改*/
     ConchQuaternion.NAN = new ConchQuaternion(NaN, NaN, NaN, NaN);

     /**
      * @private
      */
     class AnimationClipParser03 {
         /**
          * @private
          */
         static READ_DATA() {
             AnimationClipParser03._DATA.offset = AnimationClipParser03._reader.getUint32();
             AnimationClipParser03._DATA.size = AnimationClipParser03._reader.getUint32();
         }
         /**
          * @private
          */
         static READ_BLOCK() {
             var count = AnimationClipParser03._BLOCK.count = AnimationClipParser03._reader.getUint16();
             var blockStarts = AnimationClipParser03._BLOCK.blockStarts = [];
             var blockLengths = AnimationClipParser03._BLOCK.blockLengths = [];
             for (var i = 0; i < count; i++) {
                 blockStarts.push(AnimationClipParser03._reader.getUint32());
                 blockLengths.push(AnimationClipParser03._reader.getUint32());
             }
         }
         /**
          * @private
          */
         static READ_STRINGS() {
             var offset = AnimationClipParser03._reader.getUint32();
             var count = AnimationClipParser03._reader.getUint16();
             var prePos = AnimationClipParser03._reader.pos;
             AnimationClipParser03._reader.pos = offset + AnimationClipParser03._DATA.offset;
             for (var i = 0; i < count; i++)
                 AnimationClipParser03._strings[i] = AnimationClipParser03._reader.readUTFString();
             AnimationClipParser03._reader.pos = prePos;
         }
         /**
          * @private
          */
         static parse(clip, reader) {
             AnimationClipParser03._animationClip = clip;
             AnimationClipParser03._reader = reader;
             var arrayBuffer = reader.__getBuffer();
             AnimationClipParser03.READ_DATA();
             AnimationClipParser03.READ_BLOCK();
             AnimationClipParser03.READ_STRINGS();
             for (var i = 0, n = AnimationClipParser03._BLOCK.count; i < n; i++) {
                 var index = reader.getUint16();
                 var blockName = AnimationClipParser03._strings[index];
                 var fn = AnimationClipParser03["READ_" + blockName];
                 if (fn == null)
                     throw new Error("model file err,no this function:" + index + " " + blockName);
                 else
                     fn.call(null);
             }
         }
         /**
          * @private
          */
         static READ_ANIMATIONS() {
             var i, j;
             var node;
             var reader = AnimationClipParser03._reader;
             var buffer = reader.__getBuffer();
             var startTimeTypes = [];
             var startTimeTypeCount = reader.getUint16();
             startTimeTypes.length = startTimeTypeCount;
             for (i = 0; i < startTimeTypeCount; i++)
                 startTimeTypes[i] = reader.getFloat32();
             var clip = AnimationClipParser03._animationClip;
             clip.name = AnimationClipParser03._strings[reader.getUint16()];
             var clipDur = clip._duration = reader.getFloat32();
             clip.islooping = !!reader.getByte();
             clip._frameRate = reader.getInt16();
             var nodeCount = reader.getInt16();
             var nodes = clip._nodes;
             nodes.count = nodeCount;
             var nodesMap = clip._nodesMap = {};
             var nodesDic = clip._nodesDic = {};
             for (i = 0; i < nodeCount; i++) {
                 node = new KeyframeNode();
                 nodes.setNodeByIndex(i, node);
                 node._indexInList = i;
                 var type = node.type = reader.getUint8();
                 var pathLength = reader.getUint16();
                 node._setOwnerPathCount(pathLength);
                 for (j = 0; j < pathLength; j++)
                     node._setOwnerPathByIndex(j, AnimationClipParser03._strings[reader.getUint16()]); //TODO:如果只有根节点并且为空，是否可以和componentType一样优化。
                 var nodePath = node._joinOwnerPath("/");
                 var mapArray = nodesMap[nodePath];
                 (mapArray) || (nodesMap[nodePath] = mapArray = []);
                 mapArray.push(node);
                 node.propertyOwner = AnimationClipParser03._strings[reader.getUint16()];
                 var propertyLength = reader.getUint16();
                 node._setPropertyCount(propertyLength);
                 for (j = 0; j < propertyLength; j++)
                     node._setPropertyByIndex(j, AnimationClipParser03._strings[reader.getUint16()]);
                 var fullPath = nodePath + "." + node.propertyOwner + "." + node._joinProperty(".");
                 nodesDic[fullPath] = node;
                 node.fullPath = fullPath;
                 var keyframeCount = reader.getUint16();
                 node._setKeyframeCount(keyframeCount);
                 var startTime;
                 switch (type) {
                     case 0:
                         break;
                     case 1:
                     case 3:
                     case 4:
                         node.data = Render.supportWebGLPlusAnimation ? new ConchVector3 : new Vector3();
                         break;
                     case 2:
                         node.data = Render.supportWebGLPlusAnimation ? new ConchQuaternion : new Quaternion();
                         break;
                     default:
                         throw "AnimationClipParser03:unknown type.";
                 }
                 for (j = 0; j < keyframeCount; j++) {
                     switch (type) {
                         case 0:
                             var floatKeyframe = new FloatKeyframe();
                             node._setKeyframeByIndex(j, floatKeyframe);
                             startTime = floatKeyframe.time = startTimeTypes[reader.getUint16()];
                             floatKeyframe.inTangent = reader.getFloat32();
                             floatKeyframe.outTangent = reader.getFloat32();
                             floatKeyframe.value = reader.getFloat32();
                             break;
                         case 1:
                         case 3:
                         case 4:
                             var floatArrayKeyframe = new Vector3Keyframe();
                             node._setKeyframeByIndex(j, floatArrayKeyframe);
                             startTime = floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                             if (Render.supportWebGLPlusAnimation) {
                                 var data = floatArrayKeyframe.data = new Float32Array(3 * 3);
                                 for (var k = 0; k < 3; k++)
                                     data[k] = reader.getFloat32();
                                 for (k = 0; k < 3; k++)
                                     data[3 + k] = reader.getFloat32();
                                 for (k = 0; k < 3; k++)
                                     data[6 + k] = reader.getFloat32();
                             }
                             else {
                                 var inTangent = floatArrayKeyframe.inTangent;
                                 var outTangent = floatArrayKeyframe.outTangent;
                                 var value = floatArrayKeyframe.value;
                                 inTangent.x = reader.getFloat32();
                                 inTangent.y = reader.getFloat32();
                                 inTangent.z = reader.getFloat32();
                                 outTangent.x = reader.getFloat32();
                                 outTangent.y = reader.getFloat32();
                                 outTangent.z = reader.getFloat32();
                                 value.x = reader.getFloat32();
                                 value.y = reader.getFloat32();
                                 value.z = reader.getFloat32();
                             }
                             break;
                         case 2:
                             var quaArrayKeyframe = new QuaternionKeyframe();
                             node._setKeyframeByIndex(j, quaArrayKeyframe);
                             startTime = quaArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                             if (Render.supportWebGLPlusAnimation) {
                                 data = quaArrayKeyframe.data = new Float32Array(3 * 4);
                                 for (k = 0; k < 4; k++)
                                     data[k] = reader.getFloat32();
                                 for (k = 0; k < 4; k++)
                                     data[4 + k] = reader.getFloat32();
                                 for (k = 0; k < 4; k++)
                                     data[8 + k] = reader.getFloat32();
                             }
                             else {
                                 var inTangentQua = quaArrayKeyframe.inTangent;
                                 var outTangentQua = quaArrayKeyframe.outTangent;
                                 var valueQua = quaArrayKeyframe.value;
                                 inTangentQua.x = reader.getFloat32();
                                 inTangentQua.y = reader.getFloat32();
                                 inTangentQua.z = reader.getFloat32();
                                 inTangentQua.w = reader.getFloat32();
                                 outTangentQua.x = reader.getFloat32();
                                 outTangentQua.y = reader.getFloat32();
                                 outTangentQua.z = reader.getFloat32();
                                 outTangentQua.w = reader.getFloat32();
                                 valueQua.x = reader.getFloat32();
                                 valueQua.y = reader.getFloat32();
                                 valueQua.z = reader.getFloat32();
                                 valueQua.w = reader.getFloat32();
                             }
                             break;
                         default:
                             throw "AnimationClipParser03:unknown type.";
                     }
                 }
             }
             var eventCount = reader.getUint16();
             for (i = 0; i < eventCount; i++) {
                 var event = new AnimationEvent();
                 event.time = Math.min(clipDur, reader.getFloat32()); //TODO:事件时间可能大于动画总时长
                 event.eventName = AnimationClipParser03._strings[reader.getUint16()];
                 var params;
                 var paramCount = reader.getUint16();
                 (paramCount > 0) && (event.params = params = []);
                 for (j = 0; j < paramCount; j++) {
                     var eventType = reader.getByte();
                     switch (eventType) {
                         case 0:
                             params.push(!!reader.getByte());
                             break;
                         case 1:
                             params.push(reader.getInt32());
                             break;
                         case 2:
                             params.push(reader.getFloat32());
                             break;
                         case 3:
                             params.push(AnimationClipParser03._strings[reader.getUint16()]);
                             break;
                         default:
                             throw new Error("unknown type.");
                     }
                 }
                 clip.addEvent(event);
             }
         }
     }
     /**@private */
     AnimationClipParser03._strings = [];
     /**@private */
     AnimationClipParser03._BLOCK = { count: 0 };
     /**@private */
     AnimationClipParser03._DATA = { offset: 0, size: 0 };

     /**
      * @private
      */
     class AnimationClipParser04 {
         /**
          * @private
          */
         static READ_DATA() {
             AnimationClipParser04._DATA.offset = AnimationClipParser04._reader.getUint32();
             AnimationClipParser04._DATA.size = AnimationClipParser04._reader.getUint32();
         }
         /**
          * @private
          */
         static READ_BLOCK() {
             var count = AnimationClipParser04._BLOCK.count = AnimationClipParser04._reader.getUint16();
             var blockStarts = AnimationClipParser04._BLOCK.blockStarts = [];
             var blockLengths = AnimationClipParser04._BLOCK.blockLengths = [];
             for (var i = 0; i < count; i++) {
                 blockStarts.push(AnimationClipParser04._reader.getUint32());
                 blockLengths.push(AnimationClipParser04._reader.getUint32());
             }
         }
         /**
          * @private
          */
         static READ_STRINGS() {
             var offset = AnimationClipParser04._reader.getUint32();
             var count = AnimationClipParser04._reader.getUint16();
             var prePos = AnimationClipParser04._reader.pos;
             AnimationClipParser04._reader.pos = offset + AnimationClipParser04._DATA.offset;
             for (var i = 0; i < count; i++)
                 AnimationClipParser04._strings[i] = AnimationClipParser04._reader.readUTFString();
             AnimationClipParser04._reader.pos = prePos;
         }
         /**
          * @private
          */
         static parse(clip, reader, version) {
             AnimationClipParser04._animationClip = clip;
             AnimationClipParser04._reader = reader;
             AnimationClipParser04._version = version;
             AnimationClipParser04.READ_DATA();
             AnimationClipParser04.READ_BLOCK();
             AnimationClipParser04.READ_STRINGS();
             for (var i = 0, n = AnimationClipParser04._BLOCK.count; i < n; i++) {
                 var index = reader.getUint16();
                 var blockName = AnimationClipParser04._strings[index];
                 var fn = AnimationClipParser04["READ_" + blockName];
                 if (fn == null)
                     throw new Error("model file err,no this function:" + index + " " + blockName);
                 else
                     fn.call(null);
             }
             AnimationClipParser04._version = null;
             AnimationClipParser04._reader = null;
             AnimationClipParser04._animationClip = null;
         }
         /**
          * @private
          */
         static READ_ANIMATIONS() {
             var i, j;
             var node;
             var reader = AnimationClipParser04._reader;
             var buffer = reader.__getBuffer();
             var startTimeTypes = [];
             var startTimeTypeCount = reader.getUint16();
             startTimeTypes.length = startTimeTypeCount;
             for (i = 0; i < startTimeTypeCount; i++)
                 startTimeTypes[i] = reader.getFloat32();
             var clip = AnimationClipParser04._animationClip;
             clip.name = AnimationClipParser04._strings[reader.getUint16()];
             var clipDur = clip._duration = reader.getFloat32();
             clip.islooping = !!reader.getByte();
             clip._frameRate = reader.getInt16();
             var nodeCount = reader.getInt16();
             var nodes = clip._nodes;
             nodes.count = nodeCount;
             var nodesMap = clip._nodesMap = {};
             var nodesDic = clip._nodesDic = {};
             for (i = 0; i < nodeCount; i++) {
                 node = new KeyframeNode();
                 nodes.setNodeByIndex(i, node);
                 node._indexInList = i;
                 var type = node.type = reader.getUint8();
                 var pathLength = reader.getUint16();
                 node._setOwnerPathCount(pathLength);
                 for (j = 0; j < pathLength; j++)
                     node._setOwnerPathByIndex(j, AnimationClipParser04._strings[reader.getUint16()]); //TODO:如果只有根节点并且为空，是否可以和componentType一样优化。
                 var nodePath = node._joinOwnerPath("/");
                 var mapArray = nodesMap[nodePath];
                 (mapArray) || (nodesMap[nodePath] = mapArray = []);
                 mapArray.push(node);
                 node.propertyOwner = AnimationClipParser04._strings[reader.getUint16()];
                 var propertyLength = reader.getUint16();
                 node._setPropertyCount(propertyLength);
                 for (j = 0; j < propertyLength; j++)
                     node._setPropertyByIndex(j, AnimationClipParser04._strings[reader.getUint16()]);
                 var fullPath = nodePath + "." + node.propertyOwner + "." + node._joinProperty(".");
                 nodesDic[fullPath] = node;
                 node.fullPath = fullPath;
                 var keyframeCount = reader.getUint16();
                 node._setKeyframeCount(keyframeCount);
                 var startTime;
                 switch (type) {
                     case 0:
                         break;
                     case 1:
                     case 3:
                     case 4:
                         node.data = Render.supportWebGLPlusAnimation ? new ConchVector3 : new Vector3();
                         break;
                     case 2:
                         node.data = Render.supportWebGLPlusAnimation ? new ConchQuaternion : new Quaternion();
                         break;
                     default:
                         throw "AnimationClipParser04:unknown type.";
                 }
                 switch (AnimationClipParser04._version) {
                     case "LAYAANIMATION:04":
                         for (j = 0; j < keyframeCount; j++) {
                             switch (type) {
                                 case 0:
                                     var floatKeyframe = new FloatKeyframe();
                                     node._setKeyframeByIndex(j, floatKeyframe);
                                     startTime = floatKeyframe.time = startTimeTypes[reader.getUint16()];
                                     floatKeyframe.inTangent = reader.getFloat32();
                                     floatKeyframe.outTangent = reader.getFloat32();
                                     floatKeyframe.value = reader.getFloat32();
                                     break;
                                 case 1:
                                 case 3:
                                 case 4:
                                     var floatArrayKeyframe = new Vector3Keyframe();
                                     node._setKeyframeByIndex(j, floatArrayKeyframe);
                                     startTime = floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                                     if (Render.supportWebGLPlusAnimation) {
                                         var data = floatArrayKeyframe.data = new Float32Array(3 * 3);
                                         for (var k = 0; k < 3; k++)
                                             data[k] = reader.getFloat32();
                                         for (k = 0; k < 3; k++)
                                             data[3 + k] = reader.getFloat32();
                                         for (k = 0; k < 3; k++)
                                             data[6 + k] = reader.getFloat32();
                                     }
                                     else {
                                         var inTangent = floatArrayKeyframe.inTangent;
                                         var outTangent = floatArrayKeyframe.outTangent;
                                         var value = floatArrayKeyframe.value;
                                         inTangent.x = reader.getFloat32();
                                         inTangent.y = reader.getFloat32();
                                         inTangent.z = reader.getFloat32();
                                         outTangent.x = reader.getFloat32();
                                         outTangent.y = reader.getFloat32();
                                         outTangent.z = reader.getFloat32();
                                         value.x = reader.getFloat32();
                                         value.y = reader.getFloat32();
                                         value.z = reader.getFloat32();
                                     }
                                     break;
                                 case 2:
                                     var quaternionKeyframe = new QuaternionKeyframe();
                                     node._setKeyframeByIndex(j, quaternionKeyframe);
                                     startTime = quaternionKeyframe.time = startTimeTypes[reader.getUint16()];
                                     if (Render.supportWebGLPlusAnimation) {
                                         data = quaternionKeyframe.data = new Float32Array(3 * 4);
                                         for (k = 0; k < 4; k++)
                                             data[k] = reader.getFloat32();
                                         for (k = 0; k < 4; k++)
                                             data[4 + k] = reader.getFloat32();
                                         for (k = 0; k < 4; k++)
                                             data[8 + k] = reader.getFloat32();
                                     }
                                     else {
                                         var inTangentQua = quaternionKeyframe.inTangent;
                                         var outTangentQua = quaternionKeyframe.outTangent;
                                         var valueQua = quaternionKeyframe.value;
                                         inTangentQua.x = reader.getFloat32();
                                         inTangentQua.y = reader.getFloat32();
                                         inTangentQua.z = reader.getFloat32();
                                         inTangentQua.w = reader.getFloat32();
                                         outTangentQua.x = reader.getFloat32();
                                         outTangentQua.y = reader.getFloat32();
                                         outTangentQua.z = reader.getFloat32();
                                         outTangentQua.w = reader.getFloat32();
                                         valueQua.x = reader.getFloat32();
                                         valueQua.y = reader.getFloat32();
                                         valueQua.z = reader.getFloat32();
                                         valueQua.w = reader.getFloat32();
                                     }
                                     break;
                                 default:
                                     throw "AnimationClipParser04:unknown type.";
                             }
                         }
                         break;
                     case "LAYAANIMATION:COMPRESSION_04":
                         for (j = 0; j < keyframeCount; j++) {
                             switch (type) {
                                 case 0:
                                     floatKeyframe = new FloatKeyframe();
                                     node._setKeyframeByIndex(j, floatKeyframe);
                                     startTime = floatKeyframe.time = startTimeTypes[reader.getUint16()];
                                     floatKeyframe.inTangent = HalfFloatUtils.convertToNumber(reader.getUint16());
                                     floatKeyframe.outTangent = HalfFloatUtils.convertToNumber(reader.getUint16());
                                     floatKeyframe.value = HalfFloatUtils.convertToNumber(reader.getUint16());
                                     break;
                                 case 1:
                                 case 3:
                                 case 4:
                                     floatArrayKeyframe = new Vector3Keyframe();
                                     node._setKeyframeByIndex(j, floatArrayKeyframe);
                                     startTime = floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                                     if (Render.supportWebGLPlusAnimation) {
                                         data = floatArrayKeyframe.data = new Float32Array(3 * 3);
                                         for (k = 0; k < 3; k++)
                                             data[k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         for (k = 0; k < 3; k++)
                                             data[3 + k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         for (k = 0; k < 3; k++)
                                             data[6 + k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                     }
                                     else {
                                         inTangent = floatArrayKeyframe.inTangent;
                                         outTangent = floatArrayKeyframe.outTangent;
                                         value = floatArrayKeyframe.value;
                                         inTangent.x = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         inTangent.y = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         inTangent.z = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         outTangent.x = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         outTangent.y = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         outTangent.z = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         value.x = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         value.y = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         value.z = HalfFloatUtils.convertToNumber(reader.getUint16());
                                     }
                                     break;
                                 case 2:
                                     quaternionKeyframe = new QuaternionKeyframe();
                                     node._setKeyframeByIndex(j, quaternionKeyframe);
                                     startTime = quaternionKeyframe.time = startTimeTypes[reader.getUint16()];
                                     if (Render.supportWebGLPlusAnimation) {
                                         data = quaternionKeyframe.data = new Float32Array(3 * 4);
                                         for (k = 0; k < 4; k++)
                                             data[k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         for (k = 0; k < 4; k++)
                                             data[4 + k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         for (k = 0; k < 4; k++)
                                             data[8 + k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                     }
                                     else {
                                         inTangentQua = quaternionKeyframe.inTangent;
                                         outTangentQua = quaternionKeyframe.outTangent;
                                         valueQua = quaternionKeyframe.value;
                                         inTangentQua.x = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         inTangentQua.y = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         inTangentQua.z = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         inTangentQua.w = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         outTangentQua.x = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         outTangentQua.y = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         outTangentQua.z = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         outTangentQua.w = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         valueQua.x = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         valueQua.y = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         valueQua.z = HalfFloatUtils.convertToNumber(reader.getUint16());
                                         valueQua.w = HalfFloatUtils.convertToNumber(reader.getUint16());
                                     }
                                     break;
                                 default:
                                     throw "AnimationClipParser04:unknown type.";
                             }
                         }
                         break;
                 }
             }
             var eventCount = reader.getUint16();
             for (i = 0; i < eventCount; i++) {
                 var event = new AnimationEvent();
                 event.time = Math.min(clipDur, reader.getFloat32()); //TODO:事件时间可能大于动画总时长
                 event.eventName = AnimationClipParser04._strings[reader.getUint16()];
                 var params;
                 var paramCount = reader.getUint16();
                 (paramCount > 0) && (event.params = params = []);
                 for (j = 0; j < paramCount; j++) {
                     var eventType = reader.getByte();
                     switch (eventType) {
                         case 0:
                             params.push(!!reader.getByte());
                             break;
                         case 1:
                             params.push(reader.getInt32());
                             break;
                         case 2:
                             params.push(reader.getFloat32());
                             break;
                         case 3:
                             params.push(AnimationClipParser04._strings[reader.getUint16()]);
                             break;
                         default:
                             throw new Error("unknown type.");
                     }
                 }
                 clip.addEvent(event);
             }
         }
     }
     /**@private */
     AnimationClipParser04._strings = [];
     /**@private */
     AnimationClipParser04._BLOCK = { count: 0 };
     /**@private */
     AnimationClipParser04._DATA = { offset: 0, size: 0 };

     /**
      * <code>KeyframeNodeList</code> 类用于创建KeyframeNode节点队列。
      */
     class KeyframeNodeList {
         /**
          * 创建一个 <code>KeyframeNodeList</code> 实例。
          */
         constructor() {
             /**@private */
             this._nodes = [];
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
         }
         /**
          *	获取节点个数。
          * @return 节点个数。
          */
         get count() {
             return this._nodes.length;
         }
         /**
          * 设置节点个数。
          * @param value 节点个数。
          */
         set count(value) {
             this._nodes.length = value;
         }
         /**
          * 通过索引获取节点。
          * @param	index 索引。
          * @return 节点。
          */
         getNodeByIndex(index) {
             return this._nodes[index];
         }
         /**
          * 通过索引设置节点。
          * @param	index 索引。
          * @param 节点。
          */
         setNodeByIndex(index, node) {
             this._nodes[index] = node;
         }
     }

     /**
      * <code>AnimationClip</code> 类用于动画片段资源。
      */
     class AnimationClip extends Resource {
         /**
          * 创建一个 <code>AnimationClip</code> 实例。
          */
         constructor() {
             super();
             /**@private */
             this._nodes = new KeyframeNodeList();
             this._animationEvents = [];
         }
         /**
          * @inheritDoc
          */
         static _parse(data, propertyParams = null, constructParams = null) {
             var clip = new AnimationClip();
             var reader = new Byte(data);
             var version = reader.readUTFString();
             switch (version) {
                 case "LAYAANIMATION:03":
                     AnimationClipParser03.parse(clip, reader);
                     break;
                 case "LAYAANIMATION:04":
                 case "LAYAANIMATION:COMPRESSION_04":
                     AnimationClipParser04.parse(clip, reader, version);
                     break;
                 default:
                     throw "unknown animationClip version.";
             }
             return clip;
         }
         /**
          * 加载动画片段。
          * @param url 动画片段地址。
          * @param complete  完成回掉。
          */
         static load(url, complete) {
             Laya.loader.create(url, complete, null, AnimationClip.ANIMATIONCLIP);
         }
         /**
          * 获取动画片段时长。
          */
         duration() {
             return this._duration;
         }
         /**
          * @private
          */
         _hermiteInterpolate(frame, nextFrame, t, dur) {
             var t0 = frame.outTangent, t1 = nextFrame.inTangent;
             if (Number.isFinite(t0) && Number.isFinite(t1)) {
                 var t2 = t * t;
                 var t3 = t2 * t;
                 var a = 2.0 * t3 - 3.0 * t2 + 1.0;
                 var b = t3 - 2.0 * t2 + t;
                 var c = t3 - t2;
                 var d = -2.0 * t3 + 3.0 * t2;
                 return a * frame.value + b * t0 * dur + c * t1 * dur + d * nextFrame.value;
             }
             else
                 return frame.value;
         }
         /**
          * @private
          */
         _hermiteInterpolateVector3(frame, nextFrame, t, dur, out) {
             var p0 = frame.value;
             var tan0 = frame.outTangent;
             var p1 = nextFrame.value;
             var tan1 = nextFrame.inTangent;
             var t2 = t * t;
             var t3 = t2 * t;
             var a = 2.0 * t3 - 3.0 * t2 + 1.0;
             var b = t3 - 2.0 * t2 + t;
             var c = t3 - t2;
             var d = -2.0 * t3 + 3.0 * t2;
             var t0 = tan0.x, t1 = tan1.x;
             if (Number.isFinite(t0) && Number.isFinite(t1))
                 out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
             else
                 out.x = p0.x;
             t0 = tan0.y, t1 = tan1.y;
             if (Number.isFinite(t0) && Number.isFinite(t1))
                 out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
             else
                 out.y = p0.y;
             t0 = tan0.z, t1 = tan1.z;
             if (Number.isFinite(t0) && Number.isFinite(t1))
                 out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
             else
                 out.z = p0.z;
         }
         /**
          * @private
          */
         _hermiteInterpolateQuaternion(frame, nextFrame, t, dur, out) {
             var p0 = frame.value;
             var tan0 = frame.outTangent;
             var p1 = nextFrame.value;
             var tan1 = nextFrame.inTangent;
             var t2 = t * t;
             var t3 = t2 * t;
             var a = 2.0 * t3 - 3.0 * t2 + 1.0;
             var b = t3 - 2.0 * t2 + t;
             var c = t3 - t2;
             var d = -2.0 * t3 + 3.0 * t2;
             var t0 = tan0.x, t1 = tan1.x;
             if (Number.isFinite(t0) && Number.isFinite(t1))
                 out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
             else
                 out.x = p0.x;
             t0 = tan0.y, t1 = tan1.y;
             if (Number.isFinite(t0) && Number.isFinite(t1))
                 out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
             else
                 out.y = p0.y;
             t0 = tan0.z, t1 = tan1.z;
             if (Number.isFinite(t0) && Number.isFinite(t1))
                 out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
             else
                 out.z = p0.z;
             t0 = tan0.w, t1 = tan1.w;
             if (Number.isFinite(t0) && Number.isFinite(t1))
                 out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
             else
                 out.w = p0.w;
         }
         /**
          * @private
          */
         _evaluateClipDatasRealTime(nodes, playCurTime, realTimeCurrentFrameIndexes, addtive, frontPlay) {
             for (var i = 0, n = nodes.count; i < n; i++) {
                 var node = nodes.getNodeByIndex(i);
                 var type = node.type;
                 var nextFrameIndex;
                 var keyFrames = node._keyFrames;
                 var keyFramesCount = keyFrames.length;
                 var frameIndex = realTimeCurrentFrameIndexes[i];
                 if (frontPlay) {
                     if ((frameIndex !== -1) && (playCurTime < keyFrames[frameIndex].time)) { //重置正向循环
                         frameIndex = -1;
                         realTimeCurrentFrameIndexes[i] = frameIndex;
                     }
                     nextFrameIndex = frameIndex + 1;
                     while (nextFrameIndex < keyFramesCount) {
                         if (keyFrames[nextFrameIndex].time > playCurTime)
                             break;
                         frameIndex++;
                         nextFrameIndex++;
                         realTimeCurrentFrameIndexes[i] = frameIndex;
                     }
                 }
                 else {
                     nextFrameIndex = frameIndex + 1;
                     if ((nextFrameIndex !== keyFramesCount) && (playCurTime > keyFrames[nextFrameIndex].time)) { //重置逆向循环
                         frameIndex = keyFramesCount - 1;
                         realTimeCurrentFrameIndexes[i] = frameIndex;
                     }
                     nextFrameIndex = frameIndex + 1;
                     while (frameIndex > -1) {
                         if (keyFrames[frameIndex].time < playCurTime)
                             break;
                         frameIndex--;
                         nextFrameIndex--;
                         realTimeCurrentFrameIndexes[i] = frameIndex;
                     }
                 }
                 var isEnd = nextFrameIndex === keyFramesCount;
                 switch (type) {
                     case 0:
                         if (frameIndex !== -1) {
                             var frame = keyFrames[frameIndex];
                             if (isEnd) { //如果nextFarme为空，不修改数据，保持上一帧
                                 node.data = frame.value;
                             }
                             else {
                                 var nextFarme = keyFrames[nextFrameIndex];
                                 var d = nextFarme.time - frame.time;
                                 var t;
                                 if (d !== 0)
                                     t = (playCurTime - frame.time) / d;
                                 else
                                     t = 0;
                                 node.data = this._hermiteInterpolate(frame, nextFarme, t, d);
                             }
                         }
                         else {
                             node.data = keyFrames[0].value;
                         }
                         if (addtive)
                             node.data -= keyFrames[0].value;
                         break;
                     case 1:
                     case 4:
                         var clipData = node.data;
                         this._evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipData);
                         if (addtive) {
                             var firstFrameValue = keyFrames[0].value;
                             clipData.x -= firstFrameValue.x;
                             clipData.y -= firstFrameValue.y;
                             clipData.z -= firstFrameValue.z;
                         }
                         break;
                     case 2:
                         var clipQuat = node.data;
                         this._evaluateFrameNodeQuaternionDatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipQuat);
                         if (addtive) {
                             var tempQuat = AnimationClip._tempQuaternion0;
                             var firstFrameValueQua = keyFrames[0].value;
                             Utils3D.quaternionConjugate(firstFrameValueQua, tempQuat);
                             Quaternion.multiply(tempQuat, clipQuat, clipQuat);
                         }
                         break;
                     case 3:
                         clipData = node.data;
                         this._evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipData);
                         if (addtive) {
                             firstFrameValue = keyFrames[0].value;
                             clipData.x /= firstFrameValue.x;
                             clipData.y /= firstFrameValue.y;
                             clipData.z /= firstFrameValue.z;
                         }
                         break;
                     default:
                         throw "AnimationClip:unknown node type.";
                 }
             }
         }
         _evaluateClipDatasRealTimeForNative(nodes, playCurTime, realTimeCurrentFrameIndexes, addtive) {
             LayaGL.instance.evaluateClipDatasRealTime(nodes._nativeObj, playCurTime, realTimeCurrentFrameIndexes, addtive);
         }
         /**
          * @private
          */
         _evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
             if (frameIndex !== -1) {
                 var frame = keyFrames[frameIndex];
                 if (isEnd) {
                     var frameData = frame.value;
                     outDatas.x = frameData.x; //不能设为null，会造成跳过当前帧数据
                     outDatas.y = frameData.y;
                     outDatas.z = frameData.z;
                 }
                 else {
                     var nextKeyFrame = keyFrames[frameIndex + 1];
                     var t;
                     var startTime = frame.time;
                     var d = nextKeyFrame.time - startTime;
                     if (d !== 0)
                         t = (playCurTime - startTime) / d;
                     else
                         t = 0;
                     this._hermiteInterpolateVector3(frame, nextKeyFrame, t, d, outDatas);
                 }
             }
             else {
                 var firstFrameDatas = keyFrames[0].value;
                 outDatas.x = firstFrameDatas.x;
                 outDatas.y = firstFrameDatas.y;
                 outDatas.z = firstFrameDatas.z;
             }
         }
         /**
          * @private
          */
         _evaluateFrameNodeQuaternionDatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
             if (frameIndex !== -1) {
                 var frame = keyFrames[frameIndex];
                 if (isEnd) {
                     var frameData = frame.value;
                     outDatas.x = frameData.x; //不能设为null，会造成跳过当前帧数据
                     outDatas.y = frameData.y;
                     outDatas.z = frameData.z;
                     outDatas.w = frameData.w;
                 }
                 else {
                     var nextKeyFrame = keyFrames[frameIndex + 1];
                     var t;
                     var startTime = frame.time;
                     var d = nextKeyFrame.time - startTime;
                     if (d !== 0)
                         t = (playCurTime - startTime) / d;
                     else
                         t = 0;
                     this._hermiteInterpolateQuaternion(frame, nextKeyFrame, t, d, outDatas);
                 }
             }
             else {
                 var firstFrameDatas = keyFrames[0].value;
                 outDatas.x = firstFrameDatas.x;
                 outDatas.y = firstFrameDatas.y;
                 outDatas.z = firstFrameDatas.z;
                 outDatas.w = firstFrameDatas.w;
             }
         }
         /**
          * @private
          */
         _binarySearchEventIndex(time) {
             var start = 0;
             var end = this._animationEvents.length - 1;
             var mid;
             while (start <= end) {
                 mid = Math.floor((start + end) / 2);
                 var midValue = this._animationEvents[mid].time;
                 if (midValue == time)
                     return mid;
                 else if (midValue > time)
                     end = mid - 1;
                 else
                     start = mid + 1;
             }
             return start;
         }
         /**
          * 添加动画事件。
          */
         addEvent(event) {
             var index = this._binarySearchEventIndex(event.time);
             this._animationEvents.splice(index, 0, event);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _disposeResource() {
             this._nodes = null;
             this._nodesMap = null;
         }
     }
     /**AnimationClip资源。*/
     AnimationClip.ANIMATIONCLIP = "ANIMATIONCLIP";
     /**@private	*/
     AnimationClip._tempQuaternion0 = new Quaternion();

     /**
      * <code>AnimationTransform3D</code> 类用于实现3D变换。
      */
     class AnimationTransform3D extends EventDispatcher {
         /**
          * 创建一个 <code>Transform3D</code> 实例。
          * @param owner 所属精灵。
          */
         constructor(owner, localPosition = null /*[NATIVE]*/, localRotation = null /*[NATIVE]*/, localScale = null /*[NATIVE]*/, worldMatrix = null /*[NATIVE]*/) {
             super();
             this._owner = owner;
             this._children = [];
             this._localMatrix = new Float32Array(16);
             if (Render.supportWebGLPlusAnimation) {
                 /*
                 _localPosition = new Vector3(0,0,0);
                 _localPosition.forNativeElement(localPosition);
                 _localRotation = new Quaternion(0,0,0,1);
                 _localRotation.forNativeElement(localRotation);
                 _localScale = new Vector3(0,0,0);
                 _localScale.forNativeElement(localScale);
                 _worldMatrix = worldMatrix;
                 */
                 this._localPosition = new ConchVector3(0, 0, 0, localPosition);
                 this._localRotation = new ConchQuaternion(0, 0, 0, 1, localRotation);
                 this._localScale = new ConchVector3(0, 0, 0, localScale);
                 this._worldMatrix = worldMatrix;
             }
             else {
                 this._localPosition = new Vector3();
                 this._localRotation = new Quaternion();
                 this._localScale = new Vector3();
                 this._worldMatrix = new Float32Array(16);
             }
             this._localQuaternionUpdate = false;
             this._locaEulerlUpdate = false;
             this._localUpdate = false;
             this._worldUpdate = true;
         }
         /**
          * @private
          */
         _getlocalMatrix() {
             if (this._localUpdate) {
                 Utils3D._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix);
                 this._localUpdate = false;
             }
             return this._localMatrix;
         }
         /**
          * @private
          */
         _onWorldTransform() {
             if (!this._worldUpdate) {
                 this._worldUpdate = true;
                 this.event(Event.TRANSFORM_CHANGED);
                 for (var i = 0, n = this._children.length; i < n; i++)
                     this._children[i]._onWorldTransform();
             }
         }
         /**
          * @private
          */
         get localPosition() {
             return this._localPosition;
         }
         /**
          * @private
          */
         set localPosition(value) {
             this._localPosition = value;
             this._localUpdate = true;
             this._onWorldTransform();
         }
         /**
          * @private
          */
         get localRotation() {
             if (this._localQuaternionUpdate) {
                 var euler = this._localRotationEuler;
                 Quaternion.createFromYawPitchRoll(euler.y / AnimationTransform3D._angleToRandin, euler.x / AnimationTransform3D._angleToRandin, euler.z / AnimationTransform3D._angleToRandin, this._localRotation);
                 this._localQuaternionUpdate = false;
             }
             return this._localRotation;
         }
         /*
          * @private
          */
         set localRotation(value) {
             this._localRotation = value;
             //Utils3D.quaterionNormalize(_localRotation, _localRotation);
             this._locaEulerlUpdate = true;
             this._localQuaternionUpdate = false;
             this._localUpdate = true;
             this._onWorldTransform();
         }
         /**
          * @private
          */
         get localScale() {
             return this._localScale;
         }
         /**
          * @private
          */
         set localScale(value) {
             this._localScale = value;
             this._localUpdate = true;
             this._onWorldTransform();
         }
         /**
          * @private
          */
         get localRotationEuler() {
             if (this._locaEulerlUpdate) {
                 this._localRotation.getYawPitchRoll(AnimationTransform3D._tempVector3);
                 var euler = AnimationTransform3D._tempVector3;
                 var localRotationEuler = this._localRotationEuler;
                 localRotationEuler.x = euler.y * AnimationTransform3D._angleToRandin;
                 localRotationEuler.y = euler.x * AnimationTransform3D._angleToRandin;
                 localRotationEuler.z = euler.z * AnimationTransform3D._angleToRandin;
                 this._locaEulerlUpdate = false;
             }
             return this._localRotationEuler;
         }
         /**
          * @private
          */
         set localRotationEuler(value) {
             this._localRotationEuler = value;
             this._locaEulerlUpdate = false;
             this._localQuaternionUpdate = true;
             this._localUpdate = true;
             this._onWorldTransform();
         }
         /**
          * 获取世界矩阵。
          * @return	世界矩阵。
          */
         getWorldMatrix() {
             if (!Render.supportWebGLPlusAnimation && this._worldUpdate) {
                 if (this._parent != null) {
                     Utils3D.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix);
                 }
                 else {
                     var e = this._worldMatrix; //根节点的世界矩阵始终为单位矩阵。需使用Animator中的矩阵,否则移动Animator精灵无效
                     e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0;
                     e[0] = e[5] = e[10] = e[15] = 1;
                 }
                 this._worldUpdate = false;
             }
             if (Render.supportWebGLPlusAnimation && this._worldUpdate) {
                 this._worldUpdate = false;
             }
             return this._worldMatrix;
         }
         /**
          * 设置父3D变换。
          * @param	value 父3D变换。
          */
         setParent(value) {
             if (this._parent !== value) {
                 if (this._parent) {
                     var parentChilds = this._parent._children;
                     var index = parentChilds.indexOf(this);
                     parentChilds.splice(index, 1);
                 }
                 if (value) {
                     value._children.push(this);
                     (value) && (this._onWorldTransform());
                 }
                 this._parent = value;
             }
         }
     }
     /**@private */
     AnimationTransform3D._tempVector3 = new Vector3();
     /**@private */
     AnimationTransform3D._angleToRandin = 180 / Math.PI;

     /**
      * <code>BoneNode</code> 类用于实现骨骼节点。
      */
     class AnimationNode {
         /**
          * 创建一个新的 <code>AnimationNode</code> 实例。
          */
         constructor(localPosition = null /*[NATIVE]*/, localRotation = null /*[NATIVE]*/, localScale = null /*[NATIVE]*/, worldMatrix = null /*[NATIVE]*/) {
             this._children = [];
             this.transform = new AnimationTransform3D(this, localPosition, localRotation, localScale, worldMatrix);
         }
         /**
          * 添加子节点。
          * @param	child  子节点。
          */
         addChild(child) {
             child._parent = this;
             child.transform.setParent(this.transform);
             this._children.push(child);
         }
         /**
          * 移除子节点。
          * @param	child 子节点。
          */
         removeChild(child) {
             var index = this._children.indexOf(child);
             (index !== -1) && (this._children.splice(index, 1));
         }
         /**
          * 根据名字获取子节点。
          * @param	name 名字。
          */
         getChildByName(name) {
             for (var i = 0, n = this._children.length; i < n; i++) {
                 var child = this._children[i];
                 if (child.name === name)
                     return child;
             }
             return null;
         }
         /**
          * 根据索引获取子节点。
          * @param	index 索引。
          */
         getChildByIndex(index) {
             return this._children[index];
         }
         /**
          * 获取子节点的个数。
          */
         getChildCount() {
             return this._children.length;
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destNode = destObject;
             destNode.name = this.name;
             for (var i = 0, n = this._children.length; i < n; i++) {
                 var child = this._children[i];
                 var destChild = child.clone();
                 destNode.addChild(destChild);
                 var transform = child.transform;
                 var destTransform = destChild.transform;
                 var destLocalPosition = destTransform.localPosition;
                 var destLocalRotation = destTransform.localRotation;
                 var destLocalScale = destTransform.localScale;
                 transform.localPosition.cloneTo(destLocalPosition);
                 transform.localRotation.cloneTo(destLocalRotation);
                 transform.localScale.cloneTo(destLocalScale);
                 destTransform.localPosition = destLocalPosition; //深拷贝
                 destTransform.localRotation = destLocalRotation; //深拷贝
                 destTransform.localScale = destLocalScale; //深拷贝
             }
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new AnimationNode();
             this.cloneTo(dest);
             return dest;
         }
         /**
          * @private [NATIVE]
          */
         _cloneNative(localPositions, localRotations, localScales, animationNodeWorldMatrixs, animationNodeParentIndices, parentIndex, avatar) {
             var curID = avatar._nativeCurCloneCount;
             animationNodeParentIndices[curID] = parentIndex;
             var localPosition = new Float32Array(localPositions.buffer, curID * 3 * 4, 3);
             var localRotation = new Float32Array(localRotations.buffer, curID * 4 * 4, 4);
             var localScale = new Float32Array(localScales.buffer, curID * 3 * 4, 3);
             var worldMatrix = new Float32Array(animationNodeWorldMatrixs.buffer, curID * 16 * 4, 16);
             var dest = new AnimationNode(localPosition, localRotation, localScale, worldMatrix);
             dest._worldMatrixIndex = curID;
             this._cloneToNative(dest, localPositions, localRotations, localScales, animationNodeWorldMatrixs, animationNodeParentIndices, curID, avatar);
             return dest;
         }
         /**
          * @private [NATIVE]
          */
         _cloneToNative(destObject, localPositions, localRotations, localScales, animationNodeWorldMatrixs, animationNodeParentIndices, parentIndex, avatar) {
             var destNode = destObject;
             destNode.name = this.name;
             for (var i = 0, n = this._children.length; i < n; i++) {
                 var child = this._children[i];
                 avatar._nativeCurCloneCount++;
                 var destChild = child._cloneNative(localPositions, localRotations, localScales, animationNodeWorldMatrixs, animationNodeParentIndices, parentIndex, avatar);
                 destNode.addChild(destChild);
                 var transform = child.transform;
                 var destTransform = destChild.transform;
                 var destLocalPosition = destTransform.localPosition;
                 var destLocalRotation = destTransform.localRotation;
                 var destLocalScale = destTransform.localScale;
                 transform.localPosition.cloneTo(destLocalPosition);
                 transform.localRotation.cloneTo(destLocalRotation);
                 transform.localScale.cloneTo(destLocalScale);
                 destTransform.localPosition = destLocalPosition; //深拷贝
                 destTransform.localRotation = destLocalRotation; //深拷贝
                 destTransform.localScale = destLocalScale; //深拷贝
             }
         }
     }

     /**
      * <code>Avatar</code> 类用于创建Avatar。
      */
     class Avatar extends Resource {
         /**
          * 创建一个 <code>Avatar</code> 实例。
          */
         constructor() {
             super();
             /**@private [NATIVE]*/
             this._nativeNodeCount = 0;
             /**@private [NATIVE]*/
             this._nativeCurCloneCount = 0;
         }
         /**
          * @inheritDoc
          */
         static _parse(data, propertyParams = null, constructParams = null) {
             var avatar = new Avatar();
             avatar._rootNode = new AnimationNode(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)); //[NATIVE],需要优化
             if (Render.supportWebGLPlusAnimation)
                 avatar._nativeNodeCount++; //[NATIVE]
             if (data.version) {
                 var rootNode = data.rootNode;
                 (rootNode) && (avatar._parseNode(rootNode, avatar._rootNode));
             }
             return avatar;
         }
         /**
          * 加载Avatar文件。
          * @param url Avatar文件。
          * @param complete 完成回掉。
          */
         static load(url, complete) {
             Laya.loader.create(url, complete, null, Avatar.AVATAR);
         }
         /**
          * @private
          */
         _initCloneToAnimator(destNode, destAnimator) {
             destAnimator._avatarNodeMap[destNode.name] = destNode;
             for (var i = 0, n = destNode.getChildCount(); i < n; i++)
                 this._initCloneToAnimator(destNode.getChildByIndex(i), destAnimator);
         }
         /**
          * @private
          */
         _parseNode(nodaData, node) {
             var name = nodaData.props.name;
             node.name = name;
             var props = nodaData.props;
             var transform = node.transform;
             var pos = transform.localPosition;
             var rot = transform.localRotation;
             var sca = transform.localScale;
             pos.fromArray(props.translate);
             rot.fromArray(props.rotation);
             sca.fromArray(props.scale);
             transform.localPosition = pos;
             transform.localRotation = rot;
             transform.localScale = sca;
             var childrenData = nodaData.child;
             for (var j = 0, n = childrenData.length; j < n; j++) {
                 var childData = childrenData[j];
                 var childBone = new AnimationNode(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)); //[NATIVE],需要优化
                 node.addChild(childBone);
                 if (Render.supportWebGLPlusAnimation)
                     this._nativeNodeCount++; //[NATIVE]
                 this._parseNode(childData, childBone);
             }
         }
         /**
          * 克隆数据到Avatr。
          * @param	destObject 克隆源。
          */
         _cloneDatasToAnimator(destAnimator) {
             var destRoot;
             destRoot = this._rootNode.clone();
             var transform = this._rootNode.transform;
             var destTransform = destRoot.transform;
             var destPosition = destTransform.localPosition;
             var destRotation = destTransform.localRotation;
             var destScale = destTransform.localScale;
             transform.localPosition.cloneTo(destPosition);
             transform.localRotation.cloneTo(destRotation);
             transform.localScale.cloneTo(destScale);
             destTransform.localPosition = destPosition; //深拷贝
             destTransform.localRotation = destRotation; //深拷贝
             destTransform.localScale = destScale; //深拷贝
             destAnimator._avatarNodeMap = {};
             this._initCloneToAnimator(destRoot, destAnimator);
         }
         /**
          * 克隆。
          * @param	destObject 克隆源。
          */
         cloneTo(destObject) {
             var destAvatar = destObject;
             var destRoot = this._rootNode.clone();
             destAvatar._rootNode = destRoot;
         }
         /**
          * 克隆。
          * @return	 克隆副本。
          */
         clone() {
             var dest = new Avatar();
             this.cloneTo(dest);
             return dest;
         }
         /**
          * @private [NATIVE]
          */
         _cloneDatasToAnimatorNative(destAnimator) {
             var animationNodeLocalPositions = new Float32Array(this._nativeNodeCount * 3);
             var animationNodeLocalRotations = new Float32Array(this._nativeNodeCount * 4);
             var animationNodeLocalScales = new Float32Array(this._nativeNodeCount * 3);
             var animationNodeWorldMatrixs = new Float32Array(this._nativeNodeCount * 16);
             var animationNodeParentIndices = new Int16Array(this._nativeNodeCount);
             destAnimator._animationNodeLocalPositions = animationNodeLocalPositions;
             destAnimator._animationNodeLocalRotations = animationNodeLocalRotations;
             destAnimator._animationNodeLocalScales = animationNodeLocalScales;
             destAnimator._animationNodeWorldMatrixs = animationNodeWorldMatrixs;
             destAnimator._animationNodeParentIndices = animationNodeParentIndices;
             this._nativeCurCloneCount = 0;
             var destRoot = this._rootNode._cloneNative(animationNodeLocalPositions, animationNodeLocalRotations, animationNodeLocalScales, animationNodeWorldMatrixs, animationNodeParentIndices, -1, this);
             var transform = this._rootNode.transform;
             var destTransform = destRoot.transform;
             var destPosition = destTransform.localPosition;
             var destRotation = destTransform.localRotation;
             var destScale = destTransform.localScale;
             transform.localPosition.cloneTo(destPosition);
             transform.localRotation.cloneTo(destRotation);
             transform.localScale.cloneTo(destScale);
             destTransform.localPosition = destPosition; //深拷贝
             destTransform.localRotation = destRotation; //深拷贝
             destTransform.localScale = destScale; //深拷贝
             destAnimator._avatarNodeMap = {};
             this._initCloneToAnimator(destRoot, destAnimator);
         }
     }
     /**Avatar资源。*/
     Avatar.AVATAR = "AVATAR";

     /**
      * <code>SkyBoxMaterial</code> 类用于实现SkyBoxMaterial材质。
      */
     class SkyBoxMaterial extends BaseMaterial {
         /**
          * 创建一个 <code>SkyBoxMaterial</code> 实例。
          */
         constructor() {
             /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
             super();
             this.setShaderName("SkyBox");
         }
         /**
         * @private
         */
         static __initDefine__() {
         }
         /**
          * 获取颜色。
          * @return  颜色。
          */
         get tintColor() {
             return this._shaderValues.getVector(SkyBoxMaterial.TINTCOLOR);
         }
         /**
          * 设置颜色。
          * @param value 颜色。
          */
         set tintColor(value) {
             this._shaderValues.setVector(SkyBoxMaterial.TINTCOLOR, value);
         }
         /**
          * 获取曝光强度。
          * @return 曝光强度。
          */
         get exposure() {
             return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE);
         }
         /**
          * 设置曝光强度。
          * @param value 曝光强度。
          */
         set exposure(value) {
             this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE, value);
         }
         /**
          * 获取曝光强度。
          * @return 曝光强度。
          */
         get rotation() {
             return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION);
         }
         /**
          * 设置曝光强度。
          * @param value 曝光强度。
          */
         set rotation(value) {
             this._shaderValues.setNumber(SkyBoxMaterial.ROTATION, value);
         }
         /**
          * 获取天空盒纹理。
          */
         get textureCube() {
             return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE);
         }
         /**
          * 设置天空盒纹理。
          */
         set textureCube(value) {
             this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE, value);
         }
         /**
      * 克隆。
      * @return	 克隆副本。
      */
         clone() {
             var dest = new SkyBoxMaterial();
             this.cloneTo(dest);
             return dest;
         }
     }
     SkyBoxMaterial.TINTCOLOR = Shader3D.propertyNameToID("u_TintColor");
     SkyBoxMaterial.EXPOSURE = Shader3D.propertyNameToID("u_Exposure");
     SkyBoxMaterial.ROTATION = Shader3D.propertyNameToID("u_Rotation");
     SkyBoxMaterial.TEXTURECUBE = Shader3D.propertyNameToID("u_CubeTexture");

     /**
      * <code>TextureCube</code> 类用于生成立方体纹理。
      */
     class TextureCube extends BaseTexture {
         /**
          * 创建一个 <code>TextureCube</code> 实例。
          * @param	format 贴图格式。
          * @param	mipmap 是否生成mipmap。
          */
         constructor(format = BaseTexture.FORMAT_R8G8B8, mipmap = false) {
             super(format, mipmap);
             this._glTextureType = WebGLContext.TEXTURE_CUBE_MAP;
         }
         /**
          * @private
          */
         static __init__() {
             var pixels = new Uint8Array(3);
             pixels[0] = 128;
             pixels[1] = 128;
             pixels[2] = 128;
             TextureCube.grayTexture = new TextureCube(BaseTexture.FORMAT_R8G8B8, false);
             TextureCube.grayTexture.setSixSidePixels(1, 1, [pixels, pixels, pixels, pixels, pixels, pixels]);
             TextureCube.grayTexture.lock = true; //锁住资源防止被资源管理释放
         }
         /**
          * @inheritDoc
          */
         static _parse(data, propertyParams = null, constructParams = null) {
             var texture = constructParams ? new TextureCube(constructParams[0], constructParams[1]) : new TextureCube();
             texture.setSixSideImageSources(data);
             return texture;
         }
         /**
          * 加载TextureCube。
          * @param url TextureCube地址。
          * @param complete 完成回调。
          */
         static load(url, complete) {
             Laya.loader.create(url, complete, null, TextureCube.TEXTURECUBE);
         }
         /**
          * @inheritDoc
          */
         /*override*/ get defaulteTexture() {
             return TextureCube.grayTexture;
         }
         /**
          * 通过六张图片源填充纹理。
          * @param 图片源数组。
          */
         setSixSideImageSources(source, premultiplyAlpha = false) {
             var width;
             var height;
             for (var i = 0; i < 6; i++) {
                 var img = source[i];
                 if (!img) { //TODO:
                     console.log("TextureCube: image Source can't be null.");
                     return;
                 }
                 var nextWidth = img.width;
                 var nextHeight = img.height;
                 if (i > 0) {
                     if (width !== nextWidth) {
                         console.log("TextureCube: each side image's width and height must same.");
                         return;
                     }
                 }
                 width = nextWidth;
                 height = nextHeight;
                 if (width !== height) {
                     console.log("TextureCube: each side image's width and height must same.");
                     return;
                 }
             }
             this._width = width;
             this._height = height;
             var gl = LayaGL.instance;
             WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
             var glFormat = this._getGLFormat();
             if (!Render.isConchApp) {
                 (premultiplyAlpha) && (gl.pixelStorei(WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true));
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFormat, glFormat, WebGLContext.UNSIGNED_BYTE, source[0]); //back
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFormat, glFormat, WebGLContext.UNSIGNED_BYTE, source[1]); //front
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFormat, glFormat, WebGLContext.UNSIGNED_BYTE, source[2]); //right
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFormat, glFormat, WebGLContext.UNSIGNED_BYTE, source[3]); //left
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFormat, glFormat, WebGLContext.UNSIGNED_BYTE, source[4]); //up
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFormat, glFormat, WebGLContext.UNSIGNED_BYTE, source[5]); //down
                 (premultiplyAlpha) && (gl.pixelStorei(WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false));
             }
             else {
                 if (premultiplyAlpha == true) {
                     for (var j = 0; j < 6; j++)
                         source[j].setPremultiplyAlpha(premultiplyAlpha);
                 }
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, WebGLContext.RGBA, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, source[0]); //back
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, WebGLContext.RGBA, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, source[1]); //front
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X, 0, WebGLContext.RGBA, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, source[2]); //right
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, WebGLContext.RGBA, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, source[3]); //left
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, WebGLContext.RGBA, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, source[4]); //up
                 gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, WebGLContext.RGBA, WebGLContext.RGBA, WebGLContext.UNSIGNED_BYTE, source[5]); //down
             }
             if (this._mipmap && this._isPot(width) && this._isPot(height)) {
                 gl.generateMipmap(this._glTextureType);
                 this._setGPUMemory(width * height * 4 * (1 + 1 / 3) * 6);
             }
             else {
                 this._setGPUMemory(width * height * 4 * 6);
             }
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_S, this._wrapModeU);
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_T, this._wrapModeV);
             this._setFilterMode(this._filterMode);
             this._readyed = true;
             this._activeResource();
         }
         /**
          * 通过六张图片源填充纹理。
          * @param 图片源数组。
          */
         setSixSidePixels(width, height, pixels) {
             if (width <= 0 || height <= 0)
                 throw new Error("TextureCube:width or height must large than 0.");
             if (!pixels)
                 throw new Error("TextureCube:pixels can't be null.");
             this._width = width;
             this._height = height;
             var gl = LayaGL.instance;
             WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
             var glFormat = this._getGLFormat();
             gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFormat, width, height, 0, glFormat, WebGLContext.UNSIGNED_BYTE, pixels[0]); //back
             gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFormat, width, height, 0, glFormat, WebGLContext.UNSIGNED_BYTE, pixels[1]); //front
             gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFormat, width, height, 0, glFormat, WebGLContext.UNSIGNED_BYTE, pixels[2]); //right
             gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFormat, width, height, 0, glFormat, WebGLContext.UNSIGNED_BYTE, pixels[3]); //left
             gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFormat, width, height, 0, glFormat, WebGLContext.UNSIGNED_BYTE, pixels[4]); //up
             gl.texImage2D(WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFormat, width, height, 0, glFormat, WebGLContext.UNSIGNED_BYTE, pixels[5]); //down
             if (this._mipmap && this._isPot(width) && this._isPot(height)) {
                 gl.generateMipmap(this._glTextureType);
                 this._setGPUMemory(width * height * 4 * (1 + 1 / 3) * 6);
             }
             else {
                 this._setGPUMemory(width * height * 4 * 6);
             }
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_S, this._wrapModeU);
             this._setWarpMode(WebGLContext.TEXTURE_WRAP_T, this._wrapModeV);
             this._setFilterMode(this._filterMode);
             this._readyed = true;
             this._activeResource();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _recoverResource() {
             //TODO:补充
         }
     }
     /**TextureCube资源。*/
     TextureCube.TEXTURECUBE = "TEXTURECUBE";

     /**
      * <code>PhysicsTriggerComponent</code> 类用于创建物理触发器组件。
      */
     class PhysicsTriggerComponent extends PhysicsComponent {
         /**
          * 创建一个 <code>PhysicsTriggerComponent</code> 实例。
          * @param collisionGroup 所属碰撞组。
          * @param canCollideWith 可产生碰撞的碰撞组。
          */
         constructor(collisionGroup, canCollideWith) {
             super(collisionGroup, canCollideWith);
             /** @private */
             this._isTrigger = false;
         }
         /**
          * 获取是否为触发器。
          * @return 是否为触发器。
          */
         get isTrigger() {
             return this._isTrigger;
         }
         /**
          * 设置是否为触发器。
          * @param value 是否为触发器。
          */
         set isTrigger(value) {
             this._isTrigger = value;
             if (this._nativeColliderObject) {
                 var flags = this._nativeColliderObject.getCollisionFlags();
                 if (value) {
                     if ((flags & PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE) === 0)
                         this._nativeColliderObject.setCollisionFlags(flags | PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
                 }
                 else {
                     if ((flags & PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE) !== 0)
                         this._nativeColliderObject.setCollisionFlags(flags ^ PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
                 }
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onAdded() {
             super._onAdded();
             this.isTrigger = this._isTrigger;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _cloneTo(dest) {
             super._cloneTo(dest);
             dest.isTrigger = this._isTrigger;
         }
     }

     /**
      * <code>PhysicsCollider</code> 类用于创建物理碰撞器。
      */
     class PhysicsCollider extends PhysicsTriggerComponent {
         /**
          * 创建一个 <code>PhysicsCollider</code> 实例。
          * @param collisionGroup 所属碰撞组。
          * @param canCollideWith 可产生碰撞的碰撞组。
          */
         constructor(collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
             super(collisionGroup, canCollideWith);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _addToSimulation() {
             this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _removeFromSimulation() {
             this._simulation._removePhysicsCollider(this);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onTransformChanged(flag) {
             flag &= Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE; //过滤有用TRANSFORM标记
             if (flag) {
                 this._transformFlag |= flag;
                 if (this._isValid() && this._inPhysicUpdateListIndex === -1) //_isValid()表示可使用
                     this._simulation._physicsUpdateList.add(this);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data) {
             (data.friction != null) && (this.friction = data.friction);
             (data.rollingFriction != null) && (this.rollingFriction = data.rollingFriction);
             (data.restitution != null) && (this.restitution = data.restitution);
             (data.isTrigger != null) && (this.isTrigger = data.isTrigger);
             super._parse(data);
             this._parseShape(data.shapes);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onAdded() {
             var physics3D = Physics._physics3D;
             var btColObj = new physics3D.btCollisionObject();
             btColObj.setUserIndex(this.id);
             btColObj.forceActivationState(PhysicsComponent.ACTIVATIONSTATE_DISABLE_SIMULATION); //prevent simulation
             var flags = btColObj.getCollisionFlags();
             if (this.owner.isStatic) { //TODO:
                 if ((flags & PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0)
                     flags = flags ^ PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT;
                 flags = flags | PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT;
             }
             else {
                 if ((flags & PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT) > 0)
                     flags = flags ^ PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT;
                 flags = flags | PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT;
             }
             btColObj.setCollisionFlags(flags);
             this._nativeColliderObject = btColObj;
             super._onAdded();
         }
     }

     /**
      * <code>CharacterController</code> 类用于创建角色控制器。
      */
     class CharacterController extends PhysicsComponent {
         /**
          * 创建一个 <code>CharacterController</code> 实例。
          * @param stepheight 角色脚步高度。
          * @param upAxis 角色Up轴
          * @param collisionGroup 所属碰撞组。
          * @param canCollideWith 可产生碰撞的碰撞组。
          */
         constructor(stepheight = 0.1, upAxis = null, collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
             super(collisionGroup, canCollideWith);
             /** @private */
             this._upAxis = new Vector3(0, 1, 0);
             /**@private */
             this._maxSlope = 45.0;
             /**@private */
             this._jumpSpeed = 10.0;
             /**@private */
             this._fallSpeed = 55.0;
             /** @private */
             this._gravity = new Vector3(0, -9.8 * 3, 0);
             /**@private */
             this._nativeKinematicCharacter = null;
             this._stepHeight = stepheight;
             (upAxis) && (this._upAxis = upAxis);
         }
         /**
          * @private
          */
         static __init__() {
             CharacterController._nativeTempVector30 = new Physics._physics3D.btVector3(0, 0, 0);
         }
         /**
          * 获取角色降落速度。
          * @return 角色降落速度。
          */
         get fallSpeed() {
             return this._fallSpeed;
         }
         /**
          * 设置角色降落速度。
          * @param value 角色降落速度。
          */
         set fallSpeed(value) {
             this._fallSpeed = value;
             this._nativeKinematicCharacter.setFallSpeed(value);
         }
         /**
          * 获取角色跳跃速度。
          * @return 角色跳跃速度。
          */
         get jumpSpeed() {
             return this._jumpSpeed;
         }
         /**
          * 设置角色跳跃速度。
          * @param value 角色跳跃速度。
          */
         set jumpSpeed(value) {
             this._jumpSpeed = value;
             this._nativeKinematicCharacter.setJumpSpeed(value);
         }
         /**
          * 获取重力。
          * @return 重力。
          */
         get gravity() {
             return this._gravity;
         }
         /**
          * 设置重力。
          * @param value 重力。
          */
         set gravity(value) {
             this._gravity = value;
             var nativeGravity = CharacterController._nativeTempVector30;
             nativeGravity.setValue(-value.x, value.y, value.z);
             this._nativeKinematicCharacter.setGravity(nativeGravity);
         }
         /**
          * 获取最大坡度。
          * @return 最大坡度。
          */
         get maxSlope() {
             return this._maxSlope;
         }
         /**
          * 设置最大坡度。
          * @param value 最大坡度。
          */
         set maxSlope(value) {
             this._maxSlope = value;
             this._nativeKinematicCharacter.setMaxSlope((value / 180) * Math.PI);
         }
         /**
          * 获取角色是否在地表。
          */
         get isGrounded() {
             return this._nativeKinematicCharacter.onGround();
         }
         /**
          * 获取角色行走的脚步高度，表示可跨越的最大高度。
          * @return 脚步高度。
          */
         get stepHeight() {
             return this._stepHeight;
         }
         /**
          * 设置角色行走的脚步高度，表示可跨越的最大高度。
          * @param value 脚步高度。
          */
         set stepHeight(value) {
             this._stepHeight = value;
             this._constructCharacter();
         }
         /**
          * 获取角色的Up轴。
          * @return 角色的Up轴。
          */
         get upAxis() {
             return this._upAxis;
         }
         /**
          * 设置角色的Up轴。
          * @return 角色的Up轴。
          */
         set upAxis(value) {
             this._upAxis = value;
             this._constructCharacter();
         }
         /**
          * @private
          */
         _constructCharacter() {
             var physics3D = Physics._physics3D;
             if (this._nativeKinematicCharacter)
                 physics3D.destroy(this._nativeKinematicCharacter);
             var nativeUpAxis = CharacterController._nativeTempVector30;
             nativeUpAxis.setValue(this._upAxis.x, this._upAxis.y, this._upAxis.z);
             this._nativeKinematicCharacter = new physics3D.btKinematicCharacterController(this._nativeColliderObject, this._colliderShape._nativeShape, this._stepHeight, nativeUpAxis);
             this.fallSpeed = this._fallSpeed;
             this.maxSlope = this._maxSlope;
             this.jumpSpeed = this._jumpSpeed;
             this.gravity = this._gravity;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onShapeChange(colShape) {
             super._onShapeChange(colShape);
             this._constructCharacter();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onAdded() {
             var physics3D = Physics._physics3D;
             var ghostObject = new physics3D.btPairCachingGhostObject();
             ghostObject.setUserIndex(this.id);
             ghostObject.setCollisionFlags(PhysicsComponent.COLLISIONFLAGS_CHARACTER_OBJECT);
             this._nativeColliderObject = ghostObject;
             if (this._colliderShape)
                 this._constructCharacter();
             super._onAdded();
         }
         /**
          * @inheritDoc
          */
         /*override*/ _addToSimulation() {
             this._simulation._characters.push(this);
             this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _removeFromSimulation() {
             this._simulation._removeCharacter(this);
             var characters = this._simulation._characters;
             characters.splice(characters.indexOf(this), 1);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _cloneTo(dest) {
             super._cloneTo(dest);
             var destCharacterController = dest;
             destCharacterController.stepHeight = this._stepHeight;
             destCharacterController.upAxis = this._upAxis;
             destCharacterController.maxSlope = this._maxSlope;
             destCharacterController.jumpSpeed = this._jumpSpeed;
             destCharacterController.fallSpeed = this._fallSpeed;
             destCharacterController.gravity = this._gravity;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onDestroy() {
             Physics._physics3D.destroy(this._nativeKinematicCharacter);
             super._onDestroy();
             this._nativeKinematicCharacter = null;
         }
         /**
          * 通过指定移动向量移动角色。
          * @param	movement 移动向量。
          */
         move(movement) {
             var nativeMovement = CharacterController._nativeVector30;
             nativeMovement.setValue(-movement.x, movement.y, movement.z);
             this._nativeKinematicCharacter.setWalkDirection(nativeMovement);
         }
         /**
          * 跳跃。
          * @param velocity 跳跃速度。
          */
         jump(velocity = null) {
             if (velocity) {
                 var nativeVelocity = CharacterController._nativeVector30;
                 Utils3D._convertToBulletVec3(velocity, nativeVelocity, true);
                 this._nativeKinematicCharacter.jump(nativeVelocity);
             }
             else {
                 this._nativeKinematicCharacter.jump();
             }
         }
     }
     /* UP轴_X轴。*/
     CharacterController.UPAXIS_X = 0;
     /* UP轴_Y轴。*/
     CharacterController.UPAXIS_Y = 1;
     /* UP轴_Z轴。*/
     CharacterController.UPAXIS_Z = 2;

     /**
      * <code>Rigidbody3D</code> 类用于创建刚体碰撞器。
      */
     class Rigidbody3D extends PhysicsTriggerComponent {
         /**
          * 创建一个 <code>RigidBody</code> 实例。
          * @param collisionGroup 所属碰撞组。
          * @param canCollideWith 可产生碰撞的碰撞组。
          */
         constructor(collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
             //LinkedConstraints = new List<Constraint>();
             super(collisionGroup, canCollideWith);
             /** @private */
             this._isKinematic = false;
             /** @private */
             this._mass = 1.0;
             /** @private */
             this._gravity = new Vector3(0, -10, 0);
             /** @private */
             this._angularDamping = 0.0;
             /** @private */
             this._linearDamping = 0.0;
             /** @private */
             this._overrideGravity = false;
             /** @private */
             this._totalTorque = new Vector3(0, 0, 0);
             //private var _linkedConstraints:Array;//TODO:
             /** @private */
             this._linearVelocity = new Vector3();
             /** @private */
             this._angularVelocity = new Vector3();
             /** @private */
             this._linearFactor = new Vector3(1, 1, 1);
             /** @private */
             this._angularFactor = new Vector3(1, 1, 1);
             /** @private */
             this._detectCollisions = true;
         }
         /**
          * @private
          */
         static __init__() {
             Rigidbody3D._nativeTempVector30 = new Physics._physics3D.btVector3(0, 0, 0);
             Rigidbody3D._nativeTempVector31 = new Physics._physics3D.btVector3(0, 0, 0);
             Rigidbody3D._nativeVector3Zero = new Physics._physics3D.btVector3(0, 0, 0);
             Rigidbody3D._nativeInertia = new Physics._physics3D.btVector3(0, 0, 0);
             Rigidbody3D._nativeImpulse = new Physics._physics3D.btVector3(0, 0, 0);
             Rigidbody3D._nativeImpulseOffset = new Physics._physics3D.btVector3(0, 0, 0);
             Rigidbody3D._nativeGravity = new Physics._physics3D.btVector3(0, 0, 0);
         }
         /**
          * 获取质量。
          * @return 质量。
          */
         get mass() {
             return this._mass;
         }
         /**
          * 设置质量。
          * @param value 质量。
          */
         set mass(value) {
             value = Math.max(value, 1e-07); //质量最小为1e-07
             this._mass = value;
             (this._isKinematic) || (this._updateMass(value));
         }
         /**
          * 获取是否为运动物体，如果为true仅可通过transform属性移动物体,而非其他力相关属性。
          * @return 是否为运动物体。
          */
         get isKinematic() {
             return this._isKinematic;
         }
         /**
          * 设置是否为运动物体，如果为true仅可通过transform属性移动物体,而非其他力相关属性。
          * @param value 是否为运动物体。
          */
         set isKinematic(value) {
             this._isKinematic = value;
             var canInSimulation = !!(this._simulation && this._enabled && this._colliderShape);
             canInSimulation && this._removeFromSimulation();
             var natColObj = this._nativeColliderObject;
             var flags = natColObj.getCollisionFlags();
             if (value) {
                 flags = flags | PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT;
                 natColObj.setCollisionFlags(flags); //加入场景前必须配置flag,加入后无效
                 this._nativeColliderObject.forceActivationState(PhysicsComponent.ACTIVATIONSTATE_DISABLE_DEACTIVATION); //触发器开启主动检测,并防止睡眠
                 this._enableProcessCollisions = false;
                 this._updateMass(0); //必须设置Mass为0来保证InverMass为0
             }
             else {
                 if ((flags & PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0)
                     flags = flags ^ PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT;
                 natColObj.setCollisionFlags(flags); //加入场景前必须配置flag,加入后无效
                 this._nativeColliderObject.setActivationState(PhysicsComponent.ACTIVATIONSTATE_ACTIVE_TAG);
                 this._enableProcessCollisions = true;
                 this._updateMass(this._mass);
             }
             var nativeZero = Rigidbody3D._nativeVector3Zero;
             natColObj.setInterpolationLinearVelocity(nativeZero);
             natColObj.setLinearVelocity(nativeZero);
             natColObj.setInterpolationAngularVelocity(nativeZero);
             natColObj.setAngularVelocity(nativeZero);
             canInSimulation && this._addToSimulation();
         }
         /**
          * 获取刚体的线阻力。
          * @return 线阻力。
          */
         get linearDamping() {
             return this._linearDamping;
         }
         /**
          * 设置刚体的线阻力。
          * @param value  线阻力。
          */
         set linearDamping(value) {
             this._linearDamping = value;
             if (this._nativeColliderObject)
                 this._nativeColliderObject.setDamping(value, this._angularDamping);
         }
         /**
          * 获取刚体的角阻力。
          * @return 角阻力。
          */
         get angularDamping() {
             return this._angularDamping;
         }
         /**
          * 设置刚体的角阻力。
          * @param value  角阻力。
          */
         set angularDamping(value) {
             this._angularDamping = value;
             if (this._nativeColliderObject)
                 this._nativeColliderObject.setDamping(this._linearDamping, value);
         }
         /**
          * 获取是否重载重力。
          * @return 是否重载重力。
          */
         get overrideGravity() {
             return this._overrideGravity;
         }
         /**
          * 设置是否重载重力。
          * @param value 是否重载重力。
          */
         set overrideGravity(value) {
             this._overrideGravity = value;
             if (this._nativeColliderObject) {
                 var flag = this._nativeColliderObject.getFlags();
                 if (value) {
                     if ((flag & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) === 0)
                         this._nativeColliderObject.setFlags(flag | Rigidbody3D._BT_DISABLE_WORLD_GRAVITY);
                 }
                 else {
                     if ((flag & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) > 0)
                         this._nativeColliderObject.setFlags(flag ^ Rigidbody3D._BT_DISABLE_WORLD_GRAVITY);
                 }
             }
         }
         /**
          * 获取重力。
          * @return 重力。
          */
         get gravity() {
             return this._gravity;
         }
         /**
          * 设置重力。
          * @param value 重力。
          */
         set gravity(value) {
             this._gravity = value;
             Rigidbody3D._nativeGravity.setValue(-value.x, value.y, value.z);
             this._nativeColliderObject.setGravity(Rigidbody3D._nativeGravity);
         }
         /**
          * 获取总力。
          */
         get totalForce() {
             if (this._nativeColliderObject)
                 return this._nativeColliderObject.getTotalForce();
             return null;
         }
         /**
          * 获取性因子。
          */
         get linearFactor() {
             if (this._nativeColliderObject)
                 return this._linearFactor;
             return null;
         }
         /**
          * 设置性因子。
          */
         set linearFactor(value) {
             this._linearFactor = value;
             if (this._nativeColliderObject) {
                 var nativeValue = Rigidbody3D._nativeTempVector30;
                 Utils3D._convertToBulletVec3(value, nativeValue, false);
                 this._nativeColliderObject.setLinearFactor(nativeValue);
             }
         }
         /**
          * 获取线速度
          * @return 线速度
          */
         get linearVelocity() {
             if (this._nativeColliderObject)
                 Utils3D._convertToLayaVec3(this._nativeColliderObject.getLinearVelocity(), this._linearVelocity, true);
             return this._linearVelocity;
         }
         /**
          * 设置线速度。
          * @param 线速度。
          */
         set linearVelocity(value) {
             this._linearVelocity = value;
             if (this._nativeColliderObject) {
                 var nativeValue = Rigidbody3D._nativeTempVector30;
                 Utils3D._convertToBulletVec3(value, nativeValue, true);
                 (this.isSleeping) && (this.wakeUp()); //可能会因睡眠导致设置线速度无效
                 this._nativeColliderObject.setLinearVelocity(nativeValue);
             }
         }
         /**
          * 获取角因子。
          */
         get angularFactor() {
             if (this._nativeColliderObject)
                 return this._angularFactor;
             return null;
         }
         /**
          * 设置角因子。
          */
         set angularFactor(value) {
             this._angularFactor = value;
             if (this._nativeColliderObject) {
                 var nativeValue = Rigidbody3D._nativeTempVector30;
                 Utils3D._convertToBulletVec3(value, nativeValue, false);
                 this._nativeColliderObject.setAngularFactor(nativeValue);
             }
         }
         /**
          * 获取角速度。
          * @return 角速度。
          */
         get angularVelocity() {
             if (this._nativeColliderObject)
                 Utils3D._convertToLayaVec3(this._nativeColliderObject.getAngularVelocity(), this._angularVelocity, true);
             return this._angularVelocity;
         }
         /**
          * 设置角速度。
          * @param 角速度
          */
         set angularVelocity(value) {
             this._angularVelocity = value;
             if (this._nativeColliderObject) {
                 var nativeValue = Rigidbody3D._nativeTempVector30;
                 Utils3D._convertToBulletVec3(value, nativeValue, true);
                 (this.isSleeping) && (this.wakeUp()); //可能会因睡眠导致设置角速度无效
                 this._nativeColliderObject.setAngularVelocity(nativeValue);
             }
         }
         /**
          * 获取刚体所有扭力。
          */
         get totalTorque() {
             if (this._nativeColliderObject) {
                 var nativeTotalTorque = this._nativeColliderObject.getTotalTorque();
                 var totalTorque = this._totalTorque;
                 totalTorque.x = -nativeTotalTorque.x;
                 totalTorque.y = nativeTotalTorque.y;
                 totalTorque.z = nativeTotalTorque.z;
             }
             return null;
         }
         /**
          * 获取是否进行碰撞检测。
          * @return 是否进行碰撞检测。
          */
         get detectCollisions() {
             return this._detectCollisions;
         }
         /**
          * 设置是否进行碰撞检测。
          * @param value 是否进行碰撞检测。
          */
         set detectCollisions(value) {
             if (this._detectCollisions !== value) {
                 this._detectCollisions = value;
                 if (this._colliderShape && this._enabled && this._simulation) {
                     this._simulation._removeRigidBody(this);
                     this._simulation._addRigidBody(this, this._collisionGroup, value ? this._canCollideWith : 0);
                     //_nativeColliderObject.getBroadphaseHandle().set_m_collisionFilterMask(value ? _canCollideWith : 0);//有延迟问题
                 }
             }
         }
         /**
          * 获取是否处于睡眠状态。
          * @return 是否处于睡眠状态。
          */
         get isSleeping() {
             if (this._nativeColliderObject)
                 return this._nativeColliderObject.getActivationState() === PhysicsComponent.ACTIVATIONSTATE_ISLAND_SLEEPING;
             return false;
         }
         /**
          * 获取刚体睡眠的线速度阈值。
          * @return 刚体睡眠的线速度阈值。
          */
         get sleepLinearVelocity() {
             return this._nativeColliderObject.getLinearSleepingThreshold();
         }
         /**
          * 设置刚体睡眠的线速度阈值。
          * @param value 刚体睡眠的线速度阈值。
          */
         set sleepLinearVelocity(value) {
             this._nativeColliderObject.setSleepingThresholds(value, this._nativeColliderObject.getAngularSleepingThreshold());
         }
         /**
          * 获取刚体睡眠的角速度阈值。
          * @return 刚体睡眠的角速度阈值。
          */
         get sleepAngularVelocity() {
             return this._nativeColliderObject.getAngularSleepingThreshold();
         }
         /**
          * 设置刚体睡眠的角速度阈值。
          * @param value 刚体睡眠的角速度阈值。
          */
         set sleepAngularVelocity(value) {
             this._nativeColliderObject.setSleepingThresholds(this._nativeColliderObject.getLinearSleepingThreshold(), value);
         }
         /**
          * @private
          */
         _updateMass(mass) {
             if (this._nativeColliderObject && this._colliderShape) {
                 this._colliderShape._nativeShape.calculateLocalInertia(mass, Rigidbody3D._nativeInertia);
                 this._nativeColliderObject.setMassProps(mass, Rigidbody3D._nativeInertia);
                 this._nativeColliderObject.updateInertiaTensor(); //this was the major headache when I had to debug Slider and Hinge constraint
             }
         }
         /**
          * @private
          * Dynamic刚体,初始化时调用一次。
          * Kinematic刚体,每次物理tick时调用(如果未进入睡眠状态),让物理引擎知道刚体位置。
          */
         _delegateMotionStateGetWorldTransform(worldTransPointer) {
             //已调整机制,引擎会统一处理通过Transform修改坐标更新包围盒队列
             //var rigidBody:Rigidbody3D = __JS__("this._rigidbody");
             //if (!rigidBody._colliderShape)//Dynamic刚体初始化时没有colliderShape需要跳过
             //return;
             //
             //rigidBody._simulation._updatedRigidbodies++;
             //var physics3D:* = Laya3D._physics3D;
             //var worldTrans:* = physics3D.wrapPointer(worldTransPointer, physics3D.btTransform);
             //rigidBody._innerDerivePhysicsTransformation(worldTrans, true);
         }
         /**
          * @private
          * Dynamic刚体,物理引擎每帧调用一次,用于更新渲染矩阵。
          */
         _delegateMotionStateSetWorldTransform(worldTransPointer) {
             var rigidBody = this._rigidbody;
             rigidBody._simulation._updatedRigidbodies++;
             var physics3D = Physics._physics3D;
             var worldTrans = physics3D.wrapPointer(worldTransPointer, physics3D.btTransform);
             rigidBody._updateTransformComponent(worldTrans);
         }
         /**
          *  @private
          * Dynamic刚体,初始化时调用一次。
          * Kinematic刚体,每次物理tick时调用(如果未进入睡眠状态),让物理引擎知道刚体位置。
          * 该函数只有在runtime下调用
          */
         _delegateMotionStateGetWorldTransformNative(ridgidBody3D, worldTransPointer) {
             //已调整机制,引擎会统一处理通过Transform修改坐标更新包围盒队列
             //var rigidBody:Rigidbody3D = ridgidBody3D;
             //if (!rigidBody._colliderShape)//Dynamic刚体初始化时没有colliderShape需要跳过
             //return;
             //
             //rigidBody._simulation._updatedRigidbodies++;
             //var physics3D:* = Laya3D._physics3D;
             //var worldTrans:* = physics3D.wrapPointer(worldTransPointer, physics3D.btTransform);
             //rigidBody._innerDerivePhysicsTransformation(worldTrans, true);
         }
         /**
          * @private
          * Dynamic刚体,物理引擎每帧调用一次,用于更新渲染矩阵。
          * 该函数只有在runtime下调用
          */
         _delegateMotionStateSetWorldTransformNative(rigidBody3D, worldTransPointer) {
             var rigidBody = rigidBody3D;
             rigidBody._simulation._updatedRigidbodies++;
             var physics3D = Physics._physics3D;
             var worldTrans = physics3D.wrapPointer(worldTransPointer, physics3D.btTransform);
             rigidBody._updateTransformComponent(worldTrans);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onScaleChange(scale) {
             super._onScaleChange(scale);
             this._updateMass(this._isKinematic ? 0 : this._mass); //修改缩放需要更新惯性
         }
         /**
          * @private
          */
         _delegateMotionStateClear() {
             this._rigidbody = null;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onAdded() {
             var physics3D = Physics._physics3D;
             var motionState = new physics3D.LayaMotionState();
             var isConchApp = (window.conch != null);
             if (isConchApp && physics3D.LayaMotionState.prototype.setRigidbody) {
                 motionState.setRigidbody(this);
                 motionState.setNativeGetWorldTransform(this._delegateMotionStateGetWorldTransformNative);
                 motionState.setNativeSetWorldTransform(this._delegateMotionStateSetWorldTransformNative);
             }
             else {
                 motionState.getWorldTransform = this._delegateMotionStateGetWorldTransform;
                 motionState.setWorldTransform = this._delegateMotionStateSetWorldTransform;
             }
             motionState.clear = this._delegateMotionStateClear;
             motionState._rigidbody = this;
             this._nativeMotionState = motionState;
             var constructInfo = new physics3D.btRigidBodyConstructionInfo(0.0, motionState, null, Rigidbody3D._nativeVector3Zero);
             var btRigid = new physics3D.btRigidBody(constructInfo);
             btRigid.setUserIndex(this.id);
             this._nativeColliderObject = btRigid;
             super._onAdded();
             this.mass = this._mass;
             this.linearFactor = this._linearFactor;
             this.angularFactor = this._angularFactor;
             this.linearDamping = this._linearDamping;
             this.angularDamping = this._angularDamping;
             this.overrideGravity = this._overrideGravity;
             this.gravity = this._gravity;
             this.isKinematic = this._isKinematic;
             physics3D.destroy(constructInfo);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onShapeChange(colShape) {
             super._onShapeChange(colShape);
             //TODO:此时已经加入场景,只影响mass为0,函数内部设置的flas是否为static无效			
             if (this._isKinematic) {
                 this._updateMass(0);
             }
             else {
                 this._nativeColliderObject.setCenterOfMassTransform(this._nativeColliderObject.getWorldTransform()); //修改Shape会影响坐标,需要更新插值坐标,否则物理引擎motionState.setWorldTrans数据为旧数据
                 this._updateMass(this._mass);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _parse(data) {
             (data.friction != null) && (this.friction = data.friction);
             (data.rollingFriction != null) && (this.rollingFriction = data.rollingFriction);
             (data.restitution != null) && (this.restitution = data.restitution);
             (data.isTrigger != null) && (this.isTrigger = data.isTrigger);
             (data.mass != null) && (this.mass = data.mass);
             (data.isKinematic != null) && (this.isKinematic = data.isKinematic);
             (data.linearDamping != null) && (this.linearDamping = data.linearDamping);
             (data.angularDamping != null) && (this.angularDamping = data.angularDamping);
             (data.overrideGravity != null) && (this.overrideGravity = data.overrideGravity);
             if (data.gravity) {
                 this.gravity.fromArray(data.gravity);
                 this.gravity = this.gravity;
             }
             super._parse(data);
             this._parseShape(data.shapes);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onDestroy() {
             var physics3D = Physics._physics3D;
             this._nativeMotionState.clear();
             physics3D.destroy(this._nativeMotionState);
             ////Remove constraints safely
             //var toremove = new FastList<Constraint>();
             //foreach (var c in LinkedConstraints)
             //{
             //toremove.Add(c);
             //}
             //foreach (var disposable in toremove)
             //{
             //disposable.Dispose();
             //}
             //LinkedConstraints.Clear();
             ////~Remove constraints
             super._onDestroy();
             this._nativeMotionState = null;
             this._gravity = null;
             this._totalTorque = null;
             this._linearVelocity = null;
             this._angularVelocity = null;
             this._linearFactor = null;
             this._angularFactor = null;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _addToSimulation() {
             this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _removeFromSimulation() {
             this._simulation._removeRigidBody(this);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _cloneTo(dest) {
             super._cloneTo(dest);
             var destRigidbody3D = dest;
             destRigidbody3D.isKinematic = this._isKinematic;
             destRigidbody3D.mass = this._mass;
             destRigidbody3D.gravity = this._gravity;
             destRigidbody3D.angularDamping = this._angularDamping;
             destRigidbody3D.linearDamping = this._linearDamping;
             destRigidbody3D.overrideGravity = this._overrideGravity;
             //destRigidbody3D.totalTorque = _totalTorque;
             destRigidbody3D.linearVelocity = this._linearVelocity;
             destRigidbody3D.angularVelocity = this._angularVelocity;
             destRigidbody3D.linearFactor = this._linearFactor;
             destRigidbody3D.angularFactor = this._angularFactor;
             destRigidbody3D.detectCollisions = this._detectCollisions;
         }
         /**
          * 应用作用力。
          * @param	force 作用力。
          * @param	localOffset 偏移,如果为null则为中心点
          */
         applyForce(force, localOffset = null) {
             if (this._nativeColliderObject == null)
                 throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
             var nativeForce = Rigidbody3D._nativeTempVector30;
             nativeForce.setValue(-force.x, force.y, force.z);
             if (localOffset) {
                 var nativeOffset = Rigidbody3D._nativeTempVector31;
                 nativeOffset.setValue(-localOffset.x, localOffset.y, localOffset.z);
                 this._nativeColliderObject.applyForce(nativeForce, nativeOffset);
             }
             else {
                 this._nativeColliderObject.applyCentralForce(nativeForce);
             }
         }
         /**
          * 应用扭转力。
          * @param	torque 扭转力。
          */
         applyTorque(torque) {
             if (this._nativeColliderObject == null)
                 throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
             var nativeTorque = Rigidbody3D._nativeTempVector30;
             nativeTorque.setValue(-torque.x, torque.y, torque.z);
             this._nativeColliderObject.applyTorque(nativeTorque);
         }
         /**
          * 应用冲量。
          * @param	impulse 冲量。
          * @param   localOffset 偏移,如果为null则为中心点。
          */
         applyImpulse(impulse, localOffset = null) {
             if (this._nativeColliderObject == null)
                 throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
             Rigidbody3D._nativeImpulse.setValue(-impulse.x, impulse.y, impulse.z);
             if (localOffset) {
                 Rigidbody3D._nativeImpulseOffset.setValue(-localOffset.x, localOffset.y, localOffset.z);
                 this._nativeColliderObject.applyImpulse(Rigidbody3D._nativeImpulse, Rigidbody3D._nativeImpulseOffset);
             }
             else {
                 this._nativeColliderObject.applyCentralImpulse(Rigidbody3D._nativeImpulse);
             }
         }
         /**
          * 应用扭转冲量。
          * @param	torqueImpulse
          */
         applyTorqueImpulse(torqueImpulse) {
             if (this._nativeColliderObject == null)
                 throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
             var nativeTorqueImpulse = Rigidbody3D._nativeTempVector30;
             nativeTorqueImpulse.setValue(-torqueImpulse.x, torqueImpulse.y, torqueImpulse.z);
             this._nativeColliderObject.applyTorqueImpulse(nativeTorqueImpulse);
         }
         /**
          * 唤醒刚体。
          */
         wakeUp() {
             this._nativeColliderObject && (this._nativeColliderObject.activate(false));
         }
         /**
          *清除应用到刚体上的所有力。
          */
         clearForces() {
             var rigidBody = this._nativeColliderObject;
             if (rigidBody == null)
                 throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
             rigidBody.clearForces();
             var nativeZero = Rigidbody3D._nativeVector3Zero;
             rigidBody.setInterpolationLinearVelocity(nativeZero);
             rigidBody.setLinearVelocity(nativeZero);
             rigidBody.setInterpolationAngularVelocity(nativeZero);
             rigidBody.setAngularVelocity(nativeZero);
         }
     }
     /*
      * 刚体类型_静态。
      * 设定为永远不会移动刚体,引擎也不会自动更新。
      * 如果你打算移动物理,建议使用TYPE_KINEMATIC。
      */
     Rigidbody3D.TYPE_STATIC = 0;
     /*
      * 刚体类型_动态。
      * 可以通过forces和impulsesy移动刚体,并且不需要修改移动转换。
      */
     Rigidbody3D.TYPE_DYNAMIC = 1;
     /*
      * 刚体类型_运动。
      * 可以移动刚体,物理引擎会自动处理动态交互。
      * 注意：和静态或其他类型刚体不会产生动态交互。
      */
     Rigidbody3D.TYPE_KINEMATIC = 2;
     /** @private */
     Rigidbody3D._BT_DISABLE_WORLD_GRAVITY = 1;
     /** @private */
     Rigidbody3D._BT_ENABLE_GYROPSCOPIC_FORCE = 2;

     /**
      * <code>Laya3D</code> 类用于初始化3D设置。
      */
     class Laya3D {
         /**
          * 创建一个 <code>Laya3D</code> 实例。
          */
         constructor() {
         }
         /**
          * 获取是否可以启用物理。
          * @param 是否启用物理。
          */
         static get enbalePhysics() {
             return Physics._enbalePhysics;
         }
         /**
          *@private
          */
         static _cancelLoadByUrl(url) {
             Laya.loader.cancelLoadByUrl(url);
             Laya3D._innerFirstLevelLoaderManager.cancelLoadByUrl(url);
             Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(url);
             Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(url);
             Laya3D._innerFourthLevelLoaderManager.cancelLoadByUrl(url);
         }
         /**
          *@private
          */
         static _changeWebGLSize(width, height) {
             WebGL.onStageResize(width, height);
             RenderContext3D.clientWidth = width;
             RenderContext3D.clientHeight = height;
         }
         /**
          *@private
          */
         static __init__(width, height, config) {
             Config.isAntialias = config.isAntialias;
             Config.isAlpha = config.isAlpha;
             Config.premultipliedAlpha = config.premultipliedAlpha;
             Config.isStencil = config.isStencil;
             if (!WebGL.enable()) {
                 alert("Laya3D init error,must support webGL!");
                 return;
             }
             RunDriver.changeWebGLSize = Laya3D._changeWebGLSize;
             Render.is3DMode = true;
             Laya.init(width, height);
             if (!Render.supportWebGLPlusRendering) {
                 LayaGL.instance = WebGLContext.mainContext;
                 LayaGL.instance.createCommandEncoder = function (reserveSize = 128, adjustSize = 64, isSyncToRenderThread = false) {
                     return new CommandEncoder(this, reserveSize, adjustSize, isSyncToRenderThread);
                 };
             }
             ILaya3D.Scene3D = Scene3D;
             ILaya3D.MeshRenderStaticBatchManager = MeshRenderStaticBatchManager;
             ILaya3D.MeshRenderDynamicBatchManager = MeshRenderDynamicBatchManager;
             ILaya3D.SubMeshDynamicBatch = SubMeshDynamicBatch;
             ILaya3D.Laya3D = Laya3D;
             ILaya3D.Matrix4x4 = Matrix4x4;
             //函数里面会有判断isConchApp
             Laya3D.enableNative3D();
             SubMeshInstanceBatch.__init__();
             SubMeshDynamicBatch.__init__();
             Physics._physics3D = window.Physics3D;
             if (Physics._physics3D) {
                 ColliderShape.__init__();
                 CompoundColliderShape.__init__();
                 PhysicsComponent.__init__();
                 PhysicsSimulation.__init__();
                 BoxColliderShape.__init__();
                 CylinderColliderShape.__init__();
                 CharacterController.__init__();
                 Rigidbody3D.__init__();
             }
             Mesh.__init__();
             Sprite3D.__init__();
             RenderableSprite3D.__init__();
             MeshSprite3D.__init__();
             SkinnedMeshSprite3D.__init__();
             ShuriKenParticle3D.__init__();
             TrailSprite3D.__init__();
             PostProcess.__init__();
             Scene3D.__init__();
             BaseMaterial.__initDefine__();
             BlinnPhongMaterial.__initDefine__();
             PBRStandardMaterial.__initDefine__();
             PBRSpecularMaterial.__initDefine__();
             SkyProceduralMaterial.__initDefine__();
             UnlitMaterial.__initDefine__();
             TrailMaterial.__initDefine__();
             EffectMaterial.__initDefine__();
             WaterPrimaryMaterial.__initDefine__();
             ShurikenParticleMaterial.__initDefine__();
             ExtendTerrainMaterial.__initDefine__();
             PixelLineMaterial.__initDefine__();
             SkyBoxMaterial.__initDefine__();
             ShaderInit3D.__init__();
             Command.__init__();
             //注册类命,解析的时候需要
             ClassUtils.regClass("Laya.BlinnPhongMaterial", BlinnPhongMaterial);
             ClassUtils.regClass("Laya.SkyProceduralMaterial", SkyProceduralMaterial);
             ClassUtils.regClass("Laya.PBRStandardMaterial", PBRStandardMaterial);
             ClassUtils.regClass("Laya.PBRSpecularMaterial", PBRSpecularMaterial);
             ClassUtils.regClass("Laya.SkyBoxMaterial", SkyBoxMaterial);
             ClassUtils.regClass("Laya.WaterPrimaryMaterial", WaterPrimaryMaterial);
             ClassUtils.regClass("Laya.ExtendTerrainMaterial", ExtendTerrainMaterial);
             ClassUtils.regClass("Laya.ShurikenParticleMaterial", ShurikenParticleMaterial);
             ClassUtils.regClass("Laya.TrailMaterial", TrailMaterial);
             ClassUtils.regClass("Laya.PhysicsCollider", PhysicsCollider);
             ClassUtils.regClass("Laya.CharacterController", CharacterController);
             ClassUtils.regClass("Laya.Animator", Animator);
             ClassUtils.regClass("PhysicsCollider", PhysicsCollider); //兼容
             ClassUtils.regClass("CharacterController", CharacterController); //兼容
             ClassUtils.regClass("Animator", Animator); //兼容
             PixelLineMaterial.defaultMaterial = new PixelLineMaterial();
             BlinnPhongMaterial.defaultMaterial = new BlinnPhongMaterial();
             EffectMaterial.defaultMaterial = new EffectMaterial();
             PBRStandardMaterial.defaultMaterial = new PBRStandardMaterial();
             PBRSpecularMaterial.defaultMaterial = new PBRSpecularMaterial();
             UnlitMaterial.defaultMaterial = new UnlitMaterial();
             ShurikenParticleMaterial.defaultMaterial = new ShurikenParticleMaterial();
             TrailMaterial.defaultMaterial = new TrailMaterial();
             SkyProceduralMaterial.defaultMaterial = new SkyProceduralMaterial();
             SkyBoxMaterial.defaultMaterial = new SkyBoxMaterial();
             WaterPrimaryMaterial.defaultMaterial = new WaterPrimaryMaterial();
             PixelLineMaterial.defaultMaterial.lock = true; //todo:
             BlinnPhongMaterial.defaultMaterial.lock = true;
             EffectMaterial.defaultMaterial.lock = true;
             PBRStandardMaterial.defaultMaterial.lock = true;
             PBRSpecularMaterial.defaultMaterial.lock = true;
             UnlitMaterial.defaultMaterial.lock = true;
             ShurikenParticleMaterial.defaultMaterial.lock = true;
             TrailMaterial.defaultMaterial.lock = true;
             SkyProceduralMaterial.defaultMaterial.lock = true;
             SkyBoxMaterial.defaultMaterial.lock = true;
             WaterPrimaryMaterial.defaultMaterial.lock = true;
             Texture2D.__init__();
             TextureCube.__init__();
             SkyBox.__init__();
             SkyDome.__init__();
             ScreenQuad.__init__();
             ScreenTriangle.__init__();
             FrustumCulling.__init__();
             HalfFloatUtils.__init__();
             var createMap = LoaderManager.createMap;
             createMap["lh"] = [Laya3D.HIERARCHY, Scene3DUtils._parse];
             createMap["ls"] = [Laya3D.HIERARCHY, Scene3DUtils._parseScene];
             createMap["lm"] = [Laya3D.MESH, Mesh._parse];
             createMap["lmat"] = [Laya3D.MATERIAL, BaseMaterial._parse];
             createMap["ltc"] = [Laya3D.TEXTURECUBE, TextureCube._parse];
             createMap["jpg"] = [Laya3D.TEXTURE2D, Texture2D._parse];
             createMap["jpeg"] = [Laya3D.TEXTURE2D, Texture2D._parse];
             createMap["bmp"] = [Laya3D.TEXTURE2D, Texture2D._parse];
             createMap["gif"] = [Laya3D.TEXTURE2D, Texture2D._parse];
             createMap["png"] = [Laya3D.TEXTURE2D, Texture2D._parse];
             createMap["dds"] = [Laya3D.TEXTURE2D, Texture2D._parse];
             createMap["ktx"] = [Laya3D.TEXTURE2D, Texture2D._parse];
             createMap["pvr"] = [Laya3D.TEXTURE2D, Texture2D._parse];
             createMap["lani"] = [Laya3D.ANIMATIONCLIP, AnimationClip._parse];
             createMap["lav"] = [Laya3D.AVATAR, Avatar._parse];
             var parserMap = Loader.parserMap;
             parserMap[Laya3D.HIERARCHY] = Laya3D._loadHierarchy;
             parserMap[Laya3D.MESH] = Laya3D._loadMesh;
             parserMap[Laya3D.MATERIAL] = Laya3D._loadMaterial;
             parserMap[Laya3D.TEXTURECUBE] = Laya3D._loadTextureCube;
             parserMap[Laya3D.TEXTURE2D] = Laya3D._loadTexture2D;
             parserMap[Laya3D.ANIMATIONCLIP] = Laya3D._loadAnimationClip;
             parserMap[Laya3D.AVATAR] = Laya3D._loadAvatar;
             //parserMap[Laya3D.TERRAINRES] = _loadTerrain;
             //parserMap[Laya3D.TERRAINHEIGHTDATA] = _loadTerrain;
             Laya3D._innerFirstLevelLoaderManager.on(Event.ERROR, null, Laya3D._eventLoadManagerError);
             Laya3D._innerSecondLevelLoaderManager.on(Event.ERROR, null, Laya3D._eventLoadManagerError);
             Laya3D._innerThirdLevelLoaderManager.on(Event.ERROR, null, Laya3D._eventLoadManagerError);
             Laya3D._innerFourthLevelLoaderManager.on(Event.ERROR, null, Laya3D._eventLoadManagerError);
         }
         static enableNative3D() {
             if (Render.isConchApp) {
                 //LayaGL = (window as any).LayaGLContext;
                 var shaderData = ShaderData;
                 var shader3D = ShaderInstance;
                 var skinnedMeshRender = SkinnedMeshRenderer;
                 var avatar = Avatar;
                 var frustumCulling = FrustumCulling;
                 var meshRender = MeshRenderer;
                 if (Render.supportWebGLPlusRendering) {
                     //替换ShaderData的函数
                     shaderData.prototype._initData = shaderData.prototype._initDataForNative;
                     shaderData.prototype.setBool = shaderData.prototype.setBoolForNative;
                     shaderData.prototype.getBool = shaderData.prototype.getBoolForNative;
                     shaderData.prototype.setInt = shaderData.prototype.setIntForNative;
                     shaderData.prototype.getInt = shaderData.prototype.getIntForNative;
                     shaderData.prototype.setNumber = shaderData.prototype.setNumberForNative;
                     shaderData.prototype.getNumber = shaderData.prototype.getNumberForNative;
                     shaderData.prototype.setVector = shaderData.prototype.setVectorForNative;
                     shaderData.prototype.getVector = shaderData.prototype.getVectorForNative;
                     shaderData.prototype.setVector2 = shaderData.prototype.setVector2ForNative;
                     shaderData.prototype.getVector2 = shaderData.prototype.getVector2ForNative;
                     shaderData.prototype.setVector3 = shaderData.prototype.setVector3ForNative;
                     shaderData.prototype.getVector3 = shaderData.prototype.getVector3ForNative;
                     shaderData.prototype.setQuaternion = shaderData.prototype.setQuaternionForNative;
                     shaderData.prototype.getQuaternion = shaderData.prototype.getQuaternionForNative;
                     shaderData.prototype.setMatrix4x4 = shaderData.prototype.setMatrix4x4ForNative;
                     shaderData.prototype.getMatrix4x4 = shaderData.prototype.getMatrix4x4ForNative;
                     shaderData.prototype.setBuffer = shaderData.prototype.setBufferForNative;
                     shaderData.prototype.getBuffer = shaderData.prototype.getBufferForNative;
                     shaderData.prototype.setTexture = shaderData.prototype.setTextureForNative;
                     shaderData.prototype.getTexture = shaderData.prototype.getTextureForNative;
                     shaderData.prototype.setAttribute = shaderData.prototype.setAttributeForNative;
                     shaderData.prototype.getAttribute = shaderData.prototype.getAttributeForNative;
                     shaderData.prototype.cloneTo = shaderData.prototype.cloneToForNative;
                     shaderData.prototype.getData = shaderData.prototype.getDataForNative;
                     shader3D.prototype._uniformMatrix2fv = shader3D.prototype._uniformMatrix2fvForNative;
                     shader3D.prototype._uniformMatrix3fv = shader3D.prototype._uniformMatrix3fvForNative;
                     shader3D.prototype._uniformMatrix4fv = shader3D.prototype._uniformMatrix4fvForNative;
                     meshRender.prototype._renderUpdateWithCamera = meshRender.prototype._renderUpdateWithCameraForNative;
                 }
                 //Matrix4x4.multiply = Matrix4x4.multiplyForNative;
                 if (Render.supportWebGLPlusCulling) {
                     frustumCulling.renderObjectCulling = FrustumCulling.renderObjectCullingNative;
                 }
                 if (Render.supportWebGLPlusAnimation) {
                     avatar.prototype._cloneDatasToAnimator = avatar.prototype._cloneDatasToAnimatorNative;
                     window.FloatKeyframe = window.conchFloatKeyframe;
                     window.Vector3Keyframe = window.conchFloatArrayKeyframe;
                     window.QuaternionKeyframe = window.conchFloatArrayKeyframe;
                     window.KeyframeNode = window.conchKeyframeNode;
                     window.KeyframeNodeList = window.conchKeyframeNodeList;
                     var animationClip = AnimationClip;
                     animationClip.prototype._evaluateClipDatasRealTime = animationClip.prototype._evaluateClipDatasRealTimeForNative;
                     skinnedMeshRender.prototype.supportWebGLPlusAnimation = skinnedMeshRender.prototype.supportWebGLPlusAnimationForNative;
                 }
             }
             WebGL.shaderHighPrecision = false;
             var precisionFormat = LayaGL.instance.getShaderPrecisionFormat(WebGLContext.FRAGMENT_SHADER, WebGLContext.HIGH_FLOAT);
             precisionFormat.precision ? WebGL.shaderHighPrecision = true : WebGL.shaderHighPrecision = false;
         }
         /**
          *@private
          */
         static formatRelativePath(base, value) {
             var path;
             path = base + value;
             var char1 = value.charAt(0);
             if (char1 === ".") {
                 var parts = path.split("/");
                 for (var i = 0, len = parts.length; i < len; i++) {
                     if (parts[i] == '..') {
                         var index = i - 1;
                         if (index > 0 && parts[index] !== '..') {
                             parts.splice(index, 2);
                             i -= 2;
                         }
                     }
                 }
                 path = parts.join('/');
             }
             return path;
         }
         /**
          * @private
          */
         static _endLoad(loader, content = null, subResous = null) {
             if (subResous) {
                 for (var i = 0, n = subResous.length; i < n; i++) {
                     var resou = Loader.getRes(subResous[i]);
                     (resou) && (resou._removeReference()); //加载失败SubResous为空
                 }
             }
             loader.endLoad(content);
         }
         /**
          *@private
          */
         static _eventLoadManagerError(msg) {
             Laya.loader.event(Event.ERROR, msg);
         }
         /**
          *@private
          */
         static _addHierarchyInnerUrls(urls, urlMap, urlVersion, hierarchyBasePath, path, type, constructParams = null, propertyParams = null) {
             var formatUrl = Laya3D.formatRelativePath(hierarchyBasePath, path);
             (urlVersion) && (formatUrl = formatUrl + urlVersion);
             urls.push({ url: formatUrl, type: type, constructParams: constructParams, propertyParams: propertyParams });
             urlMap.push(formatUrl);
             return formatUrl;
         }
         /**
          *@private
          */
         static _getSprite3DHierarchyInnerUrls(node, firstLevelUrls, secondLevelUrls, thirdLevelUrls, fourthLelUrls, subUrls, urlVersion, hierarchyBasePath) {
             var i, n;
             var props = node.props;
             switch (node.type) {
                 case "Scene3D": //TODO:应该自动序列化类型
                     var lightmaps = props.lightmaps;
                     for (i = 0, n = lightmaps.length; i < n; i++) {
                         var lightMap = lightmaps[i];
                         lightMap.path = Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, lightMap.path, Laya3D.TEXTURE2D, lightMap.constructParams, lightMap.propertyParams);
                     }
                     var reflectionTextureData = props.reflectionTexture;
                     (reflectionTextureData) && (props.reflectionTexture = Laya3D._addHierarchyInnerUrls(thirdLevelUrls, subUrls, urlVersion, hierarchyBasePath, reflectionTextureData, Laya3D.TEXTURECUBE));
                     if (props.sky) {
                         var skyboxMaterial = props.sky.material;
                         (skyboxMaterial) && (skyboxMaterial.path = Laya3D._addHierarchyInnerUrls(secondLevelUrls, subUrls, urlVersion, hierarchyBasePath, skyboxMaterial.path, Laya3D.MATERIAL));
                     }
                     break;
                 case "Camera":
                     var skyboxMatData = props.skyboxMaterial;
                     (skyboxMatData) && (skyboxMatData.path = Laya3D._addHierarchyInnerUrls(secondLevelUrls, subUrls, urlVersion, hierarchyBasePath, skyboxMatData.path, Laya3D.MATERIAL));
                     break;
                 case "TrailSprite3D":
                 case "MeshSprite3D":
                 case "SkinnedMeshSprite3D":
                     var meshPath = props.meshPath;
                     (meshPath) && (props.meshPath = Laya3D._addHierarchyInnerUrls(firstLevelUrls, subUrls, urlVersion, hierarchyBasePath, meshPath, Laya3D.MESH));
                     var materials = props.materials;
                     if (materials)
                         for (i = 0, n = materials.length; i < n; i++)
                             materials[i].path = Laya3D._addHierarchyInnerUrls(secondLevelUrls, subUrls, urlVersion, hierarchyBasePath, materials[i].path, Laya3D.MATERIAL);
                     break;
                 case "ShuriKenParticle3D":
                     var parMeshPath = props.meshPath;
                     (parMeshPath) && (props.meshPath = Laya3D._addHierarchyInnerUrls(firstLevelUrls, subUrls, urlVersion, hierarchyBasePath, parMeshPath, Laya3D.MESH));
                     props.material.path = Laya3D._addHierarchyInnerUrls(secondLevelUrls, subUrls, urlVersion, hierarchyBasePath, props.material.path, Laya3D.MATERIAL);
                     break;
                 case "Terrain":
                     Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, props.dataPath, Laya3D.TERRAINRES);
                     break;
             }
             var components = node.components;
             if (components) {
                 for (var k = 0, p = components.length; k < p; k++) {
                     var component = components[k];
                     switch (component.type) {
                         case "Animator":
                             var avatarPath = component.avatarPath;
                             var avatarData = component.avatar;
                             (avatarData) && (avatarData.path = Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, avatarData.path, Laya3D.AVATAR));
                             var clipPaths = component.clipPaths;
                             if (!clipPaths) {
                                 var layersData = component.layers;
                                 for (i = 0; i < layersData.length; i++) {
                                     var states = layersData[i].states;
                                     for (var j = 0, m = states.length; j < m; j++) {
                                         var clipPath = states[j].clipPath;
                                         (clipPath) && (states[j].clipPath = Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, clipPath, Laya3D.ANIMATIONCLIP));
                                     }
                                 }
                             }
                             else {
                                 for (i = 0, n = clipPaths.length; i < n; i++)
                                     clipPaths[i] = Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, clipPaths[i], Laya3D.ANIMATIONCLIP);
                             }
                             break;
                         case "PhysicsCollider":
                         case "Rigidbody3D":
                         case "CharacterController":
                             var shapes = component.shapes;
                             for (i = 0; i < shapes.length; i++) {
                                 var shape = shapes[i];
                                 if (shape.type === "MeshColliderShape") {
                                     var mesh = shape.mesh;
                                     (mesh) && (shape.mesh = Laya3D._addHierarchyInnerUrls(firstLevelUrls, subUrls, urlVersion, hierarchyBasePath, mesh, Laya3D.MESH));
                                 }
                             }
                             break;
                     }
                 }
             }
             var children = node.child;
             for (i = 0, n = children.length; i < n; i++)
                 Laya3D._getSprite3DHierarchyInnerUrls(children[i], firstLevelUrls, secondLevelUrls, thirdLevelUrls, fourthLelUrls, subUrls, urlVersion, hierarchyBasePath);
         }
         /**
          *@private
          */
         static _loadHierarchy(loader) {
             loader.on(Event.LOADED, null, Laya3D._onHierarchylhLoaded, [loader]);
             loader.load(loader.url, Loader.JSON, false, null, true);
         }
         /**
          *@private
          */
         static _onHierarchylhLoaded(loader, lhData) {
             var url = loader.url;
             var urlVersion = Utils3D.getURLVerion(url);
             var hierarchyBasePath = URL.getPath(url);
             var firstLevUrls = [];
             var secondLevUrls = [];
             var thirdLevUrls = [];
             var forthLevUrls = [];
             var subUrls = [];
             Laya3D._getSprite3DHierarchyInnerUrls(lhData.data, firstLevUrls, secondLevUrls, thirdLevUrls, forthLevUrls, subUrls, urlVersion, hierarchyBasePath);
             var urlCount = firstLevUrls.length + secondLevUrls.length + forthLevUrls.length;
             var totalProcessCount = urlCount + 1;
             var weight = 1 / totalProcessCount;
             Laya3D._onProcessChange(loader, 0, weight, 1.0);
             if (forthLevUrls.length > 0) {
                 var processCeil = urlCount / totalProcessCount;
                 var processHandler = Handler.create(null, Laya3D._onProcessChange, [loader, weight, processCeil], false);
                 Laya3D._innerFourthLevelLoaderManager._create(forthLevUrls, false, Handler.create(null, Laya3D._onHierarchyInnerForthLevResouLoaded, [loader, processHandler, lhData, subUrls, firstLevUrls, secondLevUrls, thirdLevUrls, weight + processCeil * forthLevUrls.length, processCeil]), processHandler, null, null, null, 1, true);
             }
             else {
                 Laya3D._onHierarchyInnerForthLevResouLoaded(loader, null, lhData, subUrls, firstLevUrls, secondLevUrls, thirdLevUrls, weight, processCeil);
             }
         }
         /**
          *@private
          */
         static _onHierarchyInnerForthLevResouLoaded(loader, processHandler, lhData, subUrls, firstLevUrls, secondLevUrls, thirdLevUrls, processOffset, processCeil) {
             (processHandler) && (processHandler.recover());
             if (thirdLevUrls.length > 0) {
                 var process = Handler.create(null, Laya3D._onProcessChange, [loader, processOffset, processCeil], false);
                 Laya3D._innerThirdLevelLoaderManager._create(thirdLevUrls, false, Handler.create(null, Laya3D._onHierarchyInnerThirdLevResouLoaded, [loader, process, lhData, subUrls, firstLevUrls, secondLevUrls, processOffset + processCeil * secondLevUrls.length, processCeil]), processHandler, null, null, null, 1, true);
             }
             else {
                 Laya3D._onHierarchyInnerThirdLevResouLoaded(loader, null, lhData, subUrls, firstLevUrls, secondLevUrls, processOffset, processCeil);
             }
         }
         /**
          *@private
          */
         static _onHierarchyInnerThirdLevResouLoaded(loader, processHandler, lhData, subUrls, firstLevUrls, secondLevUrls, processOffset, processCeil) {
             (processHandler) && (processHandler.recover());
             if (secondLevUrls.length > 0) {
                 var process = Handler.create(null, Laya3D._onProcessChange, [loader, processOffset, processCeil], false);
                 Laya3D._innerSecondLevelLoaderManager._create(secondLevUrls, false, Handler.create(null, Laya3D._onHierarchyInnerSecondLevResouLoaded, [loader, process, lhData, subUrls, firstLevUrls, processOffset + processCeil * secondLevUrls.length, processCeil]), processHandler, null, null, null, 1, true);
             }
             else {
                 Laya3D._onHierarchyInnerSecondLevResouLoaded(loader, null, lhData, subUrls, firstLevUrls, processOffset, processCeil);
             }
         }
         /**
          *@private
          */
         static _onHierarchyInnerSecondLevResouLoaded(loader, processHandler, lhData, subUrls, firstLevUrls, processOffset, processCeil) {
             (processHandler) && (processHandler.recover());
             if (firstLevUrls.length > 0) {
                 var process = Handler.create(null, Laya3D._onProcessChange, [loader, processOffset, processCeil], false);
                 Laya3D._innerFirstLevelLoaderManager._create(firstLevUrls, false, Handler.create(null, Laya3D._onHierarchyInnerFirstLevResouLoaded, [loader, process, lhData, subUrls]), processHandler, null, null, null, 1, true);
             }
             else {
                 Laya3D._onHierarchyInnerFirstLevResouLoaded(loader, null, lhData, subUrls);
             }
         }
         /**
          *@private
          */
         static _onHierarchyInnerFirstLevResouLoaded(loader, processHandler, lhData, subUrls) {
             (processHandler) && (processHandler.recover());
             loader._cache = loader._createCache;
             var item = lhData.data.type === "Scene3D" ? Scene3DUtils._parseScene(lhData, loader._propertyParams, loader._constructParams) : Scene3DUtils._parse(lhData, loader._propertyParams, loader._constructParams);
             Laya3D._endLoad(loader, item, subUrls);
         }
         /**
          *@private
          */
         static _loadMesh(loader) {
             loader.on(Event.LOADED, null, Laya3D._onMeshLmLoaded, [loader]);
             loader.load(loader.url, Loader.BUFFER, false, null, true);
         }
         /**
          *@private
          */
         static _onMeshLmLoaded(loader, lmData) {
             loader._cache = loader._createCache;
             var mesh = Mesh._parse(lmData, loader._propertyParams, loader._constructParams);
             Laya3D._endLoad(loader, mesh);
         }
         /**
          *@private
          */
         static _loadMaterial(loader) {
             loader.on(Event.LOADED, null, Laya3D._onMaterilLmatLoaded, [loader]);
             loader.load(loader.url, Loader.JSON, false, null, true);
         }
         /**
          *@private
          */
         static _onMaterilLmatLoaded(loader, lmatData) {
             var url = loader.url;
             var urlVersion = Utils3D.getURLVerion(url);
             var materialBasePath = URL.getPath(url);
             var urls = [];
             var subUrls = [];
             var customProps = lmatData.customProps;
             var formatSubUrl;
             var version = lmatData.version;
             switch (version) {
                 case "LAYAMATERIAL:01":
                 case "LAYAMATERIAL:02":
                     var i, n;
                     var textures = lmatData.props.textures;
                     if (textures) {
                         for (i = 0, n = textures.length; i < n; i++) {
                             var tex2D = textures[i];
                             var tex2DPath = tex2D.path;
                             if (tex2DPath) {
                                 formatSubUrl = Laya3D.formatRelativePath(materialBasePath, tex2DPath);
                                 (urlVersion) && (formatSubUrl = formatSubUrl + urlVersion);
                                 urls.push({ url: formatSubUrl, constructParams: tex2D.constructParams, propertyParams: tex2D.propertyParams }); //不指定类型,自动根据后缀判断Texture2D或TextureCube
                                 subUrls.push(formatSubUrl);
                                 tex2D.path = formatSubUrl;
                             }
                         }
                     }
                     break;
                 default:
                     throw new Error("Laya3D:unkonwn version.");
             }
             var urlCount = urls.length;
             var totalProcessCount = urlCount + 1;
             var lmatWeight = 1 / totalProcessCount;
             Laya3D._onProcessChange(loader, 0, lmatWeight, 1.0);
             if (urlCount > 0) {
                 var processHandler = Handler.create(null, Laya3D._onProcessChange, [loader, lmatWeight, urlCount / totalProcessCount], false);
                 Laya3D._innerFourthLevelLoaderManager._create(urls, false, Handler.create(null, Laya3D._onMateialTexturesLoaded, [loader, processHandler, lmatData, subUrls]), processHandler, null, null, null, 1, true); //TODO:还有可能是TextureCube,使用三级
             }
             else {
                 Laya3D._onMateialTexturesLoaded(loader, null, lmatData, null);
             }
         }
         /**
          *@private
          */
         static _onMateialTexturesLoaded(loader, processHandler, lmatData, subUrls) {
             loader._cache = loader._createCache;
             var mat = BaseMaterial._parse(lmatData, loader._propertyParams, loader._constructParams);
             Laya3D._endLoad(loader, mat, subUrls);
             (processHandler) && (processHandler.recover());
         }
         /**
          *@private
          */
         static _loadAvatar(loader) {
             loader.on(Event.LOADED, null, function (data) {
                 loader._cache = loader._createCache;
                 var avatar = Avatar._parse(data, loader._propertyParams, loader._constructParams);
                 Laya3D._endLoad(loader, avatar);
             });
             loader.load(loader.url, Loader.JSON, false, null, true);
         }
         /**
          *@private
          */
         static _loadAnimationClip(loader) {
             loader.on(Event.LOADED, null, function (data) {
                 loader._cache = loader._createCache;
                 var clip = AnimationClip._parse(data, loader._propertyParams, loader._constructParams);
                 Laya3D._endLoad(loader, clip);
             });
             loader.load(loader.url, Loader.BUFFER, false, null, true);
         }
         /**
          *@private
          */
         static _loadTexture2D(loader) {
             var url = loader.url;
             var index = url.lastIndexOf('.') + 1;
             var verIndex = url.indexOf('?');
             var endIndex = verIndex == -1 ? url.length : verIndex;
             var ext = url.substr(index, endIndex - index);
             var type;
             switch (ext) {
                 case "jpg":
                 case "jpeg":
                 case "bmp":
                 case "gif":
                 case "png":
                     type = "nativeimage";
                     break;
                 case "dds":
                 case "ktx":
                 case "pvr":
                     type = Loader.BUFFER;
                     break;
             }
             //需要先注册,否则可能同步加载完成没来得及注册就完成
             loader.on(Event.LOADED, null, function (image) {
                 loader._cache = loader._createCache;
                 var tex = Texture2D._parse(image, loader._propertyParams, loader._constructParams);
                 Laya3D._endLoad(loader, tex);
             });
             loader.load(loader.url, type, false, null, true);
         }
         /**
          *@private
          */
         static _loadTextureCube(loader) {
             loader.on(Event.LOADED, null, Laya3D._onTextureCubeLtcLoaded, [loader]);
             loader.load(loader.url, Loader.JSON, false, null, true);
         }
         /**
          *@private
          */
         static _onTextureCubeLtcLoaded(loader, ltcData) {
             var ltcBasePath = URL.getPath(loader.url);
             var urls = [Laya3D.formatRelativePath(ltcBasePath, ltcData.front), Laya3D.formatRelativePath(ltcBasePath, ltcData.back), Laya3D.formatRelativePath(ltcBasePath, ltcData.left), Laya3D.formatRelativePath(ltcBasePath, ltcData.right), Laya3D.formatRelativePath(ltcBasePath, ltcData.up), Laya3D.formatRelativePath(ltcBasePath, ltcData.down)];
             var ltcWeight = 1.0 / 7.0;
             Laya3D._onProcessChange(loader, 0, ltcWeight, 1.0);
             var processHandler = Handler.create(null, Laya3D._onProcessChange, [loader, ltcWeight, 6 / 7], false);
             Laya3D._innerFourthLevelLoaderManager.load(urls, Handler.create(null, Laya3D._onTextureCubeImagesLoaded, [loader, urls, processHandler]), processHandler, "nativeimage");
         }
         /**
          *@private
          */
         static _onTextureCubeImagesLoaded(loader, urls, processHandler) {
             var images = new Array(6);
             for (var i = 0; i < 6; i++)
                 images[i] = Loader.getRes(urls[i]);
             loader._cache = loader._createCache;
             var tex = TextureCube._parse(images, loader._propertyParams, loader._constructParams);
             processHandler.recover();
             for (i = 0; i < 6; i++)
                 Loader.clearRes(urls[i]);
             Laya3D._endLoad(loader, tex);
         }
         /**
          *@private
          */
         static _onProcessChange(loader, offset, weight, process) {
             process = offset + process * weight;
             (process < 1.0) && (loader.event(Event.PROGRESS, process));
         }
         /**
          * 初始化Laya3D相关设置。
          * @param	width  3D画布宽度。
          * @param	height 3D画布高度。
          */
         static init(width, height, config = null, compolete = null) {
             if (Laya3D._isInit)
                 return;
             Laya3D._isInit = true;
             config = config || Config3D._default;
             config.cloneTo(Laya3D._config);
             FrustumCulling.debugFrustumCulling = config.debugFrustumCulling;
             Laya3D._editerEnvironment = Laya3D._config._editerEnvironment;
             Scene3D.octreeCulling = config.octreeCulling;
             Scene3D.octreeInitialSize = config.octreeInitialSize;
             Scene3D.octreeInitialCenter = config.octreeInitialCenter;
             Scene3D.octreeMinNodeSize = config.octreeMinNodeSize;
             Scene3D.octreeLooseness = config.octreeLooseness;
             var physics3D = window.Physics3D;
             if (physics3D == null) {
                 Physics._enbalePhysics = false;
                 Laya3D.__init__(width, height, Laya3D._config);
                 compolete && compolete.run();
             }
             else {
                 Physics._enbalePhysics = true;
                 physics3D(Laya3D._config.defaultPhysicsMemory * 1024 * 1024).then(function () {
                     Laya3D.__init__(width, height, Laya3D._config);
                     compolete && compolete.run();
                 });
             }
         }
     }
     /**Hierarchy资源。*/
     Laya3D.HIERARCHY = "HIERARCHY"; //兼容
     /**Mesh资源。*/
     Laya3D.MESH = "MESH"; //兼容
     /**Material资源。*/
     Laya3D.MATERIAL = "MATERIAL"; //兼容
     /**Texture2D资源。*/
     Laya3D.TEXTURE2D = "TEXTURE2D"; //兼容
     /**TextureCube资源。*/
     Laya3D.TEXTURECUBE = "TEXTURECUBE"; //兼容
     /**AnimationClip资源。*/
     Laya3D.ANIMATIONCLIP = "ANIMATIONCLIP"; //兼容
     /**Avatar资源。*/
     Laya3D.AVATAR = "AVATAR"; //兼容
     /**Terrain资源。*/
     Laya3D.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA";
     /**Terrain资源。*/
     Laya3D.TERRAINRES = "TERRAIN";
     /**@private */
     Laya3D._innerFirstLevelLoaderManager = new LoaderManager(); //Mesh 
     /**@private */
     Laya3D._innerSecondLevelLoaderManager = new LoaderManager(); //Material
     /**@private */
     Laya3D._innerThirdLevelLoaderManager = new LoaderManager(); //TextureCube、TerrainResou
     /**@private */
     Laya3D._innerFourthLevelLoaderManager = new LoaderManager(); //Texture2D、Image、Avatar、AnimationClip
     /**@private */
     Laya3D._isInit = false;
     /**@private */
     Laya3D._editerEnvironment = false;
     /**@private */
     Laya3D._config = new Config3D();
     /**@private */
     Laya3D.physicsSettings = new PhysicsSettings(); //TODO:

     /**
      * <code>Script3D</code> 类用于创建脚本的父类,该类为抽象类,不允许实例。
      */
     class Script3D extends Component {
         constructor() {
             super(...arguments);
             /**@private*/
             this._indexInPool = -1;
         }
         /**
          * @inheritDoc
          */
         /*override*/ get isSingleton() {
             return false;
         }
         /**
          * @private
          */
         _checkProcessTriggers() {
             var prototype = Script3D.prototype;
             if (this.onTriggerEnter !== prototype.onTriggerEnter)
                 return true;
             if (this.onTriggerStay !== prototype.onTriggerStay)
                 return true;
             if (this.onTriggerExit !== prototype.onTriggerExit)
                 return true;
             return false;
         }
         /**
          * @private
          */
         _checkProcessCollisions() {
             var prototype = Script3D.prototype;
             if (this.onCollisionEnter !== prototype.onCollisionEnter)
                 return true;
             if (this.onCollisionStay !== prototype.onCollisionStay)
                 return true;
             if (this.onCollisionExit !== prototype.onCollisionExit)
                 return true;
             return false;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onAwake() {
             this.onAwake();
             if (this.onStart !== Script3D.prototype.onStart)
                 Laya.startTimer.callLater(this, this.onStart);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onEnable() {
             this.owner._scene._addScript(this);
             var proto = Script3D.prototype;
             if (this.onKeyDown !== proto.onKeyDown) {
                 Laya.stage.on(Event.KEY_DOWN, this, this.onKeyDown);
             }
             if (this.onKeyPress !== proto.onKeyPress) {
                 Laya.stage.on(Event.KEY_PRESS, this, this.onKeyUp);
             }
             if (this.onKeyUp !== proto.onKeyUp) {
                 Laya.stage.on(Event.KEY_UP, this, this.onKeyUp);
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onDisable() {
             this.owner._scene._removeScript(this);
             this.owner.offAllCaller(this);
             Laya.stage.offAllCaller(this);
         }
         /**
          * @inheritDoc
          */
         /*override*/ _isScript() {
             return true;
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onAdded() {
             var sprite = this.owner;
             var scripts = sprite._scripts;
             scripts || (sprite._scripts = scripts = []);
             scripts.push(this);
             if (!sprite._needProcessCollisions)
                 sprite._needProcessCollisions = this._checkProcessCollisions(); //检查是否需要处理物理碰撞
             if (!sprite._needProcessTriggers)
                 sprite._needProcessTriggers = this._checkProcessTriggers(); //检查是否需要处理触发器
         }
         /**
          * @inheritDoc
          */
         /*override*/ _onDestroy() {
             var scripts = this.owner._scripts;
             scripts.splice(scripts.indexOf(this), 1);
             var sprite = this.owner;
             sprite._needProcessTriggers = false;
             for (var i = 0, n = scripts.length; i < n; i++) {
                 if (scripts[i]._checkProcessTriggers()) {
                     sprite._needProcessTriggers = true;
                     break;
                 }
             }
             sprite._needProcessCollisions = false;
             for (i = 0, n = scripts.length; i < n; i++) {
                 if (scripts[i]._checkProcessCollisions()) {
                     sprite._needProcessCollisions = true;
                     break;
                 }
             }
             this.onDestroy();
         }
         /**
          * 创建后只执行一次
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onAwake() {
         }
         /**
          * 每次启动后执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onEnable() {
         }
         /**
          * 第一次执行update之前执行，只会执行一次
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onStart() {
         }
         /**
          * 开始触发时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onTriggerEnter(other) {
         }
         /**
          * 持续触发时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onTriggerStay(other) {
         }
         /**
          * 结束触发时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onTriggerExit(other) {
         }
         /**
          * 开始碰撞时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onCollisionEnter(collision) {
         }
         /**
          * 持续碰撞时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onCollisionStay(collision) {
         }
         /**
          * 结束碰撞时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onCollisionExit(collision) {
         }
         /**
          * 鼠标按下时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onMouseDown() {
         }
         /**
          * 鼠标拖拽时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onMouseDrag() {
         }
         /**
          * 鼠标点击时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onMouseClick() {
         }
         /**
          * 鼠标弹起时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onMouseUp() {
         }
         /**
          * 鼠标进入时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onMouseEnter() {
         }
         /**
          * 鼠标经过时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onMouseOver() {
         }
         /**
          * 鼠标离开时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onMouseOut() {
         }
         /**
          * 键盘按下时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onKeyDown(e) {
         }
         /**
          * 键盘产生一个字符时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onKeyPress(e) {
         }
         /**
          * 键盘抬起时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onKeyUp(e) {
         }
         /**
          * 每帧更新时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onUpdate() {
         }
         /**
          * 每帧更新时执行，在update之后执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onLateUpdate() {
         }
         /**
          * 渲染之前执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onPreRender() {
         }
         /**
          * 渲染之后执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onPostRender() {
         }
         /**
          * 禁用时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onDisable() {
         }
         /**
          * 销毁时执行
          * 此方法为虚方法，使用时重写覆盖即可
          */
         onDestroy() {
         }
     }

     /**
      * ...
      * @author
      */
     class CameraMoveScript extends Script3D {
         constructor() {
             super();
             /** @private */
             this._tempVector3 = new Vector3();
             this.yawPitchRoll = new Vector3();
             this.resultRotation = new Quaternion();
             this.tempRotationZ = new Quaternion();
             this.tempRotationX = new Quaternion();
             this.tempRotationY = new Quaternion();
             this.rotaionSpeed = 0.00006;
         }
         /**
          * @private
          */
         _updateRotation() {
             if (Math.abs(this.yawPitchRoll.y) < 1.50) {
                 Quaternion.createFromYawPitchRoll(this.yawPitchRoll.x, this.yawPitchRoll.y, this.yawPitchRoll.z, this.tempRotationZ);
                 this.tempRotationZ.cloneTo(this.camera.transform.localRotation);
                 this.camera.transform.localRotation = this.camera.transform.localRotation;
             }
         }
         /**
          * @inheritDoc
          */
         /*override*/ onAwake() {
             Laya.stage.on(Event.RIGHT_MOUSE_DOWN, this, this.mouseDown);
             Laya.stage.on(Event.RIGHT_MOUSE_UP, this, this.mouseUp);
             //Laya.stage.on(Event.RIGHT_MOUSE_OUT, this, mouseOut);
             this.camera = this.owner;
         }
         /**
          * @inheritDoc
          */
         /*override*/ onUpdate() {
             var elapsedTime = Laya.timer.delta;
             if (!isNaN(this.lastMouseX) && !isNaN(this.lastMouseY) && this.isMouseDown) {
                 var scene = this.owner.scene;
                 KeyBoardManager.hasKeyDown(87) && this.moveForward(-0.01 * elapsedTime); //W
                 KeyBoardManager.hasKeyDown(83) && this.moveForward(0.01 * elapsedTime); //S
                 KeyBoardManager.hasKeyDown(65) && this.moveRight(-0.01 * elapsedTime); //A
                 KeyBoardManager.hasKeyDown(68) && this.moveRight(0.01 * elapsedTime); //D
                 KeyBoardManager.hasKeyDown(81) && this.moveVertical(0.01 * elapsedTime); //Q
                 KeyBoardManager.hasKeyDown(69) && this.moveVertical(-0.01 * elapsedTime); //E
                 var offsetX = Laya.stage.mouseX - this.lastMouseX;
                 var offsetY = Laya.stage.mouseY - this.lastMouseY;
                 var yprElem = this.yawPitchRoll;
                 yprElem.x -= offsetX * this.rotaionSpeed * elapsedTime;
                 yprElem.y -= offsetY * this.rotaionSpeed * elapsedTime;
                 this._updateRotation();
             }
             this.lastMouseX = Laya.stage.mouseX;
             this.lastMouseY = Laya.stage.mouseY;
         }
         /**
          * @inheritDoc
          */
         /*override*/ onDestroy() {
             Laya.stage.off(Event.RIGHT_MOUSE_DOWN, this, this.mouseDown);
             Laya.stage.off(Event.RIGHT_MOUSE_UP, this, this.mouseUp);
             //Laya.stage.off(Event.RIGHT_MOUSE_OUT, this, mouseOut);
         }
         mouseDown(e) {
             this.camera.transform.localRotation.getYawPitchRoll(this.yawPitchRoll);
             this.lastMouseX = Laya.stage.mouseX;
             this.lastMouseY = Laya.stage.mouseY;
             this.isMouseDown = true;
         }
         mouseUp(e) {
             this.isMouseDown = false;
         }
         mouseOut(e) {
             this.isMouseDown = false;
         }
         /**
          * 向前移动。
          * @param distance 移动距离。
          */
         moveForward(distance) {
             this._tempVector3.x = this._tempVector3.y = 0;
             this._tempVector3.z = distance;
             this.camera.transform.translate(this._tempVector3);
         }
         /**
          * 向右移动。
          * @param distance 移动距离。
          */
         moveRight(distance) {
             this._tempVector3.y = this._tempVector3.z = 0;
             this._tempVector3.x = distance;
             this.camera.transform.translate(this._tempVector3);
         }
         /**
          * 向上移动。
          * @param distance 移动距离。
          */
         moveVertical(distance) {
             this._tempVector3.x = this._tempVector3.z = 0;
             this._tempVector3.y = distance;
             this.camera.transform.translate(this._tempVector3, false);
         }
     }

     /**
      * ...
      * @author
      */
     class OctreeTest {
         constructor() {
             this.curStateIndex = 0;
             var config = new Config3D();
             config.debugFrustumCulling = true;
             config.octreeCulling = true;
             config.octreeInitialSize = 32;
             config.octreeMinNodeSize = 0.01;
             config.octreeLooseness = 1.01;
             Shader3D.debugMode = true;
             Laya3D.init(0, 0, config);
             Laya.stage.scaleMode = Stage.SCALE_FULL;
             Laya.stage.screenMode = Stage.SCREEN_NONE;
             Stat.show();
             var scene = Laya.stage.addChild(new Scene3D());
             var camera = scene.addChild(new Camera(0, 0.1, 1000));
             camera.transform.translate(new Vector3(0, 2, 5));
             camera.transform.rotate(new Vector3(-15, 0, 0), true, false);
             camera.addComponent(CameraMoveScript);
             camera.clearColor = new Vector4(0.2, 0.2, 0.2, 1.0);
             var directionLight = scene.addChild(new DirectionLight());
             //设置平行光的方向
             var mat = directionLight.transform.worldMatrix;
             mat.setForward(new Vector3(1.0, -1.0, -1.0));
             directionLight.transform.worldMatrix = mat;
             this.sprite3D = scene.addChild(new Sprite3D());
             /*
             //正方体
             var box: MeshSprite3D = (<MeshSprite3D>this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createBox(0.5, 0.5, 0.5))));
             box.transform.position = new Vector3(2.0, 0.25, 0.6);
             box.transform.rotate(new Vector3(0, 45, 0), false, false);

             //球体
             var sphere: MeshSprite3D = (<MeshSprite3D>this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createSphere(0.25, 20, 20))));
             sphere.transform.position = new Vector3(1.0, 0.25, 0.6);

             //圆柱体
             var cylinder: MeshSprite3D = (<MeshSprite3D>this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createCylinder(0.25, 1, 20))));
             cylinder.transform.position = new Vector3(0, 0.5, 0.6);

             //胶囊体
             var capsule: MeshSprite3D = (<MeshSprite3D>this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createCapsule(0.25, 1, 10, 20))));
             capsule.transform.position = new Vector3(-1.0, 0.5, 0.6);

             //圆锥体
             var cone: MeshSprite3D = (<MeshSprite3D>this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createCone(0.25, 0.75))));
             cone.transform.position = new Vector3(-2.0, 0.375, 0.6);
             //
             //圆锥体
             var cone: MeshSprite3D = (<MeshSprite3D>this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createCone(0.25, 0.75))));
             cone.transform.position = new Vector3(-3.0, 0.375, 0.6);

             //圆锥体
             var cone: MeshSprite3D = (<MeshSprite3D>this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createCone(0.25, 0.75))));
             cone.transform.position = new Vector3(-4.0, 0.375, 0.6);

             //圆锥体
             var cone: MeshSprite3D = (<MeshSprite3D>this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createCone(0.25, 0.75))));
             cone.transform.position = new Vector3(-5.0, 0.375, 0.6);
             // this.character = cone;

             //平面
             var plane: MeshSprite3D = (<MeshSprite3D>this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createPlane(6, 6, 10, 10))));
             this.loadUI();
             */
             //加载猴子精灵
             var cone = this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createCone(0.25, 0.75)));
             cone.transform.position = new Vector3(-5.0, 0.375, 0.6);
             this.character = cone;
             Laya.timer.frameLoop(1, this, this.onKeyDown);
         }
         onKeyDown() {
             if (KeyBoardManager.hasKeyDown(38)) {
                 this.character.transform.translate(new Vector3(0, 0, -0.2)); //上
                 this.character.removeSelf();
             }
             KeyBoardManager.hasKeyDown(40) && this.character.transform.translate(new Vector3(0, 0, 0.2)); //左
             KeyBoardManager.hasKeyDown(37) && this.character.transform.translate(new Vector3(-0.2, 0, 0)); //下
             KeyBoardManager.hasKeyDown(39) && this.character.transform.translate(new Vector3(0.2, 0, 0)); //右
         }
         loadUI() {
             Laya.loader.load(["res/threeDimen/ui/button.png"], Handler.create(null, function () {
                 var changeActionButton = Laya.stage.addChild(new Button("res/threeDimen/ui/button.png", "正常模式"));
                 changeActionButton.size(160, 40);
                 changeActionButton.labelBold = true;
                 changeActionButton.labelSize = 30;
                 changeActionButton.sizeGrid = "4,4,4,4";
                 changeActionButton.scale(Browser.pixelRatio, Browser.pixelRatio);
                 changeActionButton.pos(Laya.stage.width / 2 - changeActionButton.width * Browser.pixelRatio / 2, Laya.stage.height - 100 * Browser.pixelRatio);
                 changeActionButton.on(Event.CLICK, this, function () {
                 });
             }));
         }
     }

     new OctreeTest();

}());
